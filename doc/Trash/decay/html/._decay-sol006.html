<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to computing with finite difference methods">
<meta name="keywords" content="decay ODE,exponential decay,mesh,grid,mesh function,finite differences,forward difference,finite differences forward,difference equation,discrete equation,algebraic equation,finite difference scheme,Forward Euler scheme,backward difference,finite differences backward,backward scheme, 1-step,Backward Euler scheme,Crank-Nicolson scheme,centered difference,finite differences centered,averaging arithmetic,weighted average,theta-rule,$\theta$-rule,time step,finite difference operator notation,operator notation, finite differences,directory,folder,doc strings,printf format,format string syntax (Python),plotting curves,visualizing curves,representative (mesh function),array arithmetics,array computing,vectorization,continuous function norms,norm continuous,discrete function norms,mesh function norms,norm discrete (mesh function),error norms,scalar computing,PNG plot,PDF plot,EPS plot,viewing graphics files,cropping images,array arithmetics,array computing,vectorization,stability,amplification factor,A-stable methods,L-stable methods,interactive Python,error amplification factor,error global,consistency,stability,convergence,lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),convergence rate,verification,implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order method,Taylor-series methods (for ODEs),Adams-Bashforth scheme, 2nd-order,Adams-Bashforth scheme, 3rd order,Runge-Kutta, 4th-order method,RK4,adaptive time stepping,Dormand-Prince Runge-Kutta 4-5 method,population dynamics,logistic model,radioactive decay,chemical reactions irreversible,chemical reactions reversible,terminal velocity,geometric mean,averaging geometric,scaling">

<title>Introduction to computing with finite difference methods</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/*
in.collapse+a.btn.showdetails:before { content:'Hide details'; }
.collapse+a.btn.showdetails:before { content:'Show details'; }
*/
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Finite difference methods',
               1,
               'decay:basics',
               'decay:basics'),
              ('A basic model for exponential decay',
               2,
               'decay:model',
               'decay:model'),
              ('The exact solution', 3, None, '___sec2'),
              ('Complete problem formulation', 3, None, '___sec3'),
              ('The Forward Euler scheme',
               2,
               'decay:schemes:FE',
               'decay:schemes:FE'),
              ('Step 1: Discretizing the domain', 3, None, '___sec5'),
              ('Step 2: Fulfilling the equation at discrete time points',
               3,
               None,
               '___sec6'),
              ('Step 3: Replacing derivatives by finite differences',
               3,
               None,
               '___sec7'),
              ('Step 4: Formulating a recursive algorithm',
               3,
               None,
               '___sec8'),
              ('Interpretation', 3, None, '___sec9'),
              ('Computing with the recursive formula', 3, None, '___sec10'),
              ('The Backward Euler scheme',
               2,
               'decay:schemes:BE',
               'decay:schemes:BE'),
              ('The Crank-Nicolson scheme',
               2,
               'decay:schemes:CN',
               'decay:schemes:CN'),
              ('The unifying $\\theta$-rule',
               2,
               'decay:schemes:theta',
               'decay:schemes:theta'),
              ('Constant time step', 2, None, '___sec14'),
              ('Mathematical derivation of finite difference formulas',
               2,
               'decay:fd:taylor',
               'decay:fd:taylor'),
              ('The forward difference', 3, None, '___sec16'),
              ('The backward difference', 3, None, '___sec17'),
              ('The centered difference', 3, None, '___sec18'),
              ('Compact operator notation for finite differences',
               2,
               'decay:fd:op',
               'decay:fd:op'),
              ('Implementation', 1, 'decay:impl1', 'decay:impl1'),
              ('Making a solver function', 2, 'decay:py1', 'decay:py1'),
              ('Function for computing the numerical solution',
               3,
               None,
               '___sec22'),
              ('Integer division', 3, None, '___sec23'),
              ('Doc strings', 3, None, '___sec24'),
              ('Formatting numbers', 3, None, '___sec25'),
              ('Running the program', 3, None, '___sec26'),
              ('Plotting the solution', 3, None, '___sec27'),
              ('Verifying the implementation', 2, None, '___sec28'),
              ('Running a few algorithmic steps by hand',
               3,
               None,
               '___sec29'),
              ('Computing the numerical error as a mesh function',
               2,
               'decay:computing:error',
               'decay:computing:error'),
              ('Computing the norm of the error mesh function',
               2,
               'decay:computing:error:norm',
               'decay:computing:error:norm'),
              ('Scalar computing', 3, None, '___sec32'),
              ('Experiments with computing and plotting',
               2,
               None,
               '___sec33'),
              ('Combining plot files', 3, None, '___sec34'),
              ('Plotting with SciTools', 3, None, '___sec35'),
              ('Memory-saving implementation', 2, None, '___sec36'),
              ('Exercises', 1, None, '___sec37'),
              ('Exercise 1: Define a mesh function and visualize it',
               2,
               'decay:exer:meshfunc',
               'decay:exer:meshfunc'),
              ('Remarks', 3, None, '___sec39'),
              ('Exercise 2: Differentiate a function',
               2,
               'decay:exer:dudt',
               'decay:exer:dudt'),
              ('Exercise 3: Experiment with integer division',
               2,
               'decay:exer:intdiv',
               'decay:exer:intdiv'),
              ('Exercise 4: Experiment with wrong computations',
               2,
               'decay:exer:decay1err',
               'decay:exer:decay1err'),
              ('Exercise 5: Plot the error function',
               2,
               'decay:exer:plot:error',
               'decay:exer:plot:error'),
              ('Exercise 6: Change formatting of numbers and debug',
               2,
               'decay:exer:inexact:output',
               'decay:exer:inexact:output'),
              ('Analysis of finite difference equations',
               1,
               'decay:analysis',
               'decay:analysis'),
              ('Experimental investigation of oscillatory solutions',
               2,
               None,
               '___sec46'),
              ('Exact numerical solution', 2, None, '___sec47'),
              ('Stability', 2, None, '___sec48'),
              ('Comparing amplification factors', 2, None, '___sec49'),
              ('Series expansion of amplification factors',
               2,
               None,
               '___sec50'),
              ('The fraction of numerical and exact amplification factors',
               2,
               None,
               '___sec51'),
              ('The global error at a point',
               2,
               'decay:analysis:gobal:error',
               'decay:analysis:gobal:error'),
              ('Integrated errors',
               2,
               'decay:analysis:gobal:error_int',
               'decay:analysis:gobal:error_int'),
              ('Truncation error',
               2,
               'decay:analysis:trunc',
               'decay:analysis:trunc'),
              ('Consistency, stability, and convergence',
               2,
               None,
               '___sec55'),
              ('Exercises', 1, None, '___sec56'),
              ('Exercise 7: Visualize the accuracy of finite differences',
               2,
               'decay:analysis:exer:fd:exp:plot',
               'decay:analysis:exer:fd:exp:plot'),
              ('Exercise 8: Explore the $\\theta$-rule for exponential growth',
               2,
               'decay:analysis:exer:growth',
               'decay:analysis:exer:growth'),
              ('Model extensions', 1, None, '___sec59'),
              ('Generalization: including a variable coefficient',
               2,
               None,
               '___sec60'),
              ('Generalization: including a source term',
               2,
               'decay:source',
               'decay:source'),
              ('Implementation of the generalized model problem',
               2,
               'decay:general',
               'decay:general'),
              ('Deriving the $\\theta$-rule formula', 3, None, '___sec63'),
              ('Python code', 3, None, '___sec64'),
              ('Coding of variable coefficients', 3, None, '___sec65'),
              ('Verifying a constant solution',
               2,
               'decay:verify:trivial',
               'decay:verify:trivial'),
              ('Verification via manufactured solutions',
               2,
               'decay:MMS',
               'decay:MMS'),
              ('Computing convergence rates',
               2,
               'decay:convergence:rate',
               'decay:convergence:rate'),
              ('Estimating $r$', 3, None, '___sec69'),
              ('Implementation', 3, None, '___sec70'),
              ('Extension to systems of ODEs', 2, None, '___sec71'),
              ('General first-order ODEs', 1, None, '___sec72'),
              ('Generic form of first-order ODEs', 2, None, '___sec73'),
              ('The $\\theta$-rule', 2, None, '___sec74'),
              ('An implicit 2-step backward scheme', 2, None, '___sec75'),
              ('Leapfrog schemes', 2, None, '___sec76'),
              ('The ordinary Leapfrog scheme', 3, None, '___sec77'),
              ('The filtered Leapfrog scheme', 3, None, '___sec78'),
              ('The 2nd-order Runge-Kutta method', 2, None, '___sec79'),
              ('A 2nd-order Taylor-series method', 2, None, '___sec80'),
              ('The 2nd- and 3rd-order Adams-Bashforth schemes',
               2,
               None,
               '___sec81'),
              ('The 4th-order Runge-Kutta method',
               2,
               'decay:fd2:RK4',
               'decay:fd2:RK4'),
              ('The Odespy software', 2, None, '___sec83'),
              ('Example: Runge-Kutta methods', 2, None, '___sec84'),
              ('Remark about using the $\\theta$-rule in Odespy',
               3,
               None,
               '___sec85'),
              ('Example: Adaptive Runge-Kutta methods',
               2,
               'decay:fd2:adaptiveRK',
               'decay:fd2:adaptiveRK'),
              ('Exercises', 1, None, '___sec87'),
              ('Exercise 9: Experiment with precision in tests and the size of $u$',
               2,
               'decay:fd2:exer:precision',
               'decay:fd2:exer:precision'),
              ('Exercise 10: Implement the 2-step backward scheme',
               2,
               'decay:fd2:exer:bw2',
               'decay:fd2:exer:bw2'),
              ('Exercise 11: Implement the 2nd-order Adams-Bashforth scheme',
               2,
               'decay:fd2:exer:AB2',
               'decay:fd2:exer:AB2'),
              ('Exercise 12: Implement the 3rd-order Adams-Bashforth scheme',
               2,
               'decay:fd2:exer:AB3',
               'decay:fd2:exer:AB3'),
              ('Exercise 13: Analyze explicit 2nd-order methods',
               2,
               'decay:exer:RK2:Taylor:analysis',
               'decay:exer:RK2:Taylor:analysis'),
              ('Problem 14: Implement and investigate the Leapfrog scheme',
               2,
               'decay:fd2:exer:leapfrog1',
               'decay:fd2:exer:leapfrog1'),
              ('Problem 15: Make a unified implementation of many schemes',
               2,
               'decay:fd2:exer:uni',
               'decay:fd2:exer:uni'),
              ('Applications of exponential decay models',
               1,
               'decay:app',
               'decay:app'),
              ('Scaling', 2, 'decay:app:scaling', 'decay:app:scaling'),
              ('Evolution of a population',
               2,
               'decay:app:pop',
               'decay:app:pop'),
              ('Compound interest and inflation',
               2,
               'decay:app:interest',
               'decay:app:interest'),
              ("Newton's law of cooling",
               2,
               'decay:app:Newton:cooling',
               'decay:app:Newton:cooling'),
              ('Radioactive decay',
               2,
               'decay:app:nuclear',
               'decay:app:nuclear'),
              ('Deterministic model', 3, None, '___sec101'),
              ('Stochastic model', 3, None, '___sec102'),
              ('Relation between stochastic and deterministic models',
               3,
               None,
               '___sec103'),
              ('Chemical kinetics',
               2,
               'decay:app:kinetics',
               'decay:app:kinetics'),
              ('Irreversible reaction of two substances',
               3,
               None,
               '___sec105'),
              ('Reversible reaction of two substances', 3, None, '___sec106'),
              ('Irreversible reaction of two substances into a third',
               3,
               None,
               '___sec107'),
              ('A biochemical reaction', 3, None, '___sec108'),
              ('Spreading of diseases', 2, 'decay:app:SIR', 'decay:app:SIR'),
              ('Decay of atmospheric pressure with altitude',
               2,
               'decay:app:atm',
               'decay:app:atm'),
              ('Multiple atmospheric layers', 3, None, '___sec111'),
              ('Simplification: $L=0$', 3, None, '___sec112'),
              ('Simplification: one-layer model', 3, None, '___sec113'),
              ('Compaction of sediments',
               2,
               'decay:app:sediment',
               'decay:app:sediment'),
              ('Vertical motion of a body in a viscous fluid',
               2,
               'decay:app:drag',
               'decay:app:drag'),
              ('Overview of forces', 3, None, '___sec116'),
              ('Equation of motion', 3, None, '___sec117'),
              ('Terminal velocity', 3, None, '___sec118'),
              ('A Crank-Nicolson scheme', 3, None, '___sec119'),
              ('Physical data', 3, None, '___sec120'),
              ('Verification', 3, None, '___sec121'),
              ('Scaling', 3, None, '___sec122'),
              ('Decay ODEs from solving a PDE by Fourier expansions',
               2,
               'decay:app:diffusion:Fourier',
               'decay:app:diffusion:Fourier'),
              ('Exercises', 1, None, '___sec124'),
              ('Exercise 16: Radioactive decay of Carbon-14',
               2,
               'decay:app:exer:radio:C14',
               'decay:app:exer:radio:C14'),
              ("Exercise 17: Derive schemes for Newton's law of cooling",
               2,
               'decay:app:exer:cooling:schemes',
               'decay:app:exer:cooling:schemes'),
              ("Exercise 18: Implement schemes for Newton's law of cooling",
               2,
               'decay:app:exer:cooling:py',
               'decay:app:exer:cooling:py'),
              ('Bug 1: Wrong time level in the $T_s$ function',
               3,
               None,
               '___sec128'),
              ('Bug 2: Wrong time level in the $T$ function',
               3,
               None,
               '___sec129'),
              ('Bug 3: Missing $\\theta$ in a term', 3, None, '___sec130'),
              ('Bug 4: Missing `k` in the updating formula',
               3,
               None,
               '___sec131'),
              ('Bug 5: Using `1-theta` instead of `theta`',
               3,
               None,
               '___sec132'),
              ('Exercise 19: Find time of murder from body temperature',
               2,
               'decay:app:exer:cooling:murder',
               'decay:app:exer:cooling:murder'),
              ('Exercise 20: Simulate an oscillating cooling process',
               2,
               'decay:app:exer:cooling:osc',
               'decay:app:exer:cooling:osc'),
              ('Exercise 21: Simulate stochastic radioactive decay',
               2,
               'decay:app:exer:stoch:nuclear',
               'decay:app:exer:stoch:nuclear'),
              ('Exercise 22: Radioactive decay of two substances',
               2,
               'decay:app:exer:radio:twosubst',
               'decay:app:exer:radio:twosubst'),
              ('Exercise 23: Simulate a simple chemical reaction',
               2,
               'decay:app:exer:kinetics:AB',
               'decay:app:exer:kinetics:AB'),
              ('Exercise 24: Simulate an $n$-th order chemical reaction',
               2,
               'decay:app:exer:kinetics:ABn',
               'decay:app:exer:kinetics:ABn'),
              ('Exercise 25: Simulate spreading of a disease',
               2,
               'decay:app:exer:SIR',
               'decay:app:exer:SIR'),
              ('Exercise 26: Simulate a biochemical process',
               2,
               'decay:app:exer:MMK',
               'decay:app:exer:MMK'),
              ('Exercise 27: Simulate the pressure drop in the atmosphere',
               2,
               'decay:app:exer:atm1',
               'decay:app:exer:atm1'),
              ('Exercise 28: Make a program for vertical motion in a fluid',
               2,
               'decay:app:exer:drag:prog',
               'decay:app:exer:drag:prog'),
              ('Project 29: Simulate parachuting',
               2,
               'decay:app:exer:parachute',
               'decay:app:exer:parachute'),
              ('Exercise 30: Formulate vertical motion in the atmosphere',
               2,
               'decay:app:exer:drag:atm1',
               'decay:app:exer:drag:atm1'),
              ('Exercise 31: Simulate vertical motion in the atmosphere',
               2,
               'decay:app:exer:drag:atm2',
               'decay:app:exer:drag:atm2'),
              ('Exercise 32: Compute $y=|x|$ by solving an ODE',
               2,
               'decay:app:exer:signum',
               'decay:app:exer:signum'),
              ('Exercise 33: Simulate growth of a fortune with random interest rate',
               2,
               'decay:app:exer:interest',
               'decay:app:exer:interest'),
              ('Exercise 34: Simulate a population in a changing environment',
               2,
               'decay:app:exer:pop:at',
               'decay:app:exer:pop:at'),
              ('Exercise 35: Simulate logistic growth',
               2,
               'decay:app:exer:pop:logistic1',
               'decay:app:exer:pop:logistic1'),
              ('Exercise 36: Rederive the equation for continuous compound interest',
               2,
               'decay:app:exer:interest:derive',
               'decay:app:exer:interest:derive'),
              ('Summarizing multiple-choice questions', 1, None, '___sec151'),
              ('Exercise 37: Characterize a finite difference',
               2,
               'decay:quiz:fd:FE',
               'decay:quiz:fd:FE'),
              ('Exercise 38: Characterize a finite difference',
               2,
               'decay:quiz:fd:CN',
               'decay:quiz:fd:CN'),
              ('Exercise 39: What is the problem with this program?',
               2,
               'decay:quiz:program',
               'decay:quiz:program'),
              ('Exercise 40: Is the solution correct?',
               2,
               'decay:quiz:stability',
               'decay:quiz:stability'),
              ('Exercise 41: Is this a proper test function?',
               2,
               'decay:quiz:testfunc',
               'decay:quiz:testfunc'),
              ('Exercise 42: Rewrite an expression with array arithmetics',
               2,
               'decay:quiz:arrayarithm',
               'decay:quiz:arrayarithm'),
              ('Exercise 43: What is the truncation error?',
               2,
               'decay:quiz:trunc',
               'decay:quiz:trunc'),
              ('Exercise 44: Recognize a programming language',
               2,
               'decay:quiz:prog:m',
               'decay:quiz:prog:m'),
              ('Exercise 45: Recognize a programming language',
               2,
               'decay:quiz:prog:py',
               'decay:quiz:prog:py'),
              ('Exercise 46: Recognize a programming language',
               2,
               'decay:quiz:prog:f77',
               'decay:quiz:prog:f77'),
              ('Exercise 47: Recognize a programming language',
               2,
               'decay:quiz:prog:c',
               'decay:quiz:prog:c'),
              ('Exercise 48: What is SymPy?',
               2,
               'decay:quiz:sympy1',
               'decay:quiz:sympy1'),
              ('Exercise 49: Testing of code',
               2,
               'decay:quiz:testing1',
               'decay:quiz:testing1'),
              ('Exercise 50: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:CN_error',
               'decay:quiz:scheme:CN_error'),
              ('Exercise 51: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:BE',
               'decay:quiz:scheme:BE'),
              ('Exercise 52: What kind of scheme is this?',
               2,
               'decay:quiz:scheme:leapfrog',
               'decay:quiz:scheme:leapfrog'),
              ('Bibliography', 1, None, '___sec168')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\E}[1]{\hbox{E}\lbrack #1 \rbrack}
\newcommand{\Var}[1]{\hbox{Var}\lbrack #1 \rbrack}
\newcommand{\Std}[1]{\hbox{Std}\lbrack #1 \rbrack}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="decay-sol.html">Introduction to computing with finite difference methods</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._decay-sol001.html#decay:basics" style="font-size: 80%;">Finite difference methods</a></li>
     <!-- navigation toc: --> <li><a href="._decay-sol002.html#decay:impl1" style="font-size: 80%;">Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._decay-sol003.html#___sec37" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._decay-sol004.html#decay:analysis" style="font-size: 80%;">Analysis of finite difference equations</a></li>
     <!-- navigation toc: --> <li><a href="._decay-sol004.html#___sec56" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._decay-sol005.html#___sec59" style="font-size: 80%;">Model extensions</a></li>
     <!-- navigation toc: --> <li><a href="._decay-sol005.html#___sec72" style="font-size: 80%;">General first-order ODEs</a></li>
     <!-- navigation toc: --> <li><a href="._decay-sol005.html#___sec87" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="#decay:app" style="font-size: 80%;">Applications of exponential decay models</a></li>
     <!-- navigation toc: --> <li><a href="#___sec124" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._decay-sol007.html#___sec151" style="font-size: 80%;">Summarizing multiple-choice questions</a></li>
     <!-- navigation toc: --> <li><a href="._decay-sol008.html#___sec168" style="font-size: 80%;">Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0006"></a>
<!-- !split -->

<h1 id="decay:app">Applications of exponential decay models</h1>

<p>
This section presents many mathematical models that all
end up with ODEs of the type \( u^{\prime}=-au+b \).
The applications are taken from biology,
finance, and physics, and cover population growth or decay, compound
interest and inflation, radioactive decay, cooling of objects,
compaction of geological media, pressure
variations in the atmosphere, and air resistance on falling or rising
bodies.

<p>
Before we turn to the applications, however, we take a brief look at
the technique of scaling, which is so useful in many applications.

<h2 id="decay:app:scaling">Scaling</h2>

<p>
Real applications of a model \( u^{\prime}=-au+b \) will often involve a lot
of parameters in the expressions for \( a \) and \( b \). It can be quite
a challenge to find relevant values of all parameters. In simple
problems, however, it turns out that it is not always necessary
to estimate all parameters because we can lump them into one or
a few <em>dimensionless</em> numbers by using a very attractive technique
called scaling. It simply means to stretch the \( u \) and \( t \) axis
in the present problem - and suddenly all parameters in the problem
are lumped into one parameter if \( b\neq 0 \) and no parameter when \( b=0 \)!

<p>
Scaling means that we introduce a new function \( \bar u(\bar t) \),
with

$$ \bar u = \frac{u - u_m}{u_c},\quad \bar t = \frac{t}{t_c},$$

where \( u_m \) is a characteristic value of \( u \), \( u_c \) is a characteristic
size of the range of \( u \) values, and \( t_c \) is a characteristic
size of the range of \( t \) where \( u \) shows significant variation.
Choosing \( u_m \), \( u_c \), and \( t_c \) is not always easy and is often an art
in complicated problems. We just state one choice first:

$$ u_c = I,\quad u_m = b/a,\quad t_c = 1/a\tp$$

Inserting \( u=u_m + u_c\bar u \) and \( t=t_c\bar t \) in the problem
\( u^{\prime}=-au + b \), assuming \( a \) and \( b \) are constants, results (after some
algebra) in the <em>scaled problem</em>

$$ \frac{d\bar u}{d\bar t} = -\bar u,\quad \bar u(0)=1 - \beta,$$

where \( \beta \) is a dimensionless number

$$ \beta = \frac{b}{Ia}\tp$$

That is, only the special combination of \( b/(Ia) \) matters, not what
the individual values of \( b \), \( a \), and \( I \) are. Moreover, if \( b=0 \),
the scaled problem is independent of \( a \) and \( I \)! In practice this means
that we can perform one numerical simulation of the scaled problem and
recover the solution of any problem for a given \( a \) and \( I \) by
stretching the axis in the plot: \( u=I\bar u \) and \( t =\bar t/a \).
For \( b\neq 0 \), we simulate the scaled problem for a few \( \beta \) values
and recover the physical solution \( u \) by translating and stretching the \( u \)
axis and stretching the \( t \) axis.

<p>
The scaling breaks down if \( I=0 \). In that case we may choose \( u_m=0 \),
\( u_c=b/a \), and \( t_c=1/b \), resulting in a slightly different scaled problem:

$$ \frac{d\bar u}{d\bar t} = 1 -\bar u,\quad \bar u(0)=0\tp$$

As with \( b=0 \), the case \( I=0 \) has a scaled problem with no physical
parameters!

<p>
It is common to drop the bars after scaling and write the scaled
problem as \( u^{\prime}=-u \), \( u(0)=1-\beta \), or \( u^{\prime}=1-u \), \( u(0)=0 \).
Any implementation of the problem \( u^{\prime}=-au+b \), \( u(0)=I \), can be
reused for the scaled problem by setting \( a=1 \), \( b=0 \), and \( I=1-\beta \)
in the code, if \( I\neq 0 \), or one sets
\( a=1 \), \( b=1 \), and \( I=0 \) when the physical \( I \) is zero.
Falling bodies in fluids, as described in the section <a href="#decay:app:drag">Vertical motion of a body in a viscous fluid</a>,
involves \( u^{\prime}=-au+b \) with seven physical parameters. All these vanish
in the scaled version of the problem if we start the motion from rest!

<p>
Many more details about scaling is presented in
the
document <a href="http://tinyurl.com/k3sdbuv/pub/scale" target="_self">Scaling</a> <a href="._decay-sol008.html#Langtangen_deqbook_scale">[4]</a>.

<h2 id="decay:app:pop">Evolution of a population</h2>

<p>
Let \( N \) be the number of individuals in a population occupying some
spatial domain.  Despite \( N \) being an integer in this problem, we
shall compute with \( N \) as a real number and view \( N(t) \) as a
continuous function of time.  The basic model assumption is that in a
time interval \( \Delta t \) the number of newcomers to the populations
(newborns) is proportional to \( N \), with proportionality constant \( \bar
b \). The amount of newcomers will increase the population and result in

$$ N(t+\Delta t) = N(t) + \bar bN(t)\tp  $$

It is obvious that a long time interval \( \Delta t \) will result in
more newcomers and hence a larger \( \bar b \). Therefore, we introduce
\( b=\bar b/\Delta t \): the number of newcomers per unit time and per
individual. We must then multiply \( b \) by the length of the time
interval considered and by the population size to get the
total number of new individuals, \( b\Delta t N \).

<p>
If the number of removals from the population (deaths) is also
proportional to \( N \), with proportionality constant \( d\Delta t \),
the population evolves according to
$$ N(t+\Delta t) = N(t) + b\Delta t N(t) - d\Delta t N(t)\tp  $$

Dividing by \( \Delta t \) and letting \( \Delta t \rightarrow 0 \),
we get the ODE

$$
\begin{equation}
N^{\prime} = (b-d)N,\quad N(0)=N_0\tp
\end{equation}
$$

In a population where the death rate (\( d \)) is larger than
then newborn rate (\( b \)), \( b-d < 0 \), and the population experiences
exponential decay rather than exponential growth.

<p>
In some populations there is an immigration of individuals into the
spatial domain. With \( I \) individuals coming in per time unit,
the equation for the population change becomes

$$ N(t+\Delta t) = N(t) + b\Delta t N(t) - d\Delta t N(t) + \Delta t I\tp  $$

The corresponding ODE reads
$$
\begin{equation}
N^{\prime} = (b-d)N + I,\quad N(0)=N_0
\tp
\end{equation}
$$

Emigration is also modeled by this \( I \) term if we just change its sign: \( I < 0 \).
So, the \( I \) term models migration in and out of the domain in general.

<p>
Some simplification arises if we introduce a fractional measure
of the population: \( u=N/N_0 \) and set \( r=b-d \). The ODE problem
now becomes

$$
\begin{equation}
u^{\prime} = ru + f,\quad u(0)=1,
\tag{82}
\end{equation}
$$

where \( f=I/N_0 \) measures the net immigration per time unit as
the fraction of the initial population. Very often, \( r \) is approximately
constant, but \( f \) is usually a function of time.

<p>
The growth rate \( r \) of a population decreases if the environment
has limited resources. Suppose the environment can sustain at
most \( N_{\max} \) individuals. We may then assume that the growth rate
approaches zero as \( N \) approaches \( N_{\max} \), i.e., as \( u \) approaches
\( M=N_{\max}/N_0 \). The simplest possible evolution of \( r \) is then a
linear function: \( r(t)={\varrho}(1-u(t)/M) \), where \( \varrho \)
is the initial growth rate when the population is small relative to the
maximum size and there is enough resources. Using this \( r(t) \) in
<a href="#mjx-eqn-82">(82)</a> results in the <em>logistic model</em> for the
evolution of a population (assuming for the moment that \( f=0 \)):
$$
\begin{equation}
u^{\prime} = {\varrho}(1-u/M)u,\quad u(0)=1
\tp
\tag{83}
\end{equation}
$$

Initially, \( u \) will grow at rate \( \varrho \), but the growth will decay
as \( u \) approaches \( M \), and then there is no more change in \( u \), causing
\( u\rightarrow M \) as \( t\rightarrow\infty \).
Note that the logistic equation \( u^{\prime}={\varrho}(1-u/M)u \) is <em>nonlinear</em> because
of the quadratic term \( -u^2{\varrho}/M \).

<h2 id="decay:app:interest">Compound interest and inflation</h2>

<p>
Say the annual interest rate is \( r \) percent and that the bank
adds the interest once a year to your investment.
If \( u^n \) is the investment in year \( n \), the investment in year \( u^{n+1} \)
grows to

$$ u^{n+1} = u^n + \frac{r}{100}u^n
\tp  $$

In reality, the interest rate is added every day. We therefore introduce
a parameter \( m \) for the number of periods per year when the interest
is added. If \( n \) counts the periods, we have the fundamental model
for compound interest:
$$
\begin{equation}
u^{n+1} = u^n + \frac{r}{100 m}u^n
\tp
\tag{84}
\end{equation}
$$

This model is a <em>difference equation</em>, but it can be transformed to a
continuous differential equation through a limit process.
The first step is to derive a formula for the growth of the investment
over a time \( t \).
Starting with an investment \( u^0 \), and assuming that \( r \) is constant in time,
we get
$$
\begin{align*}
u^{n+1} &= \left(1 + \frac{r}{100 m}\right)u^{n}\\ 
&= \left(1 + \frac{r}{100 m}\right)^2u^{n-1}\\ 
&\ \ \vdots\\ 
&= \left(1 +\frac{r}{100 m}\right)^{n+1}u^{0}
\end{align*}
$$

Introducing time \( t \), which here is a real-numbered counter for years,
we have that \( n=mt \), so we can write

$$ u^{mt} = \left(1 + \frac{r}{100 m}\right)^{mt} u^0\tp  $$

The second step is to assume <em>continuous compounding</em>, meaning that the
interest is added continuously. This implies \( m\rightarrow\infty \), and
in the limit one gets the formula
$$
\begin{equation}
u(t) = u_0e^{rt/100},
\end{equation}
$$

which is nothing but the solution of the ODE problem
$$
\begin{equation}
u^{\prime} = \frac{r}{100}u,\quad u(0)=u_0
\tp
\tag{85}
\end{equation}
$$

This is then taken as the ODE model for compound interest if \( r>0 \).
However, the reasoning applies equally well to inflation, which is
just the case \( r < 0 \).
One may also take the \( r \) in <a href="#mjx-eqn-85">(85)</a>
as the net growth of an investemt, where \( r \) takes both compound interest
and inflation into account. Note that for real applications we must
use a time-dependent \( r \) in <a href="#mjx-eqn-85">(85)</a>.

<p>
Introducing \( a=\frac{r}{100} \), continuous inflation of an initial
fortune \( I \) is then
a process exhibiting exponential decay according to
$$ u^{\prime} = -au,\quad u(0)=I\tp  $$

<h2 id="decay:app:Newton:cooling">Newton's law of cooling</h2>

<p>
<!-- <a href="http://web.bham.ac.uk/winterhs/Newton.htm" target="_self"><tt>http://web.bham.ac.uk/winterhs/Newton.htm</tt></a> -->
<!-- I. Newton, Scala Graduum Caloris, Philosophical Transactions of the Royal Society of London, 1701 -->
<!-- explanation: <a href="http://www.madsci.org/posts/archives/2000-11/973522810.Ph.r.html" target="_self"><tt>http://www.madsci.org/posts/archives/2000-11/973522810.Ph.r.html</tt></a> -->

<p>
When a body at some temperature is placed in a cooling environment,
experience shows that the temperature falls rapidly in the beginning,
and then the change in temperature levels off until the body's
temperature equals that of the surroundings. Newton carried out some
experiments on cooling hot iron and found that the temperature
evolved as a &quot;geometric progression at times in arithmetic progression&quot;,
meaning that the temperature decayed exponentially.
Later, this result was formulated as a differential equation:
the rate of change of the temperature in a body is proportional to
the temperature difference between the body and its surroundings.
This statement is known as <em>Newton's law of cooling</em>, which
mathematically can be expressed as

$$
\begin{equation}
{dT\over dt} = -k(T-T_s),
\tag{86}
\end{equation}
$$

where \( T \) is the temperature of the body, \( T_s \) is the temperature
of the surroundings (which may be time-dependent),
\( t \) is time, and \( k \) is a positive constant.
Equation <a href="#mjx-eqn-86">(86)</a> is primarily viewed as an
empirical law, valid when heat is efficiently convected away
from the surface of the body by a flowing fluid such as air
at constant temperature \( T_s \).
The <em>heat transfer coefficient</em> \( k \) reflects the transfer of
heat from the body to
the surroundings and must be determined from physical experiments.

<p>
The cooling law <a href="#mjx-eqn-86">(86)</a> needs an initial
condition \( T(0)=T_0 \).

<h2 id="decay:app:nuclear">Radioactive decay</h2>

<p>
An atomic nucleus of an unstable atom may lose energy by emitting
ionizing particles and thereby be transformed to a nucleus with a
different number of protons and neutrons.  This process is known as
<a href="http://en.wikipedia.org/wiki/Radioactive_decay" target="_self">radioactive decay</a>.
Actually, the process is stochastic when viewed for a single atom,
because it is impossible to predict exactly when a particular atom
emits a particle. Nevertheless, with a large number of atoms, \( N \), one
may view the process as deterministic and compute the mean behavior of
the decay. Below we reason intuitively about an ODE for the mean
behavior. Thereafter, we show mathematically that a detailed stochastic model
for single atoms leads to the same mean behavior.

<h3 id="___sec101">Deterministic model </h3>

<p>
Suppose at time \( t \), the number of the original atom type is \( N(t) \).
A basic model assumption is that the transformation of the atoms of the original
type in a small time interval \( \Delta t \) is proportional to
\( N \), so that

$$ N(t+\Delta t) = N(t) - a\Delta t N(t),$$

where \( a>0 \) is a constant. Introducing \( u=N(t)/N(0) \), dividing by
\( \Delta t \) and letting \( \Delta t\rightarrow 0 \) gives the
following ODE:

$$
\begin{equation}
u^{\prime} = -au,\quad u(0)=1
\tp
\end{equation}
$$

The parameter \( a \) can for a given nucleus be expressed through the
<em>half-life</em> \( t_{1/2} \), which is the time taken for the decay to reduce the
initial amount by one half, i.e., \( u(t_{1/2}) = 0.5 \).
With \( u(t)=e^{-at} \), we get \( t_{1/2}=a^{-1}\ln 2 \) or \( a=\ln 2/t_{1/2} \).

<p>
<!-- <a href="http://en.wikipedia.org/wiki/Exponential_decay" target="_self"><tt>http://en.wikipedia.org/wiki/Exponential_decay</tt></a> -->

<h3 id="___sec102">Stochastic model </h3>

<p>
Originally, we have \( N_0 \) atoms. Up to some particular time \( t \), each
atom may either have decayed or not. If not, they have &quot;survived&quot;.
We want to count how many original
atoms that have survived.
The survival of a single atom at time \( t \) is a random event. Since there
are only two outcomes, survival or decay, we have a
<a href="http://en.wikipedia.org/wiki/Bernoulli_trial" target="_self">Bernoulli trial</a>.
Let \( p \) be the
probability of survival (implying that the probability of decay
is \( 1-p \)). If each atom survives independently of
the others, and the probability of survival is the same for every
atom, we have \( N_0 \) Bernoulli trials, known as
a <em>binomial experiment</em> from probability theory.
The probability \( P(N) \) that \( N \) out
of the \( N_0 \) atoms have survived at time \( t \) is then given by the
famous <em>binomial distribution</em>

$$ P(N) = \frac{N_0!}{N! (N_0-N)!}p^N (1-p)^{N_0-N}\tp $$

The mean (or expected) value \( \E{P} \) of \( P(N) \) is known to be \( N_0p \).

<p>
It remains to estimate \( p \). Let the interval \( [0,t] \) be divided into \( m \)
small subintervals of length \( \Delta t \). We make the assumption that
the probability of decay of a single atom in an interval of length \( \Delta t \)
is \( \tilde p \), and that this probability is proportional to \( \Delta t \):
\( \tilde p = \lambda\Delta t \) (it sounds natural that the probability
of decay increases with \( \Delta t \)). The corresponding probability of survival
is \( 1-\lambda\Delta t \). Believing that \( \lambda \) is independent
of time, we have, for each interval of length \( \Delta t \),
a Bernoulli trial: the atom either survives or
decays in that interval. Now, \( p \) should be the probability that the atom
survives in all the intervals, i.e., that we have \( m \) successful
Bernoulli trials in a row and therefore

$$ p = (1-\lambda\Delta t)^m\tp$$

The expected number of atoms of the original type at time \( t \) is

$$
\begin{equation}
\E{P} = N_0p = N_0(1-\lambda\Delta t)^m,\quad m=t/\Delta t\tp
\end{equation}
$$

<p>
To see the relation between the two types of Bernoulli trials and the
ODE above, we go to the limit \( \Delta t\rightarrow t \), \( m\rightarrow\infty \).
One can show that

$$ p = \lim_{m\rightarrow\infty} (1-\lambda\Delta t)^m
= \lim_{m\rightarrow\infty} \left(1-\lambda\frac{t}{m}\right)^m = e^{-\lambda t}
$$

This is the famous exponential waiting time (or arrival time) distribution for a
Poisson process in probability theory (obtained here, as often done, as
the limit of a binomial experiment). The probability of decay,
\( 1-e^{-\lambda t} \), follows an <a href="http://en.wikipedia.org/wiki/Exponential_distribution" target="_self">exponential distribution</a>.
The limit means that \( m \) is very
large, hence \( \Delta t \) is very small, and \( \tilde p=\lambda\Delta t \)
is very small since the intensity of the events, \( \lambda \), is assumed
finite. This situation corresponds to a very small probability
that an atom will decay in a very short time interval, which is a
reasonable model.
The same model occurs in lots of different applications, e.g.,
when waiting for a taxi, or when finding defects along a rope.

<h3 id="___sec103">Relation between stochastic and deterministic models </h3>

<p>
With \( p=e^{-\lambda t} \) we get the expected number of original atoms
at \( t \) as \( N_0p=N_0e^{-\lambda t} \), which is exactly the solution of
the ODE model \( N^{\prime}=-\lambda N \). This also gives an interpretation
of \( a \) via \( \lambda \) or vice versa. Our important finding here
is that the ODE model
captures the mean behavior of the underlying stochastic model. This
is, however, not always the common relation between microscopic stochastic
models and macroscopic &quot;averaged&quot; models.

<p>
Also of interest, is that a Forward Euler discretization of
\( N^{\prime}=-\lambda N \), \( N(0)=N_0 \), gives \( N^m = N_0(1-\lambda\Delta t)^m \)
at time \( t_m=m\Delta t \), which is exactly the
expected value of the stochastic experiment with \( N_0 \) atoms
and \( m \) small intervals of length \( \Delta t \), where each atom can
decay with probability \( \lambda\Delta t \) in an interval.

<p>
A fundamental question is how accurate the ODE model is. The underlying
stochastic model fluctuates around its expected value. A measure
of the fluctuations is the standard deviation of the binomial experiment with
\( N_0 \) atoms, which can be shown to be \( \Std{P}=\sqrt{N_0p(1-p)} \). Compared
to the size of the expectation, we get
the normalized standard deviation

$$ \frac{\sqrt{\Var{P}}}{\E{P}} = N_0^{-1/2}\sqrt{p^{-1}-1}
= N_0^{-1/2}\sqrt{(1-e^{-\lambda t})^{-1}-1}\approx
(N_0\lambda t)^{-1/2},
$$

showing that the normalized fluctuations are very small if \( N_0 \) is
very large, which is usually the case.

<h2 id="decay:app:kinetics">Chemical kinetics</h2>

<h3 id="___sec105">Irreversible reaction of two substances </h3>

<p>
Consider two chemical substances, A and B, and a chemical reaction that
turns A into B. In a small time interval, some of the
molecules of type A are transformed into molecules of B. This process is,
from a mathematical modeling point of view, equivalent to the
radioactive decay process described in the previous section. We can
therefore apply the same modeling approach. If \( N_A \) is the number of
molecules of substance A, we have that \( N_A \) is governed by the
differential equation

$$ \frac{dN_A}{dt} = -kN_A,$$

where (the constant) \( k \) is called the <em>rate constant</em> of the reaction.
Rather than using the number of molecules, we use the <em>concentration</em>
of molecules: \( [A](t) = N_A(t)/N_A(0) \).
We see that \( d[A]/dt = N_A(0)^{-1} dN_A/dt \).
Replacing \( N_A \) by \( [A] \) in the equation for \( N_A \) leads to the equation
for the concentration \( [A] \):

$$
\begin{equation}
\frac{d[A]}{dt} = -k[A],\quad t\in (0,T],\ [A](0)=A_0, \tp
\tag{87}
\end{equation}
$$

Since substance A is transformed to substance B, we have that the concentration
of \( [B] \) grows by the loss of \( [A] \):

$$
\frac{d[B]}{dt} = k[A],\quad [B](0)=B_0\tp
$$

The mathematical model can either be <a href="#mjx-eqn-87">(87)</a> or
the system

$$
\begin{align}
\frac{d[A]}{dt} &= -k[A], &t\in (0,T]\\ 
\frac{d[B]}{dt} &= k[A], &t\in (0,T]\\ 
[A](0) &= A_0,\\ 
[B](0) &= B_0\tp
\end{align}
$$

<p>
This reaction is known as a <em>first-order reaction</em>, where each molecule of
A makes an independent decision about whether to complete the reaction,
i.e., independent of what happens to any other molecule.

<p>
An \( n \)-th order reaction is modeled by

$$
\begin{align}
\frac{d[A]}{dt} &= -k[A]^n,\\ 
\frac{d[B]}{dt} &= k[A]^n,
\end{align}
$$

for \( t\in (0,T] \) with initial conditions \( [A](0) = A_0 \) and
\( [B](0) = B_0 \). Here, \( n \) can be a real number,
but is most often an integer. Note that
the sum of the concentrations is constant since

$$ \frac{d[A]}{dt} + \frac{d[B]}{dt} = 0\quad\Rightarrow\quad
[A](t) + [B](t) = \hbox{const} \quad\Rightarrow\quad [A](t) + [B](t) = [A](0) + [B](0) = A_0+B_0\tp$$

<h3 id="___sec106">Reversible reaction of two substances </h3>

<p>
Let the chemical reaction turn substance A into B and substance B into A.
The rate of change of \( [A] \) has then two contributions: a loss \( k_A[A] \)
and a gain \( k_B[B] \):

$$
\begin{equation}
\frac{d[A]}{dt} = -k_A[A] + k_B[B], \quad t\in (0,T],\ [A](0)=A_0\tp
\end{equation}
$$

Similarly for substance B,

$$
\begin{equation}
\frac{d[A]}{dt} = k_A[A] - k_B[B], \quad t\in (0,T],\ [A](0)=A_0\tp
\end{equation}
$$

Again,

$$ \frac{d[A]}{dt} + \frac{d[B]}{dt} = 0\quad\Rightarrow\quad
[A](t) + [B](t) = A_0+B_0\tp$$

<h3 id="___sec107">Irreversible reaction of two substances into a third </h3>

<p>
Now we consider two chemical substances, A and B, reacting with each
other and producing a substance C. In a small time interval \( \Delta t \),
molecules of type A and B are occasionally colliding, and in some
of the collisions, a chemical reaction occurs, which turns A and B into
a molecule of type C. (More generally, \( M_A \) molecules of A and \( M_B \)
molecules of B react to form \( M_C \) molecules of \( C \).)
The number of possible pairings, and thereby collisions, of A and B is
\( N_AN_B \), where \( N_A \) is the number of molecules of A, and \( N_B \) is the
number of molecules of \( N_B \).
A fraction \( k \) of these collisions,
\( \hat k\Delta t N_AN_B \), features a chemical reaction and produce
\( N_C \) molecules of C. The fraction is thought to be proportional to
\( \Delta t \): considering a twice as long time interval, twice as many
molecules collide, and twice as many reactions occur.
The increase in molecules of substance C is now found
from the reasoning

$$ N_C(t+\Delta t) = N_C(t) + \hat k\Delta t N_AN_B\tp$$

Dividing by \( \Delta t \),

$$ \frac{N_C(t+\Delta t) - N_C(t)}{\Delta t} = \hat k N_AN_B,$$

and letting \( \Delta t\rightarrow 0 \), gives the differential equation

$$ \frac{dN_C}{dt} = \hat k N_AN_B\tp$$

(This equation is known as the important "law of mass action" discovered by
the Norwegian scientists Cato M.&nbsp;Guldberg and Peter Waage.
A more general form of the right-hand side is \( \hat kN_A^{\alpha}N_B^{\beta} \).
All the constants \( \hat k \), \( \alpha \), and \( \beta \) must be determined from
experiments.)

<p>
Working with concentrations instead, we introduce \( [C](t)=N_C(t)/N_C(0) \),
with similar definitions for \( [A] \) and \( [B] \) we get

$$
\begin{equation}
\frac{d[C]}{dt} = k [A][B]\tp
\end{equation}
$$

The constant \( k \) is related to \( \hat k \) by \( k = \hat k N_A(0)N_B(0)/N_C(0) \).
The gain in C is a loss of A and B:

$$
\begin{align}
\frac{d[A]}{dt} &= -k[A][B],\\ 
\frac{d[B]}{dt} &= -k[A][B]\tp
\end{align}
$$

<h3 id="___sec108">A biochemical reaction </h3>

<p>
A common reaction (known as <a href="https://en.wikipedia.org/wiki/Michaelis-Menten_kinetics" target="_self">Michaelis-Menton kinetics</a>) turns a substrate S into
a product P with aid of an enzyme E. The reaction is a two-stage process:
first S and E reacts to form a complex ES, where the enzyme and substrate
are bound to each other, and then ES is turned into E and P.
In the first stage, S and E react to produce a growth of ES according
to the law of mass action:

$$
\begin{align*}
\frac{d[S]}{dt} &= - k_+[E][S],\\ 
\frac{d[P]}{dt} &= - k_+[E][S],\\ 
\frac{d[ES]}{dt} &= k_+[E][S]\tp\\ 
\end{align*}
$$

The complex ES reacts and produces the product \( P \) at rate
\( -k_{v}[ES] \) and E at rate \( -k_-[ES] \). The total set of reactions can
then be expressed by

$$
\begin{align}
\frac{d[ES]}{dt} &= k_+[E][S] - k_v[ES] - k_-[ES],
\tag{88}\\ 
\frac{d[P]}{dt} &= k_v[ES],
\tag{89}\\ 
\frac{d[S]}{dt} &= -k_+[E][S] + k_-[ES],
\tag{90}\\ 
\frac{d[E]}{dt} &= -k_+[E][S] + k_-[ES] + k_v[ES]\tp
\tag{91}
\end{align}
$$

The initial conditions are \( [ES](0)=[P](0)=0 \), and \( [S]=S_0 \), \( [E]=E_0 \).
The constants \( k_+ \), \( k_- \), and \( k_v \) must be determined from experiments.

<p>
<!-- It is easy to see that \( [ES]^{\prime} + [E]^{\prime}=0 \), i.e., -->
<!-- \( [ES] + [E]= E_0=\hbox{const} \). And \( [ES] + [S] + [P] \) is constant. -->

<p>
<!-- Dimensionless Michaelis constant: (k_v + k_-)/k_+ -->

<h2 id="decay:app:SIR">Spreading of diseases</h2>

<p>
The modeling of spreading of diseases is very similar to the modeling
of chemical reactions in the section <a href="#decay:app:kinetics">Chemical kinetics</a>. The field
of epidemiology speaks about susceptibles: people who can get a disease;
infectives: people who are infected and can infect susceptibles; and
recovered: people who have recovered from the disease and
become immune.
Three categories are accordingly defined: S for susceptibles, I for
infectives, and R for recovered. The number in each category is tracked
by the functions \( S(t) \), \( I(t) \), and \( R(t) \).

<p>
To model how many people that get infected in a small time interval
\( \Delta t \), we reason as with reactions in the section <a href="#decay:app:kinetics">Chemical kinetics</a>.
The possible number of parings (&quot;collisions&quot;) between susceptibles
and infected is \( SI \). A fraction of these, \( \beta\Delta t SI \),
will actually meet and the infected succeeds of infecting the susceptible,
where \( \beta \) is a parameter to be empirically estimated.
This leads to a loss of susceptibles and a gain of infected:

$$
\begin{align*}
S(t+\Delta t) &= S(t) - \beta\Delta tSI,\\ 
I(t+\Delta t) &= I(t) + \beta\Delta tSI\tp
\end{align*}
$$

In the same time interval, a fraction \( \nu\Delta t I \)
of the infected is recovered.
The parameter \( \nu^{-1} \) has the interpretation of the average length of
the disease (time to recovery).
The \( \nu \Delta tI \) term is a loss for the I category, but a gain for the R
category:

$$
\begin{align*}
I(t+\Delta t) &= I(t) + \beta\Delta tSI - \nu\Delta t I,
R(t+\Delta t) &= R(t) + \nu\Delta t I\tp
\end{align*}
$$

Dividing these equations by \( \Delta t \) and going to the limit
\( \Delta t\rightarrow 0 \), gives the ODE system

$$
\begin{align}
\frac{dS}{dt} &= -\beta SI,
\tag{92}\\ 
\frac{dI}{dt} &=  \beta SI - \nu I,
\tag{93}\\ 
\frac{dR}{dt} &= \nu I,
\tag{94}
\end{align}
$$

with initial values \( S(0)=S_0 \), \( I(0)=I_0 \), and \( R(0)=0 \).
By adding the equations, we realize that

$$ \frac{dS}{dt}+\frac{dI}{dt}+\frac{dR}{dt}=0\quad\Rightarrow\quad
S+I+R=\hbox{const}=N,$$

where \( N \) is the total number in the population under consideration.
This property can be used as a partial verification during simulations.

<p>
Equations <a href="#mjx-eqn-92">(92)</a>-<a href="#mjx-eqn-94">(94)</a> are known as
the SIR model in epidemiology. The model can easily be extended to
incorporate vaccination programs, loss immunity after some time, etc.
Typical diseases that can be simulated by the SIR model and its variants
are measles, smallpox, flu, plague, and HIV.

<h2 id="decay:app:atm">Decay of atmospheric pressure with altitude</h2>

<p>
<!-- The Barometric Formula -->
<!-- <a href="http://en.wikipedia.org/wiki/Barometric_formula" target="_self"><tt>http://en.wikipedia.org/wiki/Barometric_formula</tt></a> -->

<p>
Vertical equilibrium of air in the atmosphere is governed by
the equation

$$
\begin{equation}
\frac{dp}{dz} = -\varrho g
\tp
\tag{95}
\end{equation}
$$

Here, \( p(z) \) is the air pressure, \( \varrho \) is the density of
air, and \( g=9.807\hbox{ m/s}^2 \) is a standard value of
the acceleration of gravity.
(Equation <a href="#mjx-eqn-95">(95)</a> follows directly from the general
Navier-Stokes equations for fluid motion, with
the assumption that the air does not move.)

<p>
The pressure is related to density and temperature through the ideal gas law

$$
\begin{equation}
\varrho = \frac{Mp}{R^*T}, \tag{96}
\end{equation}
$$

where \( M \) is the molar mass of the Earth's air (0.029 kg/mol),
\( R^* \) is the universal
gas constant (\( 8.314 \) Nm/(mol K)), and \( T \) is the temperature in Kelvin.
All variables \( p \), \( \varrho \), and \( T \) vary with the height \( z \).
Inserting <a href="#mjx-eqn-96">(96)</a> in <a href="#mjx-eqn-95">(95)</a> results
in an ODE with a variable coefficient:

$$
\begin{equation}
\frac{dp}{dz} = -\frac{Mg}{R^*T(z)} p
\tag{97}
\thinspace  .
\end{equation}
$$

<h3 id="___sec111">Multiple atmospheric layers </h3>

<p>
The atmosphere can be approximately modeled by seven layers.
In each layer, <a href="#mjx-eqn-97">(97)</a> is applied with
a linear temperature of the form

$$ T(z) = \bar T_i + L_i(z-h_i),$$

where \( z=h_i \) denotes the bottom of layer number \( i \),
having temperature \( \bar T_i \),
and \( L_i \) is a constant in layer number \( i \). The table below
lists \( h_i \) (m), \( \bar T_i \) (K), and \( L_i \) (K/m) for the layers
\( i=0,\ldots,6 \).

<p>

<div class="row">
  <div class="col-xs-4">
    <table class="table table-striped table-hover table-condensed">
<thead>
<tr><td align="center">\( i \)</td> <td align="center">\( h_i \)</td> <td align="center">\( \bar T_i \)</td> <td align="center">\( L_i \)</td> </tr>
</thead>
<tbody>
<tr><td align="left">   0          </td> <td align="right">   0            </td> <td align="right">   288               </td> <td align="right">   -0.0065      </td> </tr>
<tr><td align="left">   1          </td> <td align="right">   11,000       </td> <td align="right">   216               </td> <td align="right">   0.0          </td> </tr>
<tr><td align="left">   2          </td> <td align="right">   20,000       </td> <td align="right">   216               </td> <td align="right">   0.001        </td> </tr>
<tr><td align="left">   3          </td> <td align="right">   32,000       </td> <td align="right">   228               </td> <td align="right">   0.0028       </td> </tr>
<tr><td align="left">   4          </td> <td align="right">   47,000       </td> <td align="right">   270               </td> <td align="right">   0.0          </td> </tr>
<tr><td align="left">   5          </td> <td align="right">   51,000       </td> <td align="right">   270               </td> <td align="right">   -0.0028      </td> </tr>
<tr><td align="left">   6          </td> <td align="right">   71,000       </td> <td align="right">   214               </td> <td align="right">   -0.002       </td> </tr>
</tbody>
    </table>
  </div>
</div> <!-- col-xs-4 -->
<p>
For implementation it might be convenient to write <a href="#mjx-eqn-97">(97)</a>
on the form
$$
\begin{equation}
\frac{dp}{dz} = -\frac{Mg}{R^*(\bar T(z) + L(z)(z-h(z)))} p,
\end{equation}
$$

where \( \bar T(z) \), \( L(z) \), and \( h(z) \) are piecewise constant
functions with values given in the table.
The value of the pressure at the sea level \( z=0 \), \( p_0=p(0) \), is \( 101325 \) Pa.

<h3 id="___sec112">Simplification: \( L=0 \) </h3>

<p>
One common simplification is to assume that the temperature is
constant within each layer. This means that \( L=0 \).

<h3 id="___sec113">Simplification: one-layer model </h3>

<p>
Another commonly used approximation is to work with one layer instead of
seven. This <a href="http://en.wikipedia.org/wiki/Density_of_air" target="_self">one-layer model</a>
is based on \( T(z)=T_0 - Lz \), with
sea level standard temperature \( T_0=288 \) K and
temperature lapse rate \( L=0.0065 \) K/m.

<h2 id="decay:app:sediment">Compaction of sediments</h2>

<p>
Sediments, originally made from materials like sand and mud, get
compacted through geological time by the weight of new material that
is deposited on the sea bottom. The porosity \( \phi \) of the sediments
tells how much void (fluid) space there is between the sand and
mud grains. The porosity drops with depth, due to the weight of
the sediments above. This makes the void space shrink, and thereby compaction
increases.

<p>
A typical assumption is that the change in \( \phi \) at some depth \( z \)
is negatively proportional to \( \phi \). This assumption leads to
the differential equation problem

$$
\begin{equation}
\frac{d\phi}{dz} = -c\phi,\quad \phi(0)=\phi_0,
\tag{98}
\end{equation}
$$

where the \( z \) axis points downwards, \( z=0 \) is the surface with known
porosity, and \( c>0 \) is a constant.

<p>
The upper part of the Earth's crust consists of many geological layers
stacked on top of each other, as indicated in Figure
<a href="#decay:app:sediment:fig:layers">19</a>.  The model
<a href="#mjx-eqn-98">(98)</a> can be applied for each layer. In
layer number \( i \), we have the unknown porosity function \( \phi_i(z) \)
fulfilling \( \phi_i^{\prime}(z)=-c_iz \), since the constant \( c \) in the model
<a href="#mjx-eqn-98">(98)</a> depends on the type of sediment in
the layer. Alternatively, we can use <a href="#mjx-eqn-98">(98)</a>
to describe the porosity through all layers if \( c \) is taken as a
piecewise constant function of \( z \), equal to \( c_i \) in layer \( i \).
From the figure we see that new layers of sediments are
deposited on top of older ones as time progresses. The compaction,
as measured by \( \phi \), is
rapid in the beginning and then decreases (exponentially) with depth
in each layer.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 19:  Illustration of the compaction of geological layers (with different colors) through time. <div id="decay:app:sediment:fig:layers"></div> </p></center>
<p><img src="fig-decay/Compaction_of_Sediment.png" align="bottom" width=600></p>
</center>

<p>
When we drill a well at present time through the right-most column of
sediments in Figure <a href="#decay:app:sediment:fig:layers">19</a>, we can measure
the thickness of the sediment in (say) the bottom layer. Let \( L_1 \) be
this thickness.  Assuming that the volume of sediment remains constant
through time, we have that the initial volume, \( \int_0^{L_{1,0}}
\phi_1 dz \), must equal the volume seen today,
\( \int_{\ell-L_1}^{\ell}\phi_1 dz \), where \( \ell \) is the depth of the
bottom of the sediment in the present day configuration.  After having
solved for \( \phi_1 \) as a function of \( z \), we can then find the
original thickness \( L_{1,0} \) of the sediment from the equation

$$ \int_0^{L_{1,0}} \phi_1 dz = \int_{\ell-L_1}^{\ell}\phi_1 dz \tp $$

In hydrocarbon exploration it is important to know \( L_{1,0} \) and the
compaction history of the various layers of sediments.

<h2 id="decay:app:drag">Vertical motion of a body in a viscous fluid</h2>

<p>
A body moving vertically through a fluid (liquid or gas) is subject to
three different types of forces: the gravity force, <a href="http://en.wikipedia.org/wiki/Drag_(physics)" target="_self">the drag force</a>,
and the buoyancy force.

<h3 id="___sec116">Overview of forces </h3>

<p>
Taking the upward direction as positive,
the gravity force is \( F_g= -mg \), where \( m \) is the mass of the body and
\( g \) is the acceleration of gravity.
The uplift or buoyancy force (&quot;Archimedes force&quot;) is \( F_b = \varrho gV \),
where \( \varrho \) is the density of the fluid and
\( V \) is the volume of the body.

<p>
The drag force is of two types, depending on the Reynolds number
$$
\begin{equation}
\hbox{Re} = \frac{\varrho d|v|}{\mu},
\end{equation}
$$

where \( d \) is the diameter of the body in
the direction perpendicular to the flow, \( v \) is the velocity of the
body, and \( \mu \) is the dynamic viscosity of the fluid.
When \( \hbox{Re} < 1 \), the drag force is fairly well modeled by
the so-called Stokes' drag,
which for a spherical body of diameter \( d \) reads
$$
\begin{equation}
F_d^{(S)} = - 3\pi d\mu v
\tp
\end{equation}
$$

Quantities are taken as positive in the upwards vertical direction, so
if \( v>0 \) and the body moves upwards, the drag force acts downwards and
become negative, in accordance with the minus sign in expression for
\( F_d^{(S)} \).

<p>
For large Re, typically \( \hbox{Re} > 10^3 \), the drag force is quadratic
in the velocity:
$$
\begin{equation}
F_d^{(q)} = -{1\over2}C_D\varrho A|v|v,
\end{equation}
$$

where \( C_D \) is a dimensionless drag coefficient depending on the body's shape,
and \( A \) is the cross-sectional area as
produced by a cut plane, perpendicular to the motion, through the thickest
part of the body. The superscripts \( \,{}^q \) and \( \,{}^S \) in
\( F_d^{(S)} \) and \( F_d^{(q)} \) indicate Stokes drag and quadratic drag,
respectively.

<h3 id="___sec117">Equation of motion </h3>

<p>
All the mentioned forces act in the vertical direction.
Newton's second law of motion applied to the body says that the sum of
these forces must equal the mass of the body times its acceleration
\( a \) in the vertical direction.

$$
\begin{equation*} ma = F_g + F_d^{(S)} + F_b \tp\end{equation*}
$$

Here we have chosen to model the fluid resistance by the Stokes drag.
Inserting the expressions for the forces yields

$$  ma = -mg - 3\pi d\mu v + \varrho gV
\tp
$$

The unknowns here are \( v \) and \( a \), i.e., we have two unknowns but only
one equation. From kinematics in physics we know that
the acceleration is the time derivative of the velocity: \( a = dv/dt \).
This is our second equation.
We can easily eliminate \( a \) and get a single differential equation for \( v \):

$$ m{dv\over dt} = -mg - 3\pi d\mu v + \varrho gV
\tp
$$

A small rewrite of this equation is handy: We express \( m \) as \( \varrho_bV \),
where \( \varrho_b \) is the density of the body, and we divide by
the mass to get

$$
\begin{equation}
v^{\prime}(t) = - \frac{3\pi d\mu}{\varrho_b V} v + g\left(\frac{\varrho}{\varrho_b} -1\right)
\tag{99}
\tp
\end{equation}
$$

We may introduce the constants
$$
\begin{equation}
a = \frac{3\pi d\mu}{\varrho_b V},\quad
b = g\left(\frac{\varrho}{\varrho_b} -1\right),
\end{equation}
$$

so that the structure of the differential equation becomes obvious:

$$
\begin{equation}
v^{\prime}(t) = -av(t) + b
\tag{100}
\tp
\end{equation}
$$

The corresponding initial condition is \( v(0)=v_0 \) for some prescribed
starting velocity \( v_0 \).

<p>
This derivation can be repeated with the quadratic drag force
\( F_d^{(q)} \), leading to the result

$$
\begin{equation}
v^{\prime}(t) =
-{1\over2}C_D{\varrho A\over\varrho_b V}|v|v +
g\left({\varrho\over\varrho_b} - 1\right)
\tp
\tag{101}
\end{equation}
$$

Defining

$$
\begin{equation}
a = {1\over2}C_D{\varrho A\over\varrho_b V},
\end{equation}
$$

and \( b \) as above, we can write <a href="#mjx-eqn-101">(101)</a> as
$$
\begin{equation}
v^{\prime}(t) = -a|v|v + b
\tp
\tag{102}
\end{equation}
$$

<h3 id="___sec118">Terminal velocity </h3>

<p>
An interesting aspect of <a href="#mjx-eqn-100">(100)</a> and
<a href="#mjx-eqn-102">(102)</a> is whether \( v \) will approach
a final constant value,
the so-called <em>terminal velocity</em> \( v_T \), as \( t\rightarrow\infty \).
A constant \( v \) means that
\( v^{\prime}(t)\rightarrow 0 \) as \( t\rightarrow\infty \) and therefore
the terminal velocity \( v_T \) solves

$$0 = -av_T + b$$

and
$$ 0 = -a|v_T|v_T + b
\tp
$$

The former equation implies \( v_T = b/a \), while the latter has solutions
\( v_T =-\sqrt{|b|/a} \) for a falling body (\( v_T < 0 \)) and
\( v_T = \sqrt{b/a} \) for a rising body (\( v_T>0 \)).

<h3 id="___sec119">A Crank-Nicolson scheme </h3>

<p>
Both governing equations, the Stokes' drag model
<a href="#mjx-eqn-100">(100)</a> and the quadratic drag model
<a href="#mjx-eqn-102">(102)</a>, can be readily solved
by the Forward Euler scheme. For higher accuracy one can use
the Crank-Nicolson method, but a straightforward application
of this method gives
a nonlinear equation in the new unknown value \( v^{n+1} \) when applied to
<a href="#mjx-eqn-102">(102)</a>:

$$
\begin{equation}
\frac{v^{n+1}-v^n}{\Delta t}
= -a\half(|v^{n+1}|v^{n+1} + |v^n|v^n) + b
\tag{103}
\tp
\end{equation}
$$

The first term on the right-hand side of <a href="#mjx-eqn-103">(103)</a>
is the arithmetic average of \( -|v|v \) evaluated at time levels \( n \) and \( n+1 \).

<p>
Instead of approximating the term \( -|v|v \) by an arithmetic
average, we can use a <em>geometric mean</em>:

$$
\begin{equation}
(|v|v)^{n+\half} \approx |v^n|v^{n+1}
\tp
\end{equation}
$$

The error is of second order in \( \Delta t \), just as for the arithmetic
average and the centered finite difference approximation in
<a href="#mjx-eqn-103">(103)</a>. With the geometric mean,
the resulting discrete equation

$$
\frac{v^{n+1}-v^n}{\Delta t} = - a|v^{n}|v^{n+1} + b
$$

becomes a <em>linear</em> equation in \( v^{n+1} \), and we can
therefore easily solve for \( v^{n+1} \):

$$
\begin{equation}
v^{n+1} = \frac{v_n + \Delta t b^{n+\half}}{1 + \Delta t a^{n+\half}|v^{n}|}\tp
\tag{104}
\end{equation}
$$

<p>
Using a geometric mean instead of an arithmetic mean in the Crank-Nicolson
scheme is an attractive method for avoiding a nonlinear algebraic
equation when discretizing a nonlinear ODE.

<p>
<!-- Is the error actually of second order for an arbitrary a(u)u term? -->

<h3 id="___sec120">Physical data </h3>

<p>
Suitable values of \( \mu \) are \( 1.8\cdot 10^{-5}\hbox{ Pa}\, \hbox{s} \) for air
and \( 8.9\cdot 10^{-4}\hbox{ Pa}\, \hbox{s} \) for water.
Densities can be taken as \( 1.2\hbox{ kg/m}^3 \) for air and as
\( 1.0\cdot 10^3\hbox{ kg/m}^3 \) for water. For considerable vertical
displacement in the atmosphere one should take into account that
the density of air varies with the altitude, see the section <a href="#decay:app:atm">Decay of atmospheric pressure with altitude</a>.
One possible density variation arises from the one-layer model
in the mentioned section.

<p>
Any density variation makes \( b \) time dependent and we need
\( b^{n+\half} \) in <a href="#mjx-eqn-104">(104)</a>.
To compute the density that enters
\( b^{n+\half} \) we must also compute the vertical
position \( z(t) \) of the body. Since \( v=dz/dt \), we can use a centered
difference approximation:

$$ \frac{z^{n+\half} - z^{n-\half}}{\Delta t} = v^n
\quad\Rightarrow\quad z^{n+\half} = z^{n-\half}+\Delta t\, v^n\tp$$

This \( z^{n+\half} \) is used in the expression for \( b \)
to compute \( \varrho(z^{n+\half}) \) and then \( b^{n+\half} \).

<p>
The <a href="http://en.wikipedia.org/wiki/Drag_coefficient" target="_self">drag coefficient</a> \( C_D \) depends heavily
on the shape of the body.  Some values are: 0.45 for a sphere, 0.42
for a semi-sphere, 1.05 for a cube, 0.82 for a long cylinder (when the
center axis is in the vertical direction), 0.75 for a rocket,
1.0-1.3 for a man in upright position, 1.3 for a flat plate perpendicular
to the flow, and
0.04 for a streamlined, droplet-like body.

<h3 id="___sec121">Verification </h3>

<p>
To verify the program, one may assume a heavy body in air such that the \( F_b \)
force can be neglected, and further assume a small velocity such that the
air resistance \( F_d \) can also be neglected. This can be obtained by
setting \( \mu \) and \( \varrho \) to zero. The motion then leads to
the velocity
\( v(t)=v_0 - gt \), which is linear in \( t \) and therefore should be
reproduced to machine precision (say tolerance \( 10^{-15} \)) by any
implementation based on the Crank-Nicolson or Forward Euler schemes.

<p>
Another verification, but not as powerful as the one above,
can be based on computing the terminal velocity and comparing with
the exact expressions.
The advantage of this verification is that we can also
test the situation \( \varrho\neq 0 \).

<p>
As always, the method of manufactured solutions can be applied to
test the implementation of all terms in the governing equation, but
then the solution has no physical relevance in general.

<h3 id="___sec122">Scaling </h3>

<p>
Applying scaling, as described in the section <a href="#decay:app:scaling">Scaling</a>,
will for the linear case reduce the need to estimate values for
seven parameters down to choosing one value of a single dimensionless parameter

$$ \beta = \frac{\varrho_b gV\left(\frac{\varrho}{\varrho_b} -1\right)}{3\pi d\mu I},$$

provided \( I\neq 0 \). If the motion starts from rest, \( I=0 \), the scaled
problem reads \( \bar u^{\prime}=1-\bar u \), \( \bar u(0)=0 \), and there is
no need for estimating physical parameters (!).
This means that there is a single universal solution to the problem
of a falling body starting from rest:
\( \bar u(t) = 1 - e^{-\bar t} \). All real
physical cases correspond to stretching the \( \bar t \) axis and the \( \bar u \)
axis in this dimensionless solution. More precisely, the physical velocity
\( u(t) \) is related to the dimensionless velocity \( \bar u(\bar t) \) through

$$ u = \frac{\varrho_bgV\left(\frac{\varrho}{\varrho_b} -1\right)}{3\pi d\mu}\bar u(t/(g(\varrho/\varrho_b -1))) =
\frac{\varrho_bgV\left(\frac{\varrho}{\varrho_b} -1\right)}{3\pi d\mu}(1 -
e^{t/(g(\varrho/\varrho_b -1))})\tp$$

<h2 id="decay:app:diffusion:Fourier">Decay ODEs from solving a PDE by Fourier expansions</h2>

<p>
<!-- Maybe move to diffusion part? Makes sense there too, or refer...or -->
<!-- repeat, or make one exer with two k's and then generalize in diffusion -->

<p>
Suppose we have a partial differential equation
$$ \frac{\partial u}{\partial t} = \alpha\frac{\partial^2u}{\partial x^2}
+ f(x,t),
$$

with boundary conditions \( u(0,t)=u(L,t)=0 \) and initial condition
\( u(x,0)=I(x) \). One may express the solution as
$$ u(x,t) = \sum_{k=1}^m A_k(t)e^{ikx\pi/L},$$

for appropriate unknown functions \( A_k \), \( k=1,\ldots,m \).
We use the complex exponential \( e^{ikx\pi/L} \) for easy algebra, but
the physical \( u \) is taken as the real part of any complex expression.
Note that the expansion in terms of \( e^{ikx\pi/L} \) is compatible with
the boundary conditions: all functions \( e^{ikx\pi/L} \) vanish for
\( x=0 \) and \( x=L \). Suppose we can express \( I(x) \) as

$$ I(x) = \sum_{k=1}^m I_ke^{ikx\pi/L}
\tp
$$

Such an expansion can be computed by well-known Fourier expansion techniques,
but those details are not important here.
Also, suppose we can express the given \( f(x,t) \) as
$$ f(x,t) = \sum_{k=1}^m b_k(t)e^{ikx\pi/L}
\tp
$$

Inserting the expansions for \( u \)
and \( f \) in the differential equations demands that all terms corresponding
to a given \( k \) must be equal. The calculations result in the follow
system of ODEs:

$$
A_k^{\prime}(t) = -\alpha\frac{k^2\pi^2}{L^2} + b_k(t),\quad k=1,\ldots,m
\tp
$$

From the initial condition
$$ u(x,0)=\sum_k A_k(0)e^{ikx\pi/L}=I(x)=\sum_k I_k e^{(ikx\pi/L)},$$

so it follows that \( A_k(0)=I_k \), \( k=1,\ldots,m \). We then have \( m \)
equations of the form \( A_k^{\prime}=-a A_k +b \), \( A_k(0)=I_k \), for
appropriate definitions of \( a \) and \( b \). These ODE problems
are independent of each other such that we can solve one problem
at a time. The outlined technique is a quite common solution approach to
partial differential equations.

<p>
<b>Remark.</b>
Since \( a_k \) depends on \( k \) and the stability of the
Forward Euler scheme demands \( a_k\Delta t \leq 1 \), we get that \( \Delta
t \leq \alpha^{-1}L^2\pi^{-2} k^{-2} \) for this scheme.  Usually, quite
large \( k \) values are needed to accurately represent the given
functions \( I \) and \( f \) so that \( \Delta t \) in the Forward Euler scheme
needs to be very small for these large values of \( k \).  Therefore, the
Crank-Nicolson and Backward Euler schemes, which allow larger \( \Delta
t \) without any growth in the solutions, are more popular choices when
creating time-stepping algorithms for partial differential equations
of the type considered in this example.

<h1 id="___sec124">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:radio:C14">Exercise 16: Radioactive decay of Carbon-14</h2>

<p>
The <a href="http://en.wikipedia.org/wiki/Carbon-14" target="_self">Carbon-14</a> isotope,
whose radioactive decay is used extensively in dating organic material
that is tens of thousands of years old, has a half-life of \( 5,730 \)
years.  Determine the age of an organic material that contains 8.4 percent
of its initial amount of Carbon-14.  Use a time unit of 1 year in the
computations.  The uncertainty in the half time of Carbon-14 is \( \pm
40 \) years.  What is the corresponding uncertainty in the estimate of
the age?

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_16_1" style="font-size: 80%;"></a>
<b>Hint 1.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_16_1">

<p>
Let \( A \) be the amount of Carbon-14. The ODE problem is then
\( A^{\prime}(t)=-aA(t) \), \( A(0)=I \). Introduced the scaled amount
\( u=A/I \). The ODE problem for \( u \) is \( u^{\prime}=-au \), \( u(0)=1 \).
Measure time in years.
Simulate until the first mesh point \( t_m \) such that \( u(t_m)\leq 0.084 \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_16_2" style="font-size: 80%;"></a>
<b>Hint 2.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_16_2">

<p>
Use simulations with \( 5,730\pm 40 \) y as input
and find the corresponding uncertainty interval for the result.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_16_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_16_3">

<p>
We need a tailored solver function for this exercise:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(I, a, u_crit, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;=-a*u, u(0)=I, for t in (0,t_m] until u &lt;= u_crit</span>
<span style="color: #BA2121; font-style: italic">    with steps of dt. Return t_m.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Use list for u and t since we do not know how many points</span>
    <span style="color: #408080; font-style: italic"># that are needed</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)               <span style="color: #408080; font-style: italic"># avoid integer division</span>
    u <span style="color: #666666">=</span> []
    t <span style="color: #666666">=</span> []

    u<span style="color: #666666">.</span>append(I)                  <span style="color: #408080; font-style: italic"># assign initial condition</span>
    t<span style="color: #666666">.</span>append(<span style="color: #666666">0</span>)
    <span style="color: #008000; font-weight: bold">while</span> u[<span style="color: #666666">-1</span>] <span style="color: #666666">&gt;</span> u_crit:
        u_new <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>a<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>a)<span style="color: #666666">*</span>u[<span style="color: #666666">-1</span>]
        u<span style="color: #666666">.</span>append(u_new)
        t<span style="color: #666666">.</span>append(t[<span style="color: #666666">-1</span>] <span style="color: #666666">+</span> dt)
    <span style="color: #008000; font-weight: bold">return</span> t[<span style="color: #666666">-1</span>]


half_life <span style="color: #666666">=</span> <span style="color: #666666">5730</span>
a  <span style="color: #666666">=</span> np<span style="color: #666666">.</span>log(<span style="color: #666666">2</span>)<span style="color: #666666">/</span>half_life
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Age:&#39;</span>, solver(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=</span>a, u_crit<span style="color: #666666">=0.084</span>, dt<span style="color: #666666">=10</span>, theta<span style="color: #666666">=0.5</span>)
</pre></div>
<p>
Running this code gives an age of 20,480 years.

<p>
The uncertainty can be estimated by the following code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">half_life_min <span style="color: #666666">=</span> <span style="color: #666666">5730</span> <span style="color: #666666">-</span> <span style="color: #666666">40</span>
half_life_max <span style="color: #666666">=</span> <span style="color: #666666">5730</span> <span style="color: #666666">+</span> <span style="color: #666666">40</span>
a_min <span style="color: #666666">=</span> np<span style="color: #666666">.</span>log(<span style="color: #666666">2</span>)<span style="color: #666666">/</span>half_life_min
a_max <span style="color: #666666">=</span> np<span style="color: #666666">.</span>log(<span style="color: #666666">2</span>)<span style="color: #666666">/</span>half_life_max
age_min <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=</span>a_max, u_crit<span style="color: #666666">=0.084</span>, dt<span style="color: #666666">=10</span>, theta<span style="color: #666666">=0.5</span>)
age_max <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=</span>a_min, u_crit<span style="color: #666666">=0.084</span>, dt<span style="color: #666666">=10</span>, theta<span style="color: #666666">=0.5</span>)
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Uncertainty: [</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">]&#39;</span> <span style="color: #666666">%</span> (age_min, age_max)
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>carbon14</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:cooling:schemes">Exercise 17: Derive schemes for Newton's law of cooling</h2>

<p>
Show in detail how we can apply the ideas of the Forward Euler,
Backward Euler, and Crank-Nicolson
discretizations to derive explicit
computational formulas for new temperature values in Newton's law of
cooling (see the section <a href="#decay:app:Newton:cooling">Newton's law of cooling</a>):

$$
\frac{dT}{dt} = -k(T-T_s(t)),\quad T(0)=T_0\tp
$$

Here, \( T \) is the temperature of the body, \( T_s(t) \) is the temperature
of the surroundings, \( t \) is time, \( k \) is the heat transfer
coefficient, and \( T_0 \) is the initial temperature of the body.
Summarize the discretizations in a \( \theta \)-rule
such that you can get the three
schemes from a single formula by varying the \( \theta \) parameter.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_1">

<p>
The idea of the Forward Euler scheme is to sample the ODE at \( t=t_n \)
and apply a forward difference approximation to the derivative:

$$ \frac{T^{n+1}-T^n}{\Delta t} = -k(T^n - T_s(t_n))\tp$$

The Backward Euler applies a backward difference instead:

$$ \frac{T^{n}-T^{n-1}}{\Delta t} = -k(T^n - T_s(t_n))\tp$$

The Crank-Nicolson scheme samples the ODE at \( t_{n+\half} \), applies
a centered difference approximation, and an arithmetic mean approximation
to \( T^{n+\half} \):

$$ \frac{T^{n+1}-T^n}{\Delta t} = -k(T^{n+\half} - T_s(t_{n+\half}))
\approx -k(\half(T^n + T^{n+1}) - T_s(t_{n+\half}))\tp$$

For each scheme we solve with respect to the unknown \( T^{n+1} \) (note
that we switch index from \( n \) to \( n+1 \) in the Backward Euler scheme):

$$
\begin{align*}
T^{n+1} &= T^n - k\Delta t(T^n - T_s(t_n)),\\ 
T^{n+1} &= \frac{T^n + k\Delta t T_s(t_{n+1})}{1 + k\Delta t},\\ 
T^{n+1} &= \frac{T^n - \half k\Delta t T^n + k\Delta t T_s(t_{n+\half})}{1 + \half k\Delta t}\tp
\end{align*}
$$

A \( \theta \) scheme can be formulated as

$$ T^{n+1} = \frac{T^n - (1-\theta) k\Delta t T^n + k\Delta t T_s((1-\theta) t_n+ \theta t_{n+1})}{1 + \theta k\Delta t}
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>schemes_cooling</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:cooling:py">Exercise 18: Implement schemes for Newton's law of cooling</h2>

<p>
The goal of this exercise is to implement the schemes from
<a href="#decay:app:exer:cooling:schemes">Exercise 17: Derive schemes for Newton's law of cooling</a> and investigate
several approaches for verifying the implementation.

<p>
<b>a)</b>
Implement the \( \theta \)-rule from
<a href="#decay:app:exer:cooling:schemes">Exercise 17: Derive schemes for Newton's law of cooling</a> in a function

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">cooling(T0, k, T_s, t_end, dt, theta=0.5)
</pre></div>
<p>
where <code>T0</code> is the initial temperature, <code>k</code> is
the heat transfer coefficient, <code>T_s</code> is a function of <code>t</code> for
the temperature of the
surroundings, <code>t_end</code> is the end time of the simulation, <code>dt</code> is the
time step, and <code>theta</code> corresponds to \( \theta \).  The <code>cooling</code>
function should return the temperature as an array <code>T</code> of values at
the mesh points and the time mesh <code>t</code>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_3">

<p>
Here is an appropriate function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cooling</span>(T0, k, T_s, t_end, dt, theta<span style="color: #666666">=0.5</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve T&#39;=-k(T-T_s(t)), T(0)=T0,</span>
<span style="color: #BA2121; font-style: italic">    for t in (0,t_end] with steps of dt.</span>
<span style="color: #BA2121; font-style: italic">    T_s(t) is a Python function of t.</span>
<span style="color: #BA2121; font-style: italic">    theta=0.5 means Crank-Nicolson, 1 is Backward</span>
<span style="color: #BA2121; font-style: italic">    Euler, and 0 is Forward Euler scheme.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)                  <span style="color: #408080; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(t_end<span style="color: #666666">/</span>dt))       <span style="color: #408080; font-style: italic"># no of time intervals</span>
    t_end <span style="color: #666666">=</span> Nt<span style="color: #666666">*</span>dt                   <span style="color: #408080; font-style: italic"># adjust to fit time step dt</span>
    T <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)              <span style="color: #408080; font-style: italic"># array of T[n] values</span>
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, t_end, Nt<span style="color: #666666">+1</span>) <span style="color: #408080; font-style: italic"># time mesh</span>
    T[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> T0                       <span style="color: #408080; font-style: italic"># set initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):          <span style="color: #408080; font-style: italic"># n=0,1,...,Nt-1</span>
        T[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> ((<span style="color: #666666">1</span> <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>k)<span style="color: #666666">*</span>T[n] <span style="color: #666666">+</span> \ 
        dt<span style="color: #666666">*</span>k<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>T_s(t[n<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>T_s(t[n])))<span style="color: #666666">/</span> \ 
        (<span style="color: #666666">1</span> <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>theta<span style="color: #666666">*</span>k)
    <span style="color: #008000; font-weight: bold">return</span> T, t
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
In the case \( \lim_{t\rightarrow\infty}T_s(t)=C=\mbox{const} \),
explain why \( T(t)\rightarrow C \). Construct an example where you
can illustrate this property in a plot. Implement a corresponding
test function that checks the correctness of the asymptotic
value of the solution.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_4">

<p>
Apply the limit to the ODE:

$$ \lim_{t\rightarrow\infty}\frac{dT}{dt} = -k(\lim_{t\rightarrow\infty} T
- \lim_{t\rightarrow\infty} T_s)\tp
$$

Assuming steady state behavior, \( dT/dt\rightarrow\infty \) as
\( t\rightarrow\infty \). Then we get

$$ 0 = -k(\lim_{t\rightarrow\infty} T
- C),
$$

which means

$$ \lim_{t\rightarrow\infty} T = C\tp$$

<p>
A corresponding test function takes the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_asymptotic</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Test that ``any&#39;&#39; initial condition leads to</span>
<span style="color: #BA2121; font-style: italic">    the same asymptotic behavior when T_s=constant.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
    plt<span style="color: #666666">.</span>figure()
    T_s <span style="color: #666666">=</span> <span style="color: #666666">5.</span>
    k <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
    dt <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    tol <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>  <span style="color: #408080; font-style: italic"># tolerance for testing asymptotic value</span>
    t_end <span style="color: #666666">=</span> <span style="color: #666666">7</span>    <span style="color: #408080; font-style: italic"># make sure t_end is large enough for tol</span>
    T0_values <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">2</span>, <span style="color: #666666">4</span>, <span style="color: #666666">5</span>, <span style="color: #666666">6</span>, <span style="color: #666666">8</span>, <span style="color: #666666">10</span>] <span style="color: #408080; font-style: italic"># test many cases</span>

    <span style="color: #008000; font-weight: bold">for</span> T0 <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #666666">0</span>, <span style="color: #666666">2</span>, <span style="color: #666666">4</span>, <span style="color: #666666">5</span>, <span style="color: #666666">6</span>, <span style="color: #666666">8</span>, <span style="color: #666666">10</span>]:
        u, t <span style="color: #666666">=</span> cooling(T0, k, <span style="color: #008000; font-weight: bold">lambda</span> t: T_s, t_end, dt)
        plt<span style="color: #666666">.</span>plot(t, u)

        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(u[<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> T_s) <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121"> != </span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (u[<span style="color: #666666">-1</span>], T_s)

    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;T0=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> T0 <span style="color: #008000; font-weight: bold">for</span> T0 <span style="color: #AA22FF; font-weight: bold">in</span> T0_values])
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Testing asymptotic behavior T_s=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> T_s)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
    plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;T&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp1.png&#39;</span>);  plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp1.pdf&#39;</span>)
    plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
Note that we have added a plot in the test function for convenience.
Letting test functions perform plotting is, however, not a good idea
if you want to run a large set of tests.

<p>
<center><p><img src="fig-decay/cooling_asymptotic.png" align="bottom" width=600></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
A piecewise constant surrounding temperature,

$$ T_s(t) = \left\lbrace\begin{array}{ll} C_0,& 0\leq t\leq t^*\\ 
C_1, & t>t^*,\end{array}\right.
$$

corresponds to a sudden change in the environment
at \( t=t^* \). Choose \( C_0=2T_0 \), \( C_1=\frac{1}{2}T_0 \), and
\( t^*=3/k \). Plot the solution \( T(t) \) and explain why it seems physically
reasonable.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_5" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_5">

<p>
First we implement a general tool for piecewise constant functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Piecewise</span>(<span style="color: #008000">object</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Class for holding a piecewise constant function.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, C0, C1, t_star):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>C0, <span style="color: #008000">self</span><span style="color: #666666">.</span>C1 <span style="color: #666666">=</span> C0, C1
        <span style="color: #008000">self</span><span style="color: #666666">.</span>t_star <span style="color: #666666">=</span> t_star

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__call__</span>(<span style="color: #008000">self</span>, t):
        <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">        Return value of piecewise constant function.</span>
<span style="color: #BA2121; font-style: italic">        t can be float or numpy array.</span>
<span style="color: #BA2121; font-style: italic">        &quot;&quot;&quot;</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(t, (<span style="color: #008000">float</span>,<span style="color: #008000">int</span>)):
            <span style="color: #008000; font-weight: bold">if</span> t <span style="color: #666666">&lt;=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>t_star:
                T_s <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>C0
            <span style="color: #008000; font-weight: bold">elif</span> t <span style="color: #666666">&gt;</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>t_star:
                T_s <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>C1
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #408080; font-style: italic"># assume numpy array</span>
            T_s <span style="color: #666666">=</span> np<span style="color: #666666">.</span>piecewise(t,
                               [t <span style="color: #666666">&lt;=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>t_star, t <span style="color: #666666">&gt;</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>t_star],
                               [<span style="color: #008000">self</span><span style="color: #666666">.</span>C0, <span style="color: #008000">self</span><span style="color: #666666">.</span>C1])
            <span style="color: #408080; font-style: italic"># Alternative</span>
            <span style="color: #408080; font-style: italic"># T_s = np.where(t &lt;= self.t_star, C0, C1)</span>
        <span style="color: #008000; font-weight: bold">return</span> T_s
</pre></div>
<p>
It is convenient to scale the problem such that we do not need to find
physically relevant values for \( k \). A common scaling of \( T \) is

$$ \bar T = \frac{T-T_0}{T_s-T_0},$$

when \( T_s \) is constant since then \( \bar T\in [0,1] \). Here, we may choose
the long-term value of \( T_s \) in the denominator such that \( \lim_{t\rightarrow\infty}\bar T=1 \), i.e.,

$$ \bar T = \frac{T-T_0}{0.5T_0-T_0}= -2\frac{T-T_0}{T_0},$$

but it leads to a shift in the sign of the temperature on the
right-hand side of the ODE, and we cannot reuse the code for the
original problem in the dimensionless case. We therefore avoid the negative
sign and use a temperature scale \( 2T_0-T_0 \),

$$ \bar T = \frac{T-T_0}{2T_0-T_0}= \frac{T-T_0}{T_0},$$

which gives \( \bar T \) varying from \( 0 \) initially to a maximum of
\( 1 \) and finally to a minimum of \( -\half \).
We scale \( T_s \) by its maximum value \( 2T_0 \) so \( \bar T_s\in [0,1] \):

$$ \bar T_s(\bar t) = \frac{T_s(t)}{\max_t T_s(t)} = \frac{T_s(t_c\bar t)}{2T_0} = \left\lbrace\begin{array}{ll}
1, & \bar t < t^*/t_c,\\ 
\frac{1}{4},& \bar t \geq t^*/t_c
\end{array}\right.
$$

where \( t_c \) is the time scale. Inserted in the ODE we get

$$
\frac{T_0}{t_c}\frac{d\bar T}{d\bar t} = -k(T_0\bar T + T_0 -
2T_0\bar T_s,
$$

leading to

$$
\frac{d\bar T}{d\bar t} = -kt_c(\bar T + 1 - 2\bar T_s)\tp
$$

A natural choice is \( t_c=1/k \) so we get the scaled problem

$$
\frac{d\bar T}{d\bar t} = -(\bar T + 1 - 2\bar T_s) =
-(\bar T -(2\bar T_s - 1)),\quad \bar T(0)=0\tp
$$

We can simulate this problem using the code for the original
problem by choosing \( k=1 \), \( T_0=0 \), and
\( T_s= (2-1)=1 \) for \( t < 3 \) and \( T_s=(2\frac{1}{4}-1)=-\half \)
for \( t > 3 \).

<p>
The appropriate code becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">simulate_piecewise_constant_Ts</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Simulate scaled problem: T&#39; = -(T - (2T_s-1)), T(0)=0,</span>
<span style="color: #BA2121; font-style: italic">    where T_s=1 for t &lt; 3 and -0.5 for t &gt; 3.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    k <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    T0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    t_star <span style="color: #666666">=</span> <span style="color: #666666">3.0</span>
    C0 <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    C1 <span style="color: #666666">=</span> <span style="color: #666666">-0.5</span>
    T_s <span style="color: #666666">=</span> Piecewise(C0, C1, t_star)
    dt <span style="color: #666666">=</span> t_star<span style="color: #666666">/100.0</span>
    T, t <span style="color: #666666">=</span> cooling(T0, k, T_s, t_end<span style="color: #666666">=3*</span>t_star, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=0.5</span>)
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
    plt<span style="color: #666666">.</span>figure()
    plt<span style="color: #666666">.</span>plot(t, T)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>);  plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.png&#39;</span>);  plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.pdf&#39;</span>)
    plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
The plot looks like this:

<p>
<center><p><img src="fig-decay/cooling_piecewise.png" align="bottom" width=600></p></center>

<p>
The result is reasonable because first \( T_s=1 \) and the body's temperature
will try to rise from \( 0 \) to \( 1 \), and it almost gets there in
the time \( [0,3] \), before \( T_s=-0.5 \) and then the body is cooled down
to \( -0.5 \) as \( t \) increases, and this is also the asymptotic value.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>d)</b>
We know from the ODE \( u^\prime =-au \) that the Crank-Nicolson scheme
can give non-physical oscillations for \( \Delta t > 2/a \).
In the present problem, this results indicates
that the Crank-Nicolson scheme give undesired
oscillations for \( \Delta t > 2/k \).
Discuss if this a potential problem in the physical case from c).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_6" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_6">

<p>
In the unscaled problem, the first stage of the simulation is
covers time interval \( [0,t^*]=[0, 3/k] \). It makes sense to
choose \( \Delta t \) significantly smaller than \( 3/k \), and the
stability limit \( 2/k \) is a too large step. The next time level
is then \( 4/k \), and it sounds reasonable to include the point \( t^*=3/k \)
as a mesh point. Oscillations would then occur if we choose
\( \Delta t = 3/k \), but this means only one step through the first
interval \( [0,t^*] \), which is a very coarse mesh. Halving \( \Delta t \)
is still a coarse mesh, but then there cannot be oscillations.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>e)</b>
Find an expression for the exact solution of
\( T^{\prime} = -k(T-T_s(t)) \), \( T(0)=T_0 \).
Construct a test case and compare the
numerical and exact solution in a plot.

<p>
Find a value of the time step
\( \Delta t \) such that the two solution curves cannot (visually) be
distinguished from each other. Many scientists will claim that such a
plot provides evidence for a correct implementation, but point out why
there still may be errors in the code.  Can you introduce bugs in the
<code>cooling</code> function and still achieve visually coinciding curves?

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_1">

<p>
The exact solution can be derived by multiplying <a href="#mjx-eqn-86">(86)</a>
by the integrating factor \( e^{kt} \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_7" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_7">

<p>
Multiplication of \( e^{kt} \), using the product rule for differentiation
&quot;backwards&quot;, and integrating from 0 to \( t \), results in

$$ \int_0^t (e^{kt}T)^{\prime}dt = k\int_0^t e^{kt}T_sdt\tp$$

The left-hand side becomes \( e^{kt}T(t)-T_0 \). Multiplying by \( e^{-kt} \)
then gives

$$ T(t) = T_0e^{-kt} + ke^{-kt}\int_0^t e^{k\tau}T_s(\tau)d\tau,$$

which is the general expression for the exact solution.

<p>
As a check, we consider the case where \( T_s \) is constant.
That problem can easily be solved by introducing \( u=T-T_s \), resulting in
\( u^{\prime}=-ku \), \( u(0)=T_0-T_s \), with solution \( u(t)=(T_0-T_s)e^{-kt} \),
and consequently \( T=T_s + (T_0-T_s)e^{-kt} \). With a constant \( T_s \) in
the general solution above, the solution becomes

$$
\begin{align*}
T(t) &= T_0e^{-kt} + ke^{-kt}\int_0^t e^{kt}T_sdt\\ 
& = T_0e^{-kt} + ke^{-kt}T_sk^{-1}(e^{kt} - 1)\\ 
& = T_0e^{-kt} + T_s - T_se^{-kt}\\ 
& = T_s + (T_0-T_s)e^{-kt},
\end{align*}
$$

as desired.

<p>
We choose the same test problem as in c) and use SymPy to do the
integration. A function doing the integration and returning
Python functions for the formulas for \( t < t^* \) and \( t\geq t^* \)
is convenient:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">symbolic_exact_solution</span>(verbose<span style="color: #666666">=</span><span style="color: #008000">False</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compute the exact solution formula via sympy.&quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># sol1: solution for t &lt; t_star,</span>
    <span style="color: #408080; font-style: italic"># sol2: solution for t &gt; t_star</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sym</span>
    T0 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;T0&#39;</span>)
    k <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;k&#39;</span>, positive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
    <span style="color: #408080; font-style: italic"># Piecewise linear T_sunction</span>
    t, t_star, C0, C1 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;t t_star C0 C1&#39;</span>)
    T_s <span style="color: #666666">=</span> C0
    I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(sym<span style="color: #666666">.</span>exp(k<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>T_s, (t, <span style="color: #666666">0</span>, t))
    sol1 <span style="color: #666666">=</span> T0<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>k<span style="color: #666666">*</span>t) <span style="color: #666666">+</span> k<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>k<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>I
    sol1 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(sym<span style="color: #666666">.</span>expand(sol1))
    <span style="color: #008000; font-weight: bold">if</span> verbose:
        <span style="color: #408080; font-style: italic"># Some debugging print</span>
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;solution t &lt; t_star:&#39;</span>, sol1
        <span style="color: #408080; font-style: italic">#print sym.latex(sol1)</span>
    T_s <span style="color: #666666">=</span> C1
    I <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>integrate(sym<span style="color: #666666">.</span>exp(k<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>C0, (t, <span style="color: #666666">0</span>, t_star)) <span style="color: #666666">+</span> \ 
        sym<span style="color: #666666">.</span>integrate(sym<span style="color: #666666">.</span>exp(k<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>C1, (t, t_star, t))
    sol2 <span style="color: #666666">=</span> T0<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>k<span style="color: #666666">*</span>t) <span style="color: #666666">+</span> k<span style="color: #666666">*</span>sym<span style="color: #666666">.</span>exp(<span style="color: #666666">-</span>k<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>I
    sol2 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>simplify(sym<span style="color: #666666">.</span>expand(sol2))
    <span style="color: #008000; font-weight: bold">if</span> verbose:
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;solution t &gt; t_star:&#39;</span>, sol2
        <span style="color: #408080; font-style: italic">#print sym.latex(sol2)</span>

    <span style="color: #408080; font-style: italic"># Convert to numerical functions</span>
    exact0 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([t, C0, k, T0],
                          sol1, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
    exact1 <span style="color: #666666">=</span> sym<span style="color: #666666">.</span>lambdify([t, C0, C1, t_star, k, T0],
                          sol2, modules<span style="color: #666666">=</span><span style="color: #BA2121">&#39;numpy&#39;</span>)
    <span style="color: #008000; font-weight: bold">return</span> exact0, exact1
</pre></div>
<p>
Then we need a function that can evaluate the exact solution as
a mesh function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">evaluate_exact_solution</span>(t, k, T0, C0, C1, t_star,
                            verbose<span style="color: #666666">=</span><span style="color: #008000">False</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Return exact (analytical) solution of the problem.</span>
<span style="color: #BA2121; font-style: italic">    Exact solution is produced by sympy.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    exact0, exact1 <span style="color: #666666">=</span> symbolic_exact_solution()
    <span style="color: #408080; font-style: italic"># exact0/1 works with t as numpy array</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">isinstance</span>(t, (<span style="color: #008000">float</span>,<span style="color: #008000">int</span>)):
        <span style="color: #008000; font-weight: bold">if</span> t <span style="color: #666666">&lt;</span> t_star:
            <span style="color: #008000; font-weight: bold">return</span> exact0(t, C0, k, T0)
        <span style="color: #008000; font-weight: bold">else</span>:
            <span style="color: #008000; font-weight: bold">return</span> exact1(t, C0, C1, t_star, k, T0)
    <span style="color: #008000; font-weight: bold">else</span>:
        <span style="color: #408080; font-style: italic"># assume numpy array</span>
        <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>where(
            t <span style="color: #666666">&lt;</span> t_star,
            exact0(t, C0, k, T0),
            exact1(t, C0, C1, t_star, k, T0))
</pre></div>
<p>
Finally we can run the comparison:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compare_numerical_and_exact_solution</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compare exact and numerical solution with piecewise</span>
<span style="color: #BA2121; font-style: italic">    constant surrounding temperature. Use scaled problem</span>
<span style="color: #BA2121; font-style: italic">    from function simulate_piecewise_constant_Ts.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    T0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    k <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    C0 <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    C1 <span style="color: #666666">=</span> <span style="color: #666666">-0.5</span>
    t_star <span style="color: #666666">=</span> <span style="color: #666666">3</span>
    t_end <span style="color: #666666">=</span> <span style="color: #666666">7</span>

    T_s <span style="color: #666666">=</span> Piecewise(C0, C1, t_star)

    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
    plt<span style="color: #666666">.</span>figure()
    dt_values <span style="color: #666666">=</span> [<span style="color: #666666">1</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0.025</span>]
    <span style="color: #408080; font-style: italic">#dt_values = [0.025]</span>
    <span style="color: #008000; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values:
        T, t <span style="color: #666666">=</span> cooling(T0, k, T_s, t_end, dt, theta<span style="color: #666666">=0.5</span>)
        plt<span style="color: #666666">.</span>plot(t, T)

    t_e <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, t_end, <span style="color: #666666">1001</span>)  <span style="color: #408080; font-style: italic"># find mesh for T_e</span>
    <span style="color: #408080; font-style: italic"># Could use sym.Rational(1,2) instead of 0.5, but not necessary</span>
    <span style="color: #408080; font-style: italic"># when we are not interested in symbolic formulas</span>
    T_e <span style="color: #666666">=</span> evaluate_exact_solution(t_e, k, T0, C0, C1, t_star)
    plt<span style="color: #666666">.</span>plot(t_e, T_e)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;CN, dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> dt <span style="color: #008000; font-weight: bold">for</span> dt <span style="color: #AA22FF; font-weight: bold">in</span> dt_values] <span style="color: #666666">+</span> [<span style="color: #BA2121">&#39;exact&#39;</span>])
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;T(t) for piecewise constant $T_s(t)$&#39;</span>)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
    plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;T&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp3.png&#39;</span>);  plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp3.pdf&#39;</span>)
    plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
The \( \Delta t \) values were found after some trial and error, but they
illustrate crude approximations and one with the biggest possible
\( \Delta t \) such that the exact solution and the numerical solution cannot
be visually distinguished:

<p>
<center><p><img src="fig-decay/cooling_piecewise_compare.png" align="bottom" width=600></p></center>

<p>
We can now start to introduce bugs in the <code>cooling</code> function to
see if it is possible to have some \( \Delta t \) and still find
coinciding curves.

<h3 id="___sec128">Bug 1: Wrong time level in the \( T_s \) function </h3>

<p>
We replace <code>T_s[n]</code> by <code>T_s[n+1]</code> in the implementation of the scheme
and rerun the case. Now the lowest \( \Delta t \) is still on top of
the exact solution, but the numerical solution on the two coarser
meshes are more accurate! This is because we lower the surrounding
temperature somewhat earlier in the buggy scheme and this reduces
the &quot;overshoot&quot; on the coarsest meshes in the figure above.

<p>
<center><p><img src="fig-decay/cooling_piecewise_bug1.png" align="bottom" width=600></p></center>

<h3 id="___sec129">Bug 2: Wrong time level in the \( T \) function </h3>

<p>
We can replace <code>T[n]</code> by <code>T[n+1]</code> on the right-hand side of the scheme.
This is a serious error since <code>T[n+1]</code> is not yet computed and therefore
equal to zero when <code>T</code> was made by calling <code>np.zeros</code>. The results
are also nonsense, and one would immediately look for a bug.

<p>
<center><p><img src="fig-decay/cooling_piecewise_bug2.png" align="bottom" width=600></p></center>

<h3 id="___sec130">Bug 3: Missing \( \theta \) in a term </h3>

<p>
Let us forget to multiply by <code>theta</code> in the nominator of the scheme, i.e.,
we replace

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">T[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> ((<span style="color: #666666">1</span> <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>k)<span style="color: #666666">*</span>T[n] <span style="color: #666666">+</span> \ 
         dt<span style="color: #666666">*</span>k<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>T_s(t[n<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>T_s(t[n])))<span style="color: #666666">/</span> \ 
         (<span style="color: #666666">1</span> <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>theta<span style="color: #666666">*</span>k)
</pre></div>
<p>
by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">T[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> ((<span style="color: #666666">1</span> <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>k)<span style="color: #666666">*</span>T[n] <span style="color: #666666">+</span> \ 
         dt<span style="color: #666666">*</span>k<span style="color: #666666">*</span>(T_s(t[n<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>T_s(t[n])))<span style="color: #666666">/</span> \ 
         (<span style="color: #666666">1</span> <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>theta<span style="color: #666666">*</span>k)
</pre></div>
<p>
This error leads to convergence towards a wrong solution:

<p>
<center><p><img src="fig-decay/cooling_piecewise_bug3.png" align="bottom" width=600></p></center>

<p>
If we did not have the exact solution, one could be led to think
that the solution was correct, but it is non-physical since we
do not expect the temperature to rise from \( T_0 \) to a level
<em>above</em> the surrounding temperature. The plot shows that \( \bar T>1 \),
the value of the (scaled) surrounding temperature.
Note that if we used the Backward Euler scheme instead of the
Crank-Nicolson scheme, this bug would have no effect!

<h3 id="___sec131">Bug 4: Missing <code>k</code> in the updating formula </h3>

<p>
Obviously, when we solve the scaled problem where \( k=1 \) by definition,
such a programming mistake has no effect. Otherwise, \( k \) influences
the time scale, so there will be a stretch of the time axis in the
numerical solution and this should be easily detected in a plot.

<h3 id="___sec132">Bug 5: Using <code>1-theta</code> instead of <code>theta</code> </h3>

<p>
Such an error is not detectable in the Crank-Nicolson scheme, but
will have a significant effect in the other schemes.
As a test, we replace <code>1-theta</code> in the nominator by <code>theta</code>.
This leads to \( T=0 \) in the Forward Euler scheme, but a reasonable shape
in the Backward Euler scheme, although the solution becomes larger
than the surrounding temperature (1 in the scaled problem).

<p>
<center><p><img src="fig-decay/cooling_piecewise_bug5.png" align="bottom" width=600></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>f)</b>
Implement a test function for checking that the solution returned by
the <code>cooling</code> function is identical to the exact numerical
solution of the problem (to machine precision) when \( T_s \) is constant.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_2" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_2">

<p>
The exact solution of the
discrete equations in the case \( T_s \) is a constant can be found by
introducing \( u=T-T_s \) to get a problem \( u^{\prime}=-ku \), \( u(0)=T_0-T_s \).
The solution of the discrete equations is then of the form
\( u^{n}=(T_0-T_s)A^n \) for some amplification factor \( A \). The
expression for \( T^n \) is then \( T^n = T_s(t_n) + u^n =
T_s + (T_0-T_s)A^n \).
We find that

$$ A = \frac{1 - (1-\theta) k\Delta t}{1 + \theta k\Delta t}\tp$$

The test function, testing several \( \theta \) values for a quite coarse
mesh, may take the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_discrete_solution</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Compare the numerical solution with an exact solution of the scheme</span>
<span style="color: #BA2121; font-style: italic">    when the T_s is constant.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    T_s <span style="color: #666666">=</span> <span style="color: #666666">10</span>
    T0 <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    k <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
    dt <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>   <span style="color: #408080; font-style: italic"># can use any mesh</span>
    N_t <span style="color: #666666">=</span> <span style="color: #666666">6</span>    <span style="color: #408080; font-style: italic"># any no of steps will do</span>
    t_end <span style="color: #666666">=</span> dt<span style="color: #666666">*</span>N_t
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, t_end, N_t<span style="color: #666666">+1</span>)

    <span style="color: #008000; font-weight: bold">for</span> theta <span style="color: #AA22FF; font-weight: bold">in</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0.2</span>]:
        u, t <span style="color: #666666">=</span> cooling(T0, k, <span style="color: #008000; font-weight: bold">lambda</span> t: T_s , t_end, dt, theta)
        A <span style="color: #666666">=</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> (<span style="color: #666666">1-</span>theta)<span style="color: #666666">*</span>k<span style="color: #666666">*</span>dt)<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">+</span> theta<span style="color: #666666">*</span>k<span style="color: #666666">*</span>dt)
        u_discrete_exact <span style="color: #666666">=</span> T_s <span style="color: #666666">+</span> (T0<span style="color: #666666">-</span>T_s)<span style="color: #666666">*</span>A<span style="color: #666666">**</span>(np<span style="color: #666666">.</span>arange(<span style="color: #008000">len</span>(t)))
        diff <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(u <span style="color: #666666">-</span> u_discrete_exact)<span style="color: #666666">.</span>max()
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;diff computed and exact discrete solution:&#39;</span>, diff
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        success <span style="color: #666666">=</span> diff <span style="color: #666666">&lt;</span> tol
        <span style="color: #008000; font-weight: bold">assert</span> success, <span style="color: #BA2121">&#39;diff=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff
</pre></div>
<p>
Running this function shows that the <code>diff</code> variable is <code>3.55E-15</code>
as maximum so a tolerance of \( 10^{-14} \) is appropriate.
This is a good test that the <code>cooling</code> function works!

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>cooling</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:cooling:murder">Exercise 19: Find time of murder from body temperature</h2>

<p>
<!-- <a href="http://www.biology.arizona.edu/BioMath/tutorials/Applications/Cooling.html" target="_self"><tt>http://www.biology.arizona.edu/BioMath/tutorials/Applications/Cooling.html</tt></a> -->

<p>
A detective measures the temperature of a dead body to be 26.7 C at 2
pm. One hour later the temperature is 25.8 C. The question is when
death occurred.

<p>
Assume that Newton's law of cooling <a href="#mjx-eqn-86">(86)</a> is an
appropriate mathematical model for the evolution of the temperature in
the body.  First, determine \( k \) in <a href="#mjx-eqn-86">(86)</a> by
formulating a Forward Euler approximation with one time steep from
time 2 am to time 3 am, where knowing the two temperatures allows for
finding \( k \). Assume the temperature in the air to be 20 C. Thereafter,
simulate the temperature evolution from the time of murder, taken as
\( t=0 \), when \( T=37\hbox{ C} \), until the temperature reaches 25.8 C. The
corresponding time allows for answering when death occurred.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_1">

<p>
A Forward Euler step from \( T^0 \) to \( T^1 \) reads

$$ T^1 = T_0 + -k\Delta t (T^0 - T_s),$$

and solving with respect to \( k \) results in

$$ k = \frac{T^1 - T^0}{\Delta t(T_s - T_0)}\tp$$

We implement this formula in a function,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">estimate_k</span>(T0, T1, Ts, dt):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">float</span>(T1 <span style="color: #666666">-</span> T0)<span style="color: #666666">/</span>(dt<span style="color: #666666">*</span>(Ts <span style="color: #666666">-</span> T0))
</pre></div>
<p>
We have \( T_0=26.7 \) C, \( T_1=25.8 \) C, \( T_s=20 \) C, and \( \Delta t = 1 \) h,
i.e., \( \Delta t = 3600 \) s. The proper call is therefore

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">k <span style="color: #666666">=</span> estimate_k(<span style="color: #666666">26.7</span>, <span style="color: #666666">25.8</span>, <span style="color: #666666">20</span>, <span style="color: #666666">3600</span>)
</pre></div>
<p>
For the simulation we use the Forward Euler method,

$$ T^{n+1} = T^n - k\Delta t(T^n - T_s),$$

and simulate as long as \( T > 25.8 \) C:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">T <span style="color: #666666">=</span> <span style="color: #666666">37</span>
Ts <span style="color: #666666">=</span> <span style="color: #666666">20</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cooling</span> <span style="color: #008000; font-weight: bold">import</span> cooling
<span style="color: #008000; font-weight: bold">while</span> T <span style="color: #666666">&gt;</span> <span style="color: #666666">25.8</span>:
    T <span style="color: #666666">=</span> T <span style="color: #666666">-</span> k<span style="color: #666666">*</span>dt<span style="color: #666666">*</span>(T <span style="color: #666666">-</span> Ts)
    t<span style="color: #666666">+=</span> dt

minutes, seconds <span style="color: #666666">=</span> <span style="color: #008000">divmod</span>(t, <span style="color: #666666">60</span>)
hours, minutes <span style="color: #666666">=</span> <span style="color: #008000">divmod</span>(minutes, <span style="color: #666666">60</span>)
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&quot;&quot;&quot;</span>
<span style="color: #BA2121">The death occurred </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> hours, </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> minutes,</span>
<span style="color: #BA2121">and </span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> seconds before 3am.&quot;&quot;&quot;</span> <span style="color: #666666">%</span> (hours, minutes, seconds)
</pre></div>
<p>
The result of running the code becomes

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python detective.py
k=3.73134e-05

The death occurred 8 hours, 0 minutes,
and 19 seconds before 3am.
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>detective</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:cooling:osc">Exercise 20: Simulate an oscillating cooling process</h2>

<p>
The surrounding temperature \( T_s \) in Newton's law of cooling
<a href="#mjx-eqn-86">(86)</a> may vary in time. Assume that the
variations are periodic with period \( P \) and amplitude \( a \) around
a constant mean temperature \( T_m \):

$$
\begin{equation}
T_s(t) = T_m + a\sin\left(\frac{2\pi}{P}t\right)
\tp
\end{equation}
$$

Simulate a process with the following data: \( k=0.05 \hbox{ min}^{-1} \),
\( T(0)=5 \) C, \( T_m=25 \) C, \( a=2.5 \) C, and \( P=1 \) h, \( P=10 \) min, and \( P=6 \) h.
Plot the \( T \) solutions and \( T_s \) in the same plot.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_20_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_20_1">

<p>
We can reuse the <code>cooling</code> function from <a href="#decay:app:exer:cooling:py">Exercise 18: Implement schemes for Newton's law of cooling</a>
to do the simulations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">cooling</span>(T0, k, T_s, t_end, dt, theta<span style="color: #666666">=0.5</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve T&#39;=-k(T-T_s(t)), T(0)=T0,</span>
<span style="color: #BA2121; font-style: italic">    for t in (0,t_end] with steps of dt.</span>
<span style="color: #BA2121; font-style: italic">    T_s(t) is a Python function of t.</span>
<span style="color: #BA2121; font-style: italic">    theta=0.5 means Crank-Nicolson, 1 is Backward</span>
<span style="color: #BA2121; font-style: italic">    Euler, and 0 is Forward Euler scheme.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)                  <span style="color: #408080; font-style: italic"># avoid integer division</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(t_end<span style="color: #666666">/</span>dt))       <span style="color: #408080; font-style: italic"># no of time intervals</span>
    t_end <span style="color: #666666">=</span> Nt<span style="color: #666666">*</span>dt                   <span style="color: #408080; font-style: italic"># adjust to fit time step dt</span>
    T <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)              <span style="color: #408080; font-style: italic"># array of T[n] values</span>
    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, t_end, Nt<span style="color: #666666">+1</span>) <span style="color: #408080; font-style: italic"># time mesh</span>
    T[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> T0                       <span style="color: #408080; font-style: italic"># set initial condition</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):          <span style="color: #408080; font-style: italic"># n=0,1,...,Nt-1</span>
        T[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> ((<span style="color: #666666">1</span> <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>k)<span style="color: #666666">*</span>T[n] <span style="color: #666666">+</span> \ 
        dt<span style="color: #666666">*</span>k<span style="color: #666666">*</span>(theta<span style="color: #666666">*</span>T_s(t[n<span style="color: #666666">+1</span>]) <span style="color: #666666">+</span> (<span style="color: #666666">1</span> <span style="color: #666666">-</span> theta)<span style="color: #666666">*</span>T_s(t[n])))<span style="color: #666666">/</span> \ 
        (<span style="color: #666666">1</span> <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>theta<span style="color: #666666">*</span>k)
    <span style="color: #008000; font-weight: bold">return</span> T, t
</pre></div>
<p>
The challenge is to use the right units
for the input data. We can use Celsius for temperature since it has
the same increments as Kelvin. Time quantities should be measured
in seconds:

$$
\begin{align*}
k &= 20 \hbox{ min}^{-1} = \frac{20}{60}\hbox{ s}^{-1},\\ 
P &= (1 \hbox{ h} = 3600\hbox{ s}, 10\hbox{ min} = 600\hbox{ s},
6\hbox{ h}=6\cdot 3600\hbox{ s})\tp
\end{align*}
$$

<p>
To achieve reasonable accuracy,
we choose \( \Delta t \) as 40 steps per the
shortest period of the \( T_s \) oscillations:
\( \Delta t = 600/40 \). With some trials we find
an appropriate simulation interval for all three cases to be
\( [0,8] \) h.

<p>
The code becomes

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">cooling</span> <span style="color: #008000; font-weight: bold">import</span> cooling
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> pi, sin

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">T_s</span>(t):
    <span style="color: #008000; font-weight: bold">return</span> Tm <span style="color: #666666">+</span> a<span style="color: #666666">*</span>sin((<span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>P)<span style="color: #666666">*</span>t)

Tm <span style="color: #666666">=</span> <span style="color: #666666">25</span>
a <span style="color: #666666">=</span> <span style="color: #666666">2.5</span>
P_values <span style="color: #666666">=</span> [<span style="color: #666666">3600</span>, <span style="color: #666666">600</span>, <span style="color: #666666">3600*6</span>]
k <span style="color: #666666">=</span> <span style="color: #666666">0.05/60</span>
T0 <span style="color: #666666">=</span> <span style="color: #666666">5</span>

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">for</span> P <span style="color: #AA22FF; font-weight: bold">in</span> P_values:
    T, t <span style="color: #666666">=</span> cooling(T0, k, T_s, t_end<span style="color: #666666">=8*3600</span>, dt<span style="color: #666666">=600/40</span>)
    plt<span style="color: #666666">.</span>plot(t, T)
plt<span style="color: #666666">.</span>plot(t, T_s(t), <span style="color: #BA2121">&#39;k--&#39;</span>)
legends <span style="color: #666666">=</span> [<span style="color: #BA2121">&#39;P=1 h&#39;</span>, <span style="color: #BA2121">&#39;P=10 min&#39;</span>, <span style="color: #BA2121">&#39;P=6 h&#39;</span>, <span style="color: #BA2121">&#39;$T_s$&#39;</span>]
plt<span style="color: #666666">.</span>legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;lower right&#39;</span>)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>); plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;T&#39;</span>)
plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.png&#39;</span>);  plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.pdf&#39;</span>)
plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
<center><p><img src="fig-decay/osc_cooling.png" align="bottom" width=700></p></center>

<p>
<b>Discussion of the results.</b>
We see that it takes some time to increase the temperature from \( T_0 \)
to oscillations around \( T_m \). When \( T_s \) oscillates fast (\( P=10 \) min),
\( k \) is not large enough so that \( T \) can reach the surrounding temperature
in the time available before the surrounding temperature decreases.
However, for large \( P \) (6 h), there is almost enough time to heat
and cool the object to reach the maximum and minimum temperatures
of the surroundings.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>osc_cooling</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:stoch:nuclear">Exercise 21: Simulate stochastic radioactive decay</h2>

<p>
The purpose of this exercise is to implement the stochastic model
described in the section <a href="#decay:app:nuclear">Radioactive decay</a> and show that its
mean behavior approximates the solution of the corresponding
ODE model.

<p>
The simulation goes on for a time interval \( [0,T] \) divided into
\( N_t \) intervals of length \( \Delta t \). We start with \( N_0 \)
atoms. In some time interval, we have \( N \) atoms that have survived.
Simulate \( N \) Bernoulli trials with probability \( \lambda\Delta t \)
in this interval by drawing \( N \) random numbers, each being 0 (survival)
or 1 (decay), where the probability of getting 1 is \( \lambda\Delta t \).
We are interested in the number of decays, \( d \), and the number of
survived atoms in the next interval is then \( N-d \).
The Bernoulli trials
are simulated by drawing \( N \) uniformly distributed real numbers on
\( [0,1] \) and saying that 1 corresponds to a value less than \( \lambda\Delta t \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #408080; font-style: italic"># Given lambda_, dt, N</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
uniform <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(N)
Bernoulli_trials <span style="color: #666666">=</span> np<span style="color: #666666">.</span>asarray(uniform <span style="color: #666666">&lt;</span> lambda_<span style="color: #666666">*</span>dt, dtype<span style="color: #666666">=</span>np<span style="color: #666666">.</span>int)
d <span style="color: #666666">=</span> Bernoulli_trials<span style="color: #666666">.</span>size
</pre></div>
<p>
Observe that <code>uniform &lt; lambda_*dt</code> is a boolean array whose true
and false values become 1 and 0, respectively, when converted to an
integer array.

<p>
Repeat the simulation over \( [0,T] \) a large number of times, compute the average
value of \( N \) in each interval, and compare with the solution of
the corresponding ODE model.
Filename: <code>stochastic_decay</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:radio:twosubst">Exercise 22: Radioactive decay of two substances</h2>

<p>
Consider two radioactive substances A and B. The nuclei in substance A
decay to form nuclei of type B with a half-life \( A_{1/2} \), while
substance B decay to form type A nuclei with a half-life \( B_{1/2} \).
Letting \( u_A \) and \( u_B \) be the fractions of the initial amount of
material in substance A and B, respectively, the following system of
ODEs governs the evolution of \( u_A(t) \) and \( u_B(t) \):
$$
\begin{align}
\frac{1}{\ln 2} u_A^{\prime} &= u_B/B_{1/2} - u_A/A_{1/2},\\ 
\frac{1}{\ln 2} u_B^{\prime} &= u_A/A_{1/2} - u_B/B_{1/2},
\end{align}
$$

with \( u_A(0)=u_B(0)=1 \).

<p>
<b>a)</b>
Make a simulation program that solves for \( u_A(t) \) and \( u_B(t) \).

<p>
<b>b)</b>
Verify the implementation by computing analytically
the limiting values of
\( u_A \) and \( u_B \) as \( t\rightarrow \infty \) (assume \( u_A^{\prime},u_B^{\prime}\rightarrow 0 \))
and comparing these with those obtained numerically.

<p>
<b>c)</b>
Run the program for the case of \( A_{1/2}=10 \) minutes and \( B_{1/2}=50 \) minutes.
Use a time unit of 1 minute. Plot \( u_A \) and \( u_B \) versus time in the same
plot.

<p>
Filename: <code>radioactive_decay_2subst</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:kinetics:AB">Exercise 23: Simulate a simple chemical reaction</h2>

<p>
Consider the simple chemical reaction where a substance A is turned
into a substance B according to

$$
\begin{align*}
\frac{[A]}{dt} &= -k[A],\\ 
\frac{[B]}{dt} &= k[A],\\ 
\end{align*}
$$

where \( [A] \) and \( [B] \) are the concentrations of A and B, respectively.
It may be a challenge to find appropriate values of \( k \), but we can avoid
this problem by working with a scaled model (as explained in
the section <a href="#decay:app:scaling">Scaling</a>).
Scale the model above, using a time scale \( 1/k \), and use
the initial concentration
of \( [A] \) as scale for \( [A] \) and \( [B] \). Show that the scaled system
reads

$$
\begin{align*}
\frac{u}{dt} &= -u,\\ 
\frac{v}{dt} &= u,\\ 
\end{align*}
$$

with initial conditions \( u(0)=1 \), and \( v(0)=\alpha \), where
\( \alpha = [B](0)/[A](0) \) is a dimensionless number, and
\( u \) and \( v \) are the scaled concentrations of \( [A] \) and \( [B] \),
respectively. Implement a numerical scheme that can be used to
find the solutions
\( u(t) \) and \( v(t) \). Visualize \( u \) and \( v \) in the same plot.
Filename: <code>chemcial_kinetics_AB</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:kinetics:ABn">Exercise 24: Simulate an \( n \)-th order chemical reaction</h2>

<p>
An \( n \)-order chemical reaction, generalizing the model in
<a href="#decay:app:exer:kinetics:AB">Exercise 23: Simulate a simple chemical reaction</a>, takes the form

$$
\begin{align*}
\frac{[A]}{dt} &= -k[A]^n,\\ 
\frac{[B]}{dt} &= k[A]^n,\\ 
\end{align*}
$$

where symbols are as defined in <a href="#decay:app:exer:kinetics:AB">Exercise 23: Simulate a simple chemical reaction</a>.
Bring this model on dimensionless form, using a time scale \( [A](0)^{n-1}/k \),
and show that the dimensionless model simplifies to

$$
\begin{align*}
\frac{u}{dt} &= -u^n,\\ 
\frac{v}{dt} &= u^n,\\ 
\end{align*}
$$

with \( u(0)=1 \) and \( v(0)=\alpha = [B](0)/[A](0) \). Solve numerically for
\( u(t) \) and show a plot with \( u \) for \( n=0.5, 1, 2, 4 \).
Filename: <code>chemcial_kinetics_ABn</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:SIR">Exercise 25: Simulate spreading of a disease</h2>

<p>
The SIR model <a href="#mjx-eqn-92">(92)</a>-<a href="#mjx-eqn-94">(94)</a> can be used
to simulate spreading of an epidemic disease.

<p>
<b>a)</b>
Estimating the parameter \( \beta \)
is difficult so it can be handy to scale the equations. Use
\( t_c=1/\nu \) as time scale, and scale \( S \), \( I \), and \( R \) by
the population size \( N=S(0)+I(0)+R(0) \). Show that the resulting dimensionless
model becomes

$$
\begin{align}
\frac{d\bar S}{d\bar t} &= - R_0\bar S\bar I,
\tag{105}\\ 
\frac{d\bar I}{d\bar t} &= R_0 \bar S\bar I - \bar I,
\tag{106}\\ 
\frac{d\bar R}{d\bar t} &= I,
\tag{107}\\ 
\bar S(0) &= 1-\alpha,\\ 
\bar I(0) &= \alpha,\\ 
\bar R(0) &= 0,
\end{align}
$$

where \( R_0 \) and \( \alpha \) are the only parameters in the problem:

$$ R_0 = \frac{N\beta}{\nu}, \quad \alpha = \frac{I(0)}{N}\tp$$

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_25_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_25_2">

<p>
We introduce

$$ \bar t = \frac{t}{\nu^{-1}},\quad \bar S = \frac{S}{N},\quad
\bar I = \frac{I}{N},\quad \bar R = \frac{R}{N}\tp$$

Inserting these expressions in the governing equations and dividing by
\( \nu N \) gives the listed dimensionless ODEs. The scaled initial condition
for \( \bar S(0) \) follows from
\( \bar S(0) = S(0)/N = (N-I(0))/N = 1 - \alpha \), since initially,
\( R(0)=0 \) and therefore \( N=S(0) + I(0) \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Show that the \( R_0 \) parameter governs whether the disease will spread
or not at \( t=0 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_25_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_25_1">

<p>
Spreading means \( dI/dt>0 \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_25_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_25_3">

<p>
For \( dI/dt \) to be positive, we must have \( (R_0 \bar S - 1)\bar I > 0 \), i.e.,
\( R_0 \bar S - 1 > 0 \) since \( \bar I\geq 0 \). At \( t=0 \), we get
\( R_0 \bar S(0) > 1 \) as the criterion, or

$$
\tilde R_0\bar S(0) = \frac{N\beta}{\nu}\frac{S(0)}{N} = \frac{S(0)\beta}{\nu} >1
\tp$$

The dimensionless parameter \( S(0)\beta /\nu \) is denoted by \( R_0 \) in
the epidemiology literature and known as the <em>basic reproductive number</em>.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Implement the scaled SIR model. Check at every time step,
as a verification, that
\( \bar S + \bar I + \bar R = 1 \).

<p>
<b>d)</b>
Simulate the spreading of a disease where \( R_0=1.1 \) and 1 percent of
the population is infected at time \( t=0 \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_25_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_25_4">

<p>
The given data means that \( \bar I(0)=\alpha = 0.01 \) and \( \bar S(0)=0.99 \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>SIR</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:MMK">Exercise 26: Simulate a biochemical process</h2>

<p>
The purpose of this exercise is to simulate the ODE system
<a href="#mjx-eqn-88">(88)</a>-<a href="#mjx-eqn-91">(91)</a> modeling a simple
biochemical process.

<p>
<b>a)</b>
Scale <a href="#mjx-eqn-88">(88)</a>-<a href="#mjx-eqn-91">(91)</a> such that
we can work with dimensionless parameters, which are easier to prescribe.
Introduce

$$ \bar Q = \frac{[ES]}{Q_c},\quad
\bar P = \frac{P}{P_c},\quad \bar S = \frac{S}{S_0},\quad \bar E = \frac{E}{E_0},\quad \bar t = \frac{t}{t_c},$$

where appropriate scales are

$$ Q_c = \frac{S_0E_0}{K},\quad P_c = Q_c, \quad t_c=\frac{1}{k_+E_0},$$

with \( K=(k_v+k_-)/k_+ \) is the Michaelis constant. Show that the scale
system becomes

$$
\begin{align}
\frac{d\bar Q}{d\bar t} &= \alpha (\bar E\bar S
- \bar Q),
\tag{108}\\ 
\frac{d\bar P}{d\bar t} &= \beta\bar Q,
\tag{109}\\ 
\frac{d\bar S}{d\bar t} &= -\bar E\bar S
+ (1 - \beta\alpha^{-1})\bar Q,
\tag{110}\\ 
\epsilon\frac{d\bar E}{d\bar t} &= -\bar E\bar S + \bar Q,
\tag{111}
\end{align}
$$

where we have three dimensionless parameters

$$ \alpha = \frac{K}{E_0},\quad \beta = \frac{k_v}{k_+ E_0},\quad
\epsilon = \frac{E_0}{S_0}\tp
\]
The corresponding initial conditions are $\bar Q=\bar P=0$ and
$\bar S=\bar E=1$.
$$

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_26_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_26_1">

<p>
Replacing the unknowns and \( t \) by their dimensionless equivalents
leads to

$$
\begin{align*}
\frac{d\bar Q}{d\bar t} &= t_ck_+\frac{E_0S_0}{Q_c}\bar E\bar S
- t_c(k_v + k_-)\bar Q,\\ 
\frac{d\bar P}{d\bar t} &= t_ck_v\frac{Q_c}{P_c}\bar Q,\\ 
\frac{d\bar S}{d\bar t} &= -t_ck_+E_0\bar E\bar S
+ t_ck_-\frac{Q_c}{S_0}\bar Q,\\ 
\frac{d\bar E}{d\bar t} &= -t_ck_+S_0\bar E\bar S
+ t_c(k_- + k_v)\frac{Q_c}{E_0}\bar Q\tp
\end{align*}
$$

Inserting the choice of scales brings us to the given equations, after
quite some algebra and identifying coefficients in terms of the
provided dimensionless numbers.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Implement a function for
solving <a href="#mjx-eqn-108">(108)</a>-<a href="#mjx-eqn-111">(111)</a>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_26_2" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_26_2">

<p>
Let us use Odespy to solve the differential equations, although a plain
Forward Euler scheme will be fine.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">odespy</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sys</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver</span>(f, alpha, beta, epsilon, T, dt<span style="color: #666666">=0.1</span>):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(u, t):
        Q, P, S, E <span style="color: #666666">=</span> u
        <span style="color: #008000; font-weight: bold">return</span> [
            alpha<span style="color: #666666">*</span>(E<span style="color: #666666">*</span>S <span style="color: #666666">-</span> Q),
            beta<span style="color: #666666">*</span>Q,
            <span style="color: #666666">-</span>E<span style="color: #666666">*</span>S <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>beta<span style="color: #666666">/</span>alpha)<span style="color: #666666">*</span>Q,
            (<span style="color: #666666">-</span>E<span style="color: #666666">*</span>S <span style="color: #666666">+</span> Q)<span style="color: #666666">/</span>epsilon,
            ]

    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    t_mesh <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)

    solver <span style="color: #666666">=</span> odespy<span style="color: #666666">.</span>RK4(f)
    solver<span style="color: #666666">.</span>set_initial_condition([<span style="color: #666666">0</span>, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">1</span>])
    u, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(t_mesh)
    Q <span style="color: #666666">=</span> u[:,<span style="color: #666666">0</span>]
    P <span style="color: #666666">=</span> u[:,<span style="color: #666666">1</span>]
    S <span style="color: #666666">=</span> u[:,<span style="color: #666666">2</span>]
    E <span style="color: #666666">=</span> u[:,<span style="color: #666666">3</span>]
    <span style="color: #008000; font-weight: bold">return</span> Q, P, S, E
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
There are two conservation equations implied by
<a href="#mjx-eqn-88">(88)</a>-<a href="#mjx-eqn-91">(91)</a>:

$$
\begin{align}
[ES] + [E] &= E_0,\\ 
[ES] + [S] + [P] &= S_0\tp
\end{align}
$$

Derive these two equations. Use these properties in the function
in b) to do a partial verification of the solution at each time step.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_26_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_26_3">

<p>
Adding
<a href="#mjx-eqn-88">(88)</a> and <a href="#mjx-eqn-91">(91)</a> shows that

$$ \frac{d[ES]}{dt} + \frac{d[E]}{dt} = 0,$$

and therefore \( [ES] + [E]=\hbox{const} \). Since \( [ES](0)=0 \) and
\( [E](0)=E_0 \), the constant is \( E_0 \) at \( t=0 \) and will remain so.
Similarly, adding <a href="#mjx-eqn-88">(88)</a>,
<a href="#mjx-eqn-90">(90)</a>, and <a href="#mjx-eqn-89">(89)</a>
shows that their time derivatives sum up to zero, and therefore
\( [ES] + [S] + [P] =\hbox{const} \). Since \( [P](0)=0 \), the constant
must be \( 0+S_0+0=S_0 \).

<p>
To use the conservation as a consistency check in the software, we need
to find the equivalent dimensionless versions:

$$ [ES] + [E] = E_0\quad\Rightarrow\quad Q_c\bar Q + E_0\bar E = E_0,$$

and from this we get, after a little algebra,

$$ \alpha^{-1}\epsilon^{-1}\bar Q + \bar E = 1\tp$$

The other conservation equation becomes

$$ \bar Q + \alpha\bar S + \bar P  = \alpha\tp$$

<p>
The implementation may go like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">computed <span style="color: #666666">=</span> Q[n<span style="color: #666666">+1</span>]<span style="color: #666666">/</span>(alpha<span style="color: #666666">*</span>epsilon) <span style="color: #666666">+</span> E[n<span style="color: #666666">+1</span>]
expected <span style="color: #666666">=</span> <span style="color: #666666">1</span>
diff1 <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(computed <span style="color: #666666">-</span> expected)

computed <span style="color: #666666">=</span> Q[n<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> alpha<span style="color: #666666">*</span>S[n<span style="color: #666666">+1</span>] <span style="color: #666666">+</span> P[n<span style="color: #666666">+1</span>]
expected <span style="color: #666666">=</span> alpha
diff2 <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(computed <span style="color: #666666">-</span> expected)

tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
<span style="color: #008000; font-weight: bold">if</span> diff1 <span style="color: #666666">&lt;</span> tol <span style="color: #AA22FF; font-weight: bold">or</span> diff2 <span style="color: #666666">&lt;</span> tol:
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;*** Consistency check failed:&#39;</span>, diff1, diff2
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>d)</b>
Simulate a case with \( T=8 \), \( \alpha = 1 \), \( \beta=4 \), and two
\( \epsilon \) values: 0.9 and 0.1.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_26_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_26_4">

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">demo</span>():
    alpha <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    beta <span style="color: #666666">=</span> <span style="color: #666666">4</span>
    epsilon <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    T <span style="color: #666666">=</span> <span style="color: #666666">8</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>]) <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">len</span>(sys<span style="color: #666666">.</span>argv) <span style="color: #666666">&gt;=</span> <span style="color: #666666">2</span> <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">0.1</span>
    Q, P, S, E <span style="color: #666666">=</span> solver(alpha, beta, epsilon, T, dt)
    plt<span style="color: #666666">.</span>plot(t, Q, t, P, t, S, t, E)
    plt<span style="color: #666666">.</span>legend([<span style="color: #BA2121">&#39;complex&#39;</span>, <span style="color: #BA2121">&#39;product&#39;</span>, <span style="color: #BA2121">&#39;substrate&#39;</span>, <span style="color: #BA2121">&#39;enzyme&#39;</span>],
               loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;upper right&#39;</span>)
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;alpha=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, beta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, epsilon=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (alpha, beta, epsilon))
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.png&#39;</span>);  plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.pdf&#39;</span>)
    plt<span style="color: #666666">.</span>show()

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    demo()
</pre></div>
<p>
<center><p><img src="fig-decay/biochem.png" align="bottom" width=700></p></center>

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
Filename: <code>biochem</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:atm1">Exercise 27: Simulate the pressure drop in the atmosphere</h2>

<p>
We consider the models for atmospheric pressure in
the section <a href="#decay:app:atm">Decay of atmospheric pressure with altitude</a>.
Make a program with three functions,

<ul>
 <li> one computing the pressure \( p(z) \) using a seven-layer model
   and varying \( L \),</li>
 <li> one computing \( p(z) \) using a seven-layer model,
   but with constant temperature in each layer, and</li>
 <li> one computing \( p(z) \) based on the
   one-layer model.</li>
</ul>

How can these implementations be verified? Should ease of verification
impact how you code the functions?
Compare the three models in a plot.
Filename: <code>atmospheric_pressure</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:drag:prog">Exercise 28: Make a program for vertical motion in a fluid</h2>

<p>
Implement the Stokes' drag model <a href="#mjx-eqn-99">(99)</a>
and the quadratic drag model <a href="#mjx-eqn-101">(101)</a> from
the section <a href="#decay:app:drag">Vertical motion of a body in a viscous fluid</a>, using the Crank-Nicolson
scheme and a geometric mean for \( |v|v \) as explained, and assume
constant fluid density.
At each time level, compute the Reynolds number
Re and choose the Stokes' drag model if \( \hbox{Re} < 1 \) and the
quadratic drag model otherwise.

<p>
The computation of the numerical solution should take place either in
a stand-alone function or in a solver class that looks up a problem
class for physical data. Create a module and equip it with pytest/nose
compatible test functions for automatically verifying the code.

<p>
Verification tests can be based on

<ul>
 <li> the terminal velocity (see the section <a href="#decay:app:drag">Vertical motion of a body in a viscous fluid</a>),</li>
 <li> the exact solution when the drag force is neglected
   (see the section <a href="#decay:app:drag">Vertical motion of a body in a viscous fluid</a>),</li>
 <li> the method of manufactured solutions (see the section <a href="._decay-sol005.html#decay:MMS">Verification via manufactured solutions</a>)
   combined with computing
   convergence rates (see the section <a href="._decay-sol005.html#decay:convergence:rate">Computing convergence rates</a>).</li>
</ul>

Use, e.g., a quadratic polynomial for the velocity in the method of
manufactured solutions. The expected error is \( \Oof{\Delta t^2} \)
from the centered finite difference approximation and the geometric
mean approximation for \( |v|v \).

<p>
A solution that is linear in \( t \) will also be an exact solution of the
discrete equations in many problems.  Show that this is true for
linear drag (by adding a source term that depends on \( t \)), but not
for quadratic drag because of the geometric mean approximation.  Use
the method of manufactured solutions to add a source term <em>in the
discrete equations for quadratic drag</em> such that a linear function of
\( t \) is a solution. Add a test function for checking that the linear
function is reproduced to machine precision in the case of both linear
and quadratic drag.

<p>
Apply the software to a case where a ball rises in water.  The
buoyancy force is here the driving force, but the drag will be
significant and balance the other forces after a short time.  A soccer
ball has radius 11 cm and mass 0.43 kg.  Start the motion from rest, set
the density of water, \( \varrho \), to \( 1000\hbox{ kg/m}^3 \), set the
dynamic viscosity, \( \mu \), to \( 10^{-3}\hbox{ Pa s} \), and use a drag
coefficient for a sphere: 0.45. Plot the velocity of the rising ball.
Filename: <code>vertical_motion</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:parachute">Project 29: Simulate parachuting</h2>

<p>
The aim of this project is to develop a general solver for the
vertical motion of a body with quadratic air drag, verify the solver,
apply the solver to a skydiver in free fall, and finally apply the
solver to a complete parachute jump.

<p>
All the pieces of software implemented in this project
should be realized as Python functions and/or classes and collected
in one module.

<p>
<b>a)</b>
Set up the differential equation problem that governs the velocity
of the motion.
The parachute jumper is subject to the gravity force and a quadratic
drag force. Assume constant density.
Add an extra source term be used for program verification.
Identify the input data to the problem.

<p>
<b>b)</b>
Make a Python module for computing the velocity of the motion.
Also equip the module with functionality for plotting the velocity.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_29_1" style="font-size: 80%;"></a>
<b>Hint 1.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_29_1">

<p>
Use the Crank-Nicolson scheme with a geometric mean of \( |v|v \) in time to
linearize the equation of motion with quadratic drag.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_29_2" style="font-size: 80%;"></a>
<b>Hint 2.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_29_2">

<p>
You can either use functions or classes for implementation.
If you choose functions, make a function
<code>solver</code> that takes all the input data in the problem as
arguments and that returns the velocity (as a mesh function) and
the time mesh. In case of a class-based implementation, introduce
a problem class with the physical data
and a solver class with the numerical data and a <code>solve</code> method
that stores the velocity and the mesh in the class.

<p>
Allow for a time-dependent area and drag coefficient in the
formula for the drag force.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>c)</b>
Show that a linear function of \( t \) does not fulfill the discrete
equations because of the geometric mean approximation
used for the quadratic drag
term.  Fit a source term, as in the method of manufactured solutions,
such that a linear function of \( t \) is a solution of the discrete
equations. Make a test function to check that this solution is reproduced
to machine precision.

<p>
<b>d)</b>
The expected error in this problem goes like \( \Delta t^2 \) because we
use a centered finite difference approximation with error \( \Oof{\Delta t^2} \)
and a geometric mean approximation with error \( \Oof{\Delta t^2} \).
Use the method of manufactured solutions combined with computing
convergence rate to verify the code. Make a test function for checking
that the convergence rate is correct.

<p>
<b>e)</b>
Compute the drag force, the gravity
force, and the buoyancy force as a function of time. Create
a plot with these three forces.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_29_3" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_29_3">

<p>
You can either make a function <code>forces(v, t, plot=None)</code>
that returns the forces (as mesh functions) and <code>t</code>, and shows
a plot on the screen and also saves the plot to a file with name
stored in <code>plot</code>
if <code>plot</code> is not <code>None</code>, or you can extend the solver class with
computation of forces and include plotting of forces in the
visualization class.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>f)</b>
Compute the velocity of
a skydiver in free fall before the parachute opens.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_29_4" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_29_4">

<p>
Meade and Struthers <a href="._decay-sol008.html#parachute_1999">[10]</a> provide some data relevant
to <a href="http://en.wikipedia.org/wiki/Parachuting" target="_self">skydiving</a>.
The mass of the human body and equipment
can be set to \( 100 \) kg.
A skydiver in spread-eagle formation has a cross-section of 0.5 \( \hbox{m}^2 \)
in the horizontal plane.
The density of air decreases varies altitude, but can be taken
as constant, 1 \( \hbox{kg/m}^3 \), for altitudes relevant to
skydiving (0-4000 m).
The drag coefficient for a man in upright position can be set to 1.2.
Start with a zero velocity.
A free fall typically has a terminating velocity of 45 m/s. (This value
can be used to tune other parameters.)

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>g)</b>
The next task is to simulate
a parachute jumper during free fall and after the parachute opens.
At time \( t_p \), the parachute opens and
the drag coefficient and the cross-sectional
area change dramatically.
Use the program to simulate a jump from \( z=3000 \) m to the ground \( z=0 \).
What is the maximum acceleration, measured in units of \( g \),
experienced by the jumper?

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_29_5" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_29_5">

<p>
Following Meade and Struthers <a href="._decay-sol008.html#parachute_1999">[10]</a>, one can set the
cross-section area perpendicular to the motion to 44 \( \hbox{m}^2 \)
when the parachute is open. Assume that it takes 8 s to increase
the area linearly from the original to the final value.
The drag coefficient for an open
parachute can be taken as 1.8, but tuned using the known value
of the typical terminating velocity reached before landing:
5.3 m/s. One can take the drag coefficient as a piecewise constant
function with an abrupt change at \( t_p \).
The parachute is typically released after \( t_p=60 \) s, but
larger values of \( t_p \) can be used to make plots more illustrative.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>parachuting</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:drag:atm1">Exercise 30: Formulate vertical motion in the atmosphere</h2>

<p>
Vertical motion of a body in the atmosphere needs to take into
account a varying air density if the range of altitudes is
many kilometers. In this case, \( \varrho \) varies with the altitude \( z \).
The equation of motion for the body is given in
the section <a href="#decay:app:drag">Vertical motion of a body in a viscous fluid</a>. Let us assume quadratic drag force
(otherwise the body has to be very, very small).
A differential equation problem for the air density, based on
the information for the one-layer atmospheric model in
the section <a href="#decay:app:atm">Decay of atmospheric pressure with altitude</a>, can be set up as

$$
\begin{align}
p^{\prime}(z) &= -\frac{Mg}{R^*(T_0+Lz)} p,\\ 
\varrho &= p \frac{M}{R^*T}
\tp
\end{align}
$$

To evaluate \( p(z) \) we need the altitude \( z \). From the principle that the
velocity is the derivative of the position we have that

$$
\begin{equation}
z^{\prime}(t) = v(t),
\end{equation}
$$

where \( v \) is the velocity of the body.

<p>
Explain in detail how the governing equations can be discretized
by the Forward Euler and the Crank-Nicolson methods.
Discuss pros and cons of the two methods.
Filename: <code>falling_in_variable_density</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:drag:atm2">Exercise 31: Simulate vertical motion in the atmosphere</h2>

<p>
Implement the Forward Euler or the Crank-Nicolson scheme
derived in <a href="#decay:app:exer:drag:atm1">Exercise 30: Formulate vertical motion in the atmosphere</a>.
Demonstrate the effect of air density variation on a falling
human, e.g., the famous fall of <a href="http://en.wikipedia.org/wiki/Felix_Baumgartner" target="_self">Felix Baumgartner</a>. The drag coefficient can be set to 1.2.
Filename: <code>falling_in_variable_density</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:signum">Exercise 32: Compute \( y=|x| \) by solving an ODE</h2>

<p>
Consider the ODE problem
$$
y^{\prime}(x) = \left\lbrace\begin{array}{ll}
-1, & x < 0,\\ 
1, & x \geq 0
\end{array}\right.\quad x\in (-1, 1],
\quad y(1-)=1,
$$

which has the solution \( y(x)=|x| \).
Using a mesh \( x_0=-1 \), \( x_1=0 \), and \( x_2=1 \), calculate by hand
\( y_1 \) and \( y_2 \) from the Forward Euler, Backward Euler, Crank-Nicolson,
and Leapfrog methods. Use all of the former three methods for computing
the \( y_1 \) value to be used in the Leapfrog calculation of \( y_2 \).
Thereafter, visualize how these schemes perform for a uniformly partitioned
mesh with \( N=10 \) and \( N=11 \) points.
Filename: <code>signum</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:interest">Exercise 33: Simulate growth of a fortune with random interest rate</h2>

<p>
The goal of this exercise is to compute the value of a fortune subject
to inflation and a random interest rate.
Suppose that the inflation is constant at \( i \) percent per year and that the
annual interest rate, \( p \), changes randomly at each time step,
starting at some value \( p_0 \) at \( t=0 \).
The random change is from a value \( p^n \) at \( t=t_n \) to
\( p_n +\Delta p \) with probability 0.25 and \( p_n -\Delta p \) with probability 0.25.
No change occurs with probability 0.5. There is also no change if
\( p^{n+1} \) exceeds 15 or becomes below 1.
Use a time step of one month, \( p_0=i \), initial fortune scaled to 1,
and simulate 1000 scenarios of
length 20 years. Compute the mean evolution of one unit of money and the
corresponding
standard deviation. Plot the mean curve along with the mean plus one
standard deviation and the mean minus one standard deviation. This will
illustrate the uncertainty in the mean curve.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_33_1" style="font-size: 80%;"></a>
<b>Hint 1.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_33_1">

<p>
The following code snippet computes \( p^{n+1} \):
<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">random</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">new_interest_rate</span>(p_n, dp<span style="color: #666666">=0.5</span>):
    r <span style="color: #666666">=</span> random<span style="color: #666666">.</span>random()  <span style="color: #408080; font-style: italic"># uniformly distr. random number in [0,1)</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #666666">0</span> <span style="color: #666666">&lt;=</span> r <span style="color: #666666">&lt;</span> <span style="color: #666666">0.25</span>:
        p_np1 <span style="color: #666666">=</span> p_n <span style="color: #666666">+</span> dp
    <span style="color: #008000; font-weight: bold">elif</span> <span style="color: #666666">0.25</span> <span style="color: #666666">&lt;=</span> r <span style="color: #666666">&lt;</span> <span style="color: #666666">0.5</span>:
        p_np1 <span style="color: #666666">=</span> p_n <span style="color: #666666">-</span> dp
    <span style="color: #008000; font-weight: bold">else</span>:
        p_np1 <span style="color: #666666">=</span> p_n
    <span style="color: #008000; font-weight: bold">return</span> (p_np1 <span style="color: #008000; font-weight: bold">if</span> <span style="color: #666666">1</span> <span style="color: #666666">&lt;=</span> p_np1 <span style="color: #666666">&lt;=</span> <span style="color: #666666">15</span> <span style="color: #008000; font-weight: bold">else</span> p_n)
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_33_2" style="font-size: 80%;"></a>
<b>Hint 2.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_33_2">

<p>
If \( u_i(t) \) is the value of the fortune in experiment number \( i \),
\( i=0,\ldots,N-1 \),
the mean evolution of the fortune is
$$ \bar u(t)= \frac{1}{N}\sum_{i=0}^{N-1} u_i(t),
$$

and the standard deviation is
$$ s(t) = \sqrt{\frac{1}{N-1}\left(- (\bar u(t))^2 +
                \sum_{i=0}^{N-1} (u_i(t))^2\right)}
\tp
$$

Suppose \( u_i(t) \) is stored in an array <code>u</code>.
The mean and the standard deviation of the fortune
is most efficiently computed by
using two accumulation arrays, <code>sum_u</code> and <code>sum_u2</code>, and
performing <code>sum_u += u</code> and <code>sum_u2 += u**2</code> after every experiment.
This technique avoids storing all the \( u_i(t) \) time series for
computing the statistics.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>random_interest</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:pop:at">Exercise 34: Simulate a population in a changing environment</h2>

<p>
We shall study a population modeled by <a href="#mjx-eqn-82">(82)</a> where
the environment, represented by \( r \) and \( f \), undergoes changes with time.

<p>
<b>a)</b>
Assume that there is a sudden drop (increase) in the birth (death)
rate at time \( t=t_r \),
because of limited nutrition or food supply:
$$ r(t) =\left\lbrace\begin{array}{ll}
\varrho, & t < t_r,\\ 
\varrho - A, & t\geq t_r,\end{array}\right.
$$

This drop in population growth is compensated by a sudden net immigration
at time \( t_f > t_r \):
$$ f(t) =\left\lbrace\begin{array}{ll}
0, & t < t_f,\\ 
f_0, & t\geq t_a,\end{array}\right.
$$

Start with \( \varrho \) and make \( A > \varrho \). Experiment with
these and other parameters to
illustrate the interplay of growth and decay in such a problem.

<p>
<b>b)</b>
Now we assume that the environmental conditions changes periodically with
time so that we may take
$$ r(t) = {\varrho} + A\sin\left(\frac{2\pi}{P}t\right)
\tp
$$

That is, the combined birth and death rate oscillates around \( \varrho \) with
a maximum change of \( \pm A \) repeating over a period of length \( P \) in time.
Set \( f=0 \) and experiment with the other parameters to illustrate typical
features of the solution.

<p>
Filename: <code>population.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:pop:logistic1">Exercise 35: Simulate logistic growth</h2>

<p>
Solve the logistic ODE
<a href="#mjx-eqn-83">(83)</a> using a Crank-Nicolson scheme where
\( (u^{n+\half})^2 \) is approximated by a <em>geometric mean</em>:
$$ (u^{n+\half})^2 \approx u^{n+1}u^n
\tp
$$

This trick makes the discrete equation linear in \( u^{n+1} \).
Filename: <code>logistic_CN</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="decay:app:exer:interest:derive">Exercise 36: Rederive the equation for continuous compound interest</h2>

<p>
The ODE model <a href="#mjx-eqn-85">(85)</a> was derived under the assumption
that \( r \) was constant. Perform an alternative derivation without
this assumption: 1) start with <a href="#mjx-eqn-84">(84)</a>;
2) introduce a time step \( \Delta t \) instead of \( m \): \( \Delta t = 1/m \) if
\( t \) is measured in years; 3) divide by \( \Delta t \) and take the
limit \( \Delta t\rightarrow 0 \). Simulate a case where the inflation is
at a constant level \( I \) percent per year and the interest rate oscillates:
\( r=-I/2 + r_0\sin(2\pi t) \).
Compare solutions for \( r_0=I, 3I/2, 2I \).
Filename: <code>interest_modeling</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._decay-sol005.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._decay-sol007.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    
