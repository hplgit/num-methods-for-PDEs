<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Solving nonlinear ODE and PDE problems">
<meta name="keywords" content="linearization explicit time integration,linearization,Picard iteration,successive substitutions,fixed-point iteration,linearization Picard iteration,linearization successive substitutions,linearization fixed-point iteration,stopping criteria (nonlinear problems),single Picard iteration technique,relaxation (nonlinear equations),stopping criteria (nonlinear problems),continuation method,online rendering of LaTeX formulas,continuation method,group finite element method,product approximation technique">

<title>Solving nonlinear ODE and PDE problems</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Introduction of basic concepts',
               1,
               'nonlin:timediscrete:logistic',
               'nonlin:timediscrete:logistic'),
              ('Linear versus nonlinear equations', 2, None, '___sec1'),
              ('Algebraic equations', 3, None, '___sec2'),
              ('Differential equations', 3, None, '___sec3'),
              ('A simple model problem', 2, None, '___sec4'),
              ('Linearization by explicit time discretization',
               2,
               'nonlin:timediscrete:logistic:FE',
               'nonlin:timediscrete:logistic:FE'),
              ('Exact solution of nonlinear algebraic equations',
               2,
               'nonlin:timediscrete:logistic:roots',
               'nonlin:timediscrete:logistic:roots'),
              ('Linearization', 2, None, '___sec7'),
              ('Picard iteration',
               2,
               'nonlin:timediscrete:logistic:Picard',
               'nonlin:timediscrete:logistic:Picard'),
              ('Stopping criteria', 3, None, '___sec9'),
              ('A single Picard iteration', 3, None, '___sec10'),
              ('Linearization by a geometric mean',
               2,
               'nonlin:timediscrete:logistic:geometric:mean',
               'nonlin:timediscrete:logistic:geometric:mean'),
              ("Newton's method",
               2,
               'nonlin:timediscrete:logistic:Newton',
               'nonlin:timediscrete:logistic:Newton'),
              ('Relaxation',
               2,
               'nonlin:timediscrete:logistic:relaxation',
               'nonlin:timediscrete:logistic:relaxation'),
              ('Implementation and experiments',
               2,
               'nonlin:timediscrete:logistic:impl',
               'nonlin:timediscrete:logistic:impl'),
              ('Generalization to a general nonlinear ODE',
               2,
               'nonlin:ode:generic',
               'nonlin:ode:generic'),
              ('Explicit time discretization', 3, None, '___sec16'),
              ('Backward Euler discretization', 3, None, '___sec17'),
              ('Crank-Nicolson discretization', 3, None, '___sec18'),
              ('Systems of ODEs',
               2,
               'nonlin:ode:generic:sys:pendulum',
               'nonlin:ode:generic:sys:pendulum'),
              ('Example', 3, None, '___sec20'),
              ('Systems of nonlinear algebraic equations',
               1,
               'nonlin:systems:alg',
               'nonlin:systems:alg'),
              ('Picard iteration',
               2,
               'nonlin:systems:alg:Picard',
               'nonlin:systems:alg:Picard'),
              ("Newton's method",
               2,
               'nonlin:systems:alg:Newton',
               'nonlin:systems:alg:Newton'),
              ('Stopping criteria',
               2,
               'nonlin:systems:alg:terminate',
               'nonlin:systems:alg:terminate'),
              ('Example: A nonlinear ODE model from epidemiology',
               2,
               'nonlin:systems:alg:SI',
               'nonlin:systems:alg:SI'),
              ('Implicit time discretization', 3, None, '___sec26'),
              ('A Picard iteration', 3, None, '___sec27'),
              ("Newton's method", 3, None, '___sec28'),
              ('Linearization at the differential equation level',
               1,
               'nonlin:pdelevel',
               'nonlin:pdelevel'),
              ('Explicit time integration',
               2,
               'nonlin:pdelevel:explicit',
               'nonlin:pdelevel:explicit'),
              ('Backward Euler scheme and Picard iteration',
               2,
               'nonlin:pdelevel:Picard',
               'nonlin:pdelevel:Picard'),
              ("Backward Euler scheme and Newton's method",
               2,
               'nonlin:pdelevel:Newton',
               'nonlin:pdelevel:Newton'),
              ('Linearization via Taylor expansions', 3, None, '___sec33'),
              ('Similarity with Picard iteration', 3, None, '___sec34'),
              ('Implementation', 3, None, '___sec35'),
              ('Derivation with alternative notation', 3, None, '___sec36'),
              ('Crank-Nicolson discretization',
               2,
               'nonlin:pdelevel:Picard:CN',
               'nonlin:pdelevel:Picard:CN'),
              ('Discretization of 1D stationary nonlinear differential equations',
               1,
               'nonlin:alglevel:1D',
               'nonlin:alglevel:1D'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:1D:fd',
               'nonlin:alglevel:1D:fd'),
              ('Solution of algebraic equations', 2, None, '___sec40'),
              ('The structure of the equation system', 3, None, '___sec41'),
              ('Picard iteration', 3, None, '___sec42'),
              ("Newton's method", 3, None, '___sec43'),
              ('Galerkin-type discretization',
               2,
               'nonlin:alglevel:1D:fe',
               'nonlin:alglevel:1D:fe'),
              ('Fundamental integration problem', 3, None, '___sec45'),
              ('Picard iteration defined from the variational form',
               2,
               'nonlin:alglevel:1D:fe:Picard',
               'nonlin:alglevel:1D:fe:Picard'),
              ("Newton's method defined from the variational form",
               2,
               'nonlin:alglevel:1D:fe:Newton',
               'nonlin:alglevel:1D:fe:Newton'),
              ('Dirichlet conditions', 3, None, '___sec48'),
              ('Multi-dimensional PDE problems', 1, None, '___sec49'),
              ('Finite element discretization',
               2,
               'nonlin:alglevel:dD:fe',
               'nonlin:alglevel:dD:fe'),
              ('Non-homogeneous Neumann conditions', 3, None, '___sec51'),
              ('Robin conditions', 3, None, '___sec52'),
              ('Finite difference discretization',
               2,
               'nonlin:alglevel:dD:fd',
               'nonlin:alglevel:dD:fd'),
              ('Picard iteration', 3, None, '___sec54'),
              ("Newton's method", 3, None, '___sec55'),
              ('Continuation methods', 2, None, '___sec56'),
              ('Exercises', 1, 'nonlin:exer', 'nonlin:exer'),
              ('Problem 1: Determine if equations are nonlinear or not',
               2,
               'nonlin:exer:lin:vs:nonlin',
               'nonlin:exer:lin:vs:nonlin'),
              ('Exercise 2: Derive and investigate a generalized logistic model',
               2,
               'nonlin:exer:logistic:gen',
               'nonlin:exer:logistic:gen'),
              ("Problem 3: Experience the behavior of Newton's method",
               2,
               'nonlin:exer:Newton:problems1',
               'nonlin:exer:Newton:problems1'),
              ('Problem 4: Compute the Jacobian of a $2\\times 2$ system',
               2,
               'nonlin:exer:vib:Jacobian',
               'nonlin:exer:vib:Jacobian'),
              ('Problem 5: Solve nonlinear equations arising from a vibration ODE',
               2,
               'nonlin:exer:vib:geometric:mean',
               'nonlin:exer:vib:geometric:mean'),
              ('Exercise 6: Find the truncation error of arithmetic mean of products',
               2,
               'nonlin:exer:products:arith:mean',
               'nonlin:exer:products:arith:mean'),
              ("Problem 7: Newton's method for linear problems",
               2,
               'nonlin:exer:Newton:linear',
               'nonlin:exer:Newton:linear'),
              ('Exercise 8: Discretize a 1D problem with a nonlinear coefficient',
               2,
               'nonlin:exer:1D:1pu2:fem',
               'nonlin:exer:1D:1pu2:fem'),
              ('Exercise 9: Linearize a 1D problem with a nonlinear coefficient',
               2,
               'nonlin:exer:1D:1pu2:PicardNewton',
               'nonlin:exer:1D:1pu2:PicardNewton'),
              ('Problem 10: Finite differences for the 1D Bratu problem',
               2,
               'nonlin:exer:1D:fu:discretize:fd',
               'nonlin:exer:1D:fu:discretize:fd'),
              ('Problem 11: Integrate functions of finite element expansions',
               2,
               'nonlin:exer:fu:fem:int',
               'nonlin:exer:fu:fem:int'),
              ('Problem 12: Finite elements for the 1D Bratu problem',
               2,
               'nonlin:exer:1D:fu:discretize:fe',
               'nonlin:exer:1D:fu:discretize:fe'),
              ('Exercise 13: Discretize a nonlinear 1D heat conduction PDE by finite differences',
               2,
               'nonlin:exer:1D:heat:nonlinear:fdm',
               'nonlin:exer:1D:heat:nonlinear:fdm'),
              ('Exercise 14: Use different symbols for different approximations of the solution',
               2,
               'nonlin:exer:dD:nonlinear:usymbols',
               'nonlin:exer:dD:nonlinear:usymbols'),
              ('Exercise 15: Derive Picard and Newton systems from a variational form',
               2,
               'nonlin:exer:dD:heat:nonlinear:c:a',
               'nonlin:exer:dD:heat:nonlinear:c:a'),
              ('Exercise 16: Derive algebraic equations for nonlinear 1D heat conduction',
               2,
               'nonlin:exer:1D:heat:nonlinear:c:a',
               'nonlin:exer:1D:heat:nonlinear:c:a'),
              ('Exercise 17: Differentiate a highly nonlinear term',
               2,
               'nonlin:exer:grad:pow:term',
               'nonlin:exer:grad:pow:term'),
              ('Exercise 18: Crank-Nicolson for a nonlinear 3D diffusion equation',
               2,
               'nonlin:exer:2D:heat:nonlinear:fd',
               'nonlin:exer:2D:heat:nonlinear:fd'),
              ('Exercise 19: Find the sparsity of the Jacobian',
               2,
               'nonlin:exer:sparsity:Jacobian',
               'nonlin:exer:sparsity:Jacobian'),
              ('Problem 20: Investigate a 1D problem with a continuation method',
               2,
               'nonlin:exer:continuation:1DnNflow',
               'nonlin:exer:continuation:1DnNflow'),
              ('Bibliography', 1, None, '___sec78'),
              ('Appendix: Symbolic nonlinear finite element equations',
               1,
               'nonlin:app:fem_vs_fdm',
               'nonlin:app:fem_vs_fdm'),
              ('Finite element basis functions',
               2,
               'nonlin:alglevel:1D:fe_basis',
               'nonlin:alglevel:1D:fe_basis'),
              ('The group finite element method',
               2,
               'nonlin:alglevel:1D:fe:group',
               'nonlin:alglevel:1D:fe:group'),
              ('Finite element approximation of functions of $u$',
               3,
               None,
               '___sec82'),
              ('Simplified problem', 3, None, '___sec83'),
              ('Integrating nonlinear functions', 3, None, '___sec84'),
              ('Application of the group finite element method',
               3,
               None,
               '___sec85'),
              ('Numerical integration of nonlinear terms by hand',
               2,
               'nonlin:alglevel:1D:fe:f',
               'nonlin:alglevel:1D:fe:f'),
              ('Finite element discretization of a variable coefficient Laplace term',
               2,
               'nonlin:alglevel:1D:fe:Laplace',
               'nonlin:alglevel:1D:fe:Laplace'),
              ('Group finite element method', 3, None, '___sec88'),
              ('Numerical integration at the nodes', 3, None, '___sec89')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="nonlin-sol.html">Solving nonlinear ODE and PDE problems</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#nonlin:timediscrete:logistic" style="font-size: 80%;"><b>Introduction of basic concepts</b></a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linear versus nonlinear equations</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A simple model problem</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#nonlin:timediscrete:logistic:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linearization by explicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#nonlin:timediscrete:logistic:roots" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exact solution of nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linearization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#nonlin:timediscrete:logistic:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec10" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A single Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#nonlin:timediscrete:logistic:geometric:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Linearization by a geometric mean</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#nonlin:timediscrete:logistic:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#nonlin:timediscrete:logistic:relaxation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Relaxation</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#nonlin:timediscrete:logistic:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Implementation and experiments</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#nonlin:ode:generic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Generalization to a general nonlinear ODE</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec16" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Explicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec17" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backward Euler discretization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec18" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Crank-Nicolson discretization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#nonlin:ode:generic:sys:pendulum" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Systems of ODEs</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol001.html#___sec20" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Example</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol002.html#nonlin:systems:alg" style="font-size: 80%;"><b>Systems of nonlinear algebraic equations</b></a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol002.html#nonlin:systems:alg:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol002.html#nonlin:systems:alg:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol002.html#nonlin:systems:alg:terminate" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Stopping criteria</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol002.html#nonlin:systems:alg:SI" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Example: A nonlinear ODE model from epidemiology</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol002.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implicit time discretization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol002.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol002.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol003.html#nonlin:pdelevel" style="font-size: 80%;"><b>Linearization at the differential equation level</b></a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol003.html#nonlin:pdelevel:explicit" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Explicit time integration</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol003.html#nonlin:pdelevel:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Backward Euler scheme and Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol003.html#nonlin:pdelevel:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Backward Euler scheme and Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol003.html#___sec33" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linearization via Taylor expansions</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol003.html#___sec34" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similarity with Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol003.html#___sec35" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol003.html#___sec36" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation with alternative notation</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol003.html#nonlin:pdelevel:Picard:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Crank-Nicolson discretization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#nonlin:alglevel:1D" style="font-size: 80%;"><b>Discretization of 1D stationary nonlinear differential equations</b></a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#nonlin:alglevel:1D:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#___sec40" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solution of algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#___sec41" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The structure of the equation system</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#___sec42" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#nonlin:alglevel:1D:fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Galerkin-type discretization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#___sec45" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fundamental integration problem</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#nonlin:alglevel:1D:fe:Picard" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Picard iteration defined from the variational form</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#nonlin:alglevel:1D:fe:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Newton's method defined from the variational form</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol004.html#___sec48" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dirichlet conditions</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol005.html#___sec49" style="font-size: 80%;"><b>Multi-dimensional PDE problems</b></a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol005.html#nonlin:alglevel:dD:fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite element discretization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol005.html#___sec51" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Non-homogeneous Neumann conditions</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol005.html#___sec52" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Robin conditions</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol005.html#nonlin:alglevel:dD:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference discretization</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol005.html#___sec54" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Picard iteration</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol005.html#___sec55" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol005.html#___sec56" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Continuation methods</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer" style="font-size: 80%;"><b>Exercises</b></a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:lin:vs:nonlin" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 1: Determine if equations are nonlinear or not</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:logistic:gen" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 2: Derive and investigate a generalized logistic model</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:Newton:problems1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 3: Experience the behavior of Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:vib:Jacobian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 4: Compute the Jacobian of a \( 2\times 2 \) system</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:vib:geometric:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 5: Solve nonlinear equations arising from a vibration ODE</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:products:arith:mean" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 6: Find the truncation error of arithmetic mean of products</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:Newton:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 7: Newton's method for linear problems</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:1D:1pu2:fem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 8: Discretize a 1D problem with a nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:1D:1pu2:PicardNewton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 9: Linearize a 1D problem with a nonlinear coefficient</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:1D:fu:discretize:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 10: Finite differences for the 1D Bratu problem</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:fu:fem:int" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 11: Integrate functions of finite element expansions</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:1D:fu:discretize:fe" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 12: Finite elements for the 1D Bratu problem</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:1D:heat:nonlinear:fdm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 13: Discretize a nonlinear 1D heat conduction PDE by finite differences</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:dD:nonlinear:usymbols" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 14: Use different symbols for different approximations of the solution</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:dD:heat:nonlinear:c:a" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 15: Derive Picard and Newton systems from a variational form</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:1D:heat:nonlinear:c:a" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 16: Derive algebraic equations for nonlinear 1D heat conduction</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:grad:pow:term" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 17: Differentiate a highly nonlinear term</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:2D:heat:nonlinear:fd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 18: Crank-Nicolson for a nonlinear 3D diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:sparsity:Jacobian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercise 19: Find the sparsity of the Jacobian</a></li>
     <!-- navigation toc: --> <li><a href="#nonlin:exer:continuation:1DnNflow" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Problem 20: Investigate a 1D problem with a continuation method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec78" style="font-size: 80%;"><b>Bibliography</b></a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#nonlin:app:fem_vs_fdm" style="font-size: 80%;"><b>Appendix: Symbolic nonlinear finite element equations</b></a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#nonlin:alglevel:1D:fe_basis" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#nonlin:alglevel:1D:fe:group" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite element approximation of functions of \( u \)</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#___sec83" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Simplified problem</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integrating nonlinear functions</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#___sec85" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application of the group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#nonlin:alglevel:1D:fe:f" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Numerical integration of nonlinear terms by hand</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#nonlin:alglevel:1D:fe:Laplace" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite element discretization of a variable coefficient Laplace term</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#___sec88" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Group finite element method</a></li>
     <!-- navigation toc: --> <li><a href="._nonlin-sol007.html#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical integration at the nodes</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0006"></a>
<!-- !split -->

<h1 id="nonlin:exer">Exercises</h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:lin:vs:nonlin">Problem 1: Determine if equations are nonlinear or not</h2>

<p>
Classify each term in the following equations as linear or nonlinear.
Assume that \( u \), \( \u \), and \( p \) are unknown functions and that
all other symbols are known quantities.

<ol>
<li> \( mu^{\prime\prime} + \beta |u^{\prime}|u^{\prime} + cu = F(t) \)</li>
<li> \( u_t = \dfc u_{xx} \)</li>
<li> \( u_{tt} = c^2\nabla^2 u \)</li>
<li> \( u_t = \nabla\cdot(\dfc(u)\nabla u) + f(x,y) \)</li>
<li> \( u_t + f(u)_x = 0 \)</li>
<li> \( \u_t + \u\cdot\nabla \u = -\nabla p + r\nabla^2\u \), \( \nabla\cdot\u = 0 \)
   (\( \u \) is a vector field)</li>
<li> \( u^{\prime} = f(u,t) \)</li>
<li> \( \nabla^2 u = \lambda e^u \)</li>
</ol>

<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_1_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_1_1">

<ol>
<li> \( mu^{\prime\prime} \) is linear; \( \beta |u^{\prime}|u^{\prime} \) is
   nonlinear; \( cu \) is linear; \( F(t) \) does not contain the unknown \( u \)
   and is hence constant in \( u \), so the term is linear.</li>
<li> \( u_t \) is linear; \( \dfc u_{xx} \) is linear.</li>
<li> \( u_{tt} \) is linear; \( c^2\nabla^2 u \) is linear.</li>
<li> \( u_t \) is linear; \( \nabla\cdot(\dfc(u)\nabla u) \) is nonlinear;
   \( f(x,y) \) is constant in \( u \) and hence linear.</li>
<li> \( u_t \) is linear;  \( f(u)_x \) is nonlinear if \( f \) is nonlinear in \( u \).</li>
<li> \( \u_t \) is linear; \( \u\cdot\nabla \u \) is nonlinear;
   \( -\nabla p \) is linear (in \( p \));  \( r\nabla^2\u \) is linear;
   \( \nabla\cdot\u \) is linear.</li>
<li> \( u^{\prime} \) is linear;  \( f(u,t) \) is nonlinear if \( f \) is nonlinear in \( u \).</li>
<li> \( \nabla^2 u \) is linear; \( \lambda e^u \) is nonlinear.</li>
</ol>

</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>nonlinear_vs_linear</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:logistic:gen">Exercise 2: Derive and investigate a generalized logistic model</h2>

<p>
The logistic model for population growth is derived by assuming
a nonlinear growth rate,

$$
\begin{equation}
u^{\prime} = a(u)u,\quad u(0)=I,
\tag{88}
\end{equation}
$$

and the logistic model arises from the simplest possible choice of
\( a(u) \): \( r(u)=\varrho(1 - u/M) \), where \( M \) is the maximum value of \( u \) that
the environment can sustain, and \( \varrho \) is the growth under
unlimited access to resources (as in the beginning when \( u \) is small).
The idea is that \( a(u)\sim\varrho \) when \( u \) is small and that
\( a(t)\rightarrow 0 \) as \( u\rightarrow M \).

<p>
An \( a(u) \) that generalizes the linear choice is the polynomial form

$$
\begin{equation}
a(u) = \varrho(1-u/M)^p,
\tag{89}
\end{equation}
$$

where \( p>0 \) is some real number.

<p>
<b>a)</b>
Formulate a Forward Euler, Backward Euler, and a Crank-Nicolson
scheme for <a href="#mjx-eqn-88">(88)</a>.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_1">

<p>
Use a geometric mean approximation in the Crank-Nicolson scheme:
\( [a(u)u]^{n+1/2}\approx a(u^n)u^{n+1} \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_3" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_3">

<p>
The Forward Euler scheme reads

$$ [D^+_t u = a(u)u]^n, $$

or written out,

$$ \frac{u^{n+1}-u^n}{\Delta t} = a(u^n)u^n\tp$$

The scheme is linear in the unknown \( u^{n+1} \):

$$ u^{n+1} = u^n + {\Delta t}a(u^n)u^n\tp$$

<p>
The Backward Euler scheme,

$$ [D^-_t u = a(u)u]^n, $$

becomes

$$ \frac{u^{n}-u^{n-1}}{\Delta t} = a(u^n)u^n,$$

which is a nonlinear equation in the unknown \( u \), here expressed as
\( u^{n+1} \):

$$ u^{n+1} - \Delta t a(u^{n+1})u^{n+1} = u^n\tp$$

<p>
The standard Crank-Nicolson scheme,

$$ D_t u = \overline{a(u)u}^t]^{n+\half},$$

takes the form

$$ \frac{u^{n+1}-u^n}{\Delta t} = \half a(u^n)u^n + \half a(u^{n+1})u^{n+1}\tp$$

This is a nonlinear equation in the unknown \( u^{n+1} \),

$$ u^{n+1} - \half {\Delta t} a(u^{n+1})u^{n+1}
= u^n + \half {\Delta t} a(u^n)u^n\tp$$

However, with the suggested geometric mean, the \( a(u)u \) term is
linearized:

$$ \frac{u^{n+1}-u^n}{\Delta t} = a(u^n)u^{n+1},$$

leading to a linear equation in \( u^{n+1} \):

$$ (1 - \Delta t a(u^n))u^{n+1} = u^n\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>b)</b>
Formulate Picard and Newton iteration for the Backward Euler scheme in a).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_4" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_4">

<p>
A Picard iteration for

$$ u^{n+1} - \Delta t a(u^{n+1})u^{n+1} = u^n\tp$$

applies old values in for \( u^{n+1} \) in \( a(u^{n+1}) \). If \( u^- \) is the
most recently computed approximation to \( u^{n+1} \), we can write the Picard
linearization as

$$ (1 - \Delta t a(u^-))u^{n+1} = u^n\tp$$

Alternatively, with an iteration index \( k \),

$$ (1 - \Delta t a(u^{n+1,k}))u^{n+1,k+1} = u^n\tp$$

<p>
Newton's method starts with identifying the nonlinear equation as
\( F(u)=0 \), and here

$$ F(u) = u - \Delta t a(u)u - u^n\tp$$

The Jacobian is

$$ J(u) = \frac{F(u)}{du} = 1 - \Delta t(a'(u)u + a(u))\tp$$

The key equation in Newton's method is then

$$ J(u^-)\delta u = - F(u^-),\quad u\leftarrow u - \delta u\tp$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>c)</b>
Implement the numerical solution methods from a) and b).
Use <a href="http://tinyurl.com/nm5587k/nonlin/logistic.py" target="_self"><tt>logistic.py</tt></a> to compare the case
\( p=1 \) and the choice <a href="#mjx-eqn-89">(89)</a>.

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_5" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_5">

<p>
We specialize the code for \( a(u) \) to <a href="#mjx-eqn-89">(89)</a>
since the code was developed from <code>logistic.py</code>. It is convenient to
work with a dimensionless form of the problem.
Choosing a time scale \( t_c = 1\varrho \) and a scale for \( u \),
\( u_c=M \), leads to

$$ u^{\prime} = \varrho (1-u)^p u,\quad u(0)=\alpha,$$

where \( \alpha \) is a dimensionless number

$$ \alpha = \frac{I}{M}\tp$$

<p>
The three schemes can be implemented as follows.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">FE_logistic</span>(p, u0, dt, Nt):
    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n] <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> u[n])<span style="color: #666666">**</span>p<span style="color: #666666">*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">BE_logistic</span>(p, u0, dt, Nt, choice<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Picard&#39;</span>,
                eps_r<span style="color: #666666">=1E-3</span>, omega<span style="color: #666666">=1</span>, max_iter<span style="color: #666666">=1000</span>):
    <span style="color: #408080; font-style: italic"># u[n] = u[n-1] + dt*(1-u[n])**p*u[n]</span>
    <span style="color: #408080; font-style: italic"># -dt*(1-u[n])**p*u[n] + u[n] = u[n-1]</span>
    <span style="color: #008000; font-weight: bold">if</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Picard1&#39;</span>:
        choice <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;Picard&#39;</span>
        max_iter <span style="color: #666666">=</span> <span style="color: #666666">1</span>

    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    iterations <span style="color: #666666">=</span> []
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt<span style="color: #666666">+1</span>):
        c <span style="color: #666666">=</span> <span style="color: #666666">-</span>u[n<span style="color: #666666">-1</span>]
        <span style="color: #008000; font-weight: bold">if</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Picard&#39;</span>:
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">F</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-</span>dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>p<span style="color: #666666">*</span>u <span style="color: #666666">+</span> u <span style="color: #666666">+</span> c

            u_ <span style="color: #666666">=</span> u[n<span style="color: #666666">-1</span>]
            k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">abs</span>(F(u_)) <span style="color: #666666">&gt;</span> eps_r <span style="color: #AA22FF; font-weight: bold">and</span> k <span style="color: #666666">&lt;</span> max_iter:
                <span style="color: #408080; font-style: italic"># u*(1-dt*(1-u_)**p) + c = 0</span>
                u_ <span style="color: #666666">=</span> omega<span style="color: #666666">*</span>(<span style="color: #666666">-</span>c<span style="color: #666666">/</span>(<span style="color: #666666">1-</span>dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u_)<span style="color: #666666">**</span>p)) <span style="color: #666666">+</span> (<span style="color: #666666">1-</span>omega)<span style="color: #666666">*</span>u_
                k <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            u[n] <span style="color: #666666">=</span> u_
            iterations<span style="color: #666666">.</span>append(k)

        <span style="color: #008000; font-weight: bold">elif</span> choice <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;Newton&#39;</span>:
            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">F</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-</span>dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>p<span style="color: #666666">*</span>u <span style="color: #666666">+</span> u <span style="color: #666666">+</span> c

            <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">dF</span>(u):
                <span style="color: #008000; font-weight: bold">return</span> dt<span style="color: #666666">*</span>p<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>(p<span style="color: #666666">-1</span>)<span style="color: #666666">*</span>u <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>u)<span style="color: #666666">**</span>p <span style="color: #666666">+</span> <span style="color: #666666">1</span>

            u_ <span style="color: #666666">=</span> u[n<span style="color: #666666">-1</span>]
            k <span style="color: #666666">=</span> <span style="color: #666666">0</span>
            <span style="color: #008000; font-weight: bold">while</span> <span style="color: #008000">abs</span>(F(u_)) <span style="color: #666666">&gt;</span> eps_r <span style="color: #AA22FF; font-weight: bold">and</span> k <span style="color: #666666">&lt;</span> max_iter:
                u_ <span style="color: #666666">=</span> u_ <span style="color: #666666">-</span> F(u_)<span style="color: #666666">/</span>dF(u_)
                k <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
            u[n] <span style="color: #666666">=</span> u_
            iterations<span style="color: #666666">.</span>append(k)
    <span style="color: #008000; font-weight: bold">return</span> u, iterations

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">CN_logistic</span>(p, u0, dt, Nt):
    <span style="color: #408080; font-style: italic"># u[n+1] = u[n] + dt*(1-u[n])**p*u[n+1]</span>
    <span style="color: #408080; font-style: italic"># (1 - dt*(1-u[n])**p)*u[n+1] = u[n]</span>
    u <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(Nt<span style="color: #666666">+1</span>)
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> u0
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">0</span>, Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n]<span style="color: #666666">/</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1</span> <span style="color: #666666">-</span> u[n])<span style="color: #666666">**</span>p)
    <span style="color: #008000; font-weight: bold">return</span> u
</pre></div>
<p>
A first verification is to choose \( p=1 \) and compare the results with
those from <code>logistic.py</code>. The number of iterations and the final
numerical answers should be identical.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>d)</b>
Implement unit tests that check the asymptotic limit of the solutions:
\( u\rightarrow M \) as \( t\rightarrow\infty \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_2" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_2">

<p>
You need to experiment to find what &quot;infinite time&quot; is
(increases substantially with \( p \)) and what the
appropriate tolerance is for testing the asymptotic limit.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_6" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_6">

<p>
The test function may look like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_asymptotic_value</span>():
    T <span style="color: #666666">=</span> <span style="color: #666666">100</span>
    dt <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))
    u0 <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    p <span style="color: #666666">=</span> <span style="color: #666666">1.8</span>

    u_CN <span style="color: #666666">=</span> CN_logistic(p, u0, dt, Nt)
    u_BE_Picard, iter_Picard <span style="color: #666666">=</span> BE_logistic(
        p, u0, dt, Nt, choice<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Picard&#39;</span>,
        eps_r<span style="color: #666666">=1E-5</span>, omega<span style="color: #666666">=1</span>, max_iter<span style="color: #666666">=1000</span>)
    u_BE_Newton, iter_Newton <span style="color: #666666">=</span> BE_logistic(
        p, u0, dt, Nt, choice<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Newton&#39;</span>,
        eps_r<span style="color: #666666">=1E-5</span>, omega<span style="color: #666666">=1</span>, max_iter<span style="color: #666666">=1000</span>)
    u_FE <span style="color: #666666">=</span> FE_logistic(p, u0, dt, Nt)

    <span style="color: #008000; font-weight: bold">for</span> arr <span style="color: #AA22FF; font-weight: bold">in</span> u_CN, u_BE_Picard, u_BE_Newton, u_FE:
        expected <span style="color: #666666">=</span> <span style="color: #666666">1</span>
        computed <span style="color: #666666">=</span> arr[<span style="color: #666666">-1</span>]
        tol <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;expected=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">, computed=</span><span style="color: #BB6688; font-weight: bold">%s</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (expected, computed)
        <span style="color: #008000; font-weight: bold">print</span> msg
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed) <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
It is important with a sufficiently small <code>eps_r</code> tolerance for the
asymptotic value to be accurate (using <code>eps_r=1E-3</code> leads to a value
0.92 at \( t=T \) instead of 0.994 when <code>eps_r=1E-5</code>).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<b>e)</b>
Perform experiments with Newton and Picard iteration for
the models <a href="#mjx-eqn-89">(89)</a>
and \eqref{nonlin:exer:logistic:gen:r2}. See how sensitive
the number of iterations is to \( \Delta t \) and \( p \).

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_2_7" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_2_7">

<p>
Appropriate code is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scitools.std</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">demo</span>():
    T <span style="color: #666666">=</span> <span style="color: #666666">12</span>
    p <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>
    <span style="color: #008000; font-weight: bold">try</span>:
        dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">1</span>])
        eps_r <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">2</span>])
        omega <span style="color: #666666">=</span> <span style="color: #008000">float</span>(sys<span style="color: #666666">.</span>argv[<span style="color: #666666">3</span>])
    <span style="color: #008000; font-weight: bold">except</span>:
        dt <span style="color: #666666">=</span> <span style="color: #666666">0.8</span>
        eps_r <span style="color: #666666">=</span> <span style="color: #666666">1E-3</span>
        omega <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    N <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span><span style="color: #008000">float</span>(dt)))

    u_FE <span style="color: #666666">=</span> FE_logistic(p, <span style="color: #666666">0.1</span>, dt, N)
    u_BE31, iter_BE31 <span style="color: #666666">=</span> BE_logistic(p, <span style="color: #666666">0.1</span>, dt, N,
                                    <span style="color: #BA2121">&#39;Picard1&#39;</span>, eps_r, omega)
    u_BE3, iter_BE3 <span style="color: #666666">=</span> BE_logistic(p, <span style="color: #666666">0.1</span>, dt, N,
                                  <span style="color: #BA2121">&#39;Picard&#39;</span>, eps_r, omega)
    u_BE4, iter_BE4 <span style="color: #666666">=</span> BE_logistic(p, <span style="color: #666666">0.1</span>, dt, N,
                                  <span style="color: #BA2121">&#39;Newton&#39;</span>, eps_r, omega)
    u_CN <span style="color: #666666">=</span> CN_logistic(p, <span style="color: #666666">0.1</span>, dt, N)

    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Picard mean no of iterations (dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">):&#39;</span> <span style="color: #666666">%</span> dt, \ 
          <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(mean(iter_BE3)))
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Newton mean no of iterations (dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">):&#39;</span> <span style="color: #666666">%</span> dt, \ 
          <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(mean(iter_BE4)))

    t <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, dt<span style="color: #666666">*</span>N, N<span style="color: #666666">+1</span>)
    plot(t, u_FE, t, u_BE3, t, u_BE31, t, u_BE4, t, u_CN,
         legend<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;FE&#39;</span>, <span style="color: #BA2121">&#39;BE Picard&#39;</span>, <span style="color: #BA2121">&#39;BE Picard1&#39;</span>, <span style="color: #BA2121">&#39;BE Newton&#39;</span>, <span style="color: #BA2121">&#39;CN gm&#39;</span>],
         title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, eps=</span><span style="color: #BB6688; font-weight: bold">%.0E</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dt, eps_r), xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;t&#39;</span>, ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;u&#39;</span>,
         legend_loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;lower right&#39;</span>)
    filestem <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;logistic_N</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">_eps</span><span style="color: #BB6688; font-weight: bold">%03d</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (N, log10(eps_r))
    savefig(filestem <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;_u.png&#39;</span>)
    savefig(filestem <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;_u.pdf&#39;</span>)
    figure()
    plot(<span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(iter_BE3)<span style="color: #666666">+1</span>), iter_BE3, <span style="color: #BA2121">&#39;r-o&#39;</span>,
         <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #008000">len</span>(iter_BE4)<span style="color: #666666">+1</span>), iter_BE4, <span style="color: #BA2121">&#39;b-o&#39;</span>,
         legend<span style="color: #666666">=</span>[<span style="color: #BA2121">&#39;Picard&#39;</span>, <span style="color: #BA2121">&#39;Newton&#39;</span>],
         title<span style="color: #666666">=</span><span style="color: #BA2121">&#39;dt=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, eps=</span><span style="color: #BB6688; font-weight: bold">%.0E</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (dt, eps_r),
         axis<span style="color: #666666">=</span>[<span style="color: #666666">1</span>, N<span style="color: #666666">+1</span>, <span style="color: #666666">0</span>, <span style="color: #008000">max</span>(iter_BE3 <span style="color: #666666">+</span> iter_BE4)<span style="color: #666666">+1</span>],
         xlabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;Time level&#39;</span>, ylabel<span style="color: #666666">=</span><span style="color: #BA2121">&#39;No of iterations&#39;</span>)
    savefig(filestem <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;_iter.png&#39;</span>)
    savefig(filestem <span style="color: #666666">+</span> <span style="color: #BA2121">&#39;_iter.pdf&#39;</span>)
</pre></div>
<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->

<p>
<!-- ===== Exercise: Derive a relaxation formula ===== -->

<p>
Filename: <code>logistic_p</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:Newton:problems1">Problem 3: Experience the behavior of Newton's method</h2>

<p>
The program <a href="http://tinyurl.com/nm5587k/nonlin/Newton_demo.py" target="_self"><tt>Newton_demo.py</tt></a> illustrates
graphically each step in Newton's method and is run like

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; python Newton_demo.py f dfdx x0 xmin xmax
</pre></div>
<p>
Use this program to investigate potential
problems with Newton's method when solving \( e^{-0.5x^2}\cos (\pi x)=0 \).
Try a starting point \( x_0=0.8 \) and \( x_0=0.85 \) and watch the different
behavior. Just run

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt;  python Newton_demo.py &#39;0.2 + exp(-0.5*x**2)*cos(pi*x)&#39; \ 
           &#39;-x*exp(-x**2)*cos(pi*x) - pi*exp(-x**2)*sin(pi*x)&#39; \ 
           0.85 -3 3
</pre></div>
<p>
and repeat with 0.85 replaced by 0.8.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:vib:Jacobian">Problem 4: Compute the Jacobian of a \( 2\times 2 \) system</h2>

<p>
Write up the system <a href="._nonlin-sol001.html#mjx-eqn-18">(18)</a>-<a href="._nonlin-sol001.html#mjx-eqn-19">(19)</a> in the form \( F(u)=0 \), \( F=(F_0,F_1) \), \( u=(u_0,u_1) \),
and compute the Jacobian \( J_{i,j}=\partial F_i/\partial u_j \).

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:vib:geometric:mean">Problem 5: Solve nonlinear equations arising from a vibration ODE</h2>

<p>
Consider a nonlinear vibration problem

$$
\begin{equation}
mu^{\prime\prime} + bu^{\prime}|u^{\prime}| + s(u) = F(t),
\tag{90}
\end{equation}
$$

where \( m>0 \) is a constant, \( b\geq 0 \) is a constant, \( s(u) \) a possibly
nonlinear function of \( u \), and \( F(t) \) is a prescribed function. Such
models arise from Newton's second law of motion in mechanical
vibration problems where \( s(u) \) is a spring or restoring force,
\( mu^{\prime\prime} \) is mass times acceleration, and
\( bu^{\prime}|u^{\prime}| \) models water or air drag.

<p>
<b>a)</b>
Rewrite the equation for \( u \) as a system of two first-order ODEs, and
discretize this system by a Crank-Nicolson (centered difference)
method. With \( v=u^\prime \), we get a nonlinear term
\( v^{n+\frac{1}{2}}|v^{n+\frac{1}{2}}| \). Use a geometric
average for \( v^{n+\frac{1}{2}} \).

<p>
<b>b)</b>
Formulate a Picard iteration method to solve the system of nonlinear
algebraic equations.

<p>
<b>c)</b>
Explain how to apply Newton's method to solve the nonlinear equations
at each time level. Derive expressions for the Jacobian and the
right-hand side in each Newton iteration.

<p>
<!-- 2DO: b) Newmark scheme -->
<!-- derive it logically and connect it to the centered diff scheme -->
<!-- ma + bv|v| + s(u) = F(t), v'=a, u'=v (staggered is natural, -->
<!-- v at n+1/2 and a and u at n). Should be in vib first -->

<p>
Filename: <code>nonlin_vib</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:products:arith:mean">Exercise 6: Find the truncation error of arithmetic mean of products</h2>

<p>
In the section <a href="._nonlin-sol003.html#nonlin:pdelevel:Picard:CN">Crank-Nicolson discretization</a> we introduce alternative
arithmetic means of a product. Say the product is \( P(t)Q(t) \) evaluated
at \( t=t_{n+\frac{1}{2}} \). The exact value is

$$ [PQ]^{n+\frac{1}{2}} = P^{n+\frac{1}{2}}Q^{n+\frac{1}{2}} $$

There are two obvious candidates for evaluating \( [PQ]^{n+\frac{1}{2}} \)
as a mean of values of \( P \) and \( Q \) at \( t_n \) and \( t_{n+1} \). Either
we can take the arithmetic mean of each factor \( P \) and \( Q \),

$$
\begin{equation}
[PQ]^{n+\frac{1}{2}} \approx \frac{1}{2}(P^n + P^{n+1})\frac{1}{2}(Q^n + Q^{n+1}),
\tag{91}
\end{equation}
$$

or we can take the arithmetic mean of the product \( PQ \):

$$
\begin{equation}
[PQ]^{n+\frac{1}{2}} \approx \frac{1}{2}(P^nQ^n + P^{n+1}Q^{n+1})\tp
\tag{92}
\end{equation}
$$

<p>
The arithmetic average
of \( P(t_{n+\frac{1}{2}}) \) is \( \Oof{\Delta t^2} \):

$$ P(t_{n+\frac{1}{2}}) = \frac{1}{2}(P^n + P^{n+1}) +\Oof{\Delta t^2}\tp$$

A fundamental question is whether <a href="#mjx-eqn-91">(91)</a>
and <a href="#mjx-eqn-92">(92)</a> have different
orders of accuracy in \( \Delta t = t_{n+1}-t_n \). To investigate
this question, expand quantities at \( t_{n+1} \) and \( t_n \) in
Taylor series around \( t_{n+\frac{1}{2}} \), and subtract the true
value \( [PQ]^{n+\frac{1}{2}} \) from the approximations
<a href="#mjx-eqn-91">(91)</a> and
<a href="#mjx-eqn-92">(92)</a> to see what the
order of the error terms are.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_6_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_6_1">

<p>
You may explore <code>sympy</code> for carrying out the tedious calculations.
A general Taylor series expansion of \( P(t+\frac{1}{2}\Delta t) \) around \( t \)
involving just a general function \( P(t) \) can be
created as follows:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> t, dt <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;t dt&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> P <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;P&#39;</span>, cls<span style="color: #666666">=</span>Function)
<span style="color: #666666">&gt;&gt;&gt;</span> P(t)<span style="color: #666666">.</span>series(t, <span style="color: #666666">0</span>, <span style="color: #666666">4</span>)
P(<span style="color: #666666">0</span>) <span style="color: #666666">+</span> t<span style="color: #666666">*</span>Subs(Derivative(P(_x), _x), (_x,), (<span style="color: #666666">0</span>,)) <span style="color: #666666">+</span>
t<span style="color: #666666">**2*</span>Subs(Derivative(P(_x), _x, _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/2</span> <span style="color: #666666">+</span>
t<span style="color: #666666">**3*</span>Subs(Derivative(P(_x), _x, _x, _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/6</span> <span style="color: #666666">+</span> O(t<span style="color: #666666">**4</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> P_p <span style="color: #666666">=</span> P(t)<span style="color: #666666">.</span>series(t, <span style="color: #666666">0</span>, <span style="color: #666666">4</span>)<span style="color: #666666">.</span>subs(t, dt<span style="color: #666666">/2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> P_p
P(<span style="color: #666666">0</span>) <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>Subs(Derivative(P(_x), _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/2</span> <span style="color: #666666">+</span>
dt<span style="color: #666666">**2*</span>Subs(Derivative(P(_x), _x, _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/8</span> <span style="color: #666666">+</span>
dt<span style="color: #666666">**3*</span>Subs(Derivative(P(_x), _x, _x, _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/48</span> <span style="color: #666666">+</span> O(dt<span style="color: #666666">**4</span>)
</pre></div>
<p>
The error of the arithmetic mean, \( \frac{1}{2}(P(-\frac{1}{2}\Delta t)
+ P(-\frac{1}{2}\Delta t)) \) for \( t=0 \) is then

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> P_m <span style="color: #666666">=</span> P(t)<span style="color: #666666">.</span>series(t, <span style="color: #666666">0</span>, <span style="color: #666666">4</span>)<span style="color: #666666">.</span>subs(t, <span style="color: #666666">-</span>dt<span style="color: #666666">/2</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> mean <span style="color: #666666">=</span> Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>)<span style="color: #666666">*</span>(P_m <span style="color: #666666">+</span> P_p)
<span style="color: #666666">&gt;&gt;&gt;</span> error <span style="color: #666666">=</span> simplify(expand(mean) <span style="color: #666666">-</span> P(<span style="color: #666666">0</span>))
<span style="color: #666666">&gt;&gt;&gt;</span> error
dt<span style="color: #666666">**2*</span>Subs(Derivative(P(_x), _x, _x), (_x,), (<span style="color: #666666">0</span>,))<span style="color: #666666">/8</span> <span style="color: #666666">+</span> O(dt<span style="color: #666666">**4</span>)
</pre></div>
<p>
Use these examples to investigate the error of
<a href="#mjx-eqn-91">(91)</a> and
<a href="#mjx-eqn-92">(92)</a> for \( n=0 \). (Choosing \( n=0 \)
is necessary for making the expressions too complicated for <code>sympy</code>,
but there is of course no lack of generality by using \( n=0 \) rather
than an arbitrary \( n \) - the main point is the product and addition
of Taylor series.)

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>product_arith_mean</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:Newton:linear">Problem 7: Newton's method for linear problems</h2>

<p>
Suppose we have a linear system \( F(u) = Au- b=0 \). Apply Newton's method
to this system, and show that the method converges in one iteration.
Filename: <code>Newton_linear</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:1D:1pu2:fem">Exercise 8: Discretize a 1D problem with a nonlinear coefficient</h2>

<p>
We consider the problem

$$
\begin{equation}
((1 + u^2)u^{\prime})^{\prime} = 1,\quad x\in (0,1),\quad u(0)=u(1)=0\tp
\tag{93}
\end{equation}
$$

<p>
<b>a)</b>
Discretize <a href="#mjx-eqn-93">(93)</a> by a centered
finite difference method on a uniform mesh.

<p>
<b>b)</b>
Discretize <a href="#mjx-eqn-93">(93)</a> by a finite
element method with P1 of equal length.
Use the Trapezoidal method to compute all integrals.
Set up the resulting matrix system in symbolic form such that the
equations can be compared with those in a).

<p>
Filename: <code>nonlin_1D_coeff_discretize</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:1D:1pu2:PicardNewton">Exercise 9: Linearize a 1D problem with a nonlinear coefficient</h2>

<p>
We have a two-point boundary value problem

$$
\begin{equation}
((1 + u^2)u^{\prime})^{\prime} = 1,\quad x\in (0,1),\quad u(0)=u(1)=0\tp
\tag{94}
\end{equation}
$$

<p>
<b>a)</b>
Construct a Picard iteration method for <a href="#mjx-eqn-94">(94)</a>
without discretizing in space.

<p>
<b>b)</b>
Apply Newton's method to <a href="#mjx-eqn-94">(94)</a>
without discretizing in space.

<p>
<b>c)</b>
Discretize <a href="#mjx-eqn-94">(94)</a> by a centered finite
difference scheme. Construct a Picard method for the resulting
system of nonlinear algebraic equations.

<p>
<b>d)</b>
Discretize <a href="#mjx-eqn-94">(94)</a> by a centered finite
difference scheme. Define the system of nonlinear algebraic equations,
calculate the Jacobian, and set up Newton's method for solving the system.

<p>
Filename: <code>nonlin_1D_coeff_linearize</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:1D:fu:discretize:fd">Problem 10: Finite differences for the 1D Bratu problem</h2>

<p>
We address the so-called Bratu problem

$$
\begin{equation}
u^{\prime\prime} + \lambda e^u=0,\quad x\in (0,1),\quad u(0)=u(1)=0,
\tag{95}
\end{equation}
$$

where \( \lambda \) is a given parameter and \( u \) is a function of \( x \).
This is a widely used model problem for studying numerical
methods for nonlinear differential equations.
The problem <a href="#mjx-eqn-95">(95)</a> has an
exact solution

$$ \uex(x) = -2\ln\left(\frac{\cosh((x-\half)\theta/2)}{\cosh(\theta/4)}\right),$$

where \( \theta \) solves

$$ \theta = \sqrt{2\lambda}\cosh(\theta/4)\tp$$

There are two solutions of <a href="#mjx-eqn-95">(95)</a> for
\( 0 < \lambda < \lambda_c \) and no solution for \( \lambda >\lambda_c \).
For \( \lambda = \lambda_c \) there is one unique solution. The critical
value \( \lambda_c \) solves

$$ 1 = \sqrt{2\lambda_c}\frac{1}{4}\sinh(\theta(\lambda_c)/4)\tp$$

A numerical value is \( \lambda_c = 3.513830719 \).

<p>
<b>a)</b>
Discretize <a href="#mjx-eqn-95">(95)</a> by a
centered finite difference method.

<p>
<b>b)</b>
Set up the nonlinear equations \( F_i(u_0,u_1,\ldots,u_{N_x})=0 \)
from a). Calculate the associated Jacobian.

<p>
<b>c)</b>
Implement a solver that can compute \( u(x) \) using Newton's method.
Plot the error as a function of \( x \) in each iteration.

<p>
<b>d)</b>
Investigate whether Newton's method gives second-order convergence
by computing
\( || \uex - u||/||\uex - u^{-}||^2 \)
in each iteration, where \( u \) is solution in the current iteration and
\( u^{-} \) is the solution in the previous iteration.

<p>
Filename: <code>nonlin_1D_Bratu_fd</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:fu:fem:int">Problem 11: Integrate functions of finite element expansions</h2>

<p>
We shall investigate integrals on the form

$$
\begin{equation}
\int_0^L f(\sum_ku_k\basphi_k(x))\basphi_i(x)\dx,
\tag{96}
\end{equation}
$$

where \( \basphi_i(x) \) are P1 finite element basis functions and \( u_k \)
are unknown coefficients, more precisely the values of the unknown
function \( u \) at nodes \( \xno{k} \). We introduce a node numbering that
goes from left to right and also that all cells have
the same length \( h \). Given \( i \), the integral
only gets contributions from \( [\xno{i-1},\xno{i+1}] \). On this
interval \( \basphi_k(x)=0 \) for \( k < i-1 \) and \( k>i+1 \), so only three
basis functions will contribute:

$$
\sum_k u_k\basphi_k(x) = u_{i-1}\basphi_{i-1}(x) +
u_{i}\basphi_{i}(x) + u_{i+1}\basphi_{i+1}(x)\tp
$$

The integral <a href="#mjx-eqn-96">(96)</a> now takes the
simplified form

$$
\int_{\xno{i-1}}^{\xno{i+1}}
f(u_{i-1}\basphi_{i-1}(x) +
u_{i}\basphi_{i}(x) + u_{i+1}\basphi_{i+1}(x))\basphi_i(x)\dx\tp
$$

Split this integral in two integrals over cell L (left),
\( [\xno{i-1},\xno{i}] \), and cell R (right), \( [\xno{i},\xno{i+1}] \). Over
cell L, \( u \) simplifies to \( u_{i-1}\basphi_{i-1} + u_{i}\basphi_{i} \)
(since \( \basphi_{i+1}=0 \) on this cell), and over cell R, \( u \)
simplifies to \( u_{i}\basphi_{i} + u_{i+1}\basphi_{i+1} \).  Make a
<code>sympy</code> program that can compute the integral and write it out as a
difference equation. Give the \( f(u) \) formula on the command line.
Try out \( f(u)=u^2, \sin u, \exp u \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_11_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_11_1">

<p>
Introduce symbols <code>u_i</code>, <code>u_im1</code>, and <code>u_ip1</code> for \( u_i \), \( u_{i-1} \),
and \( u_{i+1} \), respectively, and similar symbols for \( x_i \), \( x_{i-1} \),
and \( x_{i+1} \). Find formulas for the basis functions on each of the
two cells, make expressions for \( u \) on the two cells, integrate over
each cell, expand the answer and simplify. You can ask <code>sympy</code> for
LaTeX code and render it either by creating a LaTeX document and
compiling it to a PDF document or by using
<a href="http://latex.codecogs.com" target="_self"><tt>http://latex.codecogs.com</tt></a> to display LaTeX formulas in a web
page. Here are some appropriate Python statements
for the latter purpose:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">...</span>
<span style="color: #408080; font-style: italic"># expr_i holdes the integral as a sympy expression</span>
latex_code <span style="color: #666666">=</span> latex(expr_i, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;plain&#39;</span>)
<span style="color: #408080; font-style: italic"># Replace u_im1 sympy symbol name by latex symbol u_{i-1}</span>
latex_code <span style="color: #666666">=</span> latex_code<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;im1&#39;</span>, <span style="color: #BA2121">&#39;{i-1}&#39;</span>)
<span style="color: #408080; font-style: italic"># Replace u_ip1 sympy symbol name by latex symbol u_{i+1}</span>
latex_code <span style="color: #666666">=</span> latex_code<span style="color: #666666">.</span>replace(<span style="color: #BA2121">&#39;ip1&#39;</span>, <span style="color: #BA2121">&#39;{i+1}&#39;</span>)
<span style="color: #408080; font-style: italic"># Escape (quote) latex_code so it can be sent as HTML text</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">cgi</span>
html_code <span style="color: #666666">=</span> cgi<span style="color: #666666">.</span>escape(latex_code)
<span style="color: #408080; font-style: italic"># Make a file with HTML code for displaying the LaTeX formula</span>
f <span style="color: #666666">=</span> <span style="color: #008000">open</span>(<span style="color: #BA2121">&#39;tmp.html&#39;</span>, <span style="color: #BA2121">&#39;w&#39;</span>)
<span style="color: #408080; font-style: italic"># Include an image that can be clicked on to yield a new</span>
<span style="color: #408080; font-style: italic"># page with an interactive editor and display area where the</span>
<span style="color: #408080; font-style: italic"># formula can be further edited</span>
text <span style="color: #666666">=</span> <span style="color: #BA2121">&quot;&quot;&quot;</span>
<span style="color: #BA2121">&lt;a href=&quot;http://www.codecogs.com/eqnedit.php?latex=</span><span style="color: #BB6688; font-weight: bold">%(html_code)s</span><span style="color: #BA2121">&quot;</span>
<span style="color: #BA2121"> target=&quot;_blank&quot;&gt;</span>
<span style="color: #BA2121">&lt;img src=&quot;http://latex.codecogs.com/gif.latex?</span><span style="color: #BB6688; font-weight: bold">%(html_code)s</span><span style="color: #BA2121">&quot;</span>
<span style="color: #BA2121"> title=&quot;</span><span style="color: #BB6688; font-weight: bold">%(latex_code)s</span><span style="color: #BA2121">&quot;/&gt;</span>
<span style="color: #BA2121">&lt;/a&gt;</span>
<span style="color: #BA2121"> &quot;&quot;&quot;</span> <span style="color: #666666">%</span> <span style="color: #008000">vars</span>()
f<span style="color: #666666">.</span>write(text)
f<span style="color: #666666">.</span>close()
</pre></div>
<p>
The formula is displayed by loading <code>tmp.html</code> into a web browser.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>fu_fem_int</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:1D:fu:discretize:fe">Problem 12: Finite elements for the 1D Bratu problem</h2>

<p>
We address the same 1D Bratu problem as described in
<a href="#nonlin:exer:1D:fu:discretize:fd">Problem 10: Finite differences for the 1D Bratu problem</a>.

<p>
<b>a)</b>
Discretize (<a href="#nonlin:exer:1D:fu:discretize:fe">Problem 12: Finite elements for the 1D Bratu problem</a>) by a finite element
method using a uniform mesh with P1 elements. Use a group
finite element method for the \( e^u \) term.

<p>
<b>b)</b>
Set up the nonlinear equations \( F_i(u_0,u_1,\ldots,u_{N_x})=0 \)
from a). Calculate the associated Jacobian.

<p>
Filename: <code>nonlin_1D_Bratu_fe</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:1D:heat:nonlinear:fdm">Exercise 13: Discretize a nonlinear 1D heat conduction PDE by finite differences</h2>

<p>
We address the 1D heat conduction PDE

$$ \varrho c(T) T_t = (k(T)T_x)_x,$$

for \( x\in [0,L] \),
where \( \varrho \) is the density of the solid material, \( c(T) \) is
the heat capacity, \( T \) is the temperature, and \( k(T) \) is the
heat conduction coefficient. \( T(x,0)=I(x) \), and ends are
subject to a cooling law:

$$ k(T)T_x|_{x=0} = h(T)(T-T_s),\quad -k(T)T_x|_{x=L}=h(T)(T-T_s),$$

where \( h(T) \) is a heat transfer coefficient and \( T_s \) is the
given surrounding temperature.

<p>
<b>a)</b>
Discretize this PDE in time using either a
Backward Euler or Crank-Nicolson scheme.

<p>
<b>b)</b>
Formulate a Picard iteration method for the time-discrete problem
(i.e., an iteration method before discretizing in space).

<p>
<b>c)</b>
Formulate a Newton method for the time-discrete problem in b).

<p>
<b>d)</b>
Discretize the PDE by a finite difference method in space.
Derive the matrix and right-hand side of a Picard iteration method applied
to the space-time discretized PDE.

<p>
<b>e)</b>
Derive the matrix and right-hand side of a Newton method applied
to the discretized PDE in d).

<p>
Filename: <code>nonlin_1D_heat_FD</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:dD:nonlinear:usymbols">Exercise 14: Use different symbols for different approximations of the solution</h2>

<p>
The symbol \( u \) has several meanings, depending on the context, as
briefly mentioned in the section <a href="._nonlin-sol005.html#nonlin:alglevel:dD:fe">Finite element discretization</a>.
Go through the derivation of the Picard iteration method in
that section and use different symbols for all the different
approximations of \( u \):

<ul>
 <li> \( \uex(\x,t) \) for the exact solution of the PDE problem</li>
 <li> \( \uex(\x)^n \) for the exact solution after time discretization</li>
 <li> \( u^n(\x) \) for the spatially discrete solution \( \sum_jc_j\baspsi_j \)</li>
 <li> \( u^{n,k} \) for approximation in Picard/Newton iteration no \( k \)
   to \( u^n(\x) \)</li>
</ul>

Filename: <code>nonlin_heat_FE_usymbols</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:dD:heat:nonlinear:c:a">Exercise 15: Derive Picard and Newton systems from a variational form</h2>

<p>
We study the multi-dimensional heat conduction PDE

$$ \varrho c(T) T_t = \nabla\cdot (k(T)\nabla T)$$

in a spatial domain \( \Omega \), with a nonlinear Robin boundary condition

$$ -k(T)\frac{\partial T}{\partial n} = h(T)(T-T_s(t)),$$

at the boundary \( \partial\Omega \).
The primary unknown is the temperature \( T \), \( \varrho \) is the density
of the solid material, \( c(T) \) is the heat capacity, \( k(T) \) is
the heat conduction, \( h(T) \) is a heat transfer coefficient, and
\( T_s(T) \) is a possibly time-dependent temperature of the surroundings.

<p>
<b>a)</b>
Use a Backward Euler or Crank-Nicolson time discretization and
derive the variational form for the spatial problem to be solved
at each time level.

<p>
<b>b)</b>
Define a Picard iteration method from the variational form at
a time level.

<p>
<b>c)</b>
Derive expressions for the matrix and the right-hand side of the
equation system that arises from applying Newton's method to
the variational form at a time level.

<p>
<b>d)</b>
Apply the Backward Euler or Crank-Nicolson scheme in time first.
Derive a Newton method at the PDE level. Make a variational
form of the resulting PDE at a time level.

<p>
Filename: <code>nonlin_heat_FE</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:1D:heat:nonlinear:c:a">Exercise 16: Derive algebraic equations for nonlinear 1D heat conduction</h2>

<p>
We consider the same problem as in <a href="#nonlin:exer:dD:heat:nonlinear:c:a">Exercise 15: Derive Picard and Newton systems from a variational form</a>, but restricted to one space dimension: \( \Omega = [0,L] \).
Simplify the boundary condition to \( T_x=0 \) (i.e., \( h(T)=0 \)).
Use a uniform finite element mesh of P1 elements, the group
finite element method, and the Trapezoidal
rule for integration at the nodes to derive symbolic expressions for
the algebraic equations arising from this diffusion problem.
Filename: <code>nonlin_1D_heat_FE</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:grad:pow:term">Exercise 17: Differentiate a highly nonlinear term</h2>

<p>
The operator \( \nabla\cdot(\dfc(u)\nabla u) \) with
\( \dfc(u) = |\nabla u|^q \) appears in several physical problems,
especially flow of Non-Newtonian fluids. The expression \( |\nabla u| \)
is defined as the Euclidean norm of a vector:
\( |\nabla u|^2 = \nabla u \cdot \nabla u \).
In a Newton method one
has to carry out the differentiation \( \partial\dfc(u)/\partial c_j \),
for \( u=\sum_kc_k\baspsi_k \). Show that

$$ {\partial\over\partial u_j} |\nabla u|^q =
q|\nabla  u|^{q-2}\nabla u\cdot
\nabla\baspsi_j\tp $$

<p>
<!-- --- begin solution of exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_1" style="font-size: 80%;"></a>
<b>Solution.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_1">

$$
\begin{align*}
\frac{\partial }{\partial c_j}|\nabla u |^q &=
\frac{\partial }{\partial c_j}(\nabla u\cdot \nabla u )^{\tfrac{q}{2}}
= \frac{q}{2} (\nabla u\cdot \nabla u )^{\tfrac{q}{2}-1}
\frac{\partial }{\partial c_j}(\nabla u\cdot \nabla u )\\ 
&=\frac{q}{2} |\nabla u |^{q-2}(\frac{\partial }{\partial c_j}(\nabla u)
\cdot \nabla u + \nabla u \cdot\frac{\partial }{\partial c_j}(\nabla u))\\ 
&=q|\nabla u |^{q-2}(\nabla u \cdot \nabla \frac{\partial u}{\partial c_j})
=q|\nabla u |^{q-2}(\nabla u \cdot \nabla\psi_j)
\end{align*}
$$

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end solution of exercise --- -->
Filename: <code>nonlin_differentiate</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:2D:heat:nonlinear:fd">Exercise 18: Crank-Nicolson for a nonlinear 3D diffusion equation</h2>

<p>
Redo the section <a href="._nonlin-sol005.html#nonlin:alglevel:dD:fd">Finite difference discretization</a> when a Crank-Nicolson scheme
is used to discretize the equations in time and the problem is
formulated for three spatial dimensions.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_1">

<p>
Express the Jacobian as \( J_{i,j,k,r,s,t} = \partial F_{i,j,k}/\partial u_{r,s,t} \) and observe, as in the 2D case, that \( J_{i,j,k,r,s,t} \) is very sparse:
\( J_{i,j,k,r,s,t}\neq 0 \) only for \( r=i\pm i \), \( s=j\pm 1 \), and \( t=k\pm 1 \)
as well as \( r=i \), \( s=j \), and \( t=k \).

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>nonlin_heat_FD_CN_2D</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:sparsity:Jacobian">Exercise 19: Find the sparsity of the Jacobian</h2>

<p>
Consider a typical nonlinear Laplace term like
\( \nabla\cdot\dfc(u)\nabla u \) discretized by centered finite differences.
Explain why the Jacobian corresponding to this term has the same
sparsity pattern as the matrix associated with the corresponding linear
term \( \dfc\nabla^2 u \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_19_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_19_1">

<p>
Set up the unknowns that enter the difference equation at a
point \( (i,j) \) in 2D or \( (i,j,k) \) in 3D, and identify the
nonzero entries of the Jacobian that can arise from such a type
of difference equation.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>nonlin_sparsity_Jacobian</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="nonlin:exer:continuation:1DnNflow">Problem 20: Investigate a 1D problem with a continuation method</h2>

<p>
Flow of a pseudo-plastic power-law fluid between two flat plates can be
modeled by

$$ \frac{d}{dx}\left(\mu_0\left\vert\frac{du}{dx}\right\vert^{n-1}
\frac{du}{dx}\right) = -\beta,\quad u^{\prime}(0)=0,\ u(H) = 0,$$

where \( \beta>0 \) and \( \mu_0>0 \) are constants.
A target value of \( n \) may be \( n=0.2 \).

<p>
<b>a)</b>
Formulate a Picard iteration method directly for the differential
equation problem.

<p>
<b>b)</b>
Perform a finite difference discretization of the problem in
each Picard iteration. Implement a solver that can compute \( u \)
on a mesh. Verify that the solver gives an exact solution for \( n=1 \)
on a uniform mesh regardless of the cell size.

<p>
<b>c)</b>
Given a sequence of decreasing \( n \) values, solve the problem for each
\( n \) using the solution for the previous \( n \) as initial guess for
the Picard iteration. This is called a continuation method.
Experiment with \( n=(1,0.6,0.2) \) and \( n=(1,0.9,0.8,\ldots,0.2) \)
and make a table of the number of Picard iterations versus \( n \).

<p>
<b>d)</b>
Derive a Newton method at the differential equation level and
discretize the resulting linear equations in each Newton iteration
with the finite difference method.

<p>
<b>e)</b>
Investigate if Newton's method has better convergence properties than
Picard iteration, both in combination with a continuation method.

<p>
<!-- --- end exercise --- -->

<h1 id="___sec78">Bibliography </h1>

<p>
<!-- begin bibliography -->

<ol>
 <li> <div id="Kelley_1995"></div> <b>C. T. Kelley</b>. 
    <em>Iterative Methods for Linear and Nonlinear Equations</em>,
    SIAM,
    1995.</li>
 <li> <div id="Mortensen_et_al_2011"></div> <b>M. Mortensen, H. P. Langtangen and G. N. Wells</b>. 
    A FEniCS-Based Programming Framework for Modeling Turbulent Flow by the Reynolds-Averaged Navier-Stokes Equations,
    <em>Advances in Water Resources</em>,
    34(9),
    <a href="http://dx.doi.org/10.1016/j.advwatres.2011.02.013" target="_self">doi: 10.1016/j.advwatres.2011.02.013</a>,
    2011.</li>
</ol>

<!-- end bibliography -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._nonlin-sol005.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._nonlin-sol007.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

