<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Scaling of differential equations">
<meta name="keywords" content="scaling,non-dimensionalization,dimensionless variable,units,base unit,length,mass,time,dimension of physical quantities,units US,units British,units conversion,units software,multiple software runs,web interface (Parampool),graphical web interface,exponential decay,dimensionless variable,characteristic time,e-folding time,memoize function,dimensionless number,dimensionless number,dimensionless number,logistic equation,dimensionless number,frequency,frequency, angular,period (of oscillations),radians,angular frequency,quality factor $Q$,phase shift,dimensionless number,Peclet number,dimensionless number,Reynolds number,Navier-Stokes equations,dimensionless number,Reynolds number,Reynolds number,low Reynolds number flow,Stokes problem,Stokes' flow,Froude number,creeping flow,Strouhal number,vortex shedding,Euler number,Weber number,forced convection,Peclet number,Reynolds number,free convection,Grashof number,Reynolds number,Peclet number,Eckert number,Nusselt number">

<title>Scaling of differential equations</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Dimensions and units', 1, 'scale:dimunit', 'scale:dimunit'),
              ('Base units and dimensions', 2, None, '___sec1'),
              ('Prefixes', 3, None, '___sec2'),
              ('SI vs US/British systems', 3, None, '___sec3'),
              ('PhysicalQuantity: object for computing with units',
               2,
               'scale:PQ',
               'scale:PQ'),
              ('Parampool: user interfaces with automatic unit conversion',
               2,
               'scale:parampool',
               'scale:parampool'),
              ('Example application', 3, None, '___sec6'),
              ('Pool', 3, None, '___sec7'),
              ('Fetching pool data and computing $s$', 3, None, '___sec8'),
              ('Reading command-line options', 3, None, '___sec9'),
              ('Setting default values in a file', 3, None, '___sec10'),
              ('Specifying multiple values of input parameters',
               3,
               None,
               '___sec11'),
              ('Generating a graphical user interface', 3, None, '___sec12'),
              ('Exponential decay', 1, 'sec:scale:decay', 'sec:scale:decay'),
              ('Example: Population dynamics', 3, None, '___sec14'),
              ('Example: Decay of pressure with altitude',
               3,
               None,
               '___sec15'),
              ('The technical steps of the scaling procedure',
               2,
               'sec:scale:decay:steps',
               'sec:scale:decay:steps'),
              ('Step 1: Identify independent and dependent variables',
               3,
               None,
               '___sec17'),
              ('Step 2: Make independent and dependent variables dimensionless',
               3,
               None,
               '___sec18'),
              ('Step 3: Derive the model involving only dimensionless variables',
               3,
               None,
               '___sec19'),
              ('Step 4: Make each term dimensionless', 3, None, '___sec20'),
              ('Step 5: Estimate the scales', 3, None, '___sec21'),
              ('Making software utilizing the dimensionless model',
               2,
               'sec:scale:decay:prog',
               'sec:scale:decay:prog'),
              ('Software for the original problem with dimensions',
               3,
               None,
               '___sec23'),
              ('A plain solution', 3, None, '___sec24'),
              ('Simplifying the implementation with joblib',
               3,
               None,
               '___sec25'),
              ('Scaling a generalized problem',
               2,
               'sec:scale:decay:body',
               'sec:scale:decay:body'),
              ('Exact solution', 3, None, '___sec27'),
              ('Theory', 3, None, '___sec28'),
              ('Software', 3, None, '___sec29'),
              ('Variable coefficients',
               2,
               'sec:scale:decay:jump',
               'sec:scale:decay:jump'),
              ('Scaling a cooling problem with constant surroundings',
               2,
               'scale:decay:cooling:const',
               'scale:decay:cooling:const'),
              ('Scaling a cooling problem with time-dependent surroundings',
               2,
               'scale:decay:cooling:osc',
               'scale:decay:cooling:osc'),
              ('Exact solution', 3, None, '___sec33'),
              ('Scaling', 3, None, '___sec34'),
              ('Software', 3, None, '___sec35'),
              ('Discussion of the time scale', 3, None, '___sec36'),
              ('Scaling a nonlinear ODE',
               2,
               'sec:scale:decay:nonlinear',
               'sec:scale:decay:nonlinear'),
              ('ODE systems for spreading of diseases', 2, None, '___sec38'),
              ('SIR model', 3, None, '___sec39'),
              ('SIRV model with finite immunity', 3, None, '___sec40'),
              ('Michaelis-Menten kinetics for biochemical reactions',
               2,
               'scale:MMK',
               'scale:MMK'),
              ('Classical analysis', 3, None, '___sec42'),
              ('Dimensionless ODE system', 3, None, '___sec43'),
              ('Determining scales', 3, None, '___sec44'),
              ('Analysis of the scaled system', 3, None, '___sec45'),
              ('Vibration problems', 1, 'sec:scale:vib', 'sec:scale:vib'),
              ('Undamped vibrations without forcing',
               2,
               'sec:scale:vib:undamped',
               'sec:scale:vib:undamped'),
              ('The first technical steps of scaling', 3, None, '___sec48'),
              ('The exact solution', 3, None, '___sec49'),
              ('Discussion of the displacement scale', 3, None, '___sec50'),
              ('Discussion of the time scale', 3, None, '___sec51'),
              ('Alternative displacement scale', 3, None, '___sec52'),
              ('About frequency and dimensions', 3, None, '___sec53'),
              ('Undamped vibrations with constant forcing',
               2,
               'sec:scale:vib:undamped:mg',
               'sec:scale:vib:undamped:mg'),
              ('Undamped vibrations with time-dependent forcing',
               2,
               'sec:scale:vib:undamped:F',
               'sec:scale:vib:undamped:F'),
              ('Investigating scales via analytical solutions',
               3,
               None,
               '___sec56'),
              ('The displacement and time scales', 3, None, '___sec57'),
              ('Finding the displacement scale from the differential equation',
               3,
               None,
               '___sec58'),
              ('Scaling with free vibrations as time scale',
               3,
               None,
               '___sec59'),
              ('Software', 3, None, '___sec60'),
              ('Choice of $u_c$ close to resonance', 3, None, '___sec61'),
              ('Unit size of all terms in the ODE', 3, None, '___sec62'),
              ('Choice of $u_c$ when $\\psi\\gg\\omega$',
               3,
               None,
               '___sec63'),
              ('Displacement scale based on $I$', 3, None, '___sec64'),
              ('Damped vibrations with forcing',
               2,
               'sec:scale:vib:damped:F',
               'sec:scale:vib:damped:F'),
              ('The exact solution', 3, None, '___sec66'),
              ('Choosing scales', 3, None, '___sec67'),
              ('Choice of $u_c$ at resonance', 3, None, '___sec68'),
              ('Choice of $u_c$ when $\\omega\\gg\\psi$',
               3,
               None,
               '___sec69'),
              ('Choice of $u_c$ when $\\omega\\ll\\psi$',
               3,
               None,
               '___sec70'),
              ('Oscillating electric circuits', 2, None, '___sec71'),
              ('The wave equation', 1, 'sec:scale:wave', 'sec:scale:wave'),
              ('Simple homogeneous Dirichlet conditions',
               2,
               None,
               '___sec73'),
              ('Implementation of the scaled wave equation',
               2,
               None,
               '___sec74'),
              ('Waves on a string', 3, None, '___sec75'),
              ('Detecting an already computed case', 3, None, '___sec76'),
              ('Time-dependent Dirichlet condition',
               2,
               'scale:wave:pde2',
               'scale:wave:pde2'),
              ('Velocity initial condition',
               2,
               'scale:wave:pde2:Vcond',
               'scale:wave:pde2:Vcond'),
              ('Variable wave velocity and forcing',
               2,
               'scale:wave:pde2:cvar',
               'scale:wave:pde2:cvar'),
              ('Damped wave equation',
               2,
               'scale:wave:pde2:damped',
               'scale:wave:pde2:damped'),
              ('A three-dimensional wave equation problem',
               2,
               None,
               '___sec81'),
              ('The diffusion equation',
               1,
               'sec:scale:diffu',
               'sec:scale:diffu'),
              ('Homogeneous diffusion equation',
               2,
               'sec:scale:diffu:homo1D',
               'sec:scale:diffu:homo1D'),
              ('Simplified 1D PDE', 3, None, '___sec84'),
              ('Generalized PDE', 3, None, '___sec85'),
              ('Jump boundary condition', 2, None, '___sec86'),
              ('Oscillating Dirichlet condition', 2, None, '___sec87'),
              ('Diffusion equation with source term',
               2,
               'sec:scale:diffu:source',
               'sec:scale:diffu:source'),
              ("Fisher's equation",
               2,
               'sec:scale:diffu:Fisher',
               'sec:scale:diffu:Fisher'),
              ('The convection-diffusion equation',
               1,
               'scale:convdiff',
               'scale:convdiff'),
              ('Convection-diffusion without a force term',
               2,
               None,
               '___sec91'),
              ('Stationary PDE', 2, None, '___sec92'),
              ('Convection-diffusion with a force term',
               2,
               'scale:convdiff',
               'scale:convdiff'),
              ('The equations of linear elasticity', 1, None, '___sec94'),
              ('The Navier-Stokes equations',
               1,
               'sec:scale:ns',
               'sec:scale:ns'),
              ('The momentum equation without body forces',
               2,
               None,
               '___sec96'),
              ('The most common dimensionless form of the Navier-Stokes equations',
               2,
               None,
               '___sec97'),
              ('Scaling of time for low Reynolds numbers',
               2,
               None,
               '___sec98'),
              ('Shear stress as pressure scale', 2, None, '___sec99'),
              ('Including the gravity force', 2, None, '___sec100'),
              ('Oscillating boundary conditions', 2, None, '___sec101'),
              ('The Euler number', 2, None, '___sec102'),
              ('Free surface conditions', 2, None, '___sec103'),
              ('Thermal convection', 1, None, '___sec104'),
              ('Forced convection', 2, None, '___sec105'),
              ('Free convection',
               2,
               'scale:fluid:forced_convection',
               'scale:fluid:forced_convection'),
              ('Governing equations', 3, None, '___sec107'),
              ('Heating by viscous effects', 3, None, '___sec108'),
              ('Relation between density and temperature',
               3,
               None,
               '___sec109'),
              ('Comment on the form of the equation of continuity',
               3,
               None,
               '___sec110'),
              ('The Boussinesq approximation', 3, None, '___sec111'),
              ('Scaling', 3, None, '___sec112'),
              ('The Grashof, Prandtl, and Eckert numbers',
               2,
               None,
               '___sec113'),
              ('Heat transfer at boundaries', 2, None, '___sec114'),
              ('The bidomain model in electrophysiology',
               1,
               'scale:bidomain',
               'scale:bidomain'),
              ('Two-phase porous media flow', 1, None, '___sec116'),
              ('The Euler equations of gas dynamics', 1, None, '___sec117'),
              ('Exercises', 1, None, '___sec118'),
              ('Exercise 1: Perform unit conversion',
               2,
               'sec:scale:exer:US2SI1',
               'sec:scale:exer:US2SI1'),
              ('Problem 2: Scale a simple formula',
               2,
               'sec:scale:exer:ball_y',
               'sec:scale:exer:ball_y'),
              ('Problem 3: Scale a nonlinear ODE',
               2,
               'sec:scale:exer:ball_y_wdrag',
               'sec:scale:exer:ball_y_wdrag'),
              ('Exercise 4: Implement a scaled model with jump',
               2,
               'sec:scale:exer:decay:jump',
               'sec:scale:exer:decay:jump'),
              ('Exercise 5: Implement a scaled model for cooling',
               2,
               'sec:scale:exer:decay:cooling',
               'sec:scale:exer:decay:cooling'),
              ('Problem 6: Scale variable coefficients',
               2,
               'scale:decay:exer:decay:step',
               'scale:decay:exer:decay:step'),
              ('Exercise 7: Alternative scalings of a cooling model',
               2,
               'scale:decay:exer:cooling:Ts',
               'scale:decay:exer:cooling:Ts'),
              ('Exercise 8: Alternative scalings of a cooling model',
               2,
               'scale:decay:exer:nonlin:logistic2',
               'scale:decay:exer:nonlin:logistic2'),
              ('Exercise 9: Scale projectile motion',
               2,
               'scale:vib:exer:projectile',
               'scale:vib:exer:projectile'),
              ('Problem 10: Scale a predator-pray model',
               2,
               'scale:decay:exer:predpray',
               'scale:decay:exer:predpray'),
              ('Problem 11: Find the period of sinusoidal signals',
               2,
               'scale:decay:exer:sine',
               'scale:decay:exer:sine'),
              ('Remarks', 3, None, '___sec130'),
              ('Problem 12: Scale the pendulum equation',
               2,
               'sec:scale:exer:pendulum',
               'sec:scale:exer:pendulum'),
              ("Problem 13: Scale Duffing's equation",
               2,
               'scale:vib:exer:Duffing',
               'scale:vib:exer:Duffing'),
              ('Problem 14: Scale a stationary Couette flow',
               2,
               'scale:vib:exer:stationary_Couette',
               'scale:vib:exer:stationary_Couette'),
              ('Remarks', 3, None, '___sec134'),
              ('Problem 15: Scale a starting Couette flow',
               2,
               'scale:vib:exer:starting_Couette',
               'scale:vib:exer:starting_Couette'),
              ('Exercise 16: Scale Couette flow with pressure gradient',
               2,
               'scale:vib:exer:Couette_wpressure',
               'scale:vib:exer:Couette_wpressure'),
              ('Exercise 17: Suggestions...',
               2,
               'scale::exer:suggest',
               'scale::exer:suggest'),
              ('Bibliography', 1, None, '___sec138')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
$$




    
<a name="part0006"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._scale-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._scale-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="sec:scale:wave">The wave equation</h1>

<p>
A standard, linear, one-dimensional wave equation problem
in a homogeneous medium may be written as

$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} =
c^2 {\partial^2 u\over\partial x^2}, \quad  x\in (0,L),\ t\in (0,T],
\tag{67}
\end{equation}
$$

where \( c \) is the constant wave velocity of the medium.
With a briefer notation, where subscripts indicate derivatives,
the PDE <a href="#mjx-eqn-67">(67)</a> can be written
\( u_{tt}=c^2u_{xx} \). This subscript notation will occasionally be
used later.

<p>
In multi dimensions in heterogeneous media we have the generalization

$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} =
\nabla\cdot\left(c^2 \nabla u\right) + f, \quad  x,y,z\in \Omega,\ t\in (0,T]\tp
\tag{68}
\end{equation}
$$

How to scale time depends on the PDE, the spatial scale depends on
the domain, and the scale of \( u \) usually depends on the type of
boundary and initial condition.

<h2 id="___sec73">Simple homogeneous Dirichlet conditions </h2>

<p>
Let us first start with homogeneous Dirichlet conditions in space and
no initial velocity \( u_t \):

$$
\begin{align}
u(x,0) &= I(x), \quad &x\in [0,L],
\tag{69}\\ 
{\partial\over\partial t}u(x,0) &= 0, \quad & x\in [0,L],
\tag{70}\\ 
u(0,t) & = 0, \quad  & t\in (0,T],
\tag{71}\\ 
u(L,t) & = 0, \quad  & t\in (0,T].
\tag{72}
\end{align}
$$

The independent variables are \( x \) and \( t \), while \( u \) is the dependent
variable.
The rest of the parameters, \( c \), \( L \), \( T \), and \( I(x) \), are given data.

<p>
We start with introducing dimensionless versions of the independent and
dependent variables:

$$
\bar x = \frac{x}{x_c},\quad \bar t=\frac{t}{t_c},\quad\bar u=\frac{u}{u_c}
\tp
$$

Inserting the \( x=x_c\bar x \), etc., in <a href="#mjx-eqn-67">(67)</a> and
<a href="#mjx-eqn-69">(69)</a>-<a href="#mjx-eqn-72">(72)</a> gives

$$
\begin{align*}
\frac{\partial^2 \bar u}{\partial \bar t^2} &=
\frac{t_c^2c^2}{x_c^2}{\partial^2 \bar u\over\partial x^2}, \quad & \bar x\in (0,L/x_c),\ \bar t\in (0,T/t_c],
\\ 
\bar u(\bar x,0) &= \frac{I(x_c\bar x)}{u_c},
\quad &\bar x\in [0,L/x_c],
\\ 
\frac{\partial}{\partial \bar t}\bar u(\bar x,0) &= 0,
\quad & \bar x\in [0,L/x_c],
\\ 
\bar u(0,\bar t) & = 0,
\quad  & \bar t\in (0,T/t_c],
\\ 
\bar u(L/x_c,\bar t) & = 0,
\quad &\bar t\in (0,T/t_c].
\end{align*}
$$

<p>
The key question is how to define the scales.
A natural choice is \( x_c=L \) since this makes \( \bar x\in [0,1] \).
For the problem governed by
<a href="#mjx-eqn-67">(67)</a> we
have some analytical insight, namely that the solution behaves like

$$
\begin{equation}
u(x,t) = f_R(x-ct) + f_R(x+ct),
\tag{73}
\end{equation}
$$

i.e., a right- and left-going wave with velocity \( c \). The initial
conditions constrain the choices of \( f_R \) and \( f_L \) to \( f_L + f_R=I \)
and \( -cf_L' + cf_R' = 0 \). The solution is \( f_R = f_L = \frac{1}{2} \),
and consequently

$$
u(x,t) = \frac{1}{2}I(x-ct) + \frac{1}{2}I(x+ct),
$$

which tells that the initial condition splits in two, half of it moves
to the left and half to the right.
This means in particular that we can choose \( u_c=\max_x |I(x)| \)
and get \( |\bar u|\leq 1 \), which is a goal.

<p>
Regarding the time scale, we may look at the two terms in the scaled
PDE and argue that if \( |u| \) and its derivatives are to be of order unity,
then the size of the second-order derivatives should be the same, and
\( t_c \) can be chosen to make the coefficient \( t_c^2 c^2 /x_c^2 \) unity,
i.e., \( t_c=L/c \).
Another reasoning may set \( t_c \) as the time it takes the wave
to travel through the domain \( [0,L] \). Since the wave has constant
speed \( c \), \( t_c = L/c \).

<p>
With the described choices of scales,
we end up with the dimensionless initial-boundary value problem

$$
\begin{align}
\frac{\partial^2 \bar u}{\partial \bar t^2} &=
{\partial^2 \bar u\over\partial x^2}, \quad & \bar x\in (0,1),\ \bar t\in (0,\bar T],
\tag{74}\\ 
\bar u(\bar x,0) &= \frac{I(\bar x L)}{\max_{x\in(0,L)} |I(x)|},
\quad &\bar x\in [0,1],
\tag{75}\\ 
{\partial\over\partial \bar t}\bar u(\bar x,0) &= 0,
\quad & \bar x\in [0,1],
\tag{76}\\ 
\bar u(0,\bar t) & = 0,
\quad  &\bar t\in (0,\bar T],
\tag{77}\\ 
\bar u(1,\bar t) & = 0,
\quad  &\bar t\in (0,\bar T].
\tag{78}
\end{align}
$$

Here, \( \bar T = Tc/L \).

<p>
The striking feature of
<a href="#mjx-eqn-74">(74)</a>-<a href="#mjx-eqn-78">(78)</a>
is that there are <em>no physical parameters</em> involved! Everything we need
to specify is the shape of the initial condition and then scale it
such that it is less than or equal to 1.

<p>
The physical solution with dimension is recovered from \( \bar u(\bar x,\bar t) \)
through

$$
\begin{equation}
u(x,t) = \max_{x\in(0,L)}I(x)\,\bar u(\bar x L, \bar t L/c)
\end{equation}
$$

<h2 id="___sec74">Implementation of the scaled wave equation </h2>

<p>
How do we implement <a href="#mjx-eqn-74">(74)</a>-<a href="#mjx-eqn-78">(78)</a>?
As for the simpler mathematical models, I suggest to implement the model
with dimensions and observe how to set parameters to obtain the scaled
model. In the present case, one must choose \( L=1 \), \( c=1 \), and scale \( I \) by its
maximum value. That's all!

<p>
Several implementations of 1D wave equation models with different
degree of mathematical and software complexity appear in
the directory <a href="http://tinyurl.com/nm5587k/wave/wave1D" target="_self"><tt>wave/wave1D</tt></a>. The simplest
version is <a href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_u0.py" target="_self"><tt>wave1D_u0.py</tt></a>
that implements <a href="#mjx-eqn-67">(67)</a> and
<a href="#mjx-eqn-69">(69)</a>-(ref{scale:wave:pde1:bc:L}.
This is the code to be used in the following. It is described
in in
the document <a href="http://tinyurl.com/k3sdbuv/pub/wave" target="_self">Finite difference methods for wave motion</a>
<a href="._scale-solarized010.html#Langtangen_deqbook_wave">[6]</a>.

<h3 id="___sec75">Waves on a string </h3>

<p>
As example, we may let the original initial-boundary value problem
<a href="#mjx-eqn-67">(67)</a>-<a href="#mjx-eqn-72">(72)</a> model
vibrations of a string on a string instrument. With \( u \) as the
displacement of the string, the boundary conditions \( u=0 \) at the ends
are relevant, as well as the zero velocity condition \( \partial u/\partial t=0 \)
at \( t=0 \).
The initial condition \( I(x) \) has typically a triangular shape for a picked
guitar string.
The physical problem needs parameters for the amplitude of \( I(x) \),
the length \( L \) of the string, and the value of \( c \) for the string. Only
the latter is challenging as it involves relating \( c \) to the
pitch (i.e., time frequency) of the string. In the scaled problem, we
can forget about all this. We simply set \( L=1 \), \( c=1 \), and let
\( I(x) \) have a peak of unity at \( x=x_0\in(0,1) \):

$$
\frac{I(x)}{\max_x I(x)} = \left\lbrace
\begin{array}{ll}
x/x_0, & x < x_0,\\ 
(1-x)/(1-x_0), & \hbox{otherwise}
\end{array}\right.
$$

The dimensionless coordinate of the peak, \( x_0 \), is the only
dimensionless parameter in the problem. For fixed \( x_0 \),
one single simulation will capture all possible solutions with such
a triangular shape.

<h3 id="___sec76">Detecting an already computed case </h3>

<p>
In the section <a href="._scale-solarized004.html#sec:scale:decay:prog">Making software utilizing the dimensionless model</a> we demonstrated the use of <code>joblib</code>
for making a function that detects if a case has already been run and
in that case the previous solution can be returned from a database.
It turns out that <code>joblib</code> cannot handle functions with function arguments,
which we have a lot of in the <code>solver</code> functions for 1D wave equations.

<p>
A manual strategy taken from <a href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn_vc.py" target="_self"><tt>wave1D_dn_vc.py</tt></a> and explained in
the document
<a href="http://tinyurl.com/k3sdbuv/pub/softeng2" target="_self">Scientific software engineering; wave equation model</a> <a href="._scale-solarized010.html#Langtangen_deqbook_softeng2">[7]</a>
is to convert
all input data to the <code>solver</code> function to a string,
which is thereafter converted to an SHA1 hash string
(via <code>hashlib.sha1</code>) and used to recognize the input.
A SHA1 string is also suitable as part of a file or directory name
where computed solutions can be stored.

<p>
We can, in the wave equation solver
retrieve the solution, rather than computing it, if
the hash string is the same (because then the computations have already been
done). This can save a lot of computations if a scaled solution can be
reused in a number of cases with dimensions. We will sketch the
code that implements the idea.

<p>
A solver for the scaled problem is first developed. We limit the
focus to the simple constant-coefficient wave equation with \( u_t(x,0)=0 \).
The solver for the unscaled problem is taken from the previously
mentioned <code>wave1D_u0.py</code> file.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Enable loading modules in the wave eq solver and softeng2 dirs</span>
sys.path.insert(<span style="color: #B452CD">0</span>, os.path.join(
    os.pardir, os.pardir, <span style="color: #CD5555">&#39;wave&#39;</span>, <span style="color: #CD5555">&#39;src-wave&#39;</span>, <span style="color: #CD5555">&#39;wave1D&#39;</span>))
sys.path.insert(<span style="color: #B452CD">0</span>, os.path.join(
    os.pardir, os.pardir, <span style="color: #CD5555">&#39;softeng2&#39;</span>, <span style="color: #CD5555">&#39;src-softeng2&#39;</span>))
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">wave1D_u0</span> <span style="color: #8B008B; font-weight: bold">import</span> solver <span style="color: #8B008B; font-weight: bold">as</span> solver_unscaled
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">Storage</span> <span style="color: #8B008B; font-weight: bold">import</span> Storage

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver_scaled</span>(I, dt, C, T):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve 1D wave equation in dimensionless form.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># Make a hash of the arguments</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">inspect</span>, <span style="color: #008b45; text-decoration: underline">hashlib</span>
    data = inspect.getsource(I) + <span style="color: #CD5555">&#39;_&#39;</span> + <span style="color: #658b00">str</span>(dt) + <span style="color: #CD5555">&#39;_&#39;</span> + \ 
           <span style="color: #658b00">str</span>(C) + <span style="color: #CD5555">&#39;_&#39;</span> + <span style="color: #658b00">str</span>(T)
    <span style="color: #228B22"># Not fool proof: if x0 changes value, I source is the same...</span>
    hashed_input = hashlib.sha1(data).hexdigest()

    cachedir = <span style="color: #CD5555">&#39;tmp_%s&#39;</span> % hashed_input
    is_computed = os.path.isdir(cachedir)
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;cachedir:&#39;</span>, cachedir, is_computed
    storage = Storage(cachedir, verbose=<span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">action</span>(u, x, t, n):
        <span style="color: #8B008B; font-weight: bold">if</span> n == <span style="color: #B452CD">0</span>:
            storage.save(<span style="color: #CD5555">&#39;x&#39;</span>, x)
            storage.save(<span style="color: #CD5555">&#39;t&#39;</span>, t)
        storage.save(<span style="color: #CD5555">&#39;u%d&#39;</span> % n, u)

    <span style="color: #8B008B; font-weight: bold">if</span> is_computed:
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;No need to compute the numerical solution&#39;</span>
        <span style="color: #8B008B; font-weight: bold">return</span> storage
    <span style="color: #8B008B; font-weight: bold">else</span>:
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Computing the numerical solution&#39;</span>
        solver_unscaled(
            I=I, V=<span style="color: #B452CD">0</span>, f=<span style="color: #B452CD">0</span>, c=<span style="color: #B452CD">1</span>, L=<span style="color: #B452CD">1</span>, dt=dt, C=C, T=T,
            user_action=action)
        <span style="color: #8B008B; font-weight: bold">return</span> storage
</pre></div>
<p>
This function employs ideas described in
the document
<a href="http://tinyurl.com/k3sdbuv/pub/softeng2" target="_self">Scientific software engineering; wave equation model</a> <a href="._scale-solarized010.html#Langtangen_deqbook_softeng2">[7]</a> for storing
arrays on disk with use of <code>joblib</code> (class <code>Storage</code>) and recognizing
previous input through a hash string. If the input is the same, the
hash is the same and we can test on the existence of a
directory whose name contains the hash. If that directory exists, the
solution for this set of input data is already computed, and we can just
return the <code>storage</code> object from which one can retrieve the space and time
mesh as well as all the solutions <code>u0</code>, <code>u1</code>, and so on.

<p>
A specific application of this simple solver is the vibrations of a guitar
string. The scaled version depends only on \( C \) (if we say \( T \) is fixed
and \( N_x \) is fixed through \( \Delta t \)). The string vibrations can be
simulated by the following function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">guitar_scaled</span>(C, animate=<span style="color: #658b00">True</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Triangular wave (pulled guitar string).&quot;&quot;&quot;</span>
    L = <span style="color: #B452CD">1.0</span>
    x0 = <span style="color: #B452CD">0.8</span>*L
    T = <span style="color: #B452CD">2</span>
    Nx = <span style="color: #B452CD">50</span>; dx = L/<span style="color: #658b00">float</span>(Nx)
    dt = dx/<span style="color: #B452CD">1</span>  <span style="color: #228B22"># Choose dt at the stability limit</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> x/x0 <span style="color: #8B008B; font-weight: bold">if</span> x &lt; x0 <span style="color: #8B008B; font-weight: bold">else</span> (L-x)/(L-x0)

    storage = solver_scaled(I, dt, C, T)
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> animate:
        <span style="color: #8B008B; font-weight: bold">return</span> storage

    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">import</span> plot
    x = storage.retrieve(<span style="color: #CD5555">&#39;x&#39;</span>)
    t = storage.retrieve(<span style="color: #CD5555">&#39;t&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(t)):
        u = storage.retrieve(<span style="color: #CD5555">&#39;u%d&#39;</span> %n)
        plot(x, u, <span style="color: #CD5555">&#39;r-&#39;</span>, label=<span style="color: #CD5555">&#39;t=%.2f&#39;</span> % t[n],
             axis=[x[<span style="color: #B452CD">0</span>], x[-<span style="color: #B452CD">1</span>], -<span style="color: #B452CD">1.2</span>, <span style="color: #B452CD">1.2</span>])
    <span style="color: #8B008B; font-weight: bold">return</span> storage
</pre></div>
<p>
Although the partial differential equation model has no physical
parameters (assuming \( x_0 \) fixed), the corresponding numerical model
depends on the Courant number \( C=c\Delta t/\Delta x \) and the length
\( T \) of the simulations.

<p>
To solve an unscaled problem, we need some unscale functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">unscale_u</span>(u, I_max, c, L):
    <span style="color: #8B008B; font-weight: bold">return</span> I_max*u

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">unscale_x</span>(x, I_max, c, L):
    <span style="color: #8B008B; font-weight: bold">return</span> x*L

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">unscale_t</span>(t, I_max, c, L):
    <span style="color: #8B008B; font-weight: bold">return</span> t*L**<span style="color: #B452CD">2</span>/<span style="color: #658b00">float</span>(c)
</pre></div>
<p>
We can now easily solve a range of unscaled cases by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">guitar</span>(C, I_max, c, L):
    <span style="color: #CD5555">&quot;&quot;&quot;Triangular wave (pulled guitar string). Unscaled version.&quot;&quot;&quot;</span>
    storage = guitar_scaled(C, animate=<span style="color: #658b00">False</span>)
    x = storage.retrieve(<span style="color: #CD5555">&#39;x&#39;</span>)
    t = storage.retrieve(<span style="color: #CD5555">&#39;t&#39;</span>)
    x = unscale_x(x, I_max, c, L)
    t = unscale_t(t, I_max, c, L)

    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">import</span> plot
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(t)):
        u = storage.retrieve(<span style="color: #CD5555">&#39;u%d&#39;</span> %n)
        u = unscale_u(u, I_max, c, L)
        plot(x, u, <span style="color: #CD5555">&#39;r-&#39;</span>, label=<span style="color: #CD5555">&#39;t=%.2f&#39;</span> % t[n],
             axis=[x[<span style="color: #B452CD">0</span>], x[-<span style="color: #B452CD">1</span>], -I_max*<span style="color: #B452CD">1.2</span>, <span style="color: #B452CD">1.2</span>*I_max])
</pre></div>
<p>
If <code>guitar_scaled</code> figures out that the scaled problem is already solved,
it just returns the <code>storage</code> object, otherwise it performs calculations.
Anyway, we retrieve the space and time mesh as well as all the solutions.
The <code>plot</code> function from <a href="https://github.com/hplgit/scitools" target="_self">SciTools</a>
is used for compact code for
animation, but Matplotlib can equally well be used (with a bit more coding).

<p>
Suppose we run three calls to <code>guitar</code> with three different values of
<code>I_max</code>. The output will be

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Computing the numerical solution
No need to compute the numerical solution
No need to compute the numerical solution
</pre></div>
<p>
This indicates that we rely on the scaled solution for the two
other cases with different <code>I_max</code> parameter. Running such a program again
will avoid all computations and show movies solely based on
precomputed file data.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 3</b>: I make a big issue of retrieving data from file, but in more complicated cases, this has little practical value as the number of dimensionless numbers gets large (approaching the number of parameters anyway). In the present simple cases, the computations are so fast that there is little to gain by avoiding them. The text is therefore biased with respect to the practical benefit of reusing old solutions. Nevertheless, it probably does not hurt to document the idea? Need views on this.)</font>
<!-- end inline comment -->

<h2 id="scale:wave:pde2">Time-dependent Dirichlet condition</h2>

<p>
A generalization of <a href="#mjx-eqn-67">(67)</a>-<a href="#mjx-eqn-72">(72)</a> is to
allow for a time-dependent Dirichlet condition at one end, say
\( u(0,t)=U_L(t) \). At the other end we may still have \( u=0 \).
This new condition at \( x=0 \) may model a specified wave that
enters the domain. For example, if we feed in a monochromatic wave
\( A\sin(k(x-ct)) \) from the left end, \( U_L(t)=A\sin (kct) \).
This forcing of the wave motion has its own amplitude and time scale that
could affect the choice of \( u_c \) and \( t_c \).

<p>
The main difference from the previous initial-boundary value problem
is the condition at \( x=0 \), which now reads

$$ \bar u(0,\bar t) = \frac{U_L(\bar t t_c)}{u_c}$$

in scaled form.

<p>
Regarding the characteristic time scale, it is natural to base this scale on
the wave propagation velocity and not on the time scale of \( U_L(t) \), because
the time scale of \( U_L \) basically determines whether
short or long waves are fed in at the boundary. All waves, long or short,
propagate with the same velocity \( c \). We therefore continue
to use \( t_c=L/c \).

<p>
The solution \( u \) will have
one wave contribution from the initial condition \( I \) and one from the
feeding of waves at \( x=0 \). This gives us three choices of \( u_c \):
\( \max_x |I| + \max_t |U_L| \), \( \max_x |I| \), or \( \max_t |U_L| \). The first seems
relevant if the size of \( I \) and \( U_L \) are about the same, but then
we can choose either \( \max_x |I| \) or \( \max_t |U_L| \) as characteristic size
of \( u \) since a factor of 2 is not important. If \( I \) is much less than
\( U_L \), \( u_c=\max_t |u_L| \) is relevant, while \( u_c=\max_xI \) is the choice
when \( I \) has much bigger impact than \( U_L \) on \( u \).

<p>
With \( u_c=\max_t |U_L(t)| \), we get the scaled problem

$$
\begin{align}
\frac{\partial^2 \bar u}{\partial \bar t^2} &=
{\partial^2 \bar u\over\partial \bar x^2},
\quad & \bar x\in (0,1),\ \bar t\in (0,\bar T],
\tag{79}\\ 
\bar u(\bar x,0) &= \frac{I(x_c\bar x)}{\max_t |U_L(t)|},
\quad &\bar x\in [0,1],
\tag{80}\\ 
{\partial\over\partial \bar t}\bar u(\bar x,0) &= 0,
\quad & \bar x\in [0,1],
\tag{81}\\ 
\bar u(0,\bar t) & = \frac{U_L(\bar tt_c)}{\max_t |U_L(t)|},
\quad  &\bar t\in (0,\bar T],
\tag{82}\\ 
\bar u(1,\bar t) & = 0,
\quad &\bar t\in (0,\bar T].
\tag{83}
\end{align}
$$

Also this problem is free of physical parameters like \( c \) and \( L \).
The input is completely specified by the shape of \( I(x) \) and \( U_L(t) \).

<p>
Software for the original problem with dimensions can be reused for
<a href="#mjx-eqn-79">(79)</a>-<a href="#mjx-eqn-83">(83)</a> by
setting \( L=1 \), \( c=1 \), and scaling \( U_L(t) \) and \( I(x) \) by
\( \max_t |U_L(t)| \).

<p>
As an example, consider

$$
\begin{align*}
U_L(t) &= a\sin(\omega t)\hbox{ for } 0\leq t\leq 2\frac{\omega}{2\pi},
\hbox{ else } 0,\\ 
I(x)   & = Ae^{-(x-L/2)^2/\sigma^2}\tp
\end{align*}
$$

That is, we start with a Gaussian peak-shaped wave in the center of the
domain and feed in a sinusoidal wave at the left end for two periods.
The solution will be the sum of three waves: two parts from the initial
condition, plus the wave fed in from the left.

<p>
Since \( \max_t |U_L|=a \) we get

$$
\begin{align*}
\bar u(\bar x,0) &= \frac{A}{a}e^{-(L/\sigma)^2(\bar x -\frac{1}{2})^2},\\ 
\bar u(0,\bar t) &= \sin(\bar t\omega L/c)\tp
\end{align*}
$$

Here, \( U_L \) models an incoming wave \( a\sin(k(x-ct) \), with \( k \) specified
(makes waves of length \( \lambda = 2\pi/k \)), we have \( \omega =kc \),
and \( \bar u(0,\bar t)=\sin(kL\bar t) = \sin(2\pi\bar t L/\lambda) \).
(This formula demonstrates the previous assertion that the time scale
of \( U_L \), i.e., \( 1/\omega \), determines the wave length \( 1/\omega = \lambda/(2\pi) \) in space.)
We realize from the formulas for \( \bar u(\bar x, 0) \) and
\( \bar u(0,\bar t) \) that there are three key dimensionless parameters related
to these specific choices of initial and boundary conditions:

$$ \alpha = \frac{A}{a},\quad\beta = \frac{L}{\sigma},\quad\gamma = kL
=2\pi\frac{L}{\lambda}\tp$$

With \( \alpha \), \( \beta \), and \( \gamma \) we can write the dimensionless
initial and boundary conditions as

$$
\begin{align*}
\bar u(\bar x,0) &= \alpha e^{-\beta^2(\bar x -\frac{1}{2})^2},\\ 
\bar u(0,\bar t) &= \sin(\gamma\bar t)\tp
\end{align*}
$$

The dimensionless parameters have the following interpretations:

<ul>
 <li> \( \alpha \): ratio of initial condition peak and amplitude of incoming wave
   at \( x=0 \)</li>
 <li> \( \beta \): ratio of length of domain and width of initial condition</li>
 <li> \( \gamma \): ratio of length of domain and wave length of incoming wave</li>
</ul>

Again, these dimensionless parameters tell a lot about the interplay of
the physical effects in the problem: only some ratios count.

<p>
We can simulate two special cases: \( \alpha=10 \) (large) where the
incoming wave is small and the solution is dominated by the two waves
arising from \( I(x) \), and \( \alpha=0.1 \) (small) where the incoming waves
dominate and the has the initial condition as a small perturbation of
the wave shape. We may choose a peak-shaped initial condition: \( \beta = 10 \),
and also a relatively short incoming wave compared to the domain size:
\( \gamma 6\pi \) (i.e., wave length of incoming wave is \( L/6 \)).
The function below applies the general unscaled
solver in <a href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn.py" target="_self"><tt>wave1D_dn.py</tt></a>
for solving the wave equation with constant \( c \)
and any time-dependent function or \( \partial u/\partial x=0 \) at the
end points.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">simulate_Gaussian_and_incoming_wave</span>():
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">wave1D_dn</span> <span style="color: #8B008B; font-weight: bold">import</span> solver, viz
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> pi
    alpha = <span style="color: #B452CD">0.1</span>
    beta = <span style="color: #B452CD">10</span>
    gamma = <span style="color: #B452CD">2</span>*pi*<span style="color: #B452CD">3</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> alpha*exp(-beta**<span style="color: #B452CD">2</span>*(x - <span style="color: #B452CD">0.5</span>)**<span style="color: #B452CD">2</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">U_0</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> sin(gamma*t) <span style="color: #8B008B; font-weight: bold">if</span> t &lt;= <span style="color: #B452CD">2</span>*pi/gamma <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #B452CD">0</span>

    L = <span style="color: #B452CD">1</span>
    c = <span style="color: #B452CD">1</span>
    Nx = <span style="color: #B452CD">80</span>; dx = L/<span style="color: #658b00">float</span>(Nx); dt = dx/<span style="color: #B452CD">1</span>
    <span style="color: #228B22">#solver(I=I, V=0, f=0, U_0=U_0, U_L=None, L=1, dt=dt, C=1, T=4,</span>
    <span style="color: #228B22">#       user_action=myplotter)</span>
    viz(I=I, V=<span style="color: #B452CD">0</span>, f=<span style="color: #B452CD">0</span>, c=<span style="color: #B452CD">1</span>, U_0=U_0, U_L=<span style="color: #658b00">None</span>, L=<span style="color: #B452CD">1</span>, dt=dt, C=<span style="color: #B452CD">1</span>,
        T=<span style="color: #B452CD">4</span>, umin=-(alpha+<span style="color: #B452CD">1</span>), umax=(alpha+<span style="color: #B452CD">1</span>),
        version=<span style="color: #CD5555">&#39;vectorized&#39;</span>, animate=<span style="color: #658b00">True</span>)
</pre></div>
<p>
The function is found in the file <a href="http://tinyurl.com/nm5587k/scale/session.py" target="_self"><tt>session.py</tt></a>.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-scale/gaussian_plus_incoming/alpha10.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-scale/gaussian_plus_incoming/alpha10.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-scale/gaussian_plus_incoming/alpha10.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>\( \alpha=10 \)</em></p>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-scale/gaussian_plus_incoming/alpha01.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-scale/gaussian_plus_incoming/alpha01.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-scale/gaussian_plus_incoming/alpha01.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>\( \alpha=0.1 \)</em></p>

<h2 id="scale:wave:pde2:Vcond">Velocity initial condition</h2>

<p>
Now we change the initial condition from \( u=I \) and \( \partial u/\partial t = 0 \) to

$$
\begin{align}
u(x,0) &= 0,\\ 
\frac{\partial}{\partial t} u(x,0) &= V(x)\tp
\end{align}
$$

Impact problems are often of this kind.
From <a href="#mjx-eqn-73">(73)</a> we now get \( f_L + f_R =0 \) and
\( cf_L' - cf_R' = V \). Introducing \( W(x) \) such that \( W'(x)=V(x) \), a solution
is \( -f_L=\frac{1}{2}W \) and \( f_R=\frac{1}{2}W \). Hence,

$$ u(x,t) = \frac{1}{2c}\int_{x-ct}^{x+ct} v(\xi) d\xi\tp$$

The scaled version of \( u_t(x,0)=V(x) \) becomes

$$ \frac{\partial}{\partial \bar t} \bar u(\bar x,0) =
\frac{t_c}{u_c}V(\bar x x_c)\tp
$$

Since \( V \) is the time-derivative of \( u \), the characteristic size of
\( V \) is typically \( u_c/t_c \), meaning that

$$ \max_{x\in(0,L)}|V(x)| = \frac{u_c}{t_c},$$

which gives $ u_c = \max_{x\in(0,L)}|V(x)| L/c$. As usual, we base \( t_c \)
on the wave speed: \( t_c = L/c \). We end up with

$$ \frac{\partial}{\partial \bar t} \bar u(\bar x,0) =
\frac{V(\bar x x_c)}{\max_x |V(x)|},
$$

which also looks like a natural scaling of a function \( V \).

<p>
Suppose we change the initial condition \( u(x,0)=0 \) to \( u(x,0)=I(x) \).
The scaled version of this condition with the present \( u_c \) becomes

$$ \bar u(\bar x, 0) = \frac{cI(\bar x x_c)}{L\max_x |V(x)|}\tp$$

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Check that dimensionless numbers are dimensionless!</b>
<p>
Is the fraction on the right-hand side dimensionless?
It is easy to make errors when scaling equations, so checking that
such fractions are dimensionless is wise.
The dimension of \( I \) is the same as \( u \), here taken to be displacement:
[L].
Since \( V \) is \( \partial u/\partial t \), its dimension is
\( [\hbox{LT}^{-1}] \). The dimensions of \( c \) and \( L \) are
\( [\hbox{LT}^{-1}] \) and \( [\hbox{L}] \). The dimension of the right-hand side
is then

$$ \frac{[\hbox{LT}^{-1}][L]}{[L][L\hbox{T}^{-1}]}
= 1,$$

demonstrating that the fraction is indeed dimensionless.
</div>


<p>
One may introduce a dimensionless initial
shape, \( \bar I (\bar x)= I(\bar xL)/\max_x |I| \). Then

$$ \bar u(\bar x, 0) = \alpha\bar I(\bar x),$$

where \( \alpha \) the dimensionless number

$$ \alpha = \frac{c}{L}\frac{\max_x |I(x)|}{\max_x |V(x)|}\tp$$

<p>
If \( V \) is much larger than \( I \), one expects that the influence of \( I \)
is small. However, it takes time for the initial velocity \( V \) to
influence the wave motion, so if \( c \) is much bigger than \( L \), the
initial wave shape \( I \)
travels quickly through the domain before the effect of \( V \) becomes
visible. The impact of \( I \) may therefore be significant for small \( t \).
This is reflected in an
\( \alpha \) value that is not small since \( c/L \) is large and \( \max |I|/\max |V| \)
is small, resulting in a scaled initial condition \( \bar u(\bar x,0) \)
that is not small.
With \( c/L \) about unity, \( \alpha \) becomes small, and \( \bar u(\bar x,0)
\approx 0 \) such that not much happens before the effect of \( V \) becomes
visible. Recall that the dimensionless initial velocity is about unity
regardless of other parameters.
Again, the scaling and the resulting dimensionless parameter(s)
teach us much about the interaction of the various physical effects.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 4</b>: Do experiments. Make exercise or insert here.)</font>
<!-- end inline comment -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 5</b>: Could make paradox: small \( I \), big \( V \), but still significant impact of \( I \) in a simulation. Why? Bug? The answer is above. Best as exercise.)</font>
<!-- end inline comment -->

<h2 id="scale:wave:pde2:cvar">Variable wave velocity and forcing</h2>

<p>
The next problem generalization regards wave propagation in
a non-homogeneous where the wave velocity \( c \) depends on the
spatial position: \( c=c(x) \). To simplify the notation we introduce
\( \lambda (x) = c^2(x) \). We introduce homogeneous Neumann conditions
at \( x=0 \) and \( x=L \). In addition, we add a force term \( f(x,t) \)
to the PDE, modeling wave generation in the interior of
the domain. For example, a moving slide at the bottom of a fjord
will generate surface waves and is modeled by such an \( f(x,t) \) term.
The initial-boundary value problem
can be then expressed as

$$
\begin{align}
\frac{\partial^2 u}{\partial t^2} &=
\frac{\partial}{\partial x}\left(
\lambda(x) {\partial u\over\partial x}\right) + f(x,t),
\quad & x\in (0,L),\ t\in (0,T],
\tag{84}\\ 
u(x,0) &= I(x),
\quad &x\in [0,L],
\tag{85}\\ 
{\partial\over\partial t}u(x,0) &= 0,
\quad & x\in [0,L],
\tag{86}\\ 
\frac{\partial}{\partial x}u(0,t) & = 0,
\quad  &t\in (0,T],
\tag{87}\\ 
\frac{\partial}{\partial x}u(L,t) & = 0,
\quad  &t\in (0,T].
\tag{88}
\end{align}
$$

We make the coefficient \( \lambda \) non-dimensional by

$$
\begin{equation}
\bar\lambda(\bar x) = \frac{\lambda(\bar xx_c)}{\lambda_c},
\end{equation}
$$

where one normally chooses the characteristic size of \( \lambda \), \( \lambda_c \),
to be the maximum value such that \( |\lambda|\leq 1 \):

$$ \lambda_c = \max_{x\in(0,L)}\lambda(x)\tp$$

Similarly, \( f \) has a scaled version

$$ \bar f(\bar x,\bar t) = \frac{f(\bar x x_c, \bar t t_c)}{f_c},$$

where normally

$$ f_c=\max_{x,t}|f(x,t)|\tp$$

Inserting dependent and independent variables expressed by their
non-dimensional counterparts yields

$$
\begin{align}
\frac{\partial^2 \bar u}{\partial \bar t^2} &=
\frac{t_c^2\lambda_c}{L^2}\frac{\partial}{\partial \bar x}\left(
\bar\lambda(\bar x) {\partial\bar u\over\partial\bar x}\right)
+ \frac{t_c^2f_c}{u_c}\bar f(\bar x,\bar t),
\quad & \bar x\in (0,1),\ \bar t\in (0,\bar T],
\tag{89}\\ 
\bar u(\bar x,0) &= \frac{I(x)}{u_c},
\quad &\bar x\in [0,1],
\tag{90}\\ 
{\partial\over\partial \bar t}\bar u(\bar x,0) &= 0,
\quad & \bar x\in [0,1],
\tag{91}\\ 
\frac{\partial}{\partial \bar \bar x}\bar u(0,\bar t) & = 0,
\quad  &\bar t\in (0,\bar T],
\tag{92}\\ 
\frac{\partial}{\partial \bar x}\bar u(1,\bar t) & = 0,
\quad  &\bar t\in (0,\bar T],
\tag{93}
\end{align}
$$

with \( \bar T = Tc/L \).

<p>
The time scale is, as before, chosen as \( t_c
=L/\sqrt{\lambda_c} \). Note that the previous (constant) wave velocity
\( c \) now corresponds to \( \sqrt{\lambda (x)} \).  Therefore,
\( \sqrt{\lambda_c} \) is a characteristic wave velocity.

<p>
One could wonder if the time scale of the force term, \( f(x,t) \),
should influence \( t_c \), but as we reasoned for the boundary condition
\( u(0,t)=U_L(t) \), we let the characteristic time be governed by the
signal speed in the medium, i.e., by \( \sqrt{\lambda_c} \) here and not
by the time scale of the excitation \( f \) which dictates the
length of the generated waves and not their propagation speed.

<p>
Furthermore, we may choose \( u_c \) as \( \max_x |I(x)| \), as before,
or we may fit \( u_c \) such that the coefficient in the source term
is unity, i.e., all terms balance each other.
This latter idea leads to

$$ u_c = \frac{L^2 f_c}{\lambda_c} $$

and a PDE without parameters,

$$
\frac{\partial^2 \bar u}{\partial \bar t^2} =
\frac{\partial}{\partial \bar x}\left(
\bar\lambda(\bar x) {\partial\bar u\over\partial\bar x}\right)
+ \bar f(\bar x,\bar t)\tp
$$

The initial condition \( u(x,0)=I(x) \) becomes in dimensionless form

$$ \bar u(\bar x, 0) = u_c^{-1} \max_x |I(x)|\bar I(\bar x) =
\beta^{-1}\bar I(\bar x),$$

where

$$ \beta = \frac{L^2}{\lambda_c}\frac{\max_{x,t} |f(x,t)|}{\max_x|I(x)|}\tp$$

<p>
In the case \( u_c=\max_x|I(x)| \), \( \bar u(\bar x,0)=\bar I(\bar x) \) and
the \( \beta \) parameter appears in the PDE,

$$
\frac{\partial^2 \bar u}{\partial \bar t^2} =
\frac{\partial}{\partial \bar x}\left(
\bar\lambda(\bar x) {\partial\bar u\over\partial\bar x}\right)
+ \beta \bar f(\bar x,\bar t)\tp
$$

With \( V=0 \), and \( u=0 \) or \( u_x=0 \) on the boundaries \( x=0,L \), this scaling gives
\( |\bar u|\leq 1 \), since initially \( |I|\leq 1 \), and no boundary condition
can increase the amplitude.

<p>
The initial condition \( u_t(x,0)=V(x) \) has its dimensionless variant as

$$ \bar V(\bar x) = \frac{t_c}{u_c}\frac{V(L\bar x)}{\max_x|V(x)|},$$

which becomes

$$ \frac{\partial\bar u}{\partial\bar t}(\bar x, 0) =
\frac{L}{\sqrt{\lambda_c}}\frac{\max_{x}|V(x)|}{\max_{x}|I(x)|}\bar V(\bar x),
\hbox{ if } u_c=\max_x|I(x)|,$$

or

$$ \frac{\partial\bar u}{\partial\bar t}(\bar x, 0) =
\frac{\sqrt{\lambda_c}}{L}\frac{\max_{x}|V(x)|}{\max_{x,t}|f(x,t)|}
\bar V(\bar x),
\hbox{ if } u_c=t_c^2f_c=\frac{L^2}{\lambda_c}\max_{x,t}|f(x,t)|\tp$$

Introducing the dimensionless number \( \alpha \) (cf. The section <a href="#scale:wave:pde2:Vcond">Velocity initial condition</a>),

$$ \alpha^{-1} = \frac{\sqrt{\lambda_c}}{L}\frac{\max_{x}|V(x)|}{\max_{x,t}|f(x,t)|},
$$

we can write

$$
\frac{\partial\bar u}{\partial\bar t}(\bar x, 0) =
\left\lbrace \begin{array}{ll}
\alpha^{-1}\bar V(\bar x),& u_c=\max_x|I|,\\ 
\alpha^{-1}\beta^{-1}\bar V(\bar x), & u_c=t_c^2f_c
\end{array}\right.
$$

<h2 id="scale:wave:pde2:damped">Damped wave equation</h2>

<p>
A linear damping term \( b\,\partial u/\partial t \) is often added to
the wave equation to model energy dissipation and amplitude reduction.

$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2}
+ b\frac{\partial u}{\partial t} =
\frac{\partial}{\partial x}\left(
\lambda(x) {\partial u\over\partial x}\right) + f(x,t)\tp
\end{equation}
$$

The scaled equation becomes

$$
\frac{\partial^2 \bar u}{\partial \bar t^2}
+ \frac{t_c} b\frac{\partial \bar u}{\partial \bar t} =
\frac{t_c^2\lambda_c}{L^2}\frac{\partial}{\partial \bar x}\left(
\bar \lambda(\bar x) {\partial \bar u\over\partial \bar x}\right) +
\frac{t_c^2f_c}{u_c}\bar f(\bar x,\bar t)\tp
$$

<p>
The damping term is usually much smaller than the two other terms involving
\( \bar u \). The time scale is therefore chosen as in the undamped case,
\( t_c=L/\sqrt{\lambda_c} \). As in the section <a href="#scale:wave:pde2:cvar">Variable wave velocity and forcing</a>,
we have two choices of \( u_c \): \( u_c=\max_x|I| \) or \( u_c=t_c^2f_c \).
The former choice of \( u_c \) gives a PDE with two dimensionless numbers,

$$
\begin{equation}
\frac{\partial^2 \bar u}{\partial \bar t^2}
+ \gamma\frac{\partial \bar u}{\partial \bar t} =
\frac{\partial}{\partial \bar x}\left(
\bar \lambda(\bar x) {\partial\bar u\over\partial\bar x}\right) +
\beta\bar f(\bar x,\bar t),
\end{equation}
$$

where

$$ \gamma = \frac{bL}{\sqrt{\lambda_c}}, $$

measures the size of the damping.
With \( u_c=t_c^2f_c \) we get a PDE where only \( \gamma \) enters,

$$
\begin{equation}
\frac{\partial^2 \bar u}{\partial \bar t^2}
+ \gamma\frac{\partial \bar u}{\partial \bar t} =
\frac{\partial}{\partial \bar x}\left(
\bar \lambda(\bar x) {\partial\bar u\over\partial\bar x}\right) +
\bar f(\bar x,\bar t)\tp
\end{equation}
$$

The scaled initial conditions are as in
the section <a href="#scale:wave:pde2:cvar">Variable wave velocity and forcing</a>.

<p>
To summarize, the effects of \( V \), \( f \), and damping are reflected in
the dimensionless numbers \( \alpha \), \( \beta \), and \( \gamma \),
respectively.

<h2 id="___sec81">A three-dimensional wave equation problem </h2>

<p>
To demonstrate how the scaling extends to and looks like in
three-dimensions, we consider

$$
\begin{equation}
\frac{\partial^2 \bar u}{\partial \bar t^2} =
\frac{\partial}{\partial x}\left(\lambda\frac{\partial u}{\partial x}\right)+
\frac{\partial}{\partial y}\left(\lambda\frac{\partial u}{\partial y}\right)+
\frac{\partial}{\partial z}\left(\lambda\frac{\partial u}{\partial z}\right)\tp
\end{equation}
$$

We introduce

$$ \bar x = \frac{x}{x_c},\quad \bar y = \frac{y}{y_c},
   \quad \bar z = \frac{z}{z_c},
   \quad \bar t = \frac{t}{t_c}, \quad \bar u =\frac{u}{u_c}\tp$$

With \( \bar\lambda = \lambda(\bar xx_c, \bar y y_c, \bar z z_c)/\lambda_c \),
we get

$$
\frac{\partial^2 \bar u}{\partial \bar t^2} =
\frac{t_c^2\lambda_c}{x_c^2}\frac{\partial}{\partial \bar x}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar x}\right)+
\frac{t_c^2\lambda_c}{y_c^2}\frac{\partial}{\partial \bar y}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar y}\right)+
\frac{t_c^2\lambda_c}{z_c^2}\frac{\partial}{\partial \bar z}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar z}\right)\tp
$$

Often, we will set \( x_c=y_c=z_c=L \) where \( L \) is some characteristic
size of the domain.
As before, \( t_c = L/\sqrt{\lambda_c} \), and these choices lead to a
dimensionless wave equation without physical parameters:

$$
\begin{equation}
\frac{\partial^2 \bar u}{\partial \bar t^2} =
\frac{\partial}{\partial \bar x}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar x}\right)+
\frac{\partial}{\partial \bar y}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar y}\right)+
\frac{\partial}{\partial \bar z}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar z}\right)\tp
\end{equation}
$$

The initial conditions remain the same as in the previous one-dimensional
examples.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._scale-solarized005.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._scale-solarized007.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

