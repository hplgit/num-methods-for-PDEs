<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Truncation error analysis">
<meta name="keywords" content="truncation error general,finite differences backward,truncation error Backward Euler scheme,finite differences forward,truncation error Forward Euler scheme,finite differences centered,truncation error Crank-Nicolson scheme,truncation error table of formulas,decay ODE,correction terms,truncation error correction terms,verification">

<title>Truncation error analysis</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Overview of truncation error analysis', 1, None, '___sec0'),
              ('Abstract problem setting', 2, None, '___sec1'),
              ('Error measures', 2, None, '___sec2'),
              ('Truncation errors in finite difference formulas',
               1,
               'trunc:finite:differences',
               'trunc:finite:differences'),
              ("Example: The backward difference for $u'(t)$",
               2,
               'trunc:fd:backward',
               'trunc:fd:backward'),
              ("Example: The forward difference for $u'(t)$",
               2,
               'trunc:fd:forward',
               'trunc:fd:forward'),
              ("Example: The central difference for $u'(t)$",
               2,
               'trunc:fd:central',
               'trunc:fd:central'),
              ('Overview of leading-order error terms in finite difference formulas',
               2,
               'trunc:table',
               'trunc:table'),
              ('Software for computing truncation errors',
               2,
               'trunc:sympy',
               'trunc:sympy'),
              ('Truncation errors in exponential decay ODE',
               1,
               'trunc:decay',
               'trunc:decay'),
              ('Truncation error of the Forward Euler scheme',
               2,
               'trunc:decay:FE',
               'trunc:decay:FE'),
              ('Truncation error of the Crank-Nicolson scheme',
               2,
               'trunc:decay:CN',
               'trunc:decay:CN'),
              ('Truncation error of the $\\theta$-rule',
               2,
               'trunc:decay:theta',
               'trunc:decay:theta'),
              ('Using symbolic software',
               2,
               'trunc:decay:software',
               'trunc:decay:software'),
              ('Empirical verification of the truncation error',
               2,
               'trunc:decay:estimate:R',
               'trunc:decay:estimate:R'),
              ('Increasing the accuracy by adding correction terms',
               2,
               'trunc:decay:corr',
               'trunc:decay:corr'),
              ('Extension to variable coefficients', 2, None, '___sec16'),
              ('Exact solutions of the finite difference equations',
               2,
               None,
               '___sec17'),
              ('Computing truncation errors in nonlinear problems',
               2,
               'trunc:decay:gen',
               'trunc:decay:gen'),
              ('Truncation errors in vibration ODEs',
               1,
               'trunc:vib',
               'trunc:vib'),
              ('Linear model without damping',
               2,
               'trunc:vib:undamped',
               'trunc:vib:undamped'),
              ('The truncation error of a centered finite difference scheme',
               3,
               None,
               '___sec21'),
              ("The truncation error of approximating $u'(0)$",
               3,
               None,
               '___sec22'),
              ('Truncation error of the equation for the first step',
               3,
               None,
               '___sec23'),
              ('Computing correction terms', 3, None, '___sec24'),
              ('Model with damping and nonlinearity',
               2,
               'trunc:vib:gen',
               'trunc:vib:gen'),
              ('Extension to quadratic damping', 2, None, '___sec26'),
              ('The general model formulated as first-order ODEs',
               2,
               'trunc:vib:gen:staggered',
               'trunc:vib:gen:staggered'),
              ('The forward-backward scheme', 3, None, '___sec28'),
              ('A centered scheme on a staggered mesh', 3, None, '___sec29'),
              ('Truncation errors in wave equations', 1, None, '___sec30'),
              ('Linear wave equation in 1D',
               2,
               'trunc:wave:1D',
               'trunc:wave:1D'),
              ('Finding correction terms',
               2,
               'trunc:wave:1D:corr',
               'trunc:wave:1D:corr'),
              ('Extension to variable coefficients',
               2,
               'trunc:wave:1D:varcoeff',
               'trunc:wave:1D:varcoeff'),
              ('1D wave equation on a staggered mesh', 2, None, '___sec34'),
              ('Linear wave equation in 2D/3D',
               2,
               'trunc:wave:2D',
               'trunc:wave:2D'),
              ('Truncation errors in diffusion equations',
               1,
               'trunc:diffu',
               'trunc:diffu'),
              ('Linear diffusion equation in 1D',
               2,
               'trunc:diffu:1D',
               'trunc:diffu:1D'),
              ('The Forward Euler scheme in time', 3, None, '___sec38'),
              ('The Crank-Nicolson scheme in time', 3, None, '___sec39'),
              ('Linear diffusion equation in 2D/3D', 2, None, '___sec40'),
              ('A nonlinear diffusion equation in 2D', 2, None, '___sec41'),
              ('Exercises', 1, None, '___sec42'),
              ('Exercise 1: Truncation error of a weighted mean',
               2,
               'trunc:exer:theta:avg',
               'trunc:exer:theta:avg'),
              ('Exercise 2: Simulate the error of a weighted mean',
               2,
               'trunc:exer:theta:avg2',
               'trunc:exer:theta:avg2'),
              ('Exercise 3: Verify a truncation error formula',
               2,
               'trunc:exer:decay:bw2',
               'trunc:exer:decay:bw2'),
              ('Exercise 4: Truncation error of the Backward Euler scheme',
               2,
               'trunc:exer:decay:BE',
               'trunc:exer:decay:BE'),
              ('Exercise 5: Empirical estimation of truncation errors',
               2,
               'trunc:exer:decay:estimate',
               'trunc:exer:decay:estimate'),
              ('Exercise 6: Correction term for a Backward Euler scheme',
               2,
               'trunc:exer:decay:corr:BE',
               'trunc:exer:decay:corr:BE'),
              ('Exercise 7: Verify the effect of correction terms',
               2,
               'trunc:exer:decay:corr:verify',
               'trunc:exer:decay:corr:verify'),
              ('Exercise 8: Truncation error of the Crank-Nicolson scheme',
               2,
               'trunc:exer:decay:varcoeff:CN',
               'trunc:exer:decay:varcoeff:CN'),
              ("Exercise 9: Truncation error of $u'=f(u,t)$",
               2,
               'trunc:exer:decay:nonlin:BEFE',
               'trunc:exer:decay:nonlin:BEFE'),
              ('Exercise 10: Truncation error of $[D_t D_tu]^n$',
               2,
               'trunc:exer:DtDtu',
               'trunc:exer:DtDtu'),
              ("Exercise 11: Investigate the impact of approximating $u'(0)$",
               2,
               'trunc:exer:vib:ic:fw',
               'trunc:exer:vib:ic:fw'),
              ('Exercise 12: Investigate the accuracy of a simplified scheme',
               2,
               'trunc:exer:vib:fbw',
               'trunc:exer:vib:fbw')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\uexd}[1]{{u_{\small\mbox{e}, #1}}}
\newcommand{\vex}{{v_{\small\mbox{e}}}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
$$




    
<a name="part0001"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._trunc-solarized000.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._trunc-solarized002.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<p>
<!-- 2DO: -->
<!-- truncation error of consistent vs lumped mass matrix for -->
<!-- diffusion and wave equations -->

<p>
<div class="alert alert-block alert-summary alert-text-normal">
<b>Purpose.</b>
<p>
Truncation error analysis provides a widely applicable framework for
analyzing the accuracy of finite difference schemes. This type of
analysis can also be used for finite element and finite volume methods
if the discrete equations are written in finite difference form.  The
result of the analysis is an asymptotic estimate of the error in the
scheme on the form \( Ch^r \), where \( h \) is a discretization parameter
(\( \Delta t \), \( \Delta x \), etc.), \( r \) is a number, known as the convergence
rate, and \( C \) is a constant, typically dependent on the
derivatives of the exact solution.

<p>
Knowing \( r \) gives understanding of the accuracy of the scheme. But
maybe even more important, a powerful verification method for computer
codes is to check that the empirically observed convergence rates in
experiments coincide with the theoretical value of \( r \) found from
truncation error analysis.

<p>
The analysis
can be carried out by hand, by symbolic software, and also
numerically. All three methods will be illustrated.
From examining the symbolic expressions of the truncation error
we can add correction terms to the differential equations in order
to increase the numerical accuracy.
</div>


<p>
In general, the term truncation error refers to the discrepancy that
arises from performing a finite number of steps to approximate a
process with infinitely many steps. The term is used in a number
of contexts, including truncation of infinite series, finite
precision arithmetic, finite differences, and differential equations.
We shall be concerned with computing truncation errors arising in
finite difference formulas and in finite difference discretizations
of differential equations.

<h1 id="___sec0">Overview of truncation error analysis </h1>

<h2 id="___sec1">Abstract problem setting </h2>

<p>
Consider an abstract differential equation

$$ \mathcal{L}(u)=0,$$

where \( \mathcal{L}(u) \) is some formula involving the unknown \( u \) and
its derivatives. One example is \( \mathcal{L}(u)=u'(t)+a(t)u(t)-b(t) \), where
\( a \) and \( b \) are constants or functions of time.
We can discretize the differential equation and obtain a corresponding
discrete model, here written as

$$ \mathcal{L}_{\Delta}(u) =0\tp$$

The solution \( u \) of this equation is the <em>numerical solution</em>.
To distinguish the
numerical solution from the exact solution of the differential
equation problem,
we denote the latter by \( \uex \) and write the
differential equation and its discrete counterpart as

$$
\begin{align*}
\mathcal{L}(\uex)&=0,\\ 
\mathcal{L}_\Delta (u)&=0\tp
\end{align*}
$$

Initial and/or boundary conditions can usually be left out of the truncation
error analysis and are omitted in the following.

<p>
The numerical solution \( u \) is in a finite difference method computed
at a collection of mesh points. The discrete equations represented
by the abstract equation \( \mathcal{L}_\Delta (u)=0 \) are usually
algebraic equations involving \( u \) at some
neighboring mesh points.

<h2 id="___sec2">Error measures </h2>

<p>
A key issue is how accurate the numerical solution is.
The ultimate way of addressing this issue would be to compute
the error \( \uex - u \) at the mesh points. This is usually extremely demanding.
In very simplified problem settings we may, however, manage to
derive formulas for the numerical solution \( u \), and
therefore closed form expressions
for the error \( \uex - u \). Such special cases can provide
considerable insight regarding accuracy and stability, but
the results are established for special problems.

<p>
The error \( \uex -u \) can be computed empirically in special cases where
we know \( \uex \). Such cases can be constructed by the method of
manufactured solutions, where we choose some exact solution \( \uex = v \)
and fit a source term \( f \) in the governing differential equation
\( \mathcal{L}(\uex)=f \) such that \( \uex=v \) is a solution (i.e.,
\( f=\mathcal{L}(v) \)).  Assuming an error model of the form \( Ch^r \),
where \( h \) is the discretization parameter, such as \( \Delta t \) or
\( \Delta x \), one can estimate the convergence rate \( r \). This is a
widely applicable procedure, but the validity of the results is,
strictly speaking, tied to the chosen test problems.

<p>
Another error measure is to ask to what extent the exact solution
\( \uex \) fits the discrete equations. Clearly, \( \uex \) is in general
not a solution of \( \mathcal{L}_\Delta(u)=0 \), but we can define
the residual

$$ R = \mathcal{L}_\Delta(\uex),$$

and investigate how close \( R \) is to zero. A small \( R \) means
intuitively that the discrete equations are close to the
differential equation, and then we are tempted to think that
\( u^n \) must also be close to \( \uex(t_n) \).

<p>
The residual \( R \) is known as the truncation error of the finite
difference scheme \( \mathcal{L}_\Delta(u)=0 \).  It appears that the
truncation error is relatively straightforward to compute by hand or
symbolic software <em>without specializing the differential equation
and the discrete model to a special case</em>. The resulting \( R \) is found
as a power series in the discretization parameters. The leading-order
terms in the series provide an asymptotic measure of the accuracy of
the numerical solution method (as the discretization parameters
tend to zero). An advantage of truncation error analysis compared
empirical estimation of convergence rates or detailed analysis
of a special problem with a mathematical expression for the numerical
solution, is that the truncation error analysis reveals the
accuracy of the various building blocks in the numerical method and
how each building block impacts the overall accuracy. The analysis
can therefore be used to detect building blocks with lower accuracy
than the others.

<p>
Knowing the truncation error or other error measures is important for
verification of programs by empirically establishing convergence
rates. The forthcoming text will provide many examples on how to
compute truncation errors for finite difference discretizations of
ODEs and PDEs.

<h1 id="trunc:finite:differences">Truncation errors in finite difference formulas</h1>

<p>
The accuracy of a finite difference formula is a fundamental issue
when discretizing differential equations. We shall first go through a
particular example in detail and thereafter list the truncation error
in the most common finite difference approximation formulas.

<h2 id="trunc:fd:backward">Example: The backward difference for \( u'(t) \)</h2>

<p>
Consider a backward
finite difference approximation of the first-order derivative \( u' \):

$$
\begin{equation}
\lbrack D_t^- u\rbrack^n  = \frac{u^{n} - u^{n-1}}{\Delta t} \approx u'(t_n)
\tag{1}
\tp
\end{equation}
$$

Here, \( u^n \) means the value of some function \( u(t) \) at a point \( t_n \), and
\( [D_t^-u]^n \) is the <em>discrete derivative</em> of \( u(t) \) at
\( t=t_n \). The discrete derivative computed by a finite difference
is not exactly equal to the derivative \( u'(t_n) \). The error in
the approximation is

$$
\begin{equation}
R^n = [D^-_tu]^n - u'(t_n)\tp
\tag{2}
\end{equation}
$$

<p>
The common way of calculating \( R^n \) is to

<ol>
<li> expand \( u(t) \) in a Taylor series around the point where the
   derivative is evaluated, here \( t_n \),</li>
<li> insert this Taylor series in <a href="#mjx-eqn-2">(2)</a>,
   and</li>
<li> collect terms that cancel and simplify the expression.</li>
</ol>

The result is an expression for \( R^n \) in terms of a power series in
\( \Delta t \). The error \( R^n \) is commonly referred to as the <em>truncation
error</em> of the finite difference formula.

<p>
The Taylor series formula often found in calculus books takes the form
$$ f(x+h) = \sum_{i=0}^\infty \frac{1}{i!}\frac{d^if}{dx^i}(x)h^i\tp  $$

In our application,
we expand the Taylor series around the point where the finite difference
formula approximates the derivative. The Taylor series of \( u^n \) at \( t_n \)
is simply \( u(t_n) \), while the Taylor series of \( u^{n-1} \) at \( t_n \) must
employ the general formula,
$$
\begin{align*}
u(t_{n-1}) = u(t-\Delta t) &= \sum_{i=0}^\infty \frac{1}{i!}\frac{d^iu}{dt^i}(t_n)(-\Delta t)^i\\ 
& = u(t_n) - u'(t_n)\Delta t + {\half}u''(t_n)\Delta t^2
+ \Oof{\Delta t^3},
\end{align*}
$$

where \( \Oof{\Delta t^3} \) means a power-series in \( \Delta t \) where
the lowest power is \( \Delta t^3 \). We assume that \( \Delta t \) is small such that
\( \Delta t^p \gg \Delta t^q \) if \( p \) is smaller than \( q \).
The details of higher-order terms
in \( \Delta t \) are therefore not of much interest.
Inserting the Taylor series above in the left-hand side of1
<a href="#mjx-eqn-2">(2)</a> gives rise to some algebra:

$$
\begin{align*}
[D_t^-u]^n - u'(t_n) &= \frac{u(t_n) - u(t_{n-1})}{\Delta t} - u'(t_n)\\ 
&= \frac{u(t_n) - (u(t_n) - u'(t_n)\Delta t + {\half}u''(t_n)\Delta t^2 + \Oof{\Delta t^3} )}{\Delta t} - u'(t_n)\\ 
&= -{\half}u''(t_n)\Delta t + \Oof{\Delta t^2} ),
\end{align*}
$$

which is, according to
<a href="#mjx-eqn-2">(2)</a>, the truncation error:

$$
\begin{equation}
R^n = - {\half}u''(t_n)\Delta t + \Oof{\Delta t^2} )
\tp
\tag{3}
\end{equation}
$$

The dominating term for small \( \Delta t \) is \( -{\half}u''(t_n)\Delta t \),
which is proportional to \( \Delta t \), and we say that the truncation error
is of <em>first order</em> in \( \Delta t \).

<h2 id="trunc:fd:forward">Example: The forward difference for \( u'(t) \)</h2>

<p>
We can analyze the approximation error in the forward difference

$$ u'(t_n) \approx [D_t^+ u]^n = \frac{u^{n+1}-u^n}{\Delta t},$$

by writing
$$ R^n = [D_t^+ u]^n - u'(t_n),$$

and expanding \( u^{n+1} \) in a Taylor series around \( t_n \),
$$ u(t_{n+1}) = u(t_n) + u'(t_n)\Delta t +
{\half}u''(t_n)\Delta t^2 + \Oof{\Delta t^3}
\tp  $$

The result becomes
$$ R = {\half}u''(t_n)\Delta t +
\Oof{\Delta t^2},$$

showing that also the forward difference is of first order.

<h2 id="trunc:fd:central">Example: The central difference for \( u'(t) \)</h2>

<p>
For the central difference approximation,
$$ u'(t_n)\approx [ D_tu]^n, \quad [D_tu]^n =
\frac{u^{n+\half} - u^{n-\half}}{\Delta t},
$$

we write

$$ R^n = [ D_tu]^n - u'(t_n),$$

and expand \( u(t_{n+\half}) \) and
\( u(t_{n-1/2}) \) in Taylor series around the point \( t_n \) where
the derivative is evaluated. We have
$$
\begin{align*}
u(t_{n+\half}) = &u(t_n) + u'(t_n)\half\Delta t +
{\half}u''(t_n)(\half\Delta t)^2 + \\ 
& \frac{1}{6}u'''(t_n) (\half\Delta t)^3
+ \frac{1}{24}u''''(t_n) (\half\Delta t)^4 + \\ 
& \frac{1}{120}u''''(t_n) (\half\Delta t)^5 + \Oof{\Delta t^6},\\ 
u(t_{n-1/2}) = &u(t_n) - u'(t_n)\half\Delta t +
{\half}u''(t_n)(\half\Delta t)^2 - \\ 
& \frac{1}{6}u'''(t_n) (\half\Delta t)^3
+ \frac{1}{24}u''''(t_n) (\half\Delta t)^4 - \\ 
& \frac{1}{120}u'''''(t_n) (\half\Delta t)^5 + \Oof{\Delta t^6}
\tp
\end{align*}
$$

Now,
$$
u(t_{n+\half}) - u(t_{n-1/2}) = u'(t_n)\Delta t + \frac{1}{24}u'''(t_n) \Delta t^3 + \frac{1}{960}u'''''(t_n) \Delta t^5 + \Oof{\Delta t^7}
\tp
$$

By collecting terms in \( [D_t u]^n - u(t_n) \) we find the truncation error
to be

$$
\begin{equation}
R^n = \frac{1}{24}u'''(t_n)\Delta t^2 + \Oof{\Delta t^4},
\tag{4}
\end{equation}
$$

with only even powers of \( \Delta t \). Since \( R\sim \Delta t^2 \) we say
the centered difference is of <em>second order</em> in \( \Delta t \).

<h2 id="trunc:table">Overview of leading-order error terms in finite difference formulas</h2>

<p>
Here we list the leading-order terms of the truncation errors
associated with several common finite difference formulas for the
first and second derivatives.

$$
\begin{align}
\lbrack D_tu \rbrack^n &= \frac{u^{n+\half} - u^{n-\half}}{\Delta t} = u'(t_n) + R^n
\tag{5},\\ 
R^n &= \frac{1}{24}u'''(t_n)\Delta t^2 + \Oof{\Delta t^4}
\tag{6}\\ 
\lbrack D_{2t}u \rbrack^n &= \frac{u^{n+1} - u^{n-1}}{2\Delta t} = u'(t_n) + R^n
\tag{7},\\ 
R^n &= \frac{1}{6}u'''(t_n)\Delta t^2 + \Oof{\Delta t^4}
\tag{8}\\ 
\lbrack D_t^-u \rbrack^n &= \frac{u^{n} - u^{n-1}}{\Delta t} = u'(t_n) + R^n
\tag{9},\\ 
R^n &= -{\half}u''(t_n)\Delta t + \Oof{\Delta t^2}
\tag{10}\\ 
\lbrack D_t^+u \rbrack^n &= \frac{u^{n+1} - u^{n}}{\Delta t} = u'(t_n) + R^n
\tag{11},\\ 
R^n &= {\half}u''(t_n)\Delta t + \Oof{\Delta t^2}
\tag{12}\\ 
[\bar D_tu]^{n+\theta} &= \frac{u^{n+1} - u^{n}}{\Delta t} = u'(t_{n+\theta}) + R^{n+\theta}
\tag{13},\\ 
R^{n+\theta} &= \half(1-2\theta)u''(t_{n+\theta})\Delta t -
\frac{1}{6}((1 - \theta)^3 - \theta^3)u'''(t_{n+\theta})\Delta t^2 +
\Oof{\Delta t^3}
\tag{14}\\ 
\lbrack D_t^{2-}u \rbrack^n &= \frac{3u^{n} - 4u^{n-1} + u^{n-2}}{2\Delta t} = u'(t_n) + R^n
\tag{15},\\ 
R^n &= -\frac{1}{3}u'''(t_n)\Delta t^2 + \Oof{\Delta t^3}
\tag{16}\\ 
\lbrack D_tD_t u \rbrack^n &= \frac{u^{n+1} - 2u^{n} + u^{n-1}}{\Delta t^2} = u''(t_n) + R^n
\tag{17},\\ 
R^n &= \frac{1}{12}u''''(t_n)\Delta t^2 + \Oof{\Delta t^4}
\tag{18}
\end{align}
$$

<p>
It will also be convenient to have the truncation errors for
various means or averages. The
weighted arithmetic mean leads to
$$
\begin{align}
[\overline{u}^{t,\theta}]^{n+\theta}
& = \theta u^{n+1} + (1-\theta)u^n =
u(t_{n+\theta}) + R^{n+\theta},
\tag{19}\\ 
R^{n+\theta} &= {\half}u''(t_{n+\theta})\Delta t^2\theta (1-\theta) +
\Oof{\Delta t^3}
\tp
\tag{20}
\end{align}
$$

The standard arithmetic mean follows from this formula when
\( \theta=1/2 \). Expressed at point \( t_n \) we get

$$
\begin{align}
[\overline{u}^{t}]^{n} &= \half(u^{n-\half} + u^{n+\half})
= u(t_n) + R^{n},
\tag{21}\\ 
R^{n} &= \frac{1}{8}u''(t_{n})\Delta t^2 + \frac{1}{384}u''''(t_n)\Delta t^4
+ \Oof{\Delta t^6}\tp
\tag{22}
\end{align}
$$

<p>
The geometric mean also has an error \( \Oof{\Delta t^2} \):

$$
\begin{align}
[\overline{u^2}^{t,g}]^{n} &= u^{n-\half}u^{n+\half} = (u^n)^2 + R^n,
\tag{23}\\ 
R^n &= - \frac{1}{4}u'(t_n)^2\Delta t^2  + \frac{1}{4}u(t_n)u''(t_n)\Delta t^2
+ \Oof{\Delta t^4}
\tp
\tag{24}
\end{align}
$$

The harmonic mean is also second-order accurate:

$$
\begin{align}
[\overline{u}^{t,h}]^{n} &= u^n = \frac{2}{\frac{1}{u^{n-\half}} + \frac{1}{u^{n+\half}}}
+ R^{n+\half},
\tag{25}\\ 
R^n &= - \frac{u'(t_n)^2}{4u(t_n)}\Delta t^2 + \frac{1}{8}u''(t_n)\Delta t^2
\tp
\tag{26}
\end{align}
$$

<h2 id="trunc:sympy">Software for computing truncation errors</h2>

<p>
We can use <code>sympy</code> to aid calculations with Taylor series.
The derivatives can be defined as symbols, say <code>D3f</code> for the
3rd derivative of some function \( f \). A truncated Taylor series
can then be written as <code>f + D1f*h + D2f*h**2/2</code>. The following
class takes some symbol <code>f</code> for the function in question
and makes a list of symbols for the derivatives. The
<code>__call__</code> method computes the symbolic form of the series
truncated at <code>num_terms</code> terms.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>

<span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">TaylorSeries</span>:
    <span style="color: #CD5555">&quot;&quot;&quot;Class for symbolic Taylor series.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, f, num_terms=<span style="color: #B452CD">4</span>):
        <span style="color: #658b00">self</span>.f = f
        <span style="color: #658b00">self</span>.N = num_terms
        <span style="color: #228B22"># Introduce symbols for the derivatives</span>
        <span style="color: #658b00">self</span>.df = [f]
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, <span style="color: #658b00">self</span>.N+<span style="color: #B452CD">1</span>):
            <span style="color: #658b00">self</span>.df.append(sym.Symbol(<span style="color: #CD5555">&#39;D%d%s&#39;</span> % (i, f.name)))

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__call__</span>(<span style="color: #658b00">self</span>, h):
        <span style="color: #CD5555">&quot;&quot;&quot;Return the truncated Taylor series at x+h.&quot;&quot;&quot;</span>
        terms = <span style="color: #658b00">self</span>.f
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, <span style="color: #658b00">self</span>.N+<span style="color: #B452CD">1</span>):
            terms += sym.Rational(<span style="color: #B452CD">1</span>, sym.factorial(i))*<span style="color: #658b00">self</span>.df[i]*h**i
        <span style="color: #8B008B; font-weight: bold">return</span> terms
</pre></div>
<p>
We may, for example, use this class to compute the truncation error
of the Forward Euler finite difference formula:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">truncation_errors</span> <span style="color: #8B008B; font-weight: bold">import</span> TaylorSeries
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; u, dt = symbols(<span style="color: #CD5555">&#39;u dt&#39;</span>)
&gt;&gt;&gt; u_Taylor = TaylorSeries(u, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; u_Taylor(dt)
D1u*dt + D2u*dt**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">2</span> + D3u*dt**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">6</span> + D4u*dt**<span style="color: #B452CD">4</span>/<span style="color: #B452CD">24</span> + u
&gt;&gt;&gt; FE = (u_Taylor(dt) - u)/dt
&gt;&gt;&gt; FE
(D1u*dt + D2u*dt**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">2</span> + D3u*dt**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">6</span> + D4u*dt**<span style="color: #B452CD">4</span>/<span style="color: #B452CD">24</span>)/dt
&gt;&gt;&gt; simplify(FE)
D1u + D2u*dt/<span style="color: #B452CD">2</span> + D3u*dt**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> + D4u*dt**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">24</span>
</pre></div>
<p>
The truncation error consists of the terms after the first one (\( u' \)).

<p>
The module file <a href="http://tinyurl.com/nm5587k/trunc/truncation_errors.py" target="_self"><tt>trunc/truncation_errors.py</tt></a> contains another class <code>DiffOp</code> with symbolic expressions for
most of the truncation errors listed in the previous section.
For example:

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; from truncation_errors import DiffOp
&gt;&gt;&gt; from sympy import *
&gt;&gt;&gt; u = Symbol(&#39;u&#39;)
&gt;&gt;&gt; diffop = DiffOp(u, independent_variable=&#39;t&#39;)
&gt;&gt;&gt; diffop[&#39;geometric_mean&#39;]
-D1u**2*dt**2/4 - D1u*D3u*dt**4/48 + D2u**2*dt**4/64 + ...
&gt;&gt;&gt; diffop[&#39;Dtm&#39;]
D1u + D2u*dt/2 + D3u*dt**2/6 + D4u*dt**3/24
&gt;&gt;&gt; &gt;&gt;&gt; diffop.operator_names()
[&#39;geometric_mean&#39;, &#39;harmonic_mean&#39;, &#39;Dtm&#39;, &#39;D2t&#39;, &#39;DtDt&#39;,
 &#39;weighted_arithmetic_mean&#39;, &#39;Dtp&#39;, &#39;Dt&#39;]
</pre></div>
<p>
The indexing of <code>diffop</code> applies names that correspond to the operators:
<code>Dtp</code> for \( D^+_t \), <code>Dtm</code> for \( D_t^- \), <code>Dt</code> for \( D_t \), <code>D2t</code> for
\( D_{2t} \), <code>DtDt</code> for \( D_tD_t \).

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._trunc-solarized000.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._trunc-solarized002.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

