<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Approximation of functions">
<meta name="keywords" content="approximation of vectors in the plane,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation,approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping">

<title>Approximation of functions</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Approximation of vectors ',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              (' Approximation of planar vectors ',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              (' The least squares method ', 3, None, '___sec2'),
              (' The projection method ', 3, None, '___sec3'),
              (' Approximation of general vectors ',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              (' The least squares method ', 3, None, '___sec5'),
              (' The Galerkin or projection method ', 3, None, '___sec6'),
              (' Approximation of functions ',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              (' The least squares method ',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              (' The projection (or Galerkin) method ', 2, None, '___sec9'),
              (' Example: linear approximation ',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              (' Implementation of the least squares method ',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              (' Symbolic integration ', 3, None, '___sec12'),
              (' Fallback on numerical integration ', 3, None, '___sec13'),
              (' Plotting the approximation ', 3, None, '___sec14'),
              (' Perfect approximation ',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              (' Ill-conditioning ',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              (' Fourier series ',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              (' Orthogonal basis functions ',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              (' Numerical computations ', 2, None, '___sec19'),
              (' The interpolation (or collocation) method ',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              (' Example ', 3, None, '___sec21'),
              (' Lagrange polynomials ',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              (' Approximation of a polynomial ', 3, None, '___sec23'),
              (' Successful example ', 3, None, '___sec24'),
              (' Less successful example ', 3, None, '___sec25'),
              (' Remedy for strong oscillations ', 3, None, '___sec26'),
              (' Finite element basis functions ',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              (' Elements and nodes ',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              (' Example ', 3, None, '___sec29'),
              (' The basis functions ', 2, None, '___sec30'),
              (' Construction principles ', 3, None, '___sec31'),
              (' Properties of $\\basphi_i$ ', 3, None, '___sec32'),
              (' Example on piecewise quadratic finite element functions ',
               2,
               None,
               '___sec33'),
              (' Example on piecewise linear finite element functions ',
               2,
               None,
               '___sec34'),
              (' Example on piecewise cubic finite element basis functions ',
               2,
               None,
               '___sec35'),
              (' Calculating the linear system ',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              (' Calculating a specific matrix entry ', 3, None, '___sec37'),
              (' Calculating a general row in the matrix ',
               3,
               None,
               '___sec38'),
              (' Assembly of elementwise computations ',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              (' Mapping to a reference element ',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              (' Example: Integration over a reference element ',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              (' Implementation ',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              (' Integration ',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              (' Linear system assembly and solution ',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              (' Example on computing symbolic approximations ',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              (' Comparison with finite elements and interpolation/collocation ',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              (' Example on computing numerical approximations ',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              (' The structure of the coefficient matrix ',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              (' Applications ',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              (' Sparse matrix storage and solution ',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              (' Comparison of finite element and finite difference approximation ',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              (' Finite difference approximation of given functions ',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              (' Finite difference interpretation of a finite element approximation ',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              (' Making finite elements behave as finite differences ',
               2,
               None,
               '___sec54'),
              (' Computations in physical space ', 3, None, '___sec55'),
              (' Elementwise computations ', 3, None, '___sec56'),
              (' Terminology ', 3, None, '___sec57'),
              (' A generalized element concept ',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              (' Cells, vertices, and degrees of freedom ',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              (' Extended finite element concept ',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              (' Implementation ',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              (' Computing the error of the approximation ',
               2,
               'fem:approx:fe:error',
               'fem:approx:fe:error'),
              (' Example: Cubic Hermite polynomials ',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              (' Numerical integration ', 1, None, '___sec64'),
              (' Newton-Cotes rules ',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              (' Gauss-Legendre rules with optimized points ',
               2,
               None,
               '___sec66'),
              (' Approximation of functions in 2D ',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              (' 2D basis functions as tensor products of 1D functions ',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              (' Example: Polynomial basis in 2D ', 2, None, '___sec69'),
              (' Implementation ',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              (' Extension to 3D ',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              (' Finite elements in 2D and 3D ', 1, None, '___sec72'),
              (' Basis functions over triangles in the physical domain ',
               2,
               None,
               '___sec73'),
              (' Element matrices and vectors ', 3, None, '___sec74'),
              (' Basis functions over triangles in the reference cell ',
               2,
               None,
               '___sec75'),
              (' Affine mapping of the reference cell ', 2, None, '___sec76'),
              (' Isoparametric mapping of the reference cell ',
               2,
               None,
               '___sec77'),
              (' Computing integrals ', 2, None, '___sec78'),
              (' Exercises ', 1, None, '___sec79'),
              (' Exercise 1: Linear algebra refresher I ',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              (' Exercise 2: Linear algebra refresher II ',
               2,
               'fem:approx:exer:linalg2',
               'fem:approx:exer:linalg2'),
              (' Exercise 3: Approximate a three-dimensional vector in a plane ',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              (' Exercise 4: Approximate the exponential function by power functions ',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              (' Exercise 5: Approximate the sine function by power functions ',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              (' Exercise 6: Approximate a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              (' Remarks ', 3, None, '___sec86'),
              (' Exercise 7: Animate the approximation of a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine2',
               'fem:approx:exer:tanh:sine2'),
              (' Exercise 8: Fourier series as a least squares approximation ',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              (' Exercise 9: Approximate a steep function by Lagrange polynomials ',
               2,
               'fem:approx:exer:tanh:Lagrange',
               'fem:approx:exer:tanh:Lagrange'),
              (' Exercise 10: Define nodes and elements ',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              (' Exercise 11: Define vertices, cells, and dof maps ',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              (' Exercise 12: Construct matrix sparsity patterns ',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              (' Exercise 13: Perform symbolic finite element computations ',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              (' Exercise 14: Approximate a steep function by P1 and P2 elements ',
               2,
               'fem:approx:exer:tanh:P1P2',
               'fem:approx:exer:tanh:P1P2'),
              (' Exercise 15: Approximate a steep function by P3 and P4 elements ',
               2,
               'fem:approx:exer:tanh:P3P4',
               'fem:approx:exer:tanh:P3P4'),
              (' Exercise 16: Investigate the approximation error in finite elements ',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              (' Exercise 17: Approximate a step function by finite elements ',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              (' Exercise 18: 2D approximation with orthogonal functions ',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              (' Exercise 19: Use the Trapezoidal rule and P1 elements ',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              (' Problem 20: Compare P1 elements and interpolation ',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              (' Exercise 21: Implement 3D computations with global basis functions ',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              (" Exercise 22: Use Simpson's rule and P2 elements ",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              (' Bibliography ', 1, None, '___sec103')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="approx.html">Approximation of functions</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._approx002.html#fem:approx:vec" style="font-size: 80%;">Approximation of vectors</a></li>
     <!-- navigation toc: --> <li><a href="._approx003.html#fem:approx:global" style="font-size: 80%;">Approximation of functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx004.html#fem:approx:fe" style="font-size: 80%;">Finite element basis functions</a></li>
     <!-- navigation toc: --> <li><a href="._approx005.html#fem:approx:fe:impl" style="font-size: 80%;">Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._approx006.html#fem:approx:fe:fd" style="font-size: 80%;">Comparison of finite element and finite difference approximation</a></li>
     <!-- navigation toc: --> <li><a href="._approx007.html#fem:approx:fe:element" style="font-size: 80%;">A generalized element concept</a></li>
     <!-- navigation toc: --> <li><a href="._approx008.html#___sec64" style="font-size: 80%;">Numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._approx009.html#fem:approx:2D" style="font-size: 80%;">Approximation of functions in 2D</a></li>
     <!-- navigation toc: --> <li><a href="._approx010.html#___sec72" style="font-size: 80%;">Finite elements in 2D and 3D</a></li>
     <!-- navigation toc: --> <li><a href="#___sec79" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._approx012.html#___sec103" style="font-size: 80%;">Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0011"></a>
<!-- !split -->

<h1 id="___sec79">Exercises </h1>

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:linalg1">Exercise 1: Linear algebra refresher I</h2>

<p>
Look up the topic of <em>vector space</em> in your favorite linear algebra
book or search for the term at Wikipedia.
Prove that vectors in the plane \( (a,b) \) form a vector space
by showing that all the axioms of a vector space
are satisfied. Similarly,
prove that all linear functions of the form \( ax+b \) constitute a vector space,
\( a,b\in\Real \).

<p>
On the contrary,
show that all quadratic functions of the form \( 1 + ax^2 + bx \) <em>do not</em>
constitute a vector space.
Filename: <code>linalg1.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:linalg2">Exercise 2: Linear algebra refresher II</h2>

<p>
As an extension of <a href="#fem:approx:exer:linalg1">Exercise 1: Linear algebra refresher I</a>, check out
the topic of <em>inner product spaces</em>. Suggest a possible inner product
for the space of all linear functions of the form \( ax+b \), \( a,b\in\Real \).
Show that this inner product satisfies the
general requirements of an inner product in a vector space.
Filename: <code>linalg2.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:vec:3Dby2D">Exercise 3: Approximate a three-dimensional vector in a plane</h2>

<p>
Given \( \f = (1,1,1) \) in \( \Real^3 \), find the best approximation vector
\( \u \) in the plane spanned by the unit vectors \( (1,0) \) and \( (0,1) \).
Repeat the calculations using the vectors \( (2,1) \) and \( (1,2) \).
Filename: <code>vec111_approx.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:exp:powers">Exercise 4: Approximate the exponential function by power functions</h2>

<p>
Let \( V \) be a function space with basis functions \( x^i \),
\( i=0,1,\ldots,N \).  Find the best approximation to \( f(x)=\exp(-x) \) on
\( \Omega =[0,8] \) among all functions in \( V \) for \( N=2,4,6 \). Illustrate
the three approximations in three separate plots.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_4_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_4_1">

<p>
The exercise is easy to solve if you apply the <code>lest_squares</code> and
<code>comparison_plot</code> functions in the <code>approx1D.py</code> module.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>exp_powers.py</code>.

<p>
<!-- good idea to add them. -->
<!-- Taylor: these polynomials go so far off on [0,8] that it is not a -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:sin:powers">Exercise 5: Approximate the sine function by power functions</h2>

<p>
In this exercise we want to approximate the sine function by polynomials
of order \( N+1 \). Consider two bases:

$$
\begin{align*}
V_1 &= \{x, x^3, x^5, \ldots, x^{N-2}, x^N \}, \\ 
V_2 &= \{1,x,x^2,x^3,\ldots, x^N\}\tp
\end{align*}
$$

The basis \( V_1 \) is motivated by the fact that the Taylor polynomial
approximation to the sine function has only odd powers, while \( V_2 \)
is motivated by the assumption that also the even powers could
improve the approximation in a least-squares setting.

<p>
Compute the best approximation to \( f(x)=\sin(x) \) among all functions in \( V_1 \)
and \( V_2 \) on two domains of increasing sizes:
\( \Omega_{1,k} = [0, k\pi] \), \( k=2,3\ldots,6 \) and
\( \Omega_{2,k} = [-k\pi /2, k\pi/2] \), \( k=2,3\ldots,6 \).
Make plots for all combinations of \( V_1 \), \( V_2 \), \( \Omega_1 \), \( \Omega_2 \),
\( k=2,3,\ldots,6 \).

<p>
Add a plot of the \( N \)-th degree Taylor polynomial approximation of
\( \sin(x) \) around \( x=0 \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_5_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_5_1">

<p>
You can make a loop over \( V_1 \) and \( V_2 \), a loop over
\( \Omega_1 \) and \( \Omega_2 \), and a loop over \( k \). Inside the loops,
call the functions <code>least_squares</code> and
<code>comparison_plot</code> from the <code>approx1D</code> module.
\( N=9 \) is a suggested value.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>sin_powers.py</code>.

<p>
<!-- Solveig explanations based on f-B approx -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:sine1">Exercise 6: Approximate a steep function by sines</h2>

<p>
Find the best approximation of \( f(x) = \tanh (s(x-\pi)) \) on
\( [0, 2\pi] \) in the space \( V \) with basis
\( \baspsi_i(x) = \sin((2i+1)x) \), \( i\in\If = \{0,\ldots,N\} \).
Make a movie showing how \( u=\sum_{j\in\If}c_j\baspsi_j(x) \)
approximates \( f(x) \) as \( N \) grows. Choose \( s \) such that \( f \) is
steep (\( s=20 \) may be appropriate).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_6_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_6_1">

<p>
One may naively call the <code>least_squares_orth</code> and <code>comparison_plot</code>
from the <code>approx1D</code> module in a loop and extend the basis with
one new element in each pass. This approach
implies a lot of recomputations.
A more efficient strategy is to let <code>least_squares_orth</code>
compute with only one basis function at a time and accumulate
the corresponding <code>u</code> in the total solution.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>tanh_sines_approx.py</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3 id="___sec86">Remarks </h3>

<p>
Approximation of a discontinuous (or steep) \( f(x) \) by sines,
results in slow convergence and oscillatory behavior of the
approximation close to the abrupt changes in \( f \).
This is known as the <a href="http://en.wikipedia.org/wiki/Gibbs_phenomenon" target="_self">Gibb's phenomenon</a>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:sine2">Exercise 7: Animate the approximation of a steep function by sines</h2>

<p>
Make a movie that shows how the approximation
in <a href="#fem:approx:exer:tanh:sine1">Exercise 6: Approximate a steep function by sines</a> is improved as \( N \) grows.
Illustrate a smooth case where \( s=0.5 \) and a steep case where \( s=20 \)
in the \( \tanh (s(x-\pi)) \) function.
Filename: <code>tanh_sines_approx_movie.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:Fourier">Exercise 8: Fourier series as a least squares approximation</h2>

<p>
Given a function \( f(x) \) on an interval \( [0,L] \), look up the formula
for the coefficients \( a_j \) and \( b_j \) in the Fourier series of \( f \):

$$
\begin{equation*}
f(x) = a_0 + \sum_{j=1}^\infty a_j\cos \left(j\frac{\pi x}{L}\right)
+ \sum_{j=1}^\infty b_j\sin \left(j\frac{\pi x}{L}\right)\tp
\end{equation*}
$$

<p>
Let an infinite-dimensional vector space \( V \) have the basis functions
\( \cos j\frac{\pi x}{L} \) for \( j=0,1,\dots,\infty \) and
\( \sin j\frac{\pi x}{L} \) for \( j=1,\dots,\infty \).  Show that the least squares
approximation method from the section <a href="._approx003.html#fem:approx:global">Approximation of functions</a> leads to a
linear system whose solution coincides with the standard formulas for
the coefficients in a Fourier series of \( f(x) \) (see also
the section <a href="._approx003.html#fem:approx:global:Fourier">Fourier series</a>). You may choose

$$
\begin{equation*} \baspsi_{2i} = \cos\left( i\frac{\pi}{L}x\right),\quad
\baspsi_{2i+1} = \sin\left( i\frac{\pi}{L}x\right),\end{equation*}
$$

for \( i=0,1,\ldots,N\rightarrow\infty \).

<p>
Choose \( f(x) = \tanh(s(x-\half)) \) on \( \Omega=[0,1] \), which is
a smooth function, but with considerable steepness around \( x=1/2 \)
as \( s \) grows in size.
Calculate the coefficients in the Fourier expansion by
solving the linear system, arising from the least squares or Galerkin
methods, by hand. Plot
some truncated versions of the series together with \( f(x) \) to show how
the series expansion converges for \( s=10 \) and \( s=100 \).
Filename: <code>Fourier_approx.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:Lagrange">Exercise 9: Approximate a steep function by Lagrange polynomials</h2>

<p>
Use interpolation/collocation with uniformly distributed
points and Chebychev nodes to approximate

$$
\begin{equation*} f(x) = -\tanh(s(x-\half)),\quad x\in [0,1],\end{equation*}
$$

by Lagrange polynomials for \( s=10 \) and \( s=100 \), and \( N=3,6,9,11 \).
Make separate plots of the approximation for each combination of
\( s \), point type (Chebyshev or uniform), and \( N \).
Filename: <code>tanh_Lagrange.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:mesh1">Exercise 10: Define nodes and elements</h2>

<p>
Consider a domain \( \Omega =[0,2] \) divided into the three elements
\( [0,1] \), \( [1,1.2] \), and \( [1.2,2] \).

<p>
For P1 and P2 elements, set up the list of coordinates and nodes
(<code>nodes</code>) and the numbers of the nodes that belong to each element
(<code>elements</code>) in two cases: 1) nodes and elements numbered from left to
right, and 2) nodes and elements numbered from right to left.
Filename: <code>fe_numberings1.py.</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:mesh2">Exercise 11: Define vertices, cells, and dof maps</h2>

<p>
Repeat <a href="#fem:approx:fe:exer:mesh1">Exercise 10: Define nodes and elements</a>, but define the
data structures <code>vertices</code>, <code>cells</code>, and <code>dof_map</code> instead of
<code>nodes</code> and <code>elements</code>.
Filename: <code>fe_numberings2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:defmesh:sparsity">Exercise 12: Construct matrix sparsity patterns</h2>

<p>
<a href="#fem:approx:fe:exer:mesh1">Exercise 10: Define nodes and elements</a> describes a element mesh
with a total of five elements, but with two different element and
node orderings. For each of the two orderings,
make a \( 5\times 5 \) matrix and fill in the entries that will be nonzero.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_12_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_12_1">

<p>
A matrix entry \( (i,j) \) is nonzero if \( i \) and \( j \) are nodes in the
same element.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>fe_sparsity_pattern.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Asinwt:symbolic">Exercise 13: Perform symbolic finite element computations</h2>

<p>
Perform symbolic calculations to find formulas for the coefficient matrix
and right-hand side
when approximating \( f(x) = \sin (x) \) on
\( \Omega=[0, \pi] \) by two P1 elements of size \( \pi/2 \).
Solve the system and compare \( u(\pi/2) \) with
the exact value 1.
Filename: <code>sin_approx_P1.py</code>.

<p>
<!-- print sp.simplify(c[1,0].subs('h', sp.pi/2)) -->
<!-- Omega=[0,sp.pi]) -->
<!-- c = approximate(sp.sin(x), symbolic=True, d=1, N_e=2, numint=None, -->
<!-- from fe_approx1D_numint import * -->
<!-- solution: -->

<p>
<!-- that arises on the right-hand side. -->
<!-- which is the integral -->
<!-- Hint: wolframalpha or sympy can help with (1-x)*sin(a*x+b), -->

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:P1P2">Exercise 14: Approximate a steep function by P1 and P2 elements</h2>

<p>
Given

$$
\begin{equation*} f(x) = \tanh(s(x-\half))\end{equation*}
$$

use the Galerkin or least squares method with finite elements to find
an approximate function \( u(x) \). Choose \( s=40 \) and try
\( N_e=4,8,16 \) P1 elements and
\( N_e=2,4,8 \) P2 elements.
Integrate \( f\basphi_i \) numerically.
Filename: <code>tanh_fe_P1P2_approx.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:exer:tanh:P3P4">Exercise 15: Approximate a steep function by P3 and P4 elements</h2>

<p>
Solve <a href="#fem:approx:exer:tanh:P1P2">Exercise 14: Approximate a steep function by P1 and P2 elements</a> using \( N_e=1,2,4 \) P3 and P4
elements. How will a collocation/interpolation method work in
this case with the same number of nodes?
Filename: <code>tanh_fe_P3P4_approx.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Asinwt:interpol:error">Exercise 16: Investigate the approximation error in finite elements</h2>

<p>
The theory <a href="._approx007.html#mjx-eqn-40">(40)</a> from
the section <a href="._approx007.html#fem:approx:fe:error">Computing the error of the approximation</a> predicts that the
error in the Pd approximation of a function
should behave as \( h^{d+1} \), where \( h \) is the length of
the element. Use experiments to verify this
asymptotic behavior (i.e., for small enough \( h \)).
Choose three examples: \( f(x)=Ae^{-\omega x} \) on \( [0,3/\omega] \),
\( f(x) = A\sin (\omega x) \) on \( \Omega=[0, 2\pi/\omega] \) for
constant \( A \) and \( \omega \), and
\( f(x)=\sqrt{x} \) on \( [0,1] \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_16_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_16_1">

<p>
Run a series of experiments: \( (h_i,E_i) \), \( i=0,\ldots,m \), where \( E_i \)
is the \( L^2 \) norm of the error corresponding to element length \( h_i \).
Assume an error model \( E=Ch^r \) and compute \( r \) from two successive
experiments:

$$ r_i = \ln (E_{i+1}/E_i)/\ln (h_{i+1}/h_i),\quad i=0,\ldots,m-1\tp$$

Hopefully, the sequence \( r_0,\ldots,r_{m-1} \) converges to the true
\( r \), and \( r_{m-1} \) can be taken as an approximation to \( r \).
Run such experiments for different \( d \) for the different \( f(x) \) functions.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Pd_approx_error.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:Heaviside">Exercise 17: Approximate a step function by finite elements</h2>

<p>
Approximate the step function

$$
\begin{equation*} f(x) = \left\lbrace\begin{array}{ll}
1 & 0\leq x < \halfi,\\ 
2 & \halfi \leq x \geq \halfi
\end{array}\right.
\end{equation*}
$$

by 2, 4, and 8 P1 and P2 elements. Compare
approximations visually.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_17_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_17_1">

<p>
This \( f \) can also be expressed in terms of the Heaviside function \( H(x) \):
\( f(x) = H(x-\halfi) \).
Therefore, \( f \) can be defined by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">f <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>Heaviside(x <span style="color: #666666">-</span> sp<span style="color: #666666">.</span>Rational(<span style="color: #666666">1</span>,<span style="color: #666666">2</span>))
</pre></div>
<p>
making the <code>approximate</code> function in the
<code>fe_approx1D.py</code> module an obvious candidate to solve the
problem. However, <code>sympy</code> does not handle symbolic integration
with this particular integrand, and the <code>approximate</code> function faces a problem
when converting <code>f</code> to a Python function (for plotting) since
<code>Heaviside</code> is not an available function in <code>numpy</code>. It is better to make
special-purpose code for this case or perform all
calculations by hand.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>Heaviside_approx_P1P2.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:2Dsines:symbolic">Exercise 18: 2D approximation with orthogonal functions</h2>

<p>
Assume we have basis functions \( \basphi_i(x,y) \) in 2D that are
orthogonal
such that \( (\basphi_i,\basphi_j)=0 \) when \( i\neq j \).
The function <code>least_squares</code> in the
file <a href="http://tinyurl.com/nm5587k/fem/fe_approx2D.py" target="_self"><tt>approx2D.py</tt></a> will then spend much time on computing off-diagonal terms
in the coefficient matrix that we know are zero.
To speed up the computations, make a
version <code>least_squares_orth</code> that utilizes the orthogonality among the
basis functions. Apply the function to approximate

$$ f(x,y) = x(1-x)y(1-y)e^{-x-y}$$

on \( \Omega = [0,1]\times [0,1] \) via basis functions

$$ \basphi_i(x,y) = \sin ((p+1)\pi x)\sin((q+1)\pi y),\quad i=q(N_x+1) + p,
$$

where \( p=0,\ldots,N_x \) and \( q=0,\ldots,N_y \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_18_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_18_1">

<p>
Get ideas from the function <code>least_squares_orth</code> in
the section <a href="._approx003.html#fem:approx:global:orth">Orthogonal basis functions</a> and
file <a href="http://tinyurl.com/nm5587k/fem/fe_approx1D.py" target="_self"><tt>approx1D.py</tt></a>.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->
Filename: <code>approx2D_least_squares_orth.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:trapez">Exercise 19: Use the Trapezoidal rule and P1 elements</h2>

<p>
Consider approximation of some \( f(x) \) on an interval \( \Omega \) using
the least squares or Galerkin methods with P1 elements. Derive
the element matrix and vector using the
Trapezoidal rule <a href="._approx008.html#mjx-eqn-41">(41)</a> for calculating
integrals on the reference element. Assemble the contributions, assuming
a uniform cell partitioning, and show that the resulting linear system
has the form \( c_i=f(\xno{i}) \) for \( i\in\If \).
Filename: <code>fe_P1_trapez.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:P1:vs:interp">Problem 20: Compare P1 elements and interpolation</h2>

<p>
We shall approximate the function

$$ f(x) = 1 + \epsilon\sin (2\pi nx),\quad x\in \Omega = [0,1],$$

where \( n\in\Integer \) and \( \epsilon \geq 0 \).

<p>
<b>a)</b>
Plot \( f(x) \) for \( n=1,2,3 \) and find the wave length of the function.

<p>
<b>b)</b>
We want to use \( N_P \) elements per wave length. Show that the number
of elements is then \( nN_P \).

<p>
<b>c)</b>
The critical quantity for accuracy is the number of elements per
wave length, not the element size in itself. It therefore suffices
to study an \( f \) with just one wave length in \( \Omega = [0,1] \).
Set \( \epsilon = 0.5 \).

<p>
Run the least squares or projection/Galerkin method for
\( N_P=2,4,8,16,32 \). Compute the error \( E=||u-f||_{L^2} \).

<p>
<!-- --- begin hint in exercise --- -->

<p>
<a class="glyphicon glyphicon-hand-right showdetails" data-toggle="collapse"
 data-target="#exer_20_1" style="font-size: 80%;"></a>
<b>Hint.</b>
<div class="collapse-group">
<p><div class="collapse" id="exer_20_1">

<p>
Use the <code>fe_approx1D_numint</code> module to compute \( u \) and use
the technique from the section <a href="._approx007.html#fem:approx:fe:error">Computing the error of the approximation</a> to
compute the norm of the error.

<p>
</div></p>
</div>
</p>

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>d)</b>
Repeat the set of experiments in the above point, but
use interpolation/collocation based on the node points to
compute \( u(x) \) (recall that \( c_i \) is now simply \( f(\xno{i}) \)).
Compute the error \( E=||u-f||_{L^2} \).
Which method seems to be most accurate?

<p>
Filename: <code>P1_vs_interp.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:3D:approx3D">Exercise 21: Implement 3D computations with global basis functions</h2>

<p>
Extend the <a href="http://tinyurl.com/nm5587k/fem/approx2D.py" target="_self"><tt>approx2D.py</tt></a> code to 3D
applying ideas from the section <a href="._approx009.html#fem:approx:3D:global">Extension to 3D</a>.
Use a 3D generalization of the test problem in the section <a href="._approx009.html#fem:approx:2D:global:code">Implementation</a> to test the implementation.
Filename: <code>approx3D.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2 id="fem:approx:fe:exer:1D:simpson">Exercise 22: Use Simpson's rule and P2 elements</h2>

<p>
Redo <a href="#fem:approx:fe:exer:1D:trapez">Exercise 19: Use the Trapezoidal rule and P1 elements</a>, but use P2
elements and Simpson's rule based on sampling the integrands at
the nodes in the reference cell.
Filename: <code>fe_P2_simpson.pdf</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._approx010.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._approx012.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

