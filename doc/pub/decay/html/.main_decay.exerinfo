
# Information about all exercises in the file main_decay.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_decay.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': '',
  'file': ['decay_plot_fd_error.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:analysis:exer:fd:exp:plot',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "The purpose of this exercise is to visualize the accuracy of finite difference\napproximations of the derivative of a given function.\nFor any finite difference approximation, take the Forward Euler difference\nas an example, and any specific function, take  $u=e^{-at}$,\nwe may introduce an error fraction\n\n!bt\n\\[ E = \\frac{[D_t^+ u]^n}{u'(t_n)} = \\frac{\\exp{(-a(t_n+\\Delta t))} - \\exp{(-at_n)}}{-a\\exp{(-at_n)}} = -\\frac{1}{a\\Delta t}\\left(\\exp{(-a\\Delta t)}  - 1\\right),\n\\]\n\n!et\nand view $E$ as a function of $\\Delta t$. We expect that\n$\\lim_{\\Delta t\\rightarrow 0}E=1$, while $E$ may deviate significantly from\nunity for large $\\Delta t$. How the error depends on $\\Delta t$ is best\nvisualized in a graph where we use a logarithmic scale on for $\\Delta t$,\nso we can cover many orders of magnitude of that quantity. Here is\na code segment creating an array of 100 intervals, on the logarithmic\nscale, ranging from $10^{-6}$ to $1$ and then plotting $E$ versus\n$p=a\\Delta t$ with logarithmic scale on the $\\Delta t$ axis:\n\n!bc pycod\nfrom numpy import logspace, exp\nfrom matplotlib.pyplot import plot\np = logspace(-6, 1, 101)\ny = -(exp(-p)-1)/p\nsemilog(p, y)\n\n!ec\nIllustrate such errors for the finite difference operators $[D_t^+u]^n$\n(forward), $[D_t^-u]^n$ (backward), and $[D_t u]^n$ (centered).\n\nPerform a Taylor series expansions of the error fractions and find\nthe leading order $r$ in the expressions of type\n$1 + C\\Delta t^r + \\Oof{\\Delta t^{r+1}}$, where $C$ is some constant.",
  'title': 'Visualize the accuracy of finite differences',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:analysis:exer:growth',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': ['growth_demo.py'],
             'hints': [],
             'solution': '',
             'text': 'Run experiments with $\\theta=0, 0.5, 1$ for various values of $\\Delta\nt$ to uncover numerical artifacts. Recall that the exact solution is a\nmonotone, growing function when $a<0$. Oscillations or significantly\nwrong growth are signs of wrong qualitative behavior, which can be\nused to define a stability criterion.\n\nUse the insight to select a few values of $\\Delta t$ that\ndemonstrate all types of numerical artifacts for the three different schemes\n($\\theta=0,0.5,1$). Keep $a$ fixed in these experiments.'},
            {'answer': '',
             'file': ['growth_ampf.py'],
             'hints': ['Modify the "`decay_ampf_plot.py`": "http://tinyurl.com/jvzzcfn/decay/decay_ampf_plot.py" code.'],
             'solution': '',
             'text': 'Write up the amplification factor and plot it for $\\theta=0,0.5,1$\ntogether with the exact one for $a\\Delta t <0$. Use the plot to\nexplain the observations made in the experiments.'}],
  'text': "This exercise asks you to solve the ODE $u'=-au$ with $a<0$ such that\nthe ODE models exponential growth instead of exponential decay.  A\ncentral theme is to investigate numerical artifacts and non-physical\nsolution behavior.",
  'title': 'Explore the $\\theta$-rule for exponential growth',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['test_precision.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:precision',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'It is claimed in Section ref{decay:MMS} that most numerical methods will\nreproduce a linear exact solution to machine precision. Test this\nassertion using the nose test function `test_linear_solution` in the\n"`decay_vc.py`": "http://tinyurl.com/jvzzcfn/decay/decay_vc.py" program.\nVary the parameter `c` from very small, via `c=1` to many larger values,\nand print out the maximum difference between the numerical solution\nand the exact solution. What is the relevant value of the `places`\n(or `delta`) argument to `nose.tools.assert_almost_equal` in each\ncase?',
  'title': 'Experiment with precision in tests and the size of $u$',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_backward2step.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:bw2',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Implement the 2-step backward method (ref{decay:fd2:bw:2step}) for the\nmodel $u'(t) = -a(t)u(t) + b(t)$, $u(0)=I$.  Allow the first step to\nbe computed by either the Backward Euler scheme or the Crank-Nicolson\nscheme. Verify the implementation by choosing $a(t)$ and $b(t)$ such\nthat the exact solution is linear in $t$ (see Section\nref{decay:MMS}). Show mathematically that a linear solution is indeed a\nsolution of the discrete equations.\n\nCompute convergence rates (see Section ref{decay:convergence:rate}) in\na test case $a=\\hbox{const}$ and $b=0$, where we easily have an exact\nsolution, and determine if the choice of a first-order scheme\n(Backward Euler) for the first step has any impact on the overall\naccuracy of this scheme. The expected error goes like $\\Oof{\\Delta t^2}$.",
  'title': 'Implement the 2-step backward scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_AdamsBashforth2.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:AB2',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Implement the 2nd-order Adams-Bashforth method (ref{decay:fd2:AB2})\nfor the decay problem $u'=-a(t)u + b(t)$, $u(0)=I$, $t\\in (0, T]$.\nUse the Forward Euler method for the first step such that the overall\nscheme is explicit. Verify the implementation using an exact\nsolution that is linear in time.\nAnalyze the scheme by searching for solutions $u^n=A^n$ when $a=\\hbox{const}$\nand $b=0$. Compare this second-order secheme to the Crank-Nicolson scheme.",
  'title': 'Implement the 2nd-order Adams-Bashforth scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_AdamsBashforth3.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:AB3',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Implement the 3rd-order Adams-Bashforth method (ref{decay:fd2:AB3})\nfor the decay problem $u'=-a(t)u + b(t)$, $u(0)=I$, $t\\in (0, T]$.\nSince the scheme is explicit, allow it to be started by two steps with\nthe Forward Euler method.  Investigate experimentally the case where\n$b=0$ and $a$ is a constant: Can we have oscillatory solutions for\nlarge $\\Delta t$?",
  'title': 'Implement the 3rd-order Adams-Bashforth scheme',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_RK2_Taylor2.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:exer:RK2:Taylor:analysis',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Show that the schemes (ref{decay:fd2:RK2:s2}) and\n(ref{decay:fd2:Taylor2}) are identical in the case $f(u,t)=-a$, where\n$a>0$ is a constant. Assume that the numerical solution reads\n$u^n=A^n$ for some unknown amplification factor $A$ to be determined.\nFind $A$ and derive stability criteria. Can the scheme produce\noscillatory solutions of $u'=-au$? Plot the numerical and exact\namplification factor.",
  'title': 'Analyze explicit 2nd-order methods',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_leapfrog.py', 'decay_leapfrog.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:leapfrog1',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Implement the Leapfrog scheme for the model equation.\nPlot the solution in the case $a=1$, $b=0$, $I=1$,\n$\\Delta t = 0.01$, $t\\in [0,4]$. Compare with the exact\nsolution $\\uex(t)=e^{-t}$.'},
            {'answer': '',
             'file': None,
             'hints': ["It can be wise to automate the calculations such that it is easy to\nredo the calculations for other types of solutions. Here is\na possible `sympy` function that takes a symbolic expression `u`\n(implemented as a Python function of `t`), fits the `b` term, and\nchecks if `u` fulfills the discrete equations:\n\n!bc pycod\nimport sympy as sp\n\ndef analyze(u):\n    t, dt, a = sp.symbols('t dt a')\n\n    print 'Analyzing u_e(t)=%s' % u(t)\n    print 'u(0)=%s' % u(t).subs(t, 0)\n\n    # Fit source term to the given u(t)\n    b = sp.diff(u(t), t) + a*u(t)\n    b = sp.simplify(b)\n    print 'Source term b:', b\n\n    # Residual in discrete equations; Forward Euler step\n    R_step1 = (u(t+dt) - u(t))/dt + a*u(t) - b\n    R_step1 = sp.simplify(R_step1)\n    print 'Residual Forward Euler step:', R_step1\n\n    # Residual in discrete equations; Leapfrog steps\n    R = (u(t+dt) - u(t-dt))/(2*dt) + a*u(t) - b\n    R = sp.simplify(R)\n    print 'Residual Leapfrog steps:', R\n\ndef u_e(t):\n    return c*t + I\n\nanalyze(u_e)\n# or short form: analyze(lambda t: c*t + I)\n\n!ec"],
             'solution': '',
             'text': 'Show mathematically that a linear solution in $t$ fulfills the\nForward Euler scheme for the first step and the Leapfrog scheme\nfor the subsequent steps. Use this linear solution to verify\nthe implementation, and automate the verification through a nose test.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show that a second-order polynomial in $t$ cannot be a solution of the discrete\nequations. However, if a Crank-Nicolson scheme is used for the first\nstep, a second-order polynomial solves the equations exactly.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': "Create a manufactured solution $u(t)=\\sin(t)$ for the ODE\n$u'=-au+b$.\nCompute the convergence rate of the Leapfrog scheme using this\nmanufactured solution. The expected convergence rate of the\nLeapfrog scheme is $\\Oof{\\Delta t^2}$. Does the use of a\n1st-order method for the first step impact the convergence rate?"},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up a set of experiments to demonstrate that the Leapfrog scheme\n(ref{decay:fd2:leapfrog}) is associated with numerical artifacts\n(instabilities). Document the main results from this investigation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Analyze and explain the\ninstabilities of the Leapfrog scheme (ref{decay:fd2:leapfrog}):\n\n o Choose $a=\\mbox{const}$ and $b=0$. Assume that an exact solution\n   of the discrete equations has\n   the form $u^n=A^n$, where $A$ is an amplification factor to\n   be determined. Derive an equation for $A$ by inserting $u^n=A^n$\n   in the Leapfrog scheme.\n o Compute $A$ either by hand and/or with the aid of `sympy`.\n   The polynomial for $A$ has two roots, $A_1$ and $A_2$. Let\n   $u^n$ be a linear combination $u^n=C_1A_1^n + C_2A_2^n$.\n o Show that one of the roots is the explanation of the instability.\n o Compare $A$ with the exact expression, using a Taylor series approximation.\n o How can $C_1$ and $C_2$ be determined?'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Since the original Leapfrog scheme is unconditionally unstable as time\ngrows, it demands some stabilization.  This can be done by filtering,\nwhere we first find $u^{n+1}$ from the original Leapfrog scheme and\nthen replace $u^{n}$ by $u^n + \\gamma (u^{n-1} - 2u^n +\nu^{n+1})$, where $\\gamma$ can be taken as 0.6.  Implement the filtered\nLeapfrog scheme and check that it can handle tests where the original\nLeapfrog scheme is unstable.'}],
  'text': "A Leapfrog scheme\nfor the ODE $u'(t) = -a(t)u(t) + b(t)$ is defined by\n\n!bt\n\\[ \\lbrack D_{2t}u = -au+b\\rbrack^n\\tp\\]\n\n!et\nA separate method is needed to compute $u^1$. The Forward Euler\nscheme is a possible candidate.\n\n\n\n\n\n\n#A possible test case is\n#$u'=-au + b$, $u(0)=0$, where $\\uex(t)=b/a + (I - b/a)e^{-at}$ if\n#$a$ and $b$ are constants.",
  'title': 'Implement and investigate the Leapfrog scheme',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['decay_schemes_oo.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:fd2:exer:uni',
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Consider the linear ODE problem $u'(t)=-a(t)u(t) + b(t)$, $u(0)=I$.\nExplicit schemes for this problem can be written in the general form\n!bt\n\\begin{equation}\nu^{n+1} = \\sum_{j=0}^m c_ju^{n-j},\nlabel{decay:analysis:exer:sumcj}\n\\end{equation}\n\n!et\nfor some choice of $c_0,\\ldots,c_m$.\nFind expressions for the $c_j$ coefficients in case of the\n$\\theta$-rule, the three-level backward scheme,\nthe Leapfrog scheme, the 2nd-order Runge-Kutta method,\nand the 3rd-order Adams-Bashforth scheme.\n\nMake a class `ExpDecay` that implements the\ngeneral updating formula (ref{decay:analysis:exer:sumcj}).\nThe formula cannot be applied for $n<m$, and for those $n$ values, other\nschemes must be used. Assume for simplicity that we just\nrepeat Crank-Nicolson steps until (ref{decay:analysis:exer:sumcj}) can be used.\nUse a subclass\nto specify the list $c_0,\\ldots,c_m$ for a particular method, and\nimplement subclasses for all the mentioned schemes.\nVerify the implementation by testing with a linear solution, which should\nbe exactly reproduced by all methods.",
  'title': 'Make a unified implementation of many schemes',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['schemes_cooling.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:schemes',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Show in detail how we can apply the ideas of the Forward Euler,\nBackward Euler, Crank-Nicolson, and $\\theta$-rule\ndiscretizations to derive explicit\ncomputational formulas for new temperature values in Newton's law of\ncooling (see Section ref{decay:app:Newton:cooling}):\n\n!bt\n\\begin{equation}\n{dT\\over dt} = -k(T-T_s),\\quad T(0)=T_0\\tp\nlabel{decay:Newton:cooling}\n\\end{equation}\n\n!et\nHere, $T$ is the temperature of the body, $T_s$ is the temperature\nof the surroundings, $t$ is time, $k$ is the heat transfer\ncoefficient, and $T_0$ is the initial temperature of the body.",
  'title': "Derive schemes for Newton's law of cooling",
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['cooling.py'],
  'heading': '=====',
  'hints': ['For verification, try to find an exact solution of the\ndiscrete equations. A trick is to introduce $u=T-T_s$, observe\nthat $u^{n}=(T_0-T_s)A^n$ for some amplification factor $A$,\nand then express this formula in terms of $T^n$.'],
  'keywords': None,
  'label': 'decay:app:exer:cooling:py',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Formulate a $\\theta$-rule for the three schemes in Exercise\nref{decay:app:exer:cooling:schemes} such that you can get the three\nschemes from a single formula by varying the $\\theta$ parameter.\nImplement the method in a function `cooling(T0, k, T_s,\nt_end, dt, theta=0.5)`, where `T0` is the initial temperature, `k` is\nthe heat transfer coefficient, `T_s` is the temperature of the\nsurroundings, `t_end` is the end time of the simulation, `dt` is the\ntime step, and `theta` corresponds to $\\theta$.  The `cooling`\nfunction should return the temperature as an array `T` of values at\nthe mesh points and the time mesh `t`.  Construct verification\nexamples to check that the implementation works.',
  'title': "Implement schemes for Newton's law of cooling",
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['detective.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:murder',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': '# URL: "http://www.biology.arizona.edu/BioMath/tutorials/Applications/Cooling.html"\n\nA detective measures the temperature of a dead body to be 26.7 C at 2\npm. One hour later the temperature is 25.8 C. The question is when\ndeath occurred.\n\nAssume that Newton\'s law of cooling (ref{decay:Newton:cooling}) is an\nappropriate mathematical model for the evolution of the temperature in\nthe body.  First, determine $k$ in (ref{decay:Newton:cooling}) by\nformulating a Forward Euler approximation with one time steep from\ntime 2 am to time 3 am, where knowing the two temperatures allows for\nfinding $k$. Assume the temperature in the air to be 20 C. Thereafter,\nsimulate the temperature evolution from the time of murder, taken as\n$t=0$, when $T=37\\hbox{ C}$, until the temperature reaches 25.8 C. The\ncorresponding time allows for answering when death occurred.',
  'title': 'Find time of murder from body temperature',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['osc_cooling.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:cooling:osc',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "The surrounding temperature $T_s$ in Newton's law of cooling\n(ref{decay:Newton:cooling}) may vary in time. Assume that the\nvariations are periodic with period $P$ and amplitude $a$ around\na constant mean temperature $T_m$:\n!bt\n\\begin{equation}\nT_s(t) = T_m + a\\sin\\left(\\frac{2\\pi}{P}t\\right)\n\\tp\n\\end{equation}\n\n!et\nSimulate a process with the following data: $k=20 \\hbox{ min}^{-1}$,\n$T(0)=5$ C, $T_m=25$ C, $a=2.5$ C, and $P=1$ h. Also experiment with\n$P=10$ min and $P=3$ h. Plot $T$ and $T_s$ in the same plot.",
  'title': 'Simulate an oscillating cooling process',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['carbon14.py'],
  'heading': '=====',
  'hints': ['Use simulations with $5,730\\pm 40$ y as input\nand find the corresponding interval for the result.'],
  'keywords': None,
  'label': 'decay:app:exer:radio:C14',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The "Carbon-14": "http://en.wikipedia.org/wiki/Carbon-14" isotope,\nwhose radioactive decay is used extensively in dating organic material\nthat is tens of thousands of years old, has a half-life of $5,730$\nyears.  Determine the age of an organic material that contains 8.4 percent\nof its initial amount of Carbon-14.  Use a time unit of 1 year in the\ncomputations.  The uncertainty in the half time of Carbon-14 is $\\pm\n40$ years.  What is the corresponding uncertainty in the estimate of\nthe age?',
  'title': 'Radioactive decay of Carbon-14',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['stochastic_decay.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:stoch:nuclear',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The purpose of this exercise is to implement the stochastic model\ndescribed in Section ref{decay:app:nuclear} and show that its\nmean behavior approximates the solution of the corresponding\nODE model.\n\nThe simulation goes on for a time interval $[0,T]$ divided into\n$N_t$ intervals of length $\\Delta t$. We start with $N_0$\natoms. In some time interval, we have $N$ atoms that have survived.\nSimulate $N$ Bernoulli trials with probability $\\lambda\\Delta t$\nin this interval by drawing $N$ random numbers, each being 0 (survival)\nor 1 (decay), where the probability of getting 1 is $\\lambda\\Delta t$.\nWe are interested in the number of decays, $d$, and the number of\nsurvived atoms in the next interval is then $N-d$.\nThe Bernoulli trials\nare simulated by drawing $N$ uniformly distributed real numbers on\n$[0,1]$ and saying that 1 corresponds to a value less than $\\lambda\\Delta t$:\n\n!bc pycod\n# Given lambda_, dt, N\nimport numpy as np\nuniform = np.random.uniform(N)\nBernoulli_trials = np.asarray(uniform < lambda_*dt, dtype=np.int)\nd = Bernoulli_trials.size\n\n!ec\nObserve that `uniform < lambda_*dt` is a boolean array whose true\nand false values become 1 and 0, respectively, when converted to an\ninteger array.\n\nRepeat the simulation over $[0,T]$ a large number of times, compute the average\nvalue of $N$ in each interval, and compare with the solution of\nthe corresponding ODE model.',
  'title': 'Simulate stochastic radioactive decay',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['radioactive_decay_2subst.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:radio:twosubst',
  'no': 16,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Consider two radioactive substances A and B. The nuclei in substance A\ndecay to form nuclei of type B with a half-life $A_{1/2}$, while\nsubstance B decay to form type A nuclei with a half-life $B_{1/2}$.\nLetting $u_A$ and $u_B$ be the fractions of the initial amount of\nmaterial in substance A and B, respectively, the following system of\nODEs governs the evolution of $u_A(t)$ and $u_B(t)$:\n!bt\n\\begin{equation}\n\\frac{1}{\\ln 2} u_A' = u_B/B_{1/2} - u_A/A_{1/2},\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\frac{1}{\\ln 2} u_B' = u_A/A_{1/2} - u_B/B_{1/2},\n\\end{equation}\n\n!et\nwith $u_A(0)=u_B(0)=1$.\n\nMake a simulation program that solves for $u_A(t)$ and $u_B(t)$.\nVerify the implementation by computing analytically\nthe limiting values of\n$u_A$ and $u_B$ as $t\\rightarrow \\infty$ (assume $u_A',u_B'\\rightarrow 0$)\nand comparing these with those obtained numerically.\n\nRun the program for the case of $A_{1/2}=10$ minutes and $B_{1/2}=50$ minutes.\nUse a time unit of 1 minute. Plot $u_A$ and $u_B$ versus time in the same\nplot.",
  'title': 'Radioactive decay of two substances',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['atmospheric_pressure.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:atm1',
  'no': 17,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'We consider the models for atmospheric pressure in\nSection ref{decay:app:atm}.\nMake a program with three functions,\n\n * one computing the pressure $p(z)$ using a seven-layer model\n   and varying $L$,\n * one computing $p(z)$ using a seven-layer model,\n   but with constant temperature in each layer, and\n * one computing $p(z)$ based on the\n   one-layer model.\n\nHow can these implementations be verified? Should ease of verification\nimpact how you code the functions?\nCompare the three models in a plot.',
  'title': 'Simulate the pressure drop in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['vertical_motion.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:prog',
  'no': 18,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Implement the Stokes' drag model (ref{decay:app:fallingbody:model:S})\nand the quadratic drag model (ref{decay:app:fallingbody:model:q}) from\nSection ref{decay:app:drag}, using the Crank-Nicolson\nscheme and a geometric mean for $|v|v$ as explained, and assume\nconstant fluid density.\nAt each time level, compute the Reynolds number\nRe and choose the Stokes' drag model if $\\hbox{Re} < 1$ and the\nquadratic drag model otherwise.\n\nThe computation of the numerical solution should take place either in\na stand-alone function (as in Section ref{decay:py1}) or in a solver class\nthat looks up a problem class for physical data (as in Section\nref{decay:prog:se:class}). Create a module (see Section\nref{decay:prog:se:module}) and equip it with nose tests (see Section\nref{decay:prog:se:nose}) for automatically verifying the code.\n\nVerification tests can be based on\n\n * the terminal velocity (see Section ref{decay:app:drag}),\n * the exact solution when the drag force is neglected\n   (see Section ref{decay:app:drag}),\n * the method of manufactured solutions (see Section ref{decay:MMS})\n   combined with computing\n   convergence rates (see Section ref{decay:convergence:rate}).\n\nUse, e.g., a quadratic polynomial for the velocity in the method of\nmanufactured solutions. The expected error is $\\Oof{\\Delta t^2}$\nfrom the centered finite difference approximation and the geometric\nmean approximation for $|v|v$.\n\nA solution that is linear in $t$ will also be an exact solution of the\ndiscrete equations in many problems.  Show that this is true for\nlinear drag (by adding a source term that depends on $t$), but not\nfor quadratic drag because of the geometric mean approximation.  Use\nthe method of manufactured solutions to add a source term *in the\ndiscrete equations for quadratic drag* such that a linear function of\n$t$ is a solution. Add a nose test for checking that the linear\nfunction is reproduced to machine precision in the case of both linear\nand quadratic drag.\n\nApply the software to a case where a ball rises in water.  The\nbuoyancy force is here the driving force, but the drag will be\nsignificant and balance the other forces after a short time.  A soccer\nball has radius 11 cm and mass 0.43 kg.  Start the motion from rest, set\nthe density of water, $\\varrho$, to $1000\\hbox{ kg/m}^3$, set the\ndynamic viscosity, $\\mu$, to $10^{-3}\\hbox{ Pa s}$, and use a drag\ncoefficient for a sphere: 0.45. Plot the velocity of the rising ball.",
  'title': 'Make a program for vertical motion in a fluid',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['skydiving.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:parachute',
  'no': 19,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up the differential equation problem that governs the velocity\nof the motion.\nThe parachute jumper is subject to the gravity force and a quadratic\ndrag force. Assume constant density.\nAdd an extra source term be used for program verification.\nIdentify the input data to the problem.'},
            {'answer': '',
             'file': None,
             'hints': ['Use the Crank-Nicolson scheme with a geometric mean of $|v|v$ in time to\nlinearize the equation of motion with quadratic drag.',
                       'You can either use functions or classes for implementation.\nIf you choose functions, make a function\n`solver` that takes all the input data in the problem as\narguments and that returns the velocity (as a mesh function) and\nthe time mesh. In case of a class-based implementation, introduce\na problem class with the physical data\nand a solver class with the numerical data and a `solve` method\nthat stores the velocity and the mesh in the class.\n\nAllow for a time-dependent area and drag coefficient in the\nformula for the drag force.'],
             'solution': '',
             'text': 'Make a Python module for computing the velocity of the motion.\nAlso equip the module with functionality for plotting the velocity.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show that a linear function of $t$ does not fulfill the discrete\nequations because of the geometric mean approximation\nused for the quadratic drag\nterm.  Fit a source term, as in the method of manufactured solutions,\nsuch that a linear function of $t$ is a solution of the discrete\nequations. Make a nose test to check that this solution is reproduced\nto machine precision.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'The expected error in this problem goes like $\\Delta t^2$ because we\nuse a centered finite difference approximation with error $\\Oof{\\Delta t^2}$\nand a geometric mean approximation with error $\\Oof{\\Delta t^2}$.\nUse the method of manufactured solutions combined with computing\nconvergence rate to verify the code. Make a nose test for checking\nthat the convergence rate is correct.'},
            {'answer': '',
             'file': None,
             'hints': ['You can either make a function `forces(v, t, plot=None)`\nthat returns the forces (as mesh functions) and `t` and shows\na plot on the screen and also saves the plot to a file with name `plot`\nif `plot` is not `None`, or you can extend the solver class with\ncomputation of forces and include plotting of forces in the\nvisualization class.'],
             'solution': '',
             'text': 'Compute the drag force, the gravity\nforce, and the buoyancy force as a function of time. Create\na plot with these three forces.'},
            {'answer': '',
             'file': None,
             'hints': ['Meade and Struthers cite{parachute_1999} provide some data relevant\nto "skydiving": "http://en.wikipedia.org/wiki/Parachuting".\nThe mass of the human body and equipment\ncan be set to $100$ kg.\nA skydiver in spread-eagle formation has a cross-section of 0.5 $\\hbox{m}^2$\nin the horizontal plane.\nThe density of air decreases varies altitude, but can be taken\nas constant, 1 $\\hbox{kg/m}^3$, for altitudes relevant to\nskydiving (0-4000 m).\nThe drag coefficient for a man in upright position can be set to 1.2.\nStart with a zero velocity.\nA free fall typically has a terminating velocity of 45 m/s. (This value\ncan be used to tune other parameters.)'],
             'solution': '',
             'text': 'Compute the velocity of\na skydiver in free fall before the parachute opens.'},
            {'answer': '',
             'file': None,
             'hints': ['Following Meade and Struthers cite{parachute_1999}, one can set the\ncross-section area perpendicular to the motion to 44 $\\hbox{m}^2$\nwhen the parachute is open. Assume that it takes 8 s to increase\nthe area linearly from the original to the final value.\nThe drag coefficient for an open\nparachute can be taken as 1.8, but tuned using the known value\nof the typical terminating velocity reached before landing:\n5.3 m/s. One can take the drag coefficient as a piecewise constant\nfunction with an abrupt change at $t_p$.\nThe parachute is typically released after $t_p=60$ s, but\nlarger values of $t_p$ can be used to make plots more illustrative.'],
             'solution': '',
             'text': 'The next task is to simulate\na parachute jumper during free fall and after the parachute opens.\nAt time $t_p$, the parachute opens and\nthe drag coefficient and the cross-sectional\narea change dramatically.\nUse the program to simulate a jump from $z=3000$ m to the ground $z=0$.\nWhat is the maximum acceleration, measured in units of $g$,\nexperienced by the jumper?'}],
  'text': 'The aim of this project is to develop a general solver for the\nvertical motion of a body with quadratic air drag, verify the solver,\napply the solver to a skydiver in free fall, and finally apply the\nsolver to a complete parachute jump.\n\nAll the pieces of software implemented in this project\nshould be realized as Python functions and/or classes and collected\nin one module.',
  'title': 'Simulate parachuting',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['falling_in_variable_density.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:atm1',
  'no': 20,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Vertical motion of a body in the atmosphere needs to take into\naccount a varying air density if the range of altitudes is\nmany kilometers. In this case, $\\varrho$ varies with the altitude $z$.\nThe equation of motion for the body is given in\nSection ref{decay:app:drag}. Let us assume quadratic drag force\n(otherwise the body has to be very, very small).\nA differential equation problem for the air density, based on\nthe information for the one-layer atmospheric model in\nSection ref{decay:app:atm}, can be set up as\n\n!bt\n\\begin{equation}\np'(z) = -\\frac{Mg}{R^*(T_0+Lz)} p,\n\\end{equation}\n\n!et\n\n!bt\n\\begin{equation}  \n\\varrho = p \\frac{M}{R^*T}\n\\tp\n\\end{equation}\n\n!et\nTo evaluate $p(z)$ we need the altitude $z$. From the principle that the\nvelocity is the derivative of the position we have that\n\n!bt\n\\begin{equation}\nz'(t) = v(t),\n\\end{equation}\n\n!et\nwhere $v$ is the velocity of the body.\n\nExplain in detail how the governing equations can be discretized\nby the Forward Euler and the Crank-Nicolson methods.",
  'title': 'Formulate vertical motion in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['falling_in_variable_density.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:drag:atm2',
  'no': 21,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement the Forward Euler or the Crank-Nicolson scheme\nderived in Exercise ref{decay:app:exer:drag:atm1}.\nDemonstrate the effect of air density variation on a falling\nhuman, e.g., the famous fall of "Felix Baumgartner": "http://en.wikipedia.org/wiki/Felix_Baumgartner". The drag coefficient can be set to 1.2.\n\n__Remark.__\nIn the Crank-Nicolson scheme one must solve a $3\\times 3$ system of\nequations at each time level, since $p$, $\\varrho$, and $v$ are\ncoupled, while each equation can be stepped forward at a time with the\nForward Euler scheme.',
  'title': 'Simulate vertical motion in the atmosphere',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['signum.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:signum',
  'no': 22,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "Consider the ODE problem\n!bt\n\\[\ny'(x) = \\left\\lbrace\\begin{array}{ll}\n-1, & x < 0,\\\\ \n1, & x \\geq 0\n\\end{array}\\right.\\quad x\\in (-1, 1],\n\\quad y(1-)=1,\n\\]\n\n!et\nwhich has the solution $y(x)=|x|$.\nUsing a mesh $x_0=-1$, $x_1=0$, and $x_2=1$, calculate by hand\n$y_1$ and $y_2$ from the Forward Euler, Backward Euler, Crank-Nicolson,\nand Leapfrog methods. Use all of the former three methods for computing\nthe $y_1$ value to be used in the Leapfrog calculation of $y_2$.\nThereafter, visualize how these schemes perform for a uniformly partitioned\nmesh with $N=10$ and $N=11$ points.",
  'title': 'Compute $y=|x|$ by solving an ODE',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['random_interest.py'],
  'heading': '=====',
  'hints': ['The following code snippet computes $p^{n+1}$:\n63 <<<!!CODE_BLOCK  pycod',
            'If $u_i(t)$ is the value of the fortune in experiment number $i$,\n$i=0,\\ldots,N-1$,\nthe mean evolution of the fortune is\n218 <<<!!MATH_BLOCK\nand the standard deviation is\n219 <<<!!MATH_BLOCK\nSuppose $u_i(t)$ is stored in an array `u`.\nThe mean and the standard deviation of the fortune\nis most efficiently computed by\nusing two accumulation arrays, `sum_u` and `sum_u2`, and\nperforming `sum_u += u` and `sum_u2 += u**2` after every experiment.\nThis technique avoids storing all the $u_i(t)$ time series for\ncomputing the statistics.'],
  'keywords': None,
  'label': 'decay:app:exer:interest',
  'no': 23,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The goal of this exercise is to compute the value of a fortune subject\nto inflation and a random interest rate.\nSuppose that the inflation is constant at $i$ percent per year and that the\nannual interest rate, $p$, changes randomly at each time step,\nstarting at some value $p_0$ at $t=0$.\nThe random change is from a value $p^n$ at $t=t_n$ to\n$p_n +\\Delta p$ with probability 0.25 and $p_n -\\Delta p$ with probability 0.25.\nNo change occurs with probability 0.5. There is also no change if\n$p^{n+1}$ exceeds 15 or becomes below 1.\nUse a time step of one month, $p_0=i$, initial fortune scaled to 1,\nand simulate 1000 scenarios of\nlength 20 years. Compute the mean evolution of one unit of money and the\ncorresponding\nstandard deviation. Plot the mean curve along with the mean plus one\nstandard deviation and the mean minus one standard deviation. This will\nillustrate the uncertainty in the mean curve.',
  'title': 'Simulate growth of a fortune with random interest rate',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:pop:at',
  'no': 24,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': ['population_drop.py'],
             'hints': [],
             'solution': '',
             'text': 'Assume that there is a sudden drop (increase) in the birth (death)\nrate at time $t=t_r$,\nbecause of limited nutrition or food supply:\n!bt\n\\[ a(t) =\\left\\lbrace\\begin{array}{ll}\nr_0, & t< t_r,\\\\ \nr_0 - A, & t\\geq t_r,\\end{array}\\right.\n\\]\n\n!et\nThis drop in population growth is compensated by a sudden net immigration\nat time $t_f>t_r$:\n!bt\n\\[ f(t) =\\left\\lbrace\\begin{array}{ll}\n0, & t< t_f,\\\\ \nf_0, & t\\geq t_a,\\end{array}\\right.\n\\]\n\n!et\nStart with $r_0$ and make $A>r_0$. Experiment with\nthese and other parameters to\nillustrate the interplay of growth and decay in such a problem.'},
            {'answer': '',
             'file': ['population_osc.py'],
             'hints': [],
             'solution': '',
             'text': 'Now we assume that the environmental conditions changes periodically with\ntime so that we may take\n!bt\n\\[ r(t) = r_0 + A\\sin\\left(\\frac{2\\pi}{P}t\\right)\n\\tp\n\\]\n\n!et\nThat is, the combined birth and death rate oscillates around $r_0$ with\na maximum change of $\\pm A$ repeating over a period of length $P$ in time.\nSet $f=0$ and experiment with the other parameters to illustrate typical\nfeatures of the solution.'}],
  'text': 'We shall study a population modeled by (ref{decay:app:pop:ueq}) where\nthe environment, represented by $r$ and $f$, undergoes changes with time.',
  'title': 'Simulate a population in a changing environment',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['logistic_CN.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:pop:logistic1',
  'no': 25,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Solve the logistic ODE\n(ref{decay:app:pop:logistic}) using a Crank-Nicolson scheme where\n$(u^{n+\\half})^2$ is approximated by a *geometric mean*:\n!bt\n\\[ (u^{n+\\half})^2 \\approx u^{n+1}u^n\n\\tp\n\\]\n\n!et\nThis trick makes the discrete equation linear in $u^{n+1}$.',
  'title': 'Simulate logistic growth',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['interest_modeling.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'decay:app:exer:interest:derive',
  'no': 26,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The ODE model (ref{decay:app:interest:eq2}) was derived under the assumption\nthat $r$ was constant. Perform an alternative derivation without\nthis assumption: 1) start with (ref{decay:app:interest:eq1});\n2) introduce a time step $\\Delta t$ instead of $m$: $\\Delta t = 1/m$ if\n$t$ is measured in years; 3) divide by $\\Delta t$ and take the\nlimit $\\Delta t\\rightarrow 0$. Simulate a case where the inflation is\nat a constant level $I$ percent per year and the interest rate oscillates:\n$r=-I/2 + r_0\\sin(2\\pi t)$.\nCompare solutions for $r_0=I, 3I/2, 2I$.',
  'title': 'Rederive the equation for continuous compound interest',
  'type': 'Exercise',
  'type_visible': True}]