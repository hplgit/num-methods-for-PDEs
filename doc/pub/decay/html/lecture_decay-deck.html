<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Intro to Computing with Finite Difference Methods">
<meta name="keywords" content="decay (problem),exponential decay,mesh,grid,mesh function,finite differences,difference equation,discrete equation,algebraic equation,finite difference scheme,Forward Euler scheme,backward scheme, 1-step,Backward Euler scheme,Crank-Nicolson scheme,weighted average,theta-rule,$\theta$-rule,finite difference operator notation,operator notation, finite differences,stability,consistency,stability,convergence,lambda functions,method of manufactured solutions,MMS (method of manufactured solutions),implicit schemes,explicit schemes,theta-rule,$\theta$-rule,backward scheme, 2-step,BDF2 scheme,Leapfrog scheme,Leapfrog scheme, filtered,Heun's method,Runge-Kutta, 2nd-order scheme,Adams-Bashforth scheme, 2nd order,Adams-Bashforth scheme, 3rd order">

<title>Study guide: Intro to Computing with Finite Difference Methods</title>






<!-- deck.js: https://github.com/imakewebthings/deck.js -->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=1024, user-scalable=no">

<!-- Required stylesheet -->
<link rel="stylesheet" href="deck.js/core/deck.core.css">

<!-- Extension CSS files go here. Remove or add as needed.
deck.goto: Adds a shortcut key to jump to any slide number.
Hit g, type in the slide number, and hit enter.

deck.hash: Enables internal linking within slides, deep
linking to individual slides, and updates the address bar and
a permalink anchor with each slide change.

deck.menu: Adds a menu view, letting you see all slides in a grid.
Hit m to toggle to menu view, continue navigating your deck,
and hit m to return to normal view. Touch devices can double-tap
the deck to switch between views.

deck.navigation: Adds clickable left and right buttons for the
less keyboard inclined.

deck.status: Adds a page number indicator. (current/total).

deck.scale: Scales each slide to fit within the deck container
using CSS Transforms for those browsers that support them.

deck.pointer: Turn mouse into laser pointer (toggle with p).
(Requires https://github.com/mikeharris100/deck.pointer.js)
-->

<link rel="stylesheet" href="deck.js/extensions/menu/deck.menu.css">
<link rel="stylesheet" href="deck.js/extensions/navigation/deck.navigation.css">
<link rel="stylesheet" href="deck.js/extensions/scale/deck.scale.css">
<link rel="stylesheet" href="deck.js/extensions/pointer/deck.pointer.css">
<link rel="stylesheet" href="deck.js/extensions/notes/deck.notes.css">
<!--
<link rel="stylesheet" href="deck.js/extensions/goto/deck.goto.css">
<link rel="stylesheet" href="deck.js/extensions/hash/deck.hash.css">
<link rel="stylesheet" href="deck.js/extensions/status/deck.status.css">
-->

<!-- Style theme. More available in themes/style/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">

<!--
<link rel="stylesheet" href="deck.js/themes/style/neon.css">
<link rel="stylesheet" href="deck.js/themes/style/swiss.css">
<link rel="stylesheet" href="deck.js/themes/style/web-2.0.css">

git clone git://github.com/duijf/mnml.git
<link rel="stylesheet" href="deck.js/themes/style/mnml.css">

git://github.com/groovecoder/deckjs-theme-mozilla.git
<link rel="stylesheet" href="deck.js/themes/style/sandstone.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.aurora.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.dark.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.firefox.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.light.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.mdn.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.nightly.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.cbc.css">

git://github.com/barraq/deck.ext.js.git
<link rel="stylesheet" href="deck.js/themes/style/beamer.css">
-->

<!-- Transition theme. More available in /themes/transition/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
<!--
<link rel="stylesheet" href="deck.js/themes/transition/fade.css">
<link rel="stylesheet" href="deck.js/themes/transition/vertical-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
-->

<!-- Required Modernizr file -->
<script src="deck.js/modernizr.custom.js"></script>

<style type="text/css">
    hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
    hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
    .slide .alert-text-small   { font-size: 80%;  }
    .slide .alert-text-large   { font-size: 130%; }
    .slide .alert-text-normal  { font-size: 90%;  }
    .slide .alert {
             padding:8px 35px 8px 14px; margin-bottom:18px;
             text-shadow:0 1px 0 rgba(255,255,255,0.5);
             border:5px solid #bababa;
               -webkit-border-radius:14px; -moz-border-radius:14px;
             border-radius:14px
             background-position: 10px 10px;
             background-repeat: no-repeat;
             background-size: 38px;
             padding-left: 30px; /* 55px; if icon */
     }
     .slide .alert-block {padding-top:14px; padding-bottom:14px}
     .slide .alert-block > p, .alert-block > ul {margin-bottom:0}
     /*.slide .alert li {margin-top: 1em}*/
     .deck .alert-block p+p {margin-top:5px}
     /*.slide .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_notice.png); }
     .slide .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_summary.png); }
     .slide .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_warning.png); }
     .slide .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body class="deck-container">

<header>
<!-- Here goes a potential header -->
</header>

<!-- do not use the article tag - it gives strange sizings -->





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
$$




    



<section class="slide">
<!-- ------------------- main content ---------------------- -->



<center><h1>Study guide: Intro to Computing with Finite Difference Methods</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b style="font-weight: bold">Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b style="font-weight: bold">Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b style="font-weight: bold">Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Aug 30, 2014</h4></center> <!-- date -->
<p>

</section>


<section class="slide">

<h1>INF5620 in a nutshell <a name="5620:about"></a></h1>

<ul>
 <p><li> Numerical methods for partial differential equations (PDEs)</li>
 <p><li> How do we solve a PDE in practice and produce numbers?</li>
 <p><li> How do we trust the answer?</li>
 <p><li> Approach: <em>simplify, understand, generalize</em></li>
</ul>
<p>

<div class="alert alert-block alert-summary alert-text-normal">
<b style="font-weight: bold">After the course.</b>
<p>
You see a PDE and can't wait to program a method
and visualize a solution! Somebody asks if the solution is right
and you can give a convincing answer.
</div>


<p>

</section>


<section class="slide">

<h2>The new official six-point course description  <a name="___sec1"></a></h2>

After having completed INF5620 you

<p>


<ul>
 <p><li class="slide"> can derive methods and implement them to solve frequently
   arising partial differential equations (PDEs) from physics and mechanics.</li>
 <p><li class="slide"> have a good understanding of finite difference and finite element
   methods and how they are applied in linear and nonlinear PDE problems.</li>
 <p><li class="slide"> can identify numerical artifacts and perform mathematical analysis
   to understand and cure non-physical effects.</li>
 <p><li class="slide"> can apply sophisticated programming techniques in Python, combined
   with Cython, C, C++, and Fortran code, to create modern,
   flexible simulation programs.</li>
 <p><li class="slide"> can construct verification tests and automate them.</li>
 <p><li class="slide"> have experience with project hosting sites (GitHub),
   version control systems (Git), report writing (LaTeX),
   and Python scripting for performing reproducible computational science.</li>
</ul>
<p>



<p>

</section>


<section class="slide">

<h2>More specific contents: finite difference methods  <a name="___sec2"></a></h2>

<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>

<ul>
   <p><li> ODEs</li>
   <p><li> the wave equation \( u_{tt}=u_{xx} \) in 1D, 2D, 3D</li>
   <p><li> the diffusion equation \( u_t=u_{xx} \) in 1D, 2D, 3D</li>
   <p><li> write your own software from scratch</li>
   <p><li> understand how the methods work and why they fail</li>
</ul>
</div>


<p>

</section>


<section class="slide">

<h2>More specific contents: finite element methods  <a name="___sec3"></a></h2>

<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>

<ul>
   <p><li> stationary diffusion equations \( u_{xx}=f \) in 1D</li>
   <p><li> time-dependent diffusion and wave equations in 1D</li>
   <p><li> PDEs in 2D and 3D by use of the FEniCS software</li>
   <p><li> perform hand-calculations, write your own software (1D)</li>
   <p><li> understand how the methods work and why they fail</li>
</ul>
</div>


<p>

</section>


<section class="slide">

<h2>More specific contents: nonlinear and advanced problems  <a name="___sec4"></a></h2>

<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold"></b>
<p>

<ul>
 <p><li> Nonlinear PDEs</li>

<ul>
   <p><li> Newton and Picard iteration methods, finite differences and elements</li>
</ul>
<p>

 <p><li> More advanced PDEs for fluid flow and elasticity</li>
 <p><li> Parallel computing</li>
</ul>
</div>


<p>

</section>


<section class="slide">

<h2>Philosophy: simplify, understand, generalize  <a name="___sec5"></a></h2>

<ul>
 <p><li> Start with simplified ODE/PDE problems</li>
 <p><li> Learn to reason about the discretization</li>
 <p><li> Learn to implement, verify, and experiment</li>
 <p><li> Understand the method, program, and results</li>
 <p><li> Generalize the problem, method, and program</li>
</ul>
<p>

This is the power of applied mathematics!

<p>

</section>


<section class="slide">

<h2>The exam  <a name="___sec6"></a></h2>



<ul>
 <p><li class="slide"> Oral exam</li>
 <p><li class="slide"> 6 problems (topics) are announced two weeks before the exam</li>
 <p><li class="slide"> Work out a 20 min presentations (talks) for each problem</li>
 <p><li class="slide"> At the exam: throw a die to pick your problem to be presented</li>
 <p><li class="slide"> Aids: plots, computer programs</li>
 <p><li class="slide"> Why? Very effective way of learning</li>
 <p><li class="slide"> Sure? Excellent results over 15 years</li>
 <p><li class="slide"> When? Late december</li>
</ul>
<p>



<p>

</section>


<section class="slide">

<h2>Required software  <a name="___sec7"></a></h2>

<ul>
 <p><li> Our software platform: Python (sometimes combined with Cython,
   Fortran, C, C++)</li>
 <p><li> Important Python packages: <code>numpy</code>, <code>scipy</code>, <code>matplotlib</code>,
   <code>sympy</code>, <code>fenics</code>, <code>scitools</code>, ...</li>
 <p><li> Suggested installation: Run <a href="http://hplgit.github.io/edu/accesspy/._accesspy_uio005.html" target="_self">Ubuntu in a virtual machine</a></li>
 <p><li> Alternative: run a <a href="http://hplgit.github.io/edu/accesspy/._accesspy_uio007.html" target="_self">Vagrant machine</a></li>
</ul>
<p>


</section>


<section class="slide">

<h2>Assumed/ideal background  <a name="___sec8"></a></h2>

<ul>
 <p><li> INF1100: Python programming, solution of ODEs</li>
 <p><li> Some experience with finite difference methods</li>
 <p><li> Some analytical and numerical knowledge of PDEs</li>
 <p><li> Much experience with calculus and linear algebra</li>
 <p><li> Much experience with programming of mathematical problems</li>
 <p><li> Experience with mathematical modeling with PDEs
   (from physics, mechanics, geophysics, or ...)</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Start-up example for the course  <a name="___sec9"></a></h2>

What if you don't have this ideal background?

<ul>
 <p><li> Students come to this course with very different backgrounds</li>
 <p><li> First task: summarize assumed background knowledge by going through
   a simple example</li>
 <p><li> Also in this example:</li>

<ul>
   <p><li> Some fundamental material on software implementation
     and software testing</li>
   <p><li> Material on analyzing numerical methods to understand
     why they can fail</li>
   <p><li> Applications to real-world problems</li>
</ul>
<p>

</ul>
<p>


</section>


<section class="slide">

<h2>Start-up example  <a name="___sec10"></a></h2>

<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">ODE problem.</b>
<p>
<p>&nbsp;<br>
$$ u'=-au,\quad u(0)=I,\ t\in (0,T],$$
<p>&nbsp;<br>

where \( a>0 \) is a constant.
</div>


<p>
Everything we do is motivated by what we need as building blocks for
solving PDEs!

<p>

</section>


<section class="slide">

<h2>What to learn in the start-up example; standard topics  <a name="___sec11"></a></h2>

<ul>
 <p><li> How to think when constructing finite difference methods, with special focus
   on the Forward Euler, Backward Euler, and Crank-Nicolson (midpoint)
   schemes</li>
 <p><li> How to formulate a computational algorithm and translate it into
   Python code</li>
 <p><li> How to make curve plots of the solutions</li>
 <p><li> How to compute numerical errors</li>
 <p><li> How to compute convergence rates</li>
</ul>
<p>


</section>


<section class="slide">

<h2>What to learn in the start-up example; programming topics  <a name="___sec12"></a></h2>

<ul>
 <p><li> How to verify an implementation and automate verification
   through nose tests in Python</li>
 <p><li> How to structure code in terms of functions, classes, and modules</li>
 <p><li> How to work with Python concepts such as arrays, lists, dictionaries,
   lambda functions, functions in functions (closures), doctests,
   unit tests, command-line interfaces, graphical user interfaces</li>
 <p><li> How to perform array computing and understand the difference from
   scalar computing</li>
 <p><li> How to conduct and automate large-scale numerical experiments</li>
 <p><li> How to generate scientific reports</li>
</ul>
<p>


</section>


<section class="slide">

<h2>What to learn in the start-up example; mathematical analysis  <a name="___sec13"></a></h2>

<ul>
 <p><li> How to uncover numerical artifacts in the computed solution</li>
 <p><li> How to analyze the numerical schemes mathematically to understand
   why artifacts occur</li>
 <p><li> How to derive mathematical expressions for various measures of
   the error in numerical methods, frequently by using the <code>sympy</code> software
   for symbolic computation</li>
 <p><li> Introduce concepts such as finite difference operators,
   mesh (grid), mesh functions,
   stability, truncation error, consistency, and convergence</li>
</ul>
<p>


</section>


<section class="slide">

<h2>What to learn in the start-up example; generalizations  <a name="___sec14"></a></h2>

<ul>
 <p><li> Generalize the example to \( u'(t)=-a(t)u(t) + b(t) \)</li>
 <p><li> Present additional methods for the general nonlinear ODE \( u'=f(u,t) \),
   which is either a scalar ODE or a system of ODEs</li>
 <p><li> How to access professional packages for solving ODEs</li>
 <p><li> How our model equations like \( u'=-au \) arises in a wide range
   of phenomena in physics, biology, and finance</li>
</ul>
<p>


</section>


<section class="slide">

<h1>Finite difference methods <a name="decay:fdm"></a></h1>

<ul>
 <p><li> The finite difference method is the simplest method
   for solving differential equations</li>
 <p><li> Fast to learn, derive, and implement</li>
 <p><li> A very useful tool to know, even if you aim at using the finite element
   or the finite volume method</li>
</ul>
<p>

<center><p><img src="fig-decay/fdm_u_ui.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h2>Topics in the first intro to the finite difference method  <a name="___sec16"></a></h2>

<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Contents.</b>
<p>

<ul>
 <p><li> How to think about finite difference discretization</li>
 <p><li> Key concepts:</li>

<ul>
   <p><li> mesh</li>
   <p><li> mesh function</li>
   <p><li> finite difference approximations</li>
</ul>
<p>

 <p><li> The Forward Euler, Backward Euler, and Crank-Nicolson methods</li>
 <p><li> Finite difference operator notation</li>
 <p><li> How to derive an algorithm and implement it in Python</li>
 <p><li> How to test the implementation</li>
</ul>
</div>


<p>

</section>


<section class="slide">

<h2>A basic model for exponential decay <a name="decay:model"></a></h2>

The world's simplest (?) ODE:

<p>&nbsp;<br>
$$
\begin{equation*}
u'(t) = -au(t),\quad u(0)=I,\ t\in (0,T]
\end{equation*}
$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Observation.</b>
<p>
We can learn a lot about numerical methods, computer implementation,
program testing, and real applications of these tools by using
this very simple ODE as example. The teaching principle is to keep the math as
simple as possible while learning computer tools.
</div>


<p>
<center><p><img src="fig-decay/FE1.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h2>The ODE model has a range of applications in many fields  <a name="___sec18"></a></h2>

<ul>
 <p><li> Growth and decay of populations (cells, animals, human)</li>
 <p><li> Growth and decay of a fortune</li>
 <p><li> Radioactive decay</li>
 <p><li> Cooling/heating of an object</li>
 <p><li> Pressure variation in the atmosphere</li>
 <p><li> Vertical motion of a body in water/air</li>
 <p><li> Time-discretization of diffusion PDEs by Fourier techniques</li>
</ul>
<p>

See the <a href="http://tinyurl.com/k3sdbuv/pub/sphinx-decay/._main_decay008.html" target="_self">text</a> for details.

<p>

</section>


<section class="slide">

<h2>The ODE problem has a continuous and discrete version  <a name="___sec19"></a></h2>

<h3>Continuous problem  <a name="___sec20"></a></h3>

<p>&nbsp;<br>
$$
\begin{equation}
u' = -au,\ t\in (0,T], \quad u(0)=I
\tag{1}
\end{equation}
$$
<p>&nbsp;<br>

(varies with a continuous \( t \))

<h3>Discrete problem  <a name="___sec21"></a></h3>

Numerical methods applied to the continuous problem turns it into
a discrete problem

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = \mbox{const} u^n, \quad n=0,1,\ldots N_t-1, \quad u^n=I
\tag{2}
\end{equation}
$$
<p>&nbsp;<br>

(varies with discrete mesh points \( t_n \))

<p>

</section>


<section class="slide">

<h2>The steps in the finite difference method <a name="decay:schemes:keysteps"></a></h2>

Solving a differential equation by a finite difference method
consists of four steps:

<ol>
<p><li> discretizing the domain,</li>
<p><li> fulfilling the equation at discrete time points,</li>
<p><li> replacing derivatives by finite differences,</li>
<p><li> formulating a recursive algorithm.</li>
</ol>
<p>


</section>


<section class="slide">

<h2>Step 1: Discretizing the domain  <a name="___sec23"></a></h2>

The time domain \( [0,T] \) is represented by a <em>mesh</em>: a finite number of
\( N_t+1 \) points

<p>&nbsp;<br>
$$0 = t_0 < t_1 < t_2 < \cdots < t_{N_t-1} < t_{N_t} = T$$
<p>&nbsp;<br>


<ul>
 <p><li> We seek the solution \( u \) at the mesh points: \( u(t_n) \), \( n=1,2,\ldots,N_t \).</li>
 <p><li> Note: \( u^0 \) is known as \( I \).</li>
 <p><li> Notational short-form for the numerical approximation to \( u(t_n) \): \( u^n \)</li>
 <p><li> In the differential equation: \( u \) is the exact solution</li>
 <p><li> In the numerical method and implementation: \( u^n \) is the numerical
   approximation, \( \uex(t) \) is the exact solution</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Step 1: Discretizing the domain  <a name="___sec24"></a></h2>

\( u^n \) is a mesh function, defined at the mesh points \( t_n \), \( n=0,\ldots,N_t \)
only.

<p>
<center><p><img src="fig-decay/fdm_u_ue.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h2>What about a mesh function between the mesh points?  <a name="___sec25"></a></h2>

Can extend the mesh function to yield values between mesh points
by <em>linear interpolation</em>:

<p>&nbsp;<br>
$$
\begin{equation}
u(t) \approx u^n + \frac{u^{n+1}-u^n}{t_{n+1}-t_n}(t - t_n)
\end{equation}
$$
<p>&nbsp;<br>


<p>
<center><p><img src="fig-decay/fdm_u_ui.png" align="bottom" width=500></p></center>

<p>

</section>


<section class="slide">

<h2>Step 2: Fulfilling the equation at discrete time points  <a name="___sec26"></a></h2>

<ul>
 <p><li> The ODE holds for all \( t\in (0,T] \) (infinite no of points)</li>
 <p><li> Idea: let the ODE be valid at the mesh points only (finite no of points)</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
u'(t_n) = -au(t_n),\quad n=1,\ldots,N_t
\tag{3}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Step 3: Replacing derivatives by finite differences  <a name="___sec27"></a></h2>

Now it is time for the <em>finite difference</em> approximations of
derivatives:

<p>&nbsp;<br>
$$
\begin{equation}
u'(t_n) \approx \frac{u^{n+1}-u^{n}}{t_{n+1}-t_n}
\tag{4}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<center><p><img src="fig-decay/fd_forward.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h2>Step 3: Replacing derivatives by finite differences  <a name="___sec28"></a></h2>

Inserting the finite difference approximation in

<p>&nbsp;<br>
$$ u'(t_n) = -au(t_n)$$
<p>&nbsp;<br>

gives

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -au^{n},\quad n=0,1,\ldots,N_t-1
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>


<p>
(Known as <em>discrete equation</em>, or <em>discrete problem</em>,
or <em>finite difference method/scheme</em>)

<p>

</section>


<section class="slide">

<h2>Step 4: Formulating a recursive algorithm  <a name="___sec29"></a></h2>

How can we actually compute the \( u^n \) values?

<ul>
  <p><li> given \( u^0=I \)</li>
  <p><li> compute \( u^1 \) from \( u^0 \)</li>
  <p><li> compute \( u^2 \) from \( u^1 \)</li>
  <p><li> compute \( u^3 \) from \( u^2 \) (and so forth)</li>
</ul>
<p>

In general: we have \( u^n \) and seek \( u^{n+1} \)

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">The Forward Euler scheme.</b>
<p>
Solve wrt \( u^{n+1} \) to get the computational formula:

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = u^n - a(t_{n+1} -t_n)u^n
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>
</div>


<p>

</section>


<section class="slide">

<h2>Let us apply the scheme by hand  <a name="___sec30"></a></h2>

Assume constant time spacing: \( \Delta t = t_{n+1}-t_n=\mbox{const} \)

<p>&nbsp;<br>
$$
\begin{align*}
u_0 &= I,\\ 
u_1 & = u^0 - a\Delta t u^0 = I(1-a\Delta t),\\ 
u_2 & = I(1-a\Delta t)^2,\\ 
u^3 &= I(1-a\Delta t)^3,\\ 
&\vdots\\ 
u^{N_t} &= I(1-a\Delta t)^{N_t}
\end{align*}
$$
<p>&nbsp;<br>


<p>
Ooops - we can find the numerical solution by hand (in this simple
example)! No need for a computer (yet)...

<p>

</section>


<section class="slide">

<h2>A backward difference  <a name="___sec31"></a></h2>

Here is another finite difference approximation to the
derivative (backward difference):

<p>&nbsp;<br>
$$
\begin{equation}
u'(t_n) \approx \frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}}
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<center><p><img src="fig-decay/fd_backward.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h2>The Backward Euler scheme  <a name="___sec32"></a></h2>

Inserting the finite difference approximation in \( u'(t_n)=-au(t_n) \) yields
the Backward Euler (BE) scheme:

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n}-u^{n-1}}{t_{n}-t_{n-1}} = -a u^n
\tag{8}
\end{equation}
$$
<p>&nbsp;<br>

Solve with respect to the unknown \( u^{n+1} \):

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = \frac{1}{1+ a(t_{n+1}-t_n)} u^n
\tag{9}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>A centered difference  <a name="___sec33"></a></h2>

Centered differences are better approximations than forward or
backward differences.

<p>
<center><p><img src="fig-decay/fd_centered_CN.png" align="bottom" width=400></p></center>

<p>

</section>


<section class="slide">

<h2>The Crank-Nicolson scheme; ideas <a name="decay:schemes:CN"></a></h2>

Idea 1: let the ODE hold at \( t_{n+\half} \)

<p>&nbsp;<br>
$$ u'(t_{n+\half}) = -au(t_{n+\half})$$
<p>&nbsp;<br>


<p>
Idea 2: approximate \( u'(t_{n+\half} \) by a centered difference

<p>&nbsp;<br>
$$
\begin{equation}
u'(t_{n+\half}) \approx \frac{u^{n+1}-u^n}{t_{n+1}-t_n}
\tag{10}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Problem: \( u(t_{n+\half}) \) is not defined, only \( u^n=u(t_n) \) and \( u^{n+1}=u(t_{n+1}) \)

<p>
Solution:

<p>&nbsp;<br>
$$ u(t_{n+\half}) \approx \half(u^n + u^{n+1}) $$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The Crank-Nicolson scheme; result  <a name="___sec35"></a></h2>

Result:

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1}-u^n}{t_{n+1}-t_n} = -a\half (u^n + u^{n+1})
\tag{11}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Solve wrt to \( u^{n+1} \):

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = \frac{1-\half a(t_{n+1}-t_n)}{1 + \half a(t_{n+1}-t_n)}u^n
\tag{12}
\end{equation}
$$
<p>&nbsp;<br>

This is a Crank-Nicolson (CN) scheme or a midpoint or centered scheme.

<p>

</section>


<section class="slide">

<h2>The unifying \( \theta \)-rule <a name="decay:schemes:theta"></a></h2>

The Forward Euler, Backward Euler, and Crank-Nicolson schemes can be
formulated as one scheme with a varying parameter \( \theta \):

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1}-u^{n}}{t_{n+1}-t_n} = -a (\theta u^{n+1} + (1-\theta) u^{n})
\tag{13}
\end{equation}
$$
<p>&nbsp;<br>


<ul>
 <p><li> \( \theta =0 \): Forward Euler</li>
 <p><li> \( \theta =1 \): Backward Euler</li>
 <p><li> \( \theta =1/2 \): Crank-Nicolson</li>
 <p><li> We may alternatively choose any \( \theta\in [0,1] \).</li>
</ul>
<p>

\( u^n \) is known, solve for \( u^{n+1} \):

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a(t_{n+1}-t_n)}{1 + \theta a(t_{n+1}-t_n)}
\tag{14}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Constant time step  <a name="___sec37"></a></h2>

Very common assumption (not important, but exclusively used for
simplicity hereafter): constant time step \( t_{n+1}-t_n\equiv\Delta t \)

<p>
<div class="alert alert-block alert-summary alert-text-normal">
<b style="font-weight: bold">Summary of schemes for constant time step.</b>
<p>
<p>&nbsp;<br>
$$
\begin{align}
u^{n+1} &= (1 - a\Delta t )u^n  \quad (\hbox{FE})
\tag{15}\\ 
u^{n+1} &= \frac{1}{1+ a\Delta t} u^n  \quad (\hbox{BE})
\tag{16}\\ 
u^{n+1} &= \frac{1-\half a\Delta t}{1 + \half a\Delta t} u^n \quad (\hbox{CN})
\tag{17}\\ 
u^{n+1} &= \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n \quad (\theta-\hbox{rule})
\tag{18}
\end{align}
$$
<p>&nbsp;<br>
</div>


<p>

</section>


<section class="slide">

<h2>Test the understanding!  <a name="___sec38"></a></h2>

Derive Forward Euler, Backward Euler, and Crank-Nicolson schemes for
Newton's law of cooling:

<p>&nbsp;<br>
$$ T' = -k(T-T_s),\quad T(0)=T_0,\ t\in (0,t_{\mbox{end}}]$$
<p>&nbsp;<br>


<p>
Physical quantities:

<ul>
 <p><li> \( T(t) \): temperature of an object at time \( t \)</li>
 <p><li> \( k \): parameter expressing heat loss to the surroundings</li>
 <p><li> \( T_s \): temperature of the surroundings</li>
 <p><li> \( T_0 \): initial temperature</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Compact operator notation for finite differences <a name="decay:fd:op"></a></h2>

<ul>
 <p><li> Finite difference formulas can be tedious to write and read/understand</li>
 <p><li> Handy tool: finite difference operator notation</li>
 <p><li> Advantage: communicates the nature of the difference in a compact way</li>
</ul>
<p>

<p>&nbsp;<br>
$$
\begin{equation}
[D_t^- u  = -au]^n
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Specific notation for difference operators  <a name="___sec40"></a></h2>

Forward difference:

<p>&nbsp;<br>
$$
\begin{equation}
[D_t^+u]^n = \frac{u^{n+1} - u^{n}}{\Delta t}
\approx \frac{d}{dt} u(t_n) \tag{19}
\end{equation}
$$
<p>&nbsp;<br>

Centered difference:

<p>&nbsp;<br>
$$
\begin{equation}
[D_tu]^n = \frac{u^{n+\half} - u^{n-\half}}{\Delta t}
\approx \frac{d}{dt} u(t_n), \tag{20}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Backward difference:
<p>&nbsp;<br>
$$
\begin{equation}
[D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}
\approx \frac{d}{dt} u(t_n) \tag{21}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The Backward Euler scheme with operator notation  <a name="___sec41"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation*}
[D_t^-u]^n = -au^n
\end{equation*}
$$
<p>&nbsp;<br>


<p>
Common to put the whole equation inside square brackets:

<p>&nbsp;<br>
$$
\begin{equation}
[D_t^- u  = -au]^n
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The Forward Euler scheme with operator notation  <a name="___sec42"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
[D_t^+ u  = -au]^n
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The Crank-Nicolson scheme with operator notation  <a name="___sec43"></a></h2>

Introduce an averaging operator:

<p>&nbsp;<br>
$$
\begin{equation}
[\overline{u}^{t}]^n = \half (u^{n-\half} + u^{n+\half} )
\approx u(t_n) \tag{22}
\end{equation}
$$
<p>&nbsp;<br>


<p>
The Crank-Nicolson scheme can then be written as

<p>&nbsp;<br>
$$
\begin{equation}
[D_t u = -a\overline{u}^t]^{n+\half}
\tag{23}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Test: use the definitions and write out the above formula to see that
it really is the Crank-Nicolson scheme!

<p>

</section>


<section class="slide">

<h1>Implementation <a name="decay:impl1"></a></h1>

Model:
<p>&nbsp;<br>
$$
u'(t) = -au(t),\quad t\in (0,T], \quad u(0)=I
$$
<p>&nbsp;<br>


<p>
Numerical method:

<p>&nbsp;<br>
$$
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n
$$
<p>&nbsp;<br>

for \( \theta\in [0,1] \). Note

<ul>
 <p><li> \( \theta=0 \) gives Forward Euler</li>
 <p><li> \( \theta=1 \) gives Backward Euler</li>
 <p><li> \( \theta=1/2 \) gives Crank-Nicolson</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Requirements of a program  <a name="___sec45"></a></h2>

<ul>
  <p><li> Compute the numerical solution \( u^n \), \( n=1,2,\ldots,N_t \)</li>
  <p><li> Display the numerical and exact solution \( \uex(t)=e^{-at} \)</li>
  <p><li> Bring evidence to a correct implementation (<em>verification</em>)</li>
  <p><li> Compare the numerical and the exact solution in a plot</li>
  <p><li> computes the error \( \uex (t_n) - u^n \)</li>
  <p><li> computes the convergence rate of the numerical scheme</li>
  <p><li> reads its input data from the command line</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Tools to learn  <a name="___sec46"></a></h2>

<ul>
  <p><li> Basic <a href="http://python.org" target="_self">Python</a> programming</li>
  <p><li> Array computing with <a href="http://numpy.org/" target="_self"><tt>numpy</tt></a></li>
  <p><li> Plotting with <a href="http://matplotlib.sourceforge.net/" target="_self"><tt>matplotlib.pyplot</tt></a> and <a href="http://code.google.com/p/scitools/" target="_self"><tt>scitools</tt></a></li>
  <p><li> File writing and reading</li>
</ul>
<p>

<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Notice.</b>
<p>
All programs are in the directory
<a href="http://tinyurl.com/jvzzcfn/decay" target="_self"><tt>src/decay</tt></a>.
</div>


<p>

</section>


<section class="slide">

<h2>Why implement in Python?  <a name="___sec47"></a></h2>

<ul>
  <p><li> Python has a very clean, readable syntax (often known as
    "executable pseudo-code").</li>
  <p><li> Python code is very similar to MATLAB code (and MATLAB has a
    particularly widespread use for scientific computing).</li>
  <p><li> Python is a full-fledged, very powerful programming language.</li>
  <p><li> Python is similar to, but much simpler to work with and
    results in more reliable code than C++.</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Why implement in Python?  <a name="___sec48"></a></h2>

<ul>
  <p><li> Python has a rich set of modules for scientific computing, and its
    popularity in scientific computing is rapidly growing.</li>
  <p><li> Python was made for being combined with compiled languages
    (C, C++, Fortran) to reuse existing numerical software and to
    reach high computational performance of new implementations.</li>
  <p><li> Python has extensive support for administrative task
    needed when doing large-scale computational investigations.</li>
  <p><li> Python has extensive support for graphics (visualization,
    user interfaces, web applications).</li>
  <p><li> FEniCS, a very powerful tool for solving PDEs by
    the finite element method, is most human-efficient to operate
    from Python.</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Algorithm <a name="decay:py1"></a></h2>

<ul>
 <p><li> Store \( u^n \), \( n=0,1,\ldots,N_t \) in an array <code>u</code>.</li>
 <p><li> Algorithm:</li>

<ol>
  <p><li> initialize \( u^0 \)</li>
  <p><li> for \( t=t_n \), \( n=1,2,\ldots,N_t \): compute \( u_n \) using
     the \( \theta \)-rule formula</li>
</ol>
<p>

</ul>
<p>


</section>


<section class="slide">

<h2>Translation to Python function  <a name="___sec50"></a></h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    Nt = <span style="color: #658b00">int</span>(T/dt)            <span style="color: #228B22"># no of time intervals</span>
    T = Nt*dt                 <span style="color: #228B22"># adjust T to fit time step dt</span>
    u = zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
    t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>

    u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
        u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
<p>
Note about the <code>for</code> loop: <code>range(0, Nt, s)</code> generates all integers
from <code>0</code> to <code>Nt</code> in steps of <code>s</code> (default 1), <em>but not including</em> <code>Nt</code> (!).

<p>
Sample call:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u, t = solver(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">8</span>, dt=<span style="color: #B452CD">0.8</span>, theta=<span style="color: #B452CD">1</span>)
</pre></div>
<p>

</section>


<section class="slide">

<h2>Integer division  <a name="___sec51"></a></h2>

Python applies integer division: <code>1/2</code> is 0, while <code>1./2</code> or <code>1.0/2</code> or
<code>1/2.</code> or <code>1/2.0</code> or <code>1.0/2.0</code> all give 0.5.

<p>
A safer <code>solver</code> function (<code>dt = float(dt)</code> - guarantee float):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)            <span style="color: #228B22"># avoid integer division</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))     <span style="color: #228B22"># no of time intervals</span>
    T = Nt*dt                 <span style="color: #228B22"># adjust T to fit time step dt</span>
    u = zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
    t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>

    u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
        u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
<p>

</section>


<section class="slide">

<h2>Doc strings  <a name="___sec52"></a></h2>

<ul>
 <p><li> First string after the function heading</li>
 <p><li> Used for documenting the function</li>
 <p><li> Automatic documentation tools can make fancy manuals for you</li>
 <p><li> Can be used for automatic testing</li>
</ul>
<p>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve</span>

<span style="color: #CD5555">        u&#39;(t) = -a*u(t),</span>

<span style="color: #CD5555">    with initial condition u(0)=I, for t in the time interval</span>
<span style="color: #CD5555">    (0,T]. The time interval is divided into time steps of</span>
<span style="color: #CD5555">    length dt.</span>

<span style="color: #CD5555">    theta=1 corresponds to the Backward Euler scheme, theta=0</span>
<span style="color: #CD5555">    to the Forward Euler scheme, and theta=0.5 to the Crank-</span>
<span style="color: #CD5555">    Nicolson method.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    ...
</pre></div>
<p>

</section>


<section class="slide">

<h2>Formatting of numbers  <a name="___sec53"></a></h2>

Can control formatting of reals and integers through the <em>printf</em> format:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;t=%6.3f u=%g&#39;</span> % (t[i], u[i])
</pre></div>
<p>
Or the alternative <em>format string syntax</em>:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;t={t:6.3f} u={u:g}&#39;</span>.format(t=t[i], u=u[i])
</pre></div>
<p>

</section>


<section class="slide">

<h2>Running the program  <a name="___sec54"></a></h2>

How to run the program <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/decay_v1.py" target="_self"><tt>decay_v1.py</tt></a>:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_v1.py
</pre></div>
<p>
Can also run it as "normal" Unix programs: <code>./decay_v1.py</code> if the
first line is

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #CD5555">`#!/usr/bin/env python`</span>
</pre></div>
<p>
Then
<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; chmod a+rx decay_v1.py
Terminal&gt; ./decay_v1.py
</pre></div>
<p>

</section>


<section class="slide">

<h2>Plotting the solution  <a name="___sec55"></a></h2>

Basic syntax:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *

plot(t, u)
show()
</pre></div>
<p>
Can (and should!) add labels on axes, title, legends.

<p>

</section>


<section class="slide">

<h2>Comparing with the exact solution  <a name="___sec56"></a></h2>

Python function for the exact solution \( \uex(t)=Ie^{-at} \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(t, I, a):
    <span style="color: #8B008B; font-weight: bold">return</span> I*exp(-a*t)
</pre></div>
<p>
Quick plotting:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u_e = exact_solution(t, I, a)
plot(t, u, t, u_e)
</pre></div>
<p>
Problem: \( \uex(t) \) applies the same mesh as \( u^n \) and
looks as a piecewise linear function.

<p>
Remedy: Introduce a very fine mesh for \( \uex \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">t_e = linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)      <span style="color: #228B22"># fine mesh</span>
u_e = exact_solution(t_e, I, a)

plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>,            <span style="color: #228B22"># blue line for u_e</span>
     t,   u,   <span style="color: #CD5555">&#39;r--o&#39;</span>)          <span style="color: #228B22"># red dashes w/circles</span>
</pre></div>
<p>

</section>


<section class="slide">

<h2>Add legends, axes labels, title, and wrap in a function  <a name="___sec57"></a></h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">plot_numerical_and_exact</span>(theta, I, a, T, dt):
    <span style="color: #CD5555">&quot;&quot;&quot;Compare the numerical and exact solution in a plot.&quot;&quot;&quot;</span>
    u, t = solver(I=I, a=a, T=T, dt=dt, theta=theta)

    t_e = linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)        <span style="color: #228B22"># fine mesh for u_e</span>
    u_e = exact_solution(t_e, I, a)

    plot(t,   u,   <span style="color: #CD5555">&#39;r--o&#39;</span>,            <span style="color: #228B22"># red dashes w/circles</span>
         t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)              <span style="color: #228B22"># blue line for exact sol.</span>
    legend([<span style="color: #CD5555">&#39;numerical&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>])
    xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
    ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
    title(<span style="color: #CD5555">&#39;theta=%g, dt=%g&#39;</span> % (theta, dt))
    savefig(<span style="color: #CD5555">&#39;plot_%s_%g.png&#39;</span> % (theta, dt))
</pre></div>
<p>
Complete code in
<a href="http://tinyurl.com/jvzzcfn/decay/decay_v2.py" target="_self"><tt>decay_v2.py</tt></a>

<p>
<center><p><img src="fig-decay/decay_v2.png" align="bottom" width=500></p></center>

<p>

</section>


<section class="slide">

<h2>Plotting with SciTools  <a name="___sec58"></a></h2>

<a href="http://code.google.com/p/scitools" target="_self">SciTools</a> provides a
unified plotting interface (Easyviz) to many different plotting
packages: Matplotlib, Gnuplot, Grace, VTK, OpenDX, ...

<p>
Can use Matplotlib (MATLAB-like) syntax,
or a more compact <code>plot</code> function syntax:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">import</span> *

plot(t,   u,   <span style="color: #CD5555">&#39;r--o&#39;</span>,           <span style="color: #228B22"># red dashes w/circles</span>
     t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>,             <span style="color: #228B22"># blue line for exact sol.</span>
     legend=[<span style="color: #CD5555">&#39;numerical&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>],
     xlabel=<span style="color: #CD5555">&#39;t&#39;</span>,
     ylabel=<span style="color: #CD5555">&#39;u&#39;</span>,
     title=<span style="color: #CD5555">&#39;theta=%g, dt=%g&#39;</span> % (theta, dt),
     savefig=<span style="color: #CD5555">&#39;%s_%g.png&#39;</span> % (theta2name[theta], dt),
     show=<span style="color: #658b00">True</span>)
</pre></div>
<p>
Change backend (plotting engine, Matplotlib by default):

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend gnuplot
Terminal&gt; python decay_plot_st.py --SCITOOLS_easyviz_backend grace
</pre></div>
<p>

</section>


<section class="slide">

<h1>Verifying the implementation <a name="decay:verification"></a></h1>

<ul>
 <p><li> Verification = bring evidence that the program works</li>
 <p><li> Find suitable test problems</li>
 <p><li> Make function for each test problem</li>
 <p><li> Later: put the verification tests in a professional testing framework</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Simplest method: run a few algorithmic steps by hand  <a name="___sec60"></a></h2>

Use a calculator (\( I=0.1 \), \( \theta=0.8 \), \( \Delta t =0.8 \)):

<p>&nbsp;<br>
$$ A\equiv \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t} = 0.298245614035$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{align*}
u^1 &= AI=0.0298245614035,\\ 
u^2 &= Au^1= 0.00889504462912,\\ 
u^3 &=Au^2= 0.00265290804728
\end{align*}
$$
<p>&nbsp;<br>


<p>
See the function <code>verify_three_steps</code> in <a href="http://tinyurl.com/jvzzcfn/decay/decay_verf1.py" target="_self"><tt>decay_verf1.py</tt></a>.

<p>

</section>


<section class="slide">

<h2>Comparison with an exact discrete solution  <a name="___sec61"></a></h2>

<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Best verification.</b>
<p>
Compare computed numerical solution
with a closed-form <em>exact discrete solution</em> (if possible).
</div>


<p>
Define
<p>&nbsp;<br>
$$ A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}$$
<p>&nbsp;<br>

Repeated use of the \( \theta \)-rule:
<p>&nbsp;<br>
$$
\begin{align*}
u^0 &= I,\\ 
u^1 &= Au^0 = AI\\ 
u^n &= A^nu^{n-1} = A^nI
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Making a test based on an exact discrete solution  <a name="___sec62"></a></h2>

The exact discrete solution is

<p>&nbsp;<br>
$$
\begin{equation}
u^n = IA^n
\tag{24}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-question alert-text-normal">
<b style="font-weight: bold">Question.</b>
<p>
Understand what \( n \) in \( u^n \) and in \( A^n \) means!
</div>


<p>
Test if

<p>&nbsp;<br>
$$ \max_n |u^n - \uex(t_n)| < \epsilon\sim 10^{-15}$$
<p>&nbsp;<br>


<p>
Implementation in <a href="http://tinyurl.com/jvzzcfn/decay/decay_verf2.py" target="_self"><tt>decay_verf2.py</tt></a>.

<p>

</section>


<section class="slide">

<h2>Test the understanding!  <a name="___sec63"></a></h2>

Make a program for solving Newton's law of cooling

<p>&nbsp;<br>
$$ T' = -k(T-T_s),\quad T(0)=T_0,\ t\in (0,t_{\mbox{end}}]$$
<p>&nbsp;<br>

with the Forward Euler, Backward Euler, and Crank-Nicolson schemes
(or a \( \theta \) scheme). Verify the implementation.

<p>

</section>


<section class="slide">

<h2>Computing the numerical error as a mesh function <a name="decay:computing:error"></a></h2>

Task: compute the numerical error \( e^n = \uex(t_n) - u^n \)

<p>
Exact solution: \( \uex(t)=Ie^{-at} \), implemented as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(t, I, a):
    <span style="color: #8B008B; font-weight: bold">return</span> I*exp(-a*t)
</pre></div>
<p>
Compute \( e^n \) by

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u, t = solver(I, a, T, dt, theta)  <span style="color: #228B22"># Numerical solution</span>
u_e = exact_solution(t, I, a)
e = u_e - u
</pre></div>
<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Array arithmetics - we compute on entire arrays!</b>
<p>

<ul>
 <p><li> <code>exact_solution(t, I, a)</code> works with <code>t</code> as array</li>
 <p><li> Must have <code>exp</code> from <code>numpy</code> (not <code>math</code>)</li>
 <p><li> <code>e = u_e - u</code>: array subtraction</li>
 <p><li> Array arithmetics gives shorter and much faster code</li>
</ul>
</div>


<p>

</section>


<section class="slide">

<h2>Computing the norm of the error <a name="decay:computing:error:norm"></a></h2>

<ul>
 <p><li> \( e^n \) is a mesh function</li>
 <p><li> Usually we want one number for the error</li>
 <p><li> Use a norm of \( e^n \)</li>
</ul>
<p>

Norms of a function \( f(t) \):

<p>&nbsp;<br>
$$
\begin{align}
||f||_{L^2} &= \left( \int_0^T f(t)^2 dt\right)^{1/2}
\tag{25}\\ 
||f||_{L^1} &= \int_0^T |f(t)| dt
\tag{26}\\ 
||f||_{L^\infty} &= \max_{t\in [0,T]}|f(t)|
\tag{27}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Norms of mesh functions  <a name="___sec66"></a></h2>

<ul>
 <p><li> Problem: \( f^n =f(t_n) \) is a mesh function and hence not defined for all \( t \).
   How to integrate \( f^n \)?</li>
 <p><li> Idea: Apply a numerical integration rule, using only
   the mesh points of the mesh function.</li>
</ul>
<p>

The Trapezoidal rule:

<p>&nbsp;<br>
$$ ||f^n|| = \left(\Delta t\left(\half(f^0)^2 + \half(f^{N_t})^2
+ \sum_{n=1}^{N_t-1} (f^n)^2\right)\right)^{1/2} $$
<p>&nbsp;<br>


<p>
Common simplification yields the \( L^2 \) norm of a mesh function:

<p>&nbsp;<br>
$$ ||f^n||_{\ell^2} = \left(\Delta t\sum_{n=0}^{N_t} (f^n)^2\right)^{1/2}$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Implementation of the norm of the error  <a name="___sec67"></a></h2>

<p>&nbsp;<br>
$$ E = ||e^n||_{\ell^2}  = \sqrt{\Delta t\sum_{n=0}^{N_t} (e^n)^2}$$
<p>&nbsp;<br>


<p>
Python w/array arithmetics:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">e = exact_solution(t) - u
E = sqrt(dt*<span style="color: #658b00">sum</span>(e**<span style="color: #B452CD">2</span>))
</pre></div>
<p>

</section>


<section class="slide">

<h2>Comment on array vs scalar computation  <a name="___sec68"></a></h2>

Scalar computing of <code>E = sqrt(dt*sum(e**2))</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">m = <span style="color: #658b00">len</span>(u)     <span style="color: #228B22"># length of u array (alt: u.size)</span>
u_e = zeros(m)
t = <span style="color: #B452CD">0</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(m):
    u_e[i] = exact_solution(t, a, I)
    t = t + dt
e = zeros(m)
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(m):
    e[i] = u_e[i] - u[i]
s = <span style="color: #B452CD">0</span>  <span style="color: #228B22"># summation variable</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(m):
    s = s + e[i]**<span style="color: #B452CD">2</span>
error = sqrt(dt*s)
</pre></div>
<p>
Obviously, scalar computing

<ul>
 <p><li> takes more code</li>
 <p><li> is less readable</li>
 <p><li> runs much slower</li>
</ul>
<p>

<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Rule.</b>
<p>
Compute on entire arrays (when possible)!
</div>


<p>

</section>


<section class="slide">

<h2>Memory-saving implementation  <a name="___sec69"></a></h2>

<ul>
 <p><li> Note 1: we store the entire array <code>u</code>, i.e., \( u^n \) for \( n=0,1,\ldots,N_t \)</li>
 <p><li> Note 2: the formula for \( u^{n+1} \) needs \( u^n \) only, not \( u^{n-1} \), \( u^{n-2} \), ...</li>
 <p><li> No need to store more than \( u^{n+1} \) and \( u^{n} \)</li>
 <p><li> Extremely important when solving PDEs</li>
 <p><li> No practical importance here (much memory available)</li>
 <p><li> But let's illustrate how to do save memory!</li>
 <p><li> Idea 1: store \( u^{n+1} \) in <code>u</code>, \( u^n \) in <code>u_1</code> (<code>float</code>)</li>
 <p><li> Idea 2: store <code>u</code> in a file, read file later for plotting</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Memory-saving solver function  <a name="___sec70"></a></h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver_memsave</span>(I, a, T, dt, theta, filename=<span style="color: #CD5555">&#39;sol.dat&#39;</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.</span>
<span style="color: #CD5555">    Minimum use of memory. The solution is stored in a file</span>
<span style="color: #CD5555">    (with name filename) for later plotting.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)         <span style="color: #228B22"># avoid integer division</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))  <span style="color: #228B22"># no of intervals</span>

    outfile = <span style="color: #658b00">open</span>(filename, <span style="color: #CD5555">&#39;w&#39;</span>)
    <span style="color: #228B22"># u: time level n+1, u_1: time level n</span>
    t = <span style="color: #B452CD">0</span>
    u_1 = I
    outfile.write(<span style="color: #CD5555">&#39;%.16E  %.16E\n&#39;</span> % (t, u_1))
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt+<span style="color: #B452CD">1</span>):
        u = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u_1
        u_1 = u
        t += dt
        outfile.write(<span style="color: #CD5555">&#39;%.16E  %.16E\n&#39;</span> % (t, u))
    outfile.close()
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
<p>

</section>


<section class="slide">

<h2>Reading computed data from file  <a name="___sec71"></a></h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">read_file</span>(filename=<span style="color: #CD5555">&#39;sol.dat&#39;</span>):
    infile = <span style="color: #658b00">open</span>(filename, <span style="color: #CD5555">&#39;r&#39;</span>)
    u = [];  t = []
    <span style="color: #8B008B; font-weight: bold">for</span> line <span style="color: #8B008B">in</span> infile:
        words = line.split()
        <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">len</span>(words) != <span style="color: #B452CD">2</span>:
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Found more than two numbers on a line!&#39;</span>, words
            sys.exit(<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># abort</span>
        t.append(<span style="color: #658b00">float</span>(words[<span style="color: #B452CD">0</span>]))
        u.append(<span style="color: #658b00">float</span>(words[<span style="color: #B452CD">1</span>]))
    <span style="color: #8B008B; font-weight: bold">return</span> np.array(t), np.array(u)
</pre></div>
<p>
Simpler code with <code>numpy</code> functionality for reading/writing tabular data:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">read_file_numpy</span>(filename=<span style="color: #CD5555">&#39;sol.dat&#39;</span>):
    data = np.loadtxt(filename)
    t = data[:,<span style="color: #B452CD">0</span>]
    u = data[:,<span style="color: #B452CD">1</span>]
    <span style="color: #8B008B; font-weight: bold">return</span> t, u
</pre></div>
<p>
Similar function <code>np.savetxt</code>, but then we need all \( u^n \) and \( t^n \) values
in a two-dimensional array (which we try to prevent now!).

<p>

</section>


<section class="slide">

<h2>Usage of memory-saving code  <a name="___sec72"></a></h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">explore</span>(I, a, T, dt, theta=<span style="color: #B452CD">0.5</span>, makeplot=<span style="color: #658b00">True</span>):
    filename = <span style="color: #CD5555">&#39;u.dat&#39;</span>
    u, t = solver_memsave(I, a, T, dt, theta, filename)

    t, u = read_file(filename)
    u_e = exact_solution(t, I, a)
    e = u_e - u
    E = np.sqrt(dt*np.sum(e**<span style="color: #B452CD">2</span>))
    <span style="color: #8B008B; font-weight: bold">if</span> makeplot:
        plt.figure()
        ...
</pre></div>
<p>
Complete program: <a href="https://github.com/hplgit/INF5620/blob/gh-pages/src/decay/decay_memsave.py" target="_self"><tt>decay_memsave.py</tt></a>.

<p>

</section>


<section class="slide">

<h1>Analysis of finite difference equations <a name="decay:analysis"></a></h1>

Model:
<p>&nbsp;<br>
$$
\begin{equation}
u'(t) = -au(t),\quad u(0)=I
\end{equation}
$$
<p>&nbsp;<br>


<p>
Method:
<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n
\tag{28}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-question alert-text-normal">
<b style="font-weight: bold">Problem setting.</b>
<p>
How good is this method? Is it safe to use it?
</div>


<p>

</section>


<section class="slide">

<h2>Encouraging numerical solutions  <a name="___sec74"></a></h2>

\( I=1 \), \( a=2 \), \( \theta =1,0.5, 0 \), \( \Delta t=1.25, 0.75, 0.5, 0.1 \).

<p>
<center><p><img src="fig-decay/BE4c.png" align="bottom" width=600,></p></center>

<p>

</section>


<section class="slide">

<h2>Discouraging numerical solutions; Crank-Nicolson  <a name="___sec75"></a></h2>

<center><p><img src="fig-decay/CN4c.png" align="bottom" width=600,></p></center>

<p>

</section>


<section class="slide">

<h2>Discouraging numerical solutions; Forward Euler  <a name="___sec76"></a></h2>

<center><p><img src="fig-decay/FE4c.png" align="bottom" width=600,></p></center>

<p>

</section>


<section class="slide">

<h2>Summary of observations  <a name="___sec77"></a></h2>

The characteristics of the displayed curves can be summarized as follows:

<ul>
  <p><li> The Backward Euler scheme <em>always</em> gives a monotone solution, lying above
    the exact curve.</li>
  <p><li> The Crank-Nicolson scheme gives the most accurate results, but for
    \( \Delta t=1.25 \) the solution oscillates.</li>
  <p><li> The Forward Euler scheme gives a growing, oscillating solution for
    \( \Delta t=1.25 \); a decaying, oscillating solution for \( \Delta t=0.75 \);
    a strange solution \( u^n=0 \) for \( n\geq 1 \) when \( \Delta t=0.5 \); and
    a solution seemingly as accurate as the one by the Backward Euler
    scheme for \( \Delta t = 0.1 \), but the curve lies <em>below</em> the exact
    solution.</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Problem setting  <a name="___sec78"></a></h2>

<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Goal.</b>
<p>
We ask the question

<ul>
  <p><li> Under what circumstances, i.e., values of
    the input data \( I \), \( a \), and \( \Delta t \) will the Forward Euler and
    Crank-Nicolson schemes result in undesired oscillatory solutions?</li>
</ul>
<p>

Techniques of investigation:

<ul>
 <p><li> Numerical experiments</li>
 <p><li> Mathematical analysis</li>
</ul>
<p>

Another question to be raised is

<ul>
 <p><li> How does \( \Delta t \) impact the error in the numerical solution?</li>
</ul>
</div>


<p>

</section>


<section class="slide">

<h2>Experimental investigation of oscillatory solutions  <a name="___sec79"></a></h2>

The solution is oscillatory if
<p>&nbsp;<br>
$$ u^{n} > u^{n-1}$$
<p>&nbsp;<br>


<p>
<center><p><img src="fig-decay/osc_region_FE.png" align="bottom" width=400></p></center>

<p>
Seems that \( a\Delta t < 1 \) for FE and 2 for CN.

<p>

</section>


<section class="slide">

<h2>Exact numerical solution  <a name="___sec80"></a></h2>

Starting with \( u^0=I \), the simple recursion <a href="#mjx-eqn-28">(28)</a>
can be applied repeatedly \( n \) times, with the result that

<p>&nbsp;<br>
$$
\begin{equation}
u^{n} = IA^n,\quad A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}
\tag{29}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Such an exact discrete solution is unusual, but very handy for analysis.

<p>

</section>


<section class="slide">

<h2>Stability  <a name="___sec81"></a></h2>

Since \( u^n\sim A^n \),

<ul>
 <p><li> \( A<0 \) gives a factor \( (-1)^n \) and oscillatory solutions</li>
 <p><li> \( |A|>1 \) gives growing solutions</li>
 <p><li> Recall: the exact solution is <em>monotone</em> and <em>decaying</em></li>
 <p><li> If these qualitative properties are not met, we say that the
   numerical solution is <em>unstable</em></li>
</ul>
<p>


</section>


<section class="slide">

<h2>Computation of stability in this problem  <a name="___sec82"></a></h2>

\( A<0 \) if

<p>&nbsp;<br>
$$
\frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t} < 0
$$
<p>&nbsp;<br>

To avoid oscillatory solutions we must have \( A> 0 \) and

<p>&nbsp;<br>
$$
\begin{equation}
\Delta t < \frac{1}{(1-\theta)a}\ 
\end{equation}
$$
<p>&nbsp;<br>


<ul>
 <p><li> Always fulfilled for Backward Euler</li>
 <p><li> \( \Delta t \leq 1/a \) for Forward Euler</li>
 <p><li> \( \Delta t \leq 2/a \) for Crank-Nicolson</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Computation of stability in this problem  <a name="___sec83"></a></h2>

\( |A|\leq 1 \) means \( -1\leq A\leq 1 \)

<p>&nbsp;<br>
$$
\begin{equation}
-1\leq\frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t} \leq 1
\tag{30}
\end{equation}
$$
<p>&nbsp;<br>

\( -1 \) is the critical limit:

<p>&nbsp;<br>
$$
\begin{align*}
\Delta t &\leq \frac{2}{(1-2\theta)a},\quad \theta < \half\\ 
\Delta t &\geq \frac{2}{(1-2\theta)a},\quad \theta > {\half}
\end{align*}
$$
<p>&nbsp;<br>


<ul>
 <p><li> Always fulfilled for Backward Euler and Crank-Nicolson</li>
 <p><li> \( \Delta t \leq 2/a \) for Forward Euler</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Explanation of problems with Forward Euler  <a name="___sec84"></a></h2>

<center><p><img src="fig-decay/FE4c.png" align="bottom" width=500,></p></center>

<ul>
 <p><li> \( a\Delta t= 2\cdot 1.25=2.5 \) and \( A=-1.5 \): oscillations and growth</li>
 <p><li> \( a\Delta t = 2\cdot 0.75=1.5 \) and \( A=-0.5 \): oscillations and decay</li>
 <p><li> \( \Delta t=0.5 \) and \( A=0 \): \( u^n=0 \) for \( n>0 \)</li>
 <p><li> Smaller \( Delta t \): qualitatively correct solution</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Explanation of problems with Crank-Nicolson  <a name="___sec85"></a></h2>

<center><p><img src="fig-decay/CN4c.png" align="bottom" width=500,></p></center>

<ul>
 <p><li> \( \Delta t=1.25 \) and \( A=-0.25 \): oscillatory solution</li>
 <p><li> Never any growing solution</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Summary of stability  <a name="___sec86"></a></h2>

<ol>
<p><li> Forward Euler is <em>conditionally stable</em></li>

<ul>
   <p><li> \( \Delta t < 2/a \) for avoiding growth</li>
   <p><li> \( \Delta t\leq 1/a \) for avoiding oscillations</li>
</ul>
<p>

<p><li> The Crank-Nicolson is <em>unconditionally stable</em> wrt growth
   and conditionally stable wrt oscillations</li>

<ul>
   <p><li> \( \Delta t < 2/a \) for avoiding oscillations</li>
</ul>
<p>

<p><li> Backward Euler is unconditionally stable</li>
</ol>
<p>


</section>


<section class="slide">

<h2>Comparing amplification factors  <a name="___sec87"></a></h2>

\( u^{n+1} \) is an amplification \( A \) of \( u^n \):

<p>&nbsp;<br>
$$ u^{n+1} = Au^n,\quad A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t} $$
<p>&nbsp;<br>


<p>
The exact solution is also an amplification:

<p>&nbsp;<br>
$$ u(t_{n+1}) = \Aex u(t_n), \quad \Aex = e^{-a\Delta t}$$
<p>&nbsp;<br>


<p>
A possible measure of accuracy: \( \Aex - A \)

<p>

</section>


<section class="slide">

<h2>Plot of amplification factors  <a name="___sec88"></a></h2>

<center><p><img src="fig-decay/A_factors.png" align="bottom" width=600></p></center>

<p>

</section>


<section class="slide">

<h2>Series expansion of amplification factors  <a name="___sec89"></a></h2>

To investigate \( \Aex - A \) mathematically, we
can Taylor expand the expression, using \( p=a\Delta t \) as variable.

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; <span style="color: #228B22"># Create p as a mathematical symbol with name &#39;p&#39;</span>
&gt;&gt;&gt; p = Symbol(<span style="color: #CD5555">&#39;p&#39;</span>)
&gt;&gt;&gt; <span style="color: #228B22"># Create a mathematical expression with p</span>
&gt;&gt;&gt; A_e = exp(-p)
&gt;&gt;&gt;
&gt;&gt;&gt; <span style="color: #228B22"># Find the first 6 terms of the Taylor series of A_e</span>
&gt;&gt;&gt; A_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">6</span>)
<span style="color: #B452CD">1</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>)*p**<span style="color: #B452CD">2</span> - p - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">6</span>*p**<span style="color: #B452CD">3</span> - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">120</span>*p**<span style="color: #B452CD">5</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">24</span>)*p**<span style="color: #B452CD">4</span> + O(p**<span style="color: #B452CD">6</span>)

&gt;&gt;&gt; theta = Symbol(<span style="color: #CD5555">&#39;theta&#39;</span>)
&gt;&gt;&gt; A = (<span style="color: #B452CD">1</span>-(<span style="color: #B452CD">1</span>-theta)*p)/(<span style="color: #B452CD">1</span>+theta*p)
&gt;&gt;&gt; FE = A_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - A.subs(theta, <span style="color: #B452CD">0</span>).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE = A_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - A.subs(theta, <span style="color: #B452CD">1</span>).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; half = Rational(<span style="color: #B452CD">1</span>,<span style="color: #B452CD">2</span>)  <span style="color: #228B22"># exact fraction 1/2</span>
&gt;&gt;&gt; CN = A_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - A.subs(theta, half).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; FE
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>)*p**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">6</span>*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE
-<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">2</span> + (<span style="color: #B452CD">5</span>/<span style="color: #B452CD">6</span>)*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; CN
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">12</span>)*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
</pre></div>
<p>

</section>


<section class="slide">

<h2>Error in amplification factors  <a name="___sec90"></a></h2>

Focus: the error measure \( A-\Aex \) as function of \( \Delta t \) (recall that \( p=a\Delta t \)):

<p>&nbsp;<br>
$$
\begin{equation}
A-\Aex = \left\lbrace\begin{array}{ll}
\Oof{\Delta t^2}, & \hbox{Forward and Backward Euler},\\ 
\Oof{\Delta t^3}, & \hbox{Crank-Nicolson}
\end{array}\right.
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The fraction of numerical and exact amplification factors  <a name="___sec91"></a></h2>

Focus: the error measure \( 1-A/\Aex \) as function of \( p=a\Delta t \):

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; FE = <span style="color: #B452CD">1</span> - (A.subs(theta, <span style="color: #B452CD">0</span>)/A_e).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE = <span style="color: #B452CD">1</span> - (A.subs(theta, <span style="color: #B452CD">1</span>)/A_e).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; CN = <span style="color: #B452CD">1</span> - (A.subs(theta, half)/A_e).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; FE
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>)*p**<span style="color: #B452CD">2</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3</span>)*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE
-<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">2</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3</span>)*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; CN
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">12</span>)*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
</pre></div>
<p>
Same leading-order terms as for the error measure \( A-\Aex \).

<p>

</section>


<section class="slide">

<h2>The true/global error at a point <a name="decay:analysis:gobal:error"></a></h2>

<ul>
 <p><li> The error in \( A \) reflects the <em>local error</em> when going from one
   time step to the next</li>
 <p><li> What is the <em>global (true) error</em> at \( t_n \)?
   \( e^n = \uex(t_n) - u^n = Ie^{-at_n} - IA^n \)</li>
 <p><li> Taylor series expansions of \( e^n \) simplify the expression</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Computing the global error at a point  <a name="___sec93"></a></h2>


<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; n = Symbol(<span style="color: #CD5555">&#39;n&#39;</span>)
&gt;&gt;&gt; u_e = exp(-p*n)   <span style="color: #228B22"># I=1</span>
&gt;&gt;&gt; u_n = A**n        <span style="color: #228B22"># I=1</span>
&gt;&gt;&gt; FE = u_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - u_n.subs(theta, <span style="color: #B452CD">0</span>).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE = u_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - u_n.subs(theta, <span style="color: #B452CD">1</span>).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; CN = u_e.series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>) - u_n.subs(theta, half).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)
&gt;&gt;&gt; FE
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>)*n*p**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>*n**<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">3</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3</span>)*n*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; BE
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>)*n**<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">3</span> - <span style="color: #B452CD">1</span>/<span style="color: #B452CD">2</span>*n*p**<span style="color: #B452CD">2</span> + (<span style="color: #B452CD">1</span>/<span style="color: #B452CD">3</span>)*n*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
&gt;&gt;&gt; CN
(<span style="color: #B452CD">1</span>/<span style="color: #B452CD">12</span>)*n*p**<span style="color: #B452CD">3</span> + O(p**<span style="color: #B452CD">4</span>)
</pre></div>
<p>
Substitute \( n \) by \( t/\Delta t \):

<ul>
 <p><li> Forward and Backward Euler: leading order term \( \half ta^2\Delta t \)</li>
 <p><li> Crank-Nicolson: leading order term \( \frac{1}{12}ta^3\Delta t^2 \)</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Convergence  <a name="___sec94"></a></h2>

The numerical scheme is convergent if the global error
\( e^n\rightarrow 0 \) as \( \Delta t\rightarrow 0 \).
If the error has a leading order term \( \Delta t^r \), the
convergence rate is of order \( r \).

<p>

</section>


<section class="slide">

<h2>Integrated errors  <a name="___sec95"></a></h2>

Focus: norm of the numerical error

<p>&nbsp;<br>
$$ ||e^n||_{\ell^2} = \sqrt{\Delta t\sum_{n=0}^{N_t} ({\uex}(t_n) - u^n)^2}$$
<p>&nbsp;<br>


<p>
Forward and Backward Euler:

<p>&nbsp;<br>
$$ ||e^n||_{\ell^2} = \frac{1}{4}\sqrt{\frac{T^3}{3}} a^2\Delta t$$
<p>&nbsp;<br>


<p>
Crank-Nicolson:

<p>&nbsp;<br>
$$ ||e^n||_{\ell^2} = \frac{1}{12}\sqrt{\frac{T^3}{3}}a^3\Delta t^2$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-summary alert-text-normal">
<b style="font-weight: bold">Summary of errors.</b>
<p>
Analysis of both the pointwise and the time-integrated true errors:

<ul>
  <p><li> 1st order for Forward and Backward Euler</li>
  <p><li> 2nd order for Crank-Nicolson</li>
</ul>
</div>


<p>

</section>


<section class="slide">

<h2>Truncation error  <a name="___sec96"></a></h2>

<ul>
 <p><li> How good is the discrete equation?</li>
 <p><li> Possible answer: see how well \( \uex \) fits the discrete equation</li>
</ul>
<p>

<p>&nbsp;<br>
$$ \lbrack D_t u = -au\rbrack^n$$
<p>&nbsp;<br>

i.e.,

<p>&nbsp;<br>
$$ \frac{u^{n+1}-u^n}{\Delta t} = -au^n$$
<p>&nbsp;<br>

Insert \( \uex \) (which does not in general fulfill this equation):

<p>&nbsp;<br>
$$
\begin{equation}
\frac{\uex(t_{n+1})-\uex(t_n)}{\Delta t} + a\uex(t_n) = R^n \neq 0
\tag{31}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Computation of the truncation error  <a name="___sec97"></a></h2>

<ul>
 <p><li> The residual \( R^n \) is the <em>truncation error</em>.</li>
 <p><li> How does \( R^n \) vary with \( \Delta t \)?</li>
</ul>
<p>

Tool: Taylor expand \( \uex \) around the point where the ODE is sampled
(here \( t_n \))

<p>&nbsp;<br>
$$ \uex(t_{n+1}) = \uex(t_n) + \uex'(t_n)\Delta t + \half\uex''(t_n)
\Delta t^2 + \cdots $$
<p>&nbsp;<br>

Inserting this Taylor series in <a href="#mjx-eqn-31">(31)</a> gives

<p>&nbsp;<br>
$$ R^n = \uex'(t_n) + \half\uex''(t_n)\Delta t + \ldots + a\uex(t_n)$$
<p>&nbsp;<br>

Now, \( \uex \) solves the ODE \( \uex'=-a\uex \), and then

<p>&nbsp;<br>
$$ R^n \approx \half\uex''(t_n)\Delta t$$
<p>&nbsp;<br>

This is a mathematical expression for the truncation error.

<p>

</section>


<section class="slide">

<h2>The truncation error for other schemes  <a name="___sec98"></a></h2>

Backward Euler:

<p>&nbsp;<br>
$$ R^n \approx -\half\uex''(t_n)\Delta t $$
<p>&nbsp;<br>


<p>
Crank-Nicolson:

<p>&nbsp;<br>
$$ R^{n+\half} \approx \frac{1}{24}\uex'''(t_{n+\half})\Delta t^2$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Consistency, stability, and convergence  <a name="___sec99"></a></h2>

<ul>
  <p><li> Truncation error measures the residual in the difference equations.
    The scheme is <em>consistent</em> if the truncation error goes to 0
    as \( \Delta t\rightarrow 0 \). Importance: the difference equations
    approaches the differential equation as \( \Delta t\rightarrow 0 \).</li>
  <p><li> <em>Stability</em> means that the numerical solution exhibits the same
    qualitative properties as the exact solution. Here: monotone,
    decaying function.</li>
  <p><li> <em>Convergence</em> implies that the true (global) error
    \( e^n =\uex(t_n)-u^n\rightarrow 0 \) as \( \Delta t\rightarrow 0 \).
    This is really what we want!</li>
</ul>
<p>

The Lax equivalence theorem for <em>linear</em> differential equations:
consistency + stability is equivalent with convergence.

<p>
(Consistency and stability is in most problems
much easier to establish than
convergence.)

<p>

</section>


<section class="slide">

<h1>Model extensions <a name="decay:generalizations"></a></h1>


</section>


<section class="slide">

<h2>Extension to a variable coefficient; Forward and Backward Euler  <a name="___sec101"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
u'(t) = -a(t)u(t),\quad t\in (0,T],\quad u(0)=I
\tag{32}
\end{equation}
$$
<p>&nbsp;<br>


<p>
The Forward Euler scheme:

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1} - u^n}{\Delta t} = -a(t_n)u^n
\end{equation}
$$
<p>&nbsp;<br>


<p>
The Backward Euler scheme:
<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n} - u^{n-1}}{\Delta t} = -a(t_n)u^n
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Extension to a variable coefficient; Crank-Nicolson  <a name="___sec102"></a></h2>

Eevaluting \( a(t_{n+\half}) \) and
using an average for \( u \):
<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a(t_{n+\half})\half(u^n + u^{n+1})
\end{equation}
$$
<p>&nbsp;<br>


<p>
Using an average for \( a \) and \( u \):
<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -\half(a(t_n)u^n + a(t_{n+1})u^{n+1})
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Extension to a variable coefficient; \( \theta \)-rule  <a name="___sec103"></a></h2>

The \( \theta \)-rule unifies the three mentioned schemes,

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -a((1-\theta)t_n + \theta t_{n+1})((1-\theta) u^n + \theta u^{n+1})
\end{equation}
$$
<p>&nbsp;<br>

or,
<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1} - u^{n}}{\Delta t} = -(1-\theta) a(t_n)u^n - \theta
a(t_{n+1})u^{n+1}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Extension to a variable coefficient; operator notation  <a name="___sec104"></a></h2>

<p>&nbsp;<br>
$$
\begin{align*}
\lbrack D^+_t u &= -au\rbrack^n,\\ 
\lbrack D^-_t u &= -au\rbrack^n,\\ 
\lbrack D_t u &= -a\overline{u}^t\rbrack^{n+\half},\\ 
\lbrack D_t u &= -\overline{au}^t\rbrack^{n+\half}\\ 
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Extension to a source term <a name="decay:source"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
u'(t) = -a(t)u(t) + b(t),\quad t\in (0,T],\quad u(0)=I
\tag{33}
\end{equation}
$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{align*}
\lbrack D^+_t u &= -au + b\rbrack^n,\\ 
\lbrack D^-_t u &= -au + b\rbrack^n,\\ 
\lbrack D_t u   &= -a\overline{u}^t + b\rbrack^{n+\half},\\ 
\lbrack D_t u   &= \overline{-au+b}^t\rbrack^{n+\half}
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Implementation of the generalized model problem <a name="decay:general"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = ((1 - \Delta t(1-\theta)a^n)u^n
+ \Delta t(\theta b^{n+1} + (1-\theta)b^n))(1 + \Delta t\theta a^{n+1})^{-1}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Implementation where \( a(t) \) and \( b(t) \) are given as
Python functions (see file <a href="http://tinyurl.com/jvzzcfn/decay/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, b, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;=-a(t)*u + b(t), u(0)=I,</span>
<span style="color: #CD5555">    for t in (0,T] with steps of dt.</span>
<span style="color: #CD5555">    a and b are Python functions of t.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)            <span style="color: #228B22"># avoid integer division</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))     <span style="color: #228B22"># no of time intervals</span>
    T = Nt*dt                 <span style="color: #228B22"># adjust T to fit time step dt</span>
    u = zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
    t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>

    u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
        u[n+<span style="color: #B452CD">1</span>] = ((<span style="color: #B452CD">1</span> - dt*(<span style="color: #B452CD">1</span>-theta)*a(t[n]))*u[n] + \ 
                  dt*(theta*b(t[n+<span style="color: #B452CD">1</span>]) + (<span style="color: #B452CD">1</span>-theta)*b(t[n])))/\ 
                  (<span style="color: #B452CD">1</span> + dt*theta*a(t[n+<span style="color: #B452CD">1</span>]))
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
<p>

</section>


<section class="slide">

<h2>Implementations of variable coefficients; functions  <a name="___sec107"></a></h2>

Plain functions:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">a</span>(t):
    <span style="color: #8B008B; font-weight: bold">return</span> a_0 <span style="color: #8B008B; font-weight: bold">if</span> t &lt; tp <span style="color: #8B008B; font-weight: bold">else</span> k*a_0

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">b</span>(t):
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">1</span>
</pre></div>
<p>

</section>


<section class="slide">

<h2>Implementations of variable coefficients; classes  <a name="___sec108"></a></h2>

Better implementation: class with the parameters <code>a0</code>, <code>tp</code>, and <code>k</code>
as attributes and a <em>special method</em> <code>__call__</code> for evaluating \( a(t) \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">A</span>:
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__init__</span>(<span style="color: #658b00">self</span>, a0=<span style="color: #B452CD">1</span>, k=<span style="color: #B452CD">2</span>):
        <span style="color: #658b00">self</span>.a0, <span style="color: #658b00">self</span>.k = a0, k

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__call__</span>(<span style="color: #658b00">self</span>, t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">self</span>.a0 <span style="color: #8B008B; font-weight: bold">if</span> t &lt; <span style="color: #658b00">self</span>.tp <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #658b00">self</span>.k*<span style="color: #658b00">self</span>.a0

a = A(a0=<span style="color: #B452CD">2</span>, k=<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># a behaves as a function a(t)</span>
</pre></div>
<p>

</section>


<section class="slide">

<h2>Implementations of variable coefficients; lambda function  <a name="___sec109"></a></h2>

Quick writing: a one-liner <em>lambda function</em>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">a = <span style="color: #8B008B; font-weight: bold">lambda</span> t: a_0 <span style="color: #8B008B; font-weight: bold">if</span> t &lt; tp <span style="color: #8B008B; font-weight: bold">else</span> k*a_0
</pre></div>
<p>
In general,
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">f = <span style="color: #8B008B; font-weight: bold">lambda</span> arg1, arg2, ...: expressin
</pre></div>
<p>
is equivalent to
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(arg1, arg2, ...):
    <span style="color: #8B008B; font-weight: bold">return</span> expression
</pre></div>
<p>
One can use lambda functions directly in calls:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u, t = solver(<span style="color: #B452CD">1</span>, <span style="color: #8B008B; font-weight: bold">lambda</span> t: <span style="color: #B452CD">1</span>, <span style="color: #8B008B; font-weight: bold">lambda</span> t: <span style="color: #B452CD">1</span>, T, dt, theta)
</pre></div>
<p>
for a problem \( u'=-u+1 \), \( u(0)=1 \).

<p>
A lambda function can appear anywhere where a variable can appear.

<p>

</section>


<section class="slide">

<h2>Verification via trivial solutions <a name="decay:verify:trivial"></a></h2>

<ul>
 <p><li> Start debugging of a new code with trying a problem
   where \( u=\hbox{const} \neq 0 \).</li>
 <p><li> Choose \( u=C \) (a constant). Choose any \( a(t) \) and set
   \( b=a(t)C \) and
   \( I=C \).</li>
 <p><li> "All" numerical methods will reproduce \( u=_{\hbox{const}} \)
   exactly (machine precision).</li>
 <p><li> Often \( u=C \) eases debugging.</li>
 <p><li> In this example: <em>any error</em> in the formula for \( u^{n+1} \)
   make \( u\neq C \)!</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Verification via trivial solutions; test function  <a name="___sec111"></a></h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_constant_solution</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Test problem where u=u_const is the exact solution, to be</span>
<span style="color: #CD5555">    reproduced (to machine precision) by any relevant method.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> u_const

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">a</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2.5</span>*(<span style="color: #B452CD">1</span>+t**<span style="color: #B452CD">3</span>)  <span style="color: #228B22"># can be arbitrary</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">b</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> a(t)*u_const

    u_const = <span style="color: #B452CD">2.15</span>
    theta = <span style="color: #B452CD">0.4</span>; I = u_const; dt = <span style="color: #B452CD">4</span>
    Nt = <span style="color: #B452CD">4</span>  <span style="color: #228B22"># enough with a few steps</span>
    u, t = solver(I=I, a=a, b=b, T=Nt*dt, dt=dt, theta=theta)
    <span style="color: #8B008B; font-weight: bold">print</span> u
    u_e = exact_solution(t)
    difference = <span style="color: #658b00">abs</span>(u_e - u).max()  <span style="color: #228B22"># max deviation</span>
    tol = <span style="color: #B452CD">1E-14</span>
    <span style="color: #8B008B; font-weight: bold">assert</span> difference &lt; tol
</pre></div>
<p>

</section>


<section class="slide">

<h2>Verification via manufactured solutions <a name="decay:MMS"></a></h2>

<ul>
 <p><li> Choose <em>any</em> formula for \( u(t) \).</li>
 <p><li> Fit \( I \), \( a(t) \), and \( b(t) \) in \( u'=-au+b \), \( u(0)=I \),
   to make the chosen formula a solution of the ODE problem.</li>
 <p><li> Then we can always have an analytical solution (!).</li>
 <p><li> Ideal for verification: testing convergence rates.</li>
 <p><li> Called the <em>method of manufactured solutions</em> (MMS)</li>
 <p><li> Special case: \( u \) linear in \( t \), because all sound numerical
   methods will reproduce a linear \( u \) exactly (machine precision).</li>
 <p><li> \( u(t) = ct + d \). \( u(0)=0 \) means \( d=I \).</li>
 <p><li> ODE implies \( c = -a(t)u + b(t) \).</li>
 <p><li> Choose \( a(t) \) and \( c \), and set \( b(t) = c + a(t)(ct + I) \).</li>
 <p><li> Any error in the formula for \( u^{n+1} \) makes \( u\neq ct+I \)!</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Linear manufactured solution  <a name="___sec113"></a></h2>

\( u^n = ct_n+I \) fulfills the discrete
equations!

<p>
First,
<p>&nbsp;<br>
$$
\begin{align}
\lbrack D_t^+ t\rbrack^n &= \frac{t_{n+1}-t_n}{\Delta t}=1,
\tag{34}\\ 
\lbrack D_t^- t\rbrack^n &= \frac{t_{n}-t_{n-1}}{\Delta t}=1,
\tag{35}\\ 
\lbrack D_t t\rbrack^n &= \frac{t_{n+\half}-t_{n-\half}}{\Delta t}=\frac{(n+\half)\Delta t - (n-\half)\Delta t}{\Delta t}=1\tag{36}
\end{align}
$$
<p>&nbsp;<br>


<p>
Forward Euler:

<p>&nbsp;<br>
$$ [D^+ u = -au + b]^n $$
<p>&nbsp;<br>


<p>
\( a^n=a(t_n) \), \( b^n=c + a(t_n)(ct_n + I) \), and \( u^n=ct_n + I \)
results in

<p>&nbsp;<br>
$$ c = -a(t_n)(ct_n+I) + c + a(t_n)(ct_n + I) = c $$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Test function for linear manufactured solution  <a name="___sec114"></a></h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_linear_solution</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Test problem where u=c*t+I is the exact solution, to be</span>
<span style="color: #CD5555">    reproduced (to machine precision) by any relevant method.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> c*t + I

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">a</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> t**<span style="color: #B452CD">0.5</span>  <span style="color: #228B22"># can be arbitrary</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">b</span>(t):
        <span style="color: #8B008B; font-weight: bold">return</span> c + a(t)*exact_solution(t)

    theta = <span style="color: #B452CD">0.4</span>; I = <span style="color: #B452CD">0.1</span>; dt = <span style="color: #B452CD">0.1</span>; c = -<span style="color: #B452CD">0.5</span>
    T = <span style="color: #B452CD">4</span>
    Nt = <span style="color: #658b00">int</span>(T/dt)  <span style="color: #228B22"># no of steps</span>
    u, t = solver(I=I, a=a, b=b, T=Nt*dt, dt=dt, theta=theta)
    u_e = exact_solution(t)
    difference = <span style="color: #658b00">abs</span>(u_e - u).max()  <span style="color: #228B22"># max deviation</span>
    <span style="color: #8B008B; font-weight: bold">print</span> difference
    tol = <span style="color: #B452CD">1E-14</span>  <span style="color: #228B22"># depends on c!</span>
    <span style="color: #8B008B; font-weight: bold">assert</span> difference &lt; tol
</pre></div>
<p>

</section>


<section class="slide">

<h2>Extension to systems of ODEs  <a name="___sec115"></a></h2>

Sample system:

<p>&nbsp;<br>
$$
\begin{align}
u' &= a u + bv\\ 
v' &= cu +  dv
\end{align}
$$
<p>&nbsp;<br>


<p>
The Forward Euler method:

<p>&nbsp;<br>
$$
\begin{align}
u^{n+1} &= u^n + \Delta t (a u^n + b v^n)\\ 
v^{n+1} &= u^n + \Delta t (cu^n + dv^n)
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The Backward Euler method gives a system of algebraic equations  <a name="___sec116"></a></h2>

The Backward Euler scheme:

<p>&nbsp;<br>
$$
\begin{align}
u^{n+1} &= u^n + \Delta t (a u^{n+1} + b v^{n+1})\\ 
v^{n+1} &= v^n + \Delta t (c u^{n+1} + d v^{n+1})
\end{align}
$$
<p>&nbsp;<br>

which is a \( 2\times 2 \) linear system:

<p>&nbsp;<br>
$$
\begin{align}
(1 - \Delta t a)u^{n+1} + bv^{n+1} &= u^n \\ 
c u^{n+1} + (1 - \Delta t d) v^{n+1} &= v^n
\end{align}
$$
<p>&nbsp;<br>


<p>
Crank-Nicolson also gives a \( 2\times 2 \) linear system.

<p>

</section>


<section class="slide">

<h1>Methods for general first-order ODEs <a name="decay:1stODEs"></a></h1>


</section>


<section class="slide">

<h2>Generic form  <a name="___sec118"></a></h2>

The standard form for ODEs:
<p>&nbsp;<br>
$$
\begin{equation}
u' = f(u,t),\quad u(0)=I
\tag{37}
\end{equation}
$$
<p>&nbsp;<br>


<p>
\( u \) and \( f \): scalar or vector.

<p>
Vectors in case of ODE systems:
<p>&nbsp;<br>
$$ u(t) = (u^{(0)}(t),u^{(1)}(t),\ldots,u^{(m-1)}(t))   $$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{align*}
f(u, t) = ( & f^{(0)}(u^{(0)},\ldots,u^{(m-1)})\\ 
            & f^{(1)}(u^{(0)},\ldots,u^{(m-1)}),\\ 
            & \vdots\\ 
            & f^{(m-1)}(u^{(0)}(t),\ldots,u^{(m-1)}(t)))
\end{align*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The \( \theta \)-rule  <a name="___sec119"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1}-u^n}{\Delta t} = \theta f(u^{n+1},t_{n+1}) +
(1-\theta)f(u^n, t_n)
\tag{38}
\end{equation}
$$
<p>&nbsp;<br>

Bringing the unknown \( u^{n+1} \) to the left-hand side and the known terms
on the right-hand side gives

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} - \Delta t \theta f(u^{n+1},t_{n+1}) =
u^n + \Delta t(1-\theta)f(u^n, t_n)
\end{equation}
$$
<p>&nbsp;<br>

This is a <em>nonlinear</em> equation in \( u^{n+1} \) (unless \( f \) is linear in \( u \))!

<p>

</section>


<section class="slide">

<h2>Implicit 2-step backward scheme  <a name="___sec120"></a></h2>

<p>&nbsp;<br>
$$ u'(t_{n+1}) \approx \frac{3u^{n+1} - 4u^{n} + u^{n-1}}{2\Delta t}$$
<p>&nbsp;<br>


<p>
Scheme:
<p>&nbsp;<br>
$$ u^{n+1} = \frac{4}{3}u^n - \frac{1}{3}u^{n-1} +
\frac{2}{3}\Delta t f(u^{n+1}, t_{n+1})
\tag{39}
$$
<p>&nbsp;<br>

Nonlinear equation for \( u^{n+1} \).

<h2>The Leapfrog scheme  <a name="___sec121"></a></h2>

Idea:
<p>&nbsp;<br>
$$
\begin{equation}
u'(t_n)\approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t} u]^n
\end{equation}
$$
<p>&nbsp;<br>


<p>
Scheme:

<p>&nbsp;<br>
$$ [D_{2t} u = f(u,t)]^n$$
<p>&nbsp;<br>

or written out,
<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = u^{n-1} + \Delta t f(u^n, t_n)
\tag{40}
\end{equation}
$$
<p>&nbsp;<br>


<ul>
 <p><li> Some other scheme must be used as starter (\( u^1 \)).</li>
 <p><li> Explicit scheme - a nonlinear \( f \) (in \( u \)) is trivial to handle.</li>
 <p><li> Downside: Leapfrog is always unstable after some time.</li>
</ul>
<p>


</section>


<section class="slide">

<h2>The filtered Leapfrog scheme  <a name="___sec122"></a></h2>

After computing \( u^{n+1} \), stabilize Leapfrog by
<p>&nbsp;<br>
$$
\begin{equation}
u^n\ \leftarrow\ u^n + \gamma (u^{n-1} - 2u^n + u^{n+1})
\tag{41}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>2nd-order Runge-Kutta scheme  <a name="___sec123"></a></h2>

Forward-Euler + approximate Crank-Nicolson:
<p>&nbsp;<br>
$$
\begin{align}
u^* &= u^n + \Delta t f(u^n, t_n),
\tag{42}\\ 
u^{n+1} &= u^n + \Delta t \half \left( f(u^n, t_n) + f(u^*, t_{n+1})
\right)
\tag{43}
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>4th-order Runge-Kutta scheme <a name="decay:fd2:RK4"></a></h2>

<ul>
 <p><li> The most famous and widely used ODE method</li>
 <p><li> 4 evaluations of \( f \) per time step</li>
 <p><li> Its <a href="http://tinyurl.com/k3sdbuv/pub/sphinx-decay/._main_decay007.html#th-order-runge-kutta-scheme" target="_self">derivation</a> is a very good illustration of numerical thinking!</li>
</ul>
<p>


</section>


<section class="slide">

<h2>2nd-order Adams-Bashforth scheme  <a name="___sec125"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = u^n + \half\Delta t\left( 3f(u^n, t_n) - f(u^{n-1}, t_{n-1})
\right)
\tag{44}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>3rd-order Adams-Bashforth scheme  <a name="___sec126"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1} = u^n + \frac{1}{12}\left( 23f(u^n, t_n) - 16 f(u^{n-1},t_{n-1})
+ 5f(u^{n-2}, t_{n-2})\right)
\tag{45}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The Odespy software  <a name="___sec127"></a></h2>

<a href="https://github.com/hplgit/odespy" target="_self">Odespy</a>
features simple Python implementations of the most fundamental
schemes as well as Python interfaces to several famous packages for
solving ODEs: <a href="https://computation.llnl.gov/casc/odepack/odepack_home.html" target="_self">ODEPACK</a>,
<a href="https://computation.llnl.gov/casc/odepack/odepack_home.html" target="_self">Vode</a>,
<a href="http://www.netlib.org/ode/rkc.f" target="_self">rkc.f</a>,
<a href="http://www.netlib.org/ode/rkf45.f" target="_self">rkf45.f</a>,
<a href="http://www.unige.ch/~hairer/software.html" target="_self">Radau5</a>, as well
as the ODE solvers in
<a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.ode.html" target="_self">SciPy</a>,
<a href="http://docs.sympy.org/dev/modules/mpmath/calculus/odes.html" target="_self">SymPy</a>, and
<a href="http://olivierverdier.github.com/odelab/" target="_self">odelab</a>.

<p>
Typical usage:

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"># Define right-hand side of ODE
def f(u, t):
    return -a*u

import odespy
import numpy as np

# Set parameters and time mesh
I = 1; a = 2; T = 6; dt = 1.0
Nt = int(round(T/dt))
t_mesh = np.linspace(0, T, Nt+1)

# Use a 4th-order Runge-Kutta method
solver = odespy.RK4(f)
solver.set_initial_condition(I)
u, t = solver.solve(t_mesh)
</pre></div>
<p>

</section>


<section class="slide">

<h2>Example: Runge-Kutta methods   <a name="___sec128"></a></h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">solvers = [odespy.RK2(f),
           odespy.RK3(f),
           odespy.RK4(f),
           odespy.BackwardEuler(f, nonlinear_solver=<span style="color: #CD5555">&#39;Newton&#39;</span>)]

<span style="color: #8B008B; font-weight: bold">for</span> solver <span style="color: #8B008B">in</span> solvers:
    solver.set_initial_condition(I)
    u, t = solver.solve(t)

<span style="color: #228B22"># + lots of plot code...</span>
</pre></div>
<p>

</section>


<section class="slide">

<h2>Plots from the experiments  <a name="___sec129"></a></h2>

<center><p><img src="fig-decay/decay_odespy1_png.png" align="bottom" width=800></p></center>

<p>
The 4-th order Runge-Kutta method (<code>RK4</code>) is the method of choice!

<p>

</section>


<section class="slide">

<h2>Example: Adaptive Runge-Kutta methods   <a name="___sec130"></a></h2>

<ul>
 <p><li> Adaptive methods find "optimal" locations of the mesh points
   to ensure that the error is less than a given tolerance.</li>
 <p><li> Downside: approximate error estimation, not always optimal
   location of points.</li>
 <p><li> "Industry standard ODE solver": Dormand-Prince 4/5-th order
   Runge-Kutta (MATLAB's famous <code>ode45</code>).</li>
</ul>
<p>

<center><p><img src="fig-decay/decay_DormandPrince_adaptivity.png" align="bottom" width=800></p></center>


</section>




<footer>
<!-- Here goes a footer -->
</footer>

<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>
-->

<!-- deck.goto snippet
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>
-->

<!-- deck.hash snippet
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>
-->

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="deck.js/jquery.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/hash/deck.hash.js"></script>
<script src="deck.js/extensions/menu/deck.menu.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/status/deck.status.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>
<script src="deck.js/extensions/notes/deck.notes.js"></script>

<!-- From https://github.com/mikeharris100/deck.pointer.js -->
<script src="deck.js/extensions/pointer/deck.pointer.js"></script>

<!-- From https://github.com/stvnwrgs/presenterview
<script type="text/javascript" src="deck.js/extensions/presenterview/deck.presenterview.js"></script> -->

<!-- From https://github.com/nemec/deck.annotate.js
<script type="text/javascript" src="deck.js/extensions/deck.annotate.js/deck.annotate.js"></script>
-->


<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>


</body>
</html>
