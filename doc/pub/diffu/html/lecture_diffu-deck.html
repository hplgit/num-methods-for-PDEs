<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Finite difference schemes for diffusion processes">
<meta name="keywords" content="diffusion equation, 1D,heat equation, 1D,mesh finite differences,stencil 1D diffusion equation,mesh function">

<title>Study guide: Finite difference schemes for diffusion processes</title>







<!-- deck.js: https://github.com/imakewebthings/deck.js -->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=1024, user-scalable=no">

<!-- Required stylesheet -->
<link rel="stylesheet" href="deck.js/core/deck.core.css">

<!-- Extension CSS files go here. Remove or add as needed.
deck.goto: Adds a shortcut key to jump to any slide number.
Hit g, type in the slide number, and hit enter.

deck.hash: Enables internal linking within slides, deep
linking to individual slides, and updates the address bar and
a permalink anchor with each slide change.

deck.menu: Adds a menu view, letting you see all slides in a grid.
Hit m to toggle to menu view, continue navigating your deck,
and hit m to return to normal view. Touch devices can double-tap
the deck to switch between views.

deck.navigation: Adds clickable left and right buttons for the
less keyboard inclined.

deck.status: Adds a page number indicator. (current/total).

deck.scale: Scales each slide to fit within the deck container
using CSS Transforms for those browsers that support them.

deck.pointer: Turn mouse into laser pointer (toggle with p).
(Requires https://github.com/mikeharris100/deck.pointer.js)
-->

<link rel="stylesheet" href="deck.js/extensions/menu/deck.menu.css">
<link rel="stylesheet" href="deck.js/extensions/navigation/deck.navigation.css">
<link rel="stylesheet" href="deck.js/extensions/scale/deck.scale.css">
<link rel="stylesheet" href="deck.js/extensions/pointer/deck.pointer.css">
<link rel="stylesheet" href="deck.js/extensions/notes/deck.notes.css">
<!--
<link rel="stylesheet" href="deck.js/extensions/goto/deck.goto.css">
<link rel="stylesheet" href="deck.js/extensions/hash/deck.hash.css">
<link rel="stylesheet" href="deck.js/extensions/status/deck.status.css">
-->

<!-- Style theme. More available in themes/style/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">

<!--
<link rel="stylesheet" href="deck.js/themes/style/neon.css">
<link rel="stylesheet" href="deck.js/themes/style/swiss.css">
<link rel="stylesheet" href="deck.js/themes/style/web-2.0.css">

git clone git://github.com/duijf/mnml.git
<link rel="stylesheet" href="deck.js/themes/style/mnml.css">

git://github.com/groovecoder/deckjs-theme-mozilla.git
<link rel="stylesheet" href="deck.js/themes/style/sandstone.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.aurora.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.dark.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.firefox.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.light.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.mdn.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.nightly.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.cbc.css">

git://github.com/barraq/deck.ext.js.git
<link rel="stylesheet" href="deck.js/themes/style/beamer.css">
-->

<!--
Transition theme. More available in /themes/transition/ or create your own. -->
<!--
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/fade.css">
<link rel="stylesheet" href="deck.js/themes/transition/vertical-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
-->

<!-- Required Modernizr file -->
<script src="deck.js/modernizr.custom.js"></script>

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */

hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
     padding:8px 35px 8px 14px; margin-bottom:18px;
     text-shadow:0 1px 0 rgba(255,255,255,0.5);
     border:5px solid #bababa;
       -webkit-border-radius:14px; -moz-border-radius:14px;
     border-radius:14px
     background-position: 10px 10px;
     background-repeat: no-repeat;
     background-size: 38px;
     padding-left: 30px; /* 55px; if icon */
 }
 .slide .alert-block {padding-top:14px; padding-bottom:14px}
 .slide .alert-block > p, .alert-block > ul {margin-bottom:0}
 /*.slide .alert li {margin-top: 1em}*/
 .deck .alert-block p+p {margin-top:5px}
 /*.slide .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_notice.png); }
 .slide .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_summary.png); }
 .slide .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_warning.png); }
 .slide .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body class="deck-container">

<header>
<!-- Here goes a potential header -->
</header>

<!-- do not use the article tag - it gives strange sizings -->





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
$$




    



<section class="slide">
<!-- ------------------- main content ---------------------- -->



<h2 style="text-align: center;">Study guide: Finite difference schemes for diffusion processes</h2>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b style="font-weight: bold">Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b style="font-weight: bold">Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b style="font-weight: bold">Department of Informatics, University of Oslo</b></center>
<p>
<center><b style="font-weight: bold">Sep 26, 2014</b></center> <!-- date -->
<p>

</section>


<section class="slide">

<h1 style="text-align: center;">The 1D diffusion equation  <a name="___sec0"></a></h1>

<p>
The famous <em>diffusion equation</em>, also known as the <em>heat equation</em>,
reads

<p>&nbsp;<br>
$$ \frac{\partial u}{\partial t} =
\dfc \frac{\partial^2 u}{\partial x^2}
$$
<p>&nbsp;<br>


<p>
Here,

<ul>
 <p><li> \( u(x,t) \): unknown</li>
 <p><li> \( \dfc \): <em>diffusion coefficient</em></li>
</ul>
<p>

Alternative, compact notation:

<p>&nbsp;<br>
$$ u_t = \dfc u_{xx} $$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The initial-boundary value problem for 1D diffusion  <a name="___sec1"></a></h2>

<p>&nbsp;<br>
$$
\begin{align}
\frac{\partial u}{\partial t} &=
\dfc \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]
\tag{1}\\ 
u(x,0) &= I(x), \quad  x\in [0,L]
\tag{2}\\ 
u(0,t) & = 0, \quad  t>0,
\tag{3}\\ 
u(L,t) & = 0, \quad  t>0\tp
\tag{4}
\end{align}
$$
<p>&nbsp;<br>


<p>
Note:

<ul>
 <p><li> First-order derivative in time: one initial condition</li>
 <p><li> Second-order derivative in space: a boundary condition at each
   point of the boundary (2 points in 1D)</li>
 <p><li> Numerous applications throughout physics and biology</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Step 1: Discretizing the domain <a name="diffu:1D:mesh"></a></h2>

<p>
Mesh in time:

<p>&nbsp;<br>
$$
\begin{equation}
0 = t_0 < t_1 < t_2 < \cdots < t_{N_t-1} < t_{N_t} = T   \end{equation}
$$
<p>&nbsp;<br>


<p>
Mesh in space:

<p>&nbsp;<br>
$$
\begin{equation}
0 = x_0 < x_1 < x_2 < \cdots < x_{N_x-1} < x_{N_x} = L   \end{equation}
$$
<p>&nbsp;<br>


<p>
Uniform mesh with constant mesh spacings \( \Delta t \) and \( \Delta x \):

<p>&nbsp;<br>
$$
\begin{equation}
x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
t_i = n\Delta t,\ n=0,\ldots,N_t
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The discrete solution <a name="diffu:1D:numerical:sol"></a></h2>

<ul>
 <p><li> The numerical solution is a mesh function: \( u_i^n \approx \uex(x_i,t_n) \)</li>
 <p><li> Finite difference stencil (or scheme): equation for \( u^n_i \) involving
   neighboring space-time points</li>
</ul>
<p>

<center><p><img src="mov-diffu/diffu1D_PDE_FE_Dirichlet_stencil_gpl/stencil_n_interior.png" align="bottom" width=500></p></center>

<p>

</section>


<section class="slide">

<h2>Step 2: Fulfilling the equation at the mesh points <a name="diffu:1D:samplingPDE"></a></h2>

<p>
Require the PDE <a href="#mjx-eqn-1">(1)</a> to be fulfilled at an arbitrary
<em>interior mesh point</em> \( (x_i,t_n) \)
leads to

<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial}{\partial t} u(x_i, t_n) =
\dfc\frac{\partial^2}{\partial x^2} u(x_i, t_n)
\tag{5}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Applies to all interior mesh points: \( i=1,\ldots,N_x-1 \) and \( n=1,\ldots,N_t-1 \)

<p>
For \( n=0 \) we have the initial conditions \( u=I(x) \) and \( u_t=0 \)

<p>
At the boundaries \( i=0,N_x \) we have the boundary condition \( u=0 \).

<p>

</section>


<section class="slide">

<h2>Step 3: Replacing derivatives by finite differences <a name="diffu:1D:fd"></a></h2>

<p>
Use a forward difference in time and a centered difference in space
(<em>Forward Euler</em> scheme):

<p>&nbsp;<br>
$$
\begin{equation}
[D_t^+ u = \dfc D_xD_x u]^n_i
\tag{6}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Written out,

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n+1}_i-u^n_i}{\Delta t} = \dfc \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}
\tag{7}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Initial condition: \( u^0_i = I(x_i) \), \( i=0,1,\ldots,N_x \).

<p>

</section>


<section class="slide">

<h2>Step 4: Formulating a recursive algorithm <a name="diffu:1D:alg"></a></h2>

<ul>
 <p><li> Nature of the algorithm: compute \( u \) in space at \( t=\Delta t, 2\Delta t, 3\Delta t,... \)</li>
 <p><li> Two time levels are involved in the general discrete equation:
   \( n+1 \) and \( n \)</li>
 <p><li> \( u^n_i \) is already computed for \( i=0,\ldots,N_x \),
   and \( u^{n+1}_i \) is the unknown quantity</li>
</ul>
<p>

Solve the discretized PDE for the unknown \( u^{n+1}_i \):

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1}_i = u^n_i + Fo\left(
u^{n}_{i+1} - 2u^n_i + u^n_{i-1}\right)
\tag{8}
\end{equation}
$$
<p>&nbsp;<br>


<p>
where

<p>&nbsp;<br>
$$ Fo = \dfc\frac{\Delta t}{\Delta x^2} $$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The mesh Fourier number  <a name="___sec7"></a></h2>

<p>&nbsp;<br>
$$ Fo = \dfc\frac{\Delta t}{\Delta x^2} $$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Observe.</b>
<p>
There is only one parameter, \( Fo \), in the discrete model:
\( Fo \) lumps mesh parameters \( \Delta t \) and \( \Delta x \)
with the only physical parameter, the diffusion coefficient
\( \dfc \).
The value \( Fo \) and the smoothness of \( I(x) \)
govern the quality of the numerical solution.
</div>


<p>

</section>


<section class="slide">

<h2>The finite difference stencil  <a name="___sec8"></a></h2>

<p>
<center><p><img src="mov-diffu/diffu1D_PDE_FE_Dirichlet_stencil_gpl/stencil_n_interior.png" align="bottom" width=500></p></center>

<p>

</section>


<section class="slide">

<h2>The computational algorithm for the Forward Euler scheme  <a name="___sec9"></a></h2>

<ol>
 <p><li> compute \( u^0_i=I(x_i) \), \( i=0,\ldots,N_x \)</li>
 <p><li> for \( n=0,1,\ldots,N_t \):</li>

<ol>
   <p><li> compute \( u^{n+1}_i \) from <a href="#mjx-eqn-8">(8)</a> for all the internal
      spatial points \( i=1,\ldots,N_x-1 \)</li>
   <p><li> set the boundary values
      \( u^{n+1}_i=0 \) for \( i=0 \) and \( i=N_x \)</li>
</ol>
<p>

</ol>
<p>

<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Notice.</b>
<p>
We visit one mesh point \( (x_i,t_{n+1}) \) at a time,
and we have an explicit formula
for computing the associated \( u^{n+1}_i \) value.
The spatial points can be updated in any sequence, but the
time levels \( t_n \) must be updated in cronological order: \( t_n \) before
\( t_{n+1} \).
</div>


<p>

</section>


<section class="slide">

<h2>The Python implementation of the computational algorithm  <a name="___sec10"></a></h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)    <span style="color: #228B22"># mesh points in space</span>
dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)    <span style="color: #228B22"># mesh points in time</span>
dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]
Fo = a*dt/dx**<span style="color: #B452CD">2</span>
u   = zeros(Nx+<span style="color: #B452CD">1</span>)
u_1 = zeros(Nx+<span style="color: #B452CD">1</span>)

<span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
    <span style="color: #228B22"># Compute u at inner mesh points</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        u[i] = u_1[i] + Fo*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])

    <span style="color: #228B22"># Insert boundary conditions</span>
    u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>

    <span style="color: #228B22"># Update u_1 before next step</span>
    u_1[:]= u
    <span style="color: #228B22"># or more efficient switch of references</span>
    <span style="color: #228B22">#u_1, u = u, u_1</span>
</pre></div>
<p>

</section>


<section class="slide">

<h2>Moving finite difference stencil  <a name="___sec11"></a></h2>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_PDE_FE_Dirichlet_stencil_gpl/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<a href="http://tinyurl.com/opdfafk/pub/mov-diffu/diffu1D_PDE_FE_Dirichlet_stencil_gpl/index.html" target="_self">web page</a>
or a <a href="http://tinyurl.com/opdfafk/pub/mov-diffu/diffu1D_PDE_FE_Dirichlet_stencil_gpl/movie.ogg" target="_self">movie file</a>.

<p>

</section>


<section class="slide">

<h2>Demo program  <a name="___sec12"></a></h2>

<ul>
 <p><li> Program: <a href="http://tinyurl.com/nm5587k/diffu/diff1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a></li>
 <p><li> Produces animation on the screen</li>
 <p><li> Each frame stored in <code>tmp_frame%04d.png</code> files<br />
   <code>tmp_frame0000.png</code>, <code>tmp_frame0001.png</code>, ...</li>
</ul>
<p>

How to make movie file in modern formats:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; name=tmp_frame%04d.png
Terminal&gt; fps=8  # frames per second in movie
Terminal&gt; avconv -r $fps -i $name -vcodec flv       movie.flv
Terminal&gt; avconv -r $fps -i $name -vcodec libx64    movie.mp4
Terminal&gt; avconv -r $fps -i $name -vcodec libvpx    movie.webm
Terminal&gt; avconv -r $fps -i $name -vcodec libtheora movie.ogg
</pre></div>
<p>

</section>


<section class="slide">

<h2>Forward Euler applied to an initial plug profile  <a name="___sec13"></a></h2>

<p>
\( N_x=50 \). The method results in a growing, unstable solution if \( Fo>0.5 \).

<p>

<table border="0">
<tr>
<td class="padding">
Choosing \( Fo=0.5 \) gives a strange saw tooth-like curve.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

</td>
<td class="padding">
Lowering \( Fo \) to 0.25 gives a smooth (expected) solution.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_Fo025/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_Fo025/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_Fo025/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

</td>
</tr>
</table>


<p>


<p>

</section>


<section class="slide">

<h2>Forward Euler applied to a Gaussian profile  <a name="___sec14"></a></h2>

<p>
\( N_x=50 \). \( Fo=0.5 \).

<p>

<table border="0">
<tr>
<td class="padding">
<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

</td>
<td class="padding">
<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian2/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian2/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian2/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

</td>
</tr>
</table>


<p>


<p>

</section>


<section class="slide">

<h2>Backward Euler scheme <a name="diffu:pde1:BE"></a></h2>

<p>
Backward difference in time, centered difference in space:

<p>&nbsp;<br>
$$
\begin{equation}
[D_t^- u = D_xD_x u]^n_i
\tag{9}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Written out:

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u^{n}_i-u^{n-1}_i}{\Delta t} = \dfc\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}
\tag{10}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Assumption: \( u^{n-1}_i \) is computed, but all quantities at the new
time level \( t_n \) are unknown.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Notice.</b>
<p>
We cannot solve wrt \( u^n_i \) because that unknown value is coupled to
two other unknown values: \( u^n_{i-1} \) and \( u^n_{i+1} \).
That is, all the new unknown values are coupled to each other
in a <em>linear system of algebraic equations</em>.
</div>


<p>

</section>


<section class="slide">

<h2>Let's write out the equations for \( N_x=3 \)  <a name="___sec16"></a></h2>

<p>
Equation <a href="#mjx-eqn-10">(10)</a> written for \( i=1,\ldots,Nx-1= 1,2 \) becomes

<p>&nbsp;<br>
$$
\begin{align}
\frac{u^{n}_1-u^{n-1}_1}{\Delta t} &= \dfc\frac{u^{n}_{2} - 2u^n_1 + u^n_{0}}{\Delta x^2}\\ 
\frac{u^{n}_2-u^{n-1}_2}{\Delta t} &= \dfc\frac{u^{n}_{3} - 2u^n_2 + u^n_{1}}{\Delta x^2}
\end{align}
$$
<p>&nbsp;<br>


<p>
(The boundary values \( u^n_0 \) and \( u^n_3 \) are known as zero.)

<p>
Collecting the unknown new values  on the left-hand side and writing
as \( 2\times 2 \) matrix system:

<p>&nbsp;<br>
$$ \left(\begin{array}{cc}
1+  2Fo &   - Fo\\ 
- Fo    & 1+  2Fo
\end{array}\right)
\left(\begin{array}{c}
u^{n}_1\\ 
u^{n}_{2}\\ 
\end{array}\right)
=
\left(\begin{array}{c}
u^{n-1}_1\\ 
u^{n-1}_2
\end{array}\right)
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Two classes of discretization methods: explicit and implicit  <a name="___sec17"></a></h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Implicit.</b>
<p>
Discretization methods that lead linear systems are known
as <em>implicit methods</em>.
</div>


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b style="font-weight: bold">Explicit.</b>
<p>
Discretization methods that avoid linear systems and have
an explicit formula for each new value of the unknown are called
<em>explicit methods</em>.
</div>


<p>

</section>


<section class="slide">

<h2>The linear system for a general \( N_x \)  <a name="___sec18"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
- F_o u^n_{i-1} + \left(1+  2F_o \right) u^{n}_i - F_o u^n_{i+1} =
u_{i-1}^{n-1}
\tag{11}
\end{equation}
$$
<p>&nbsp;<br>

for \( i=1,\ldots,Nx-1 \).

<p>
What are the unknowns in the linear system?

<ol>
<p><li> either \( u^n_i \) for \( i=1,\ldots,N_x-1 \) (all <em>internal</em> spatial mesh points)</li>
<p><li> or \( u^n_i \), \( i=0,\ldots,N_x \) (all spatial points)</li>
</ol>
<p>

The linear system in matrix notation:

<p>&nbsp;<br>
$$
\begin{equation*} AU = b,\quad U=(u^n_0,\ldots,u^n_{N_x})
\end{equation*}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>\( A \) is very sparse: a tridiagonal matrix  <a name="___sec19"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
A =
\left(
\begin{array}{cccccccccc}
A_{0,0} & A_{0,1} & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
A_{1,0} & A_{1,1} & 0 & \ddots &   & &  & &  \vdots \\ 
0 & A_{2,1} & A_{2,2} & A_{2,3} &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & A_{i,i-1} & A_{i,i} & A_{i,i+1} & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & A_{N_x-1,N_x} \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & A_{N_x,N_x-1} & A_{N_x,N_x}
\end{array}
\right)
\tag{12}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Detailed expressions for the matrix entries  <a name="___sec20"></a></h2>

<p>
The nonzero elements are given by

<p>&nbsp;<br>
$$
\begin{align}
A_{i,i-1} &= -F_o\\ 
A_{i,i} &= 1+ 2F_o\\ 
A_{i,i+1} &= -F_o
\end{align}
$$
<p>&nbsp;<br>


<p>
for \( i=1,\ldots,N_x-1 \).

<p>
The equations for the boundary points correspond to

<p>&nbsp;<br>
$$
A_{0,0} = 1,\quad A_{0,1} = 0,\quad A_{N_x,N_x-1} = 0,\quad
A_{N_x,N_x} = 1
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The right-hand side  <a name="___sec21"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
b = \left(\begin{array}{c}
b_0\\ 
b_1\\ 
\vdots\\ 
b_i\\ 
\vdots\\ 
b_{N_x}
\end{array}\right)
\end{equation}
$$
<p>&nbsp;<br>


<p>
with

<p>&nbsp;<br>
$$
\begin{align}
b_0 &= 0\\ 
b_i &= u^{n-1}_i,\quad i=1,\ldots,N_x-1\\ 
b_{N_x} &= 0
\end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Naive Python implementation with a dense \( (N_x+1)\times(N_x+1) \) matrix  <a name="___sec22"></a></h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># mesh points in space</span>
dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
t = linspace(<span style="color: #B452CD">0</span>, T, N+<span style="color: #B452CD">1</span>)    <span style="color: #228B22"># mesh points in time</span>
u   = zeros(Nx+<span style="color: #B452CD">1</span>)
u_1 = zeros(Nx+<span style="color: #B452CD">1</span>)

<span style="color: #228B22"># Data structures for the linear system</span>
A = zeros((Nx+<span style="color: #B452CD">1</span>, Nx+<span style="color: #B452CD">1</span>))
b = zeros(Nx+<span style="color: #B452CD">1</span>)

<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    A[i,i-<span style="color: #B452CD">1</span>] = -Fo
    A[i,i+<span style="color: #B452CD">1</span>] = -Fo
    A[i,i] = <span style="color: #B452CD">1</span> + <span style="color: #B452CD">2</span>*Fo
A[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>] = A[Nx,Nx] = <span style="color: #B452CD">1</span>

<span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scipy.linalg</span>

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
    <span style="color: #228B22"># Compute b and solve linear system</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        b[i] = -u_1[i]
    b[<span style="color: #B452CD">0</span>] = b[Nx] = <span style="color: #B452CD">0</span>
    u[:] = scipy.linalg.solve(A, b)

    <span style="color: #228B22"># Update u_1 before next step</span>
    u_1, u = u, u_1
</pre></div>
<p>

</section>


<section class="slide">

<h2>A sparse matrix representation will dramatically reduce the computational complexity <a name="diffu:pde1:impl:sparse"></a></h2>

<ul>
 <p><li> With a dense matrix, the algorithm leads to \( \Oof{N_x^3} \) operations</li>
 <p><li> Utilizing the sparsity, the algorithm has complexity \( \Oof{N_x} \)!</li>
 <p><li> <code>scipy.sparse</code> enables storage and calculations with the three
   nonzero diagonals only</li>
</ul>
<p>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Representation of sparse matrix and right-hand side</span>
diagonal  = zeros(Nx+<span style="color: #B452CD">1</span>)
lower     = zeros(Nx)
upper     = zeros(Nx)
b         = zeros(Nx+<span style="color: #B452CD">1</span>)
</pre></div>
<p>

</section>


<section class="slide">

<h2>Computing the sparse matrix  <a name="___sec24"></a></h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Precompute sparse matrix</span>
diagonal[:] = <span style="color: #B452CD">1</span> + <span style="color: #B452CD">2</span>*Fo
lower[:] = -Fo  <span style="color: #228B22">#1</span>
upper[:] = -Fo  <span style="color: #228B22">#1</span>
<span style="color: #228B22"># Insert boundary conditions</span>
diagonal[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1</span>
upper[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>
diagonal[Nx] = <span style="color: #B452CD">1</span>
lower[-<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">0</span>

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scipy.sparse</span>
A = scipy.sparse.diags(
    diagonals=[main, lower, upper],
    offsets=[<span style="color: #B452CD">0</span>, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>], shape=(Nx+<span style="color: #B452CD">1</span>, Nx+<span style="color: #B452CD">1</span>),
    format=<span style="color: #CD5555">&#39;csr&#39;</span>)

<span style="color: #228B22"># Set initial condition</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
    b = u_1
    b[<span style="color: #B452CD">0</span>] = b[-<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">0.0</span>  <span style="color: #228B22"># boundary conditions</span>
    u[:] = scipy.sparse.linalg.spsolve(A, b)
    <span style="color: #228B22"># Switch variables before next step</span>
    u_1, u = u, u_1
</pre></div>
<p>

</section>


<section class="slide">

<h2>Backward Euler applied to a plug profile  <a name="___sec25"></a></h2>

<p>
\( N_x=50 \).
\( Fo=0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_BE_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_BE_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_BE_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>

</section>


<section class="slide">

<h2>Backward Euler applied to a Gaussian profile  <a name="___sec26"></a></h2>

<p>
\( N_x=50 \).

<p>

<table border="0">
<tr>
<td class="padding">
<p>
\( Fo=0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

</td>
<td class="padding">
\( Fo=5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1_Fo5/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1_Fo5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1_Fo5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

</td>
</tr>
</table>


<p>


<p>

</section>


<section class="slide">

<h2>Crank-Nicolson scheme  <a name="___sec27"></a></h2>

<p>
The PDE is sampled at points \( (x_i,t_{n+\half}) \) (at the spatial
mesh points, but in between two temporal mesh points).

<p>&nbsp;<br>
$$
\frac{\partial}{\partial t} u(x_i, t_{n+\half}) =
\dfc\frac{\partial^2}{\partial x^2}u(x_i, t_{n+\half})
$$
<p>&nbsp;<br>

for \( i=1,\ldots,N_x-1 \) and \( n=0,\ldots, N_t-1 \).

<p>
Centered differences in space and time:

<p>&nbsp;<br>
$$ [D_t u = \dfc D_xD_x u]^{n+\half}_i$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Averaging in time is necessary in the Crank-Nicolson scheme  <a name="___sec28"></a></h2>

<p>
Right-hand side term:

<p>&nbsp;<br>
$$ \frac{1}{\Delta x^2}\left(u^{n+\half}_{i-1} - 2u^{n+\half}_i + u^{n+\half}_{i+1}\right)$$
<p>&nbsp;<br>


<p>
Problem: \( u^{n+\half}_i \) is not one of
the unknowns we compute.

<p>
Solution: replace \( u^{n+\half}_i \) by an arithmetic average:

<p>&nbsp;<br>
$$ u^{n+\half}_i\approx
\half\left(u^{n}_i +u^{n+1}_{i}\right)
$$
<p>&nbsp;<br>


<p>
In compact notation (arithmetic average in time \( \overline{u}^t \)):

<p>&nbsp;<br>
$$ [D_t u = \dfc D_xD_x \overline{u}^t]^{n+\half}_i$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Crank-Nicolsoon scheme written out  <a name="___sec29"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1}_i - \half Fo(u^{n+1}_{i-1} - 2u^{n+1}_i + u^{n+1}_{i+1})
= u^{n}_i + \half Fo(u^{n}_{i-1} - 2u^{n}_i + u^{n}_{i+1})
\end{equation}
$$
<p>&nbsp;<br>


<p>
Observe:

<ul>
 <p><li> The unknowns are \( u^{n+1}_{i-1}, u^{n+1}_{i}, u^{n+1}_{i+1} \)</li>
 <p><li> These unknowns are coupled to each other (in a linear system)</li>
 <p><li> Must solve \( AU=b \) at each time level</li>
</ul>
<p>

Now,

<p>&nbsp;<br>
$$
\begin{align}
A_{i,i-1} &= -\half F_o\\ 
A_{i,i} &= \half + F_o\\ 
A_{i,i+1} &= -\half F_o
\end{align}
$$
<p>&nbsp;<br>


<p>
for internal points. For boundary points,

<p>&nbsp;<br>
$$
\begin{align}
A_{0,0} &= 1\\ 
A_{0,1} &= 0\\ 
A_{N_x,N_x-1} &= 0\\ 
A_{N_x,N_x} &= 1
\end{align}
$$
<p>&nbsp;<br>


<p>
Right-hand side:

<p>&nbsp;<br>
$$
\begin{align}
b_0 &= 0\\ 
b_i &= u^{n-1}_i,\quad i=1,\ldots,N_x-1\\ 
b_{N_x} &= 0   \end{align}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Crank-Nicolson applied to a plug profile  <a name="___sec30"></a></h2>

<p>
Crank-Nicolson never blows up, so any \( Fo \) can be used
(modulo loss of accuracy).

<p>

<table border="0">
<tr>
<td class="padding">
\( N_x=50 \).
\( Fo=5 \) gives instabilities.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_plug_Fo5/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug_Fo5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug_Fo5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

</td>
<td class="padding">
\( N_x=50 \).
\( Fo=0.5 \) gives a smooth solution.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

</td>
</tr>
</table>


<p>


<p>

</section>


<section class="slide">

<h2>Crank-Nicolson applied to a Gaussian profile  <a name="___sec31"></a></h2>

<p>
\( N_x=50 \).

<p>

<table border="0">
<tr>
<td class="padding">
<p>
\( Fo=0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

</td>
<td class="padding">
\( Fo=5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1_Fo5/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1_Fo5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1_Fo5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

</td>
</tr>
</table>


<p>


<p>

</section>


<section class="slide">

<h2>The \( \theta \) rule <a name="diffu:pde1:theta"></a></h2>

<p>
The \( \theta \) rule condenses a family of finite difference approximations
in time to one formula

<ul>
 <p><li> \( \theta=0 \) gives the Forward Euler scheme in time</li>
 <p><li> \( \theta=1 \) gives the Backward Euler scheme in time</li>
 <p><li> \( \theta=\half \) gives the Crank-Nicolson scheme in time</li>
</ul>
<p>

Applied to \( u_t=\dfc u_{xx} \):

<p>&nbsp;<br>
$$ \frac{u^{n+1}_i-u^n_i}{\Delta t} =
\dfc\left( \theta \frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2}
+ (1-\theta) \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}\right)
$$
<p>&nbsp;<br>


<p>
Matrix entries:

<p>&nbsp;<br>
$$ A_{i,i-1} = -F_o\theta,\quad A_{i,i} = 1+2F_o\theta\quad,
A_{i,i+1} = -F_o\theta$$
<p>&nbsp;<br>


<p>
Right-hand side:

<p>&nbsp;<br>
$$ b_i = u^n_{i} + F_o(1-\theta)
\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>The Laplace and Poisson equation  <a name="___sec33"></a></h2>

<p>
Laplace equation:

<p>&nbsp;<br>
$$ \nabla^2 u = 0,\quad \mbox{1D: } u''(x)=0$$
<p>&nbsp;<br>


<p>
Poisson equation:

<p>&nbsp;<br>
$$ -\nabla^2 u = f,\quad \mbox{1D: } -u''(x)=f(x)$$
<p>&nbsp;<br>


<p>
These are limiting behavior of time-dependent diffusion equations if

<p>&nbsp;<br>
$$ \lim_{t\rightarrow\infty}\frac{\partial u}{\partial t} = 0$$
<p>&nbsp;<br>


<p>
Then \( u_t = \dfc u_{xx} + 0 \) in the limit \( t\rightarrow\infty \)
reduces to

<p>&nbsp;<br>
$$ u_{xx} + f = 0$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>We can solve 1D Poisson/Laplace equation by going to infinity in time-dependent diffusion equations  <a name="___sec34"></a></h2>

<p>
Looking at the numerical schemes, \( Fo\rightarrow\infty \) leads to the
Laplace or Poisson equations (without \( f \) or with \( f \), resp.).

<p>
Good news: choose \( Fo \) large in the BE or CN schemes and <em>one
time step</em> is enough to produce the stationary solution for
\( t\rightarrow\infty \).

<p>
<!-- Need example, but with nonzero boundary conditions -->

<p>

</section>


<section class="slide">

<h2>Extensions  <a name="___sec35"></a></h2>

<p>
These extensions are performed exactly as for a wave equation as they
only affect the spatial derivatives (which are the same as in the
wave equation).

<ul>
 <p><li> Variable coefficients</li>
 <p><li> Neumann and Robin conditions</li>
 <p><li> 2D and 3D</li>
</ul>
<p>

Future versions of this document will for completeness and
independence of the wave equation document feature info on the three
points. The Robin condition is new, but straightforward to handle:

<p>&nbsp;<br>
$$ -\dfc\frac{\partial u}{\partial n} = h_T(u-U_s),\quad
[-\dfc D_x u = h_T(u-U_s)]^n_i
$$
<p>&nbsp;<br>

<h1 style="text-align: center;">Analysis of schemes for the diffusion equation  <a name="___sec36"></a></h1>

<p>

</section>


<section class="slide">

<h2>Properties of the solution <a name="diffu:pde1:analysis:uex"></a></h2>

<p>
The PDE

<p>&nbsp;<br>
$$
\begin{equation}
u_t = \dfc u_{xx}
\tag{13}
\end{equation}
$$
<p>&nbsp;<br>

admits solutions

<p>&nbsp;<br>
$$
\begin{equation}
u(x,t) = Qe^{-\dfc k^2 t}\sin\left( kx\right)
\tag{14}
\end{equation}
$$
<p>&nbsp;<br>


<p>
Observations from this solution:

<ul>
 <p><li> The initial shape \( I(x)=Q\sin kx \)
   undergoes a damping \( \exp{(-\dfc k^2t)} \)</li>
 <p><li> The damping is very strong for short waves (large \( k \))</li>
 <p><li> The damping is weak for long waves (small \( k \))</li>
 <p><li> Consequence: \( u \) is smoothened with time</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Example  <a name="___sec38"></a></h2>

<p>
Test problem:

<p>&nbsp;<br>
$$
\begin{align*}
u_t &= u_{xx},\quad &x\in (0,1),\ t\in (0,T]\\ 
u(0,t) &= u(1,t) = 0,\quad &t\in (0,T]\\ 
u(x,0) & = \sin (\pi x) + 0.1\sin(100\pi x)
\end{align*}
$$
<p>&nbsp;<br>


<p>
Exact solution:

<p>&nbsp;<br>
$$
\begin{equation}
u(x,t) = e^{-\pi^2 t}\sin (\pi x) + 0.1e^{-\pi^2 10^4 t}\sin (100\pi x)
\tag{15}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Visualization of the damping in the diffusion equation  <a name="___sec39"></a></h2>

<p>
<center><p><img src="fig-diffu/diffusion_damping.png" align="bottom" width=800></p></center>

<p>

</section>


<section class="slide">

<h2>Damping of a discontinuity; problem and model  <a name="___sec40"></a></h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Problem.</b>
<p>
Two pieces of a material, at different temperatures, are brought
in contact at \( t=0 \). Assume the end points of the pieces are
kept at the initial temperature. How does the heat flow from
the hot to the cold piece?
</div>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Solution.</b>
<p>

<p>
Assume a 1D model is sufficient (insulated rod):

<p>&nbsp;<br>
$$
u(x,0)=\left\lbrace
\begin{array}{ll}
U_L, & x < L/2\\ 
U_R,& x\geq L/2
\end{array}\right.
$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$ \frac{\partial u}{\partial t} = \dfc
\frac{\partial^2 u}{\partial x^2},\quad u(0,t)=U_L,\ u(L,t)=U_R$$
<p>&nbsp;<br>
</div>


<p>

</section>


<section class="slide">

<h2>Damping of a discontinuity; Backward Euler simulation  <a name="___sec41"></a></h2>

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-diffu/BE_C0.5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/BE_C0.5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>

</section>


<section class="slide">

<h2>Damping of a discontinuity; Forward Euler simulation  <a name="___sec42"></a></h2>

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-diffu/FE_C0.5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/FE_C0.5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>

</section>


<section class="slide">

<h2>Damping of a discontinuity; Crank-Nicolson simulation  <a name="___sec43"></a></h2>

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-diffu/CN_C5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/CN_C5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>

</section>


<section class="slide">

<h2>Fourier representation  <a name="___sec44"></a></h2>

<p>
Represent \( I(x) \) as a Fourier series

<p>&nbsp;<br>
$$
\begin{equation}
I(x) \approx \sum_{k\in K} b_k e^{ikx}
\end{equation}
$$
<p>&nbsp;<br>


<p>
The corresponding sum for \( u \) is

<p>&nbsp;<br>
$$
\begin{equation}
u(x,t) \approx \sum_{k\in K} b_k e^{-\dfc k^2t}e^{ikx}
\tag{16}
\tp
\end{equation}
$$
<p>&nbsp;<br>


<p>
Such solutions are also accepted by the numerical schemes, but
with an amplification factor \( A \) different from \( \exp{({-\dfc k^2t})} \):

<p>&nbsp;<br>
$$
\begin{equation}
u^n_q = A^n e^{ikq\Delta x} = A^ne^{ikx}
\tag{17}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Analysis of the finite difference schemes <a name="diffu:pde1:analysis"></a></h2>

<p>
Stability:

<ul>
  <p><li> \( |A| < 1 \): decaying numerical solutions (as we want)</li>
  <p><li> \( A < 0 \): <em>oscillating</em> numerical solutions (as we do not want)</li>
</ul>
<p>

Accuracy:

<ul>
  <p><li> Compare numerical and exact amplification factor: \( A \) vs \( \Aex = \exp{(-\dfc k^2 \Delta t)} \)</li>
</ul>
<p>


</section>


<section class="slide">

<h2>Analysis of the Forward Euler scheme <a name="diffu:pde1:analysis:FE"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation*} [D_t^+ u = \dfc D_xD_x u]^n_q \end{equation*}
$$
<p>&nbsp;<br>


<p>
Inserting

<p>&nbsp;<br>
$$ u^n_q = A^n e^{ikq\Delta x}$$
<p>&nbsp;<br>

leads to

<p>&nbsp;<br>
$$
\begin{equation}
A = 1 -4C\sin^2\left(
\frac{k\Delta x}{2}\right),\quad
C = \frac{\dfc\Delta t}{\Delta x^2}
\end{equation}
$$
<p>&nbsp;<br>


<p>
The complete numerical solution is

<p>&nbsp;<br>
$$
\begin{equation}
u^n_q = (1 -4C\sin^2 p)^ne^{ikq\Delta x},\quad
p = k\Delta x/2
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Results for stability  <a name="___sec47"></a></h2>

<p>
We always have \( A\leq 1 \). The condition \( A\geq -1 \) implies

<p>&nbsp;<br>
$$ 4C\sin^2p\leq 2 $$
<p>&nbsp;<br>

The worst case is when \( \sin^2 p=1 \), so a sufficient criterion for
stability is

<p>&nbsp;<br>
$$
\begin{equation}
C\leq {\half}
\end{equation}
$$
<p>&nbsp;<br>

or:

<p>&nbsp;<br>
$$
\begin{equation}
\Delta t\leq \frac{\Delta x^2}{2\dfc}
\end{equation}
$$
<p>&nbsp;<br>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Implications of the stability result.</b>
<p>
Less favorable criterion than for \( u_{tt}=c^2u_{xx} \): halving \( \Delta x \)
implies time step \( \frac{1}{4}\Delta t \) (not just \( \half\Delta t \)
as in a wave equation). Need very small time steps for fine spatial
meshes!
</div>


<p>

</section>


<section class="slide">

<h2>Analysis of the Backward Euler scheme <a name="diffu:pde1:analysis:BE"></a></h2>

<p>&nbsp;<br>
$$
\begin{equation*} [D_t^- u = \dfc D_xD_x u]^n_q\end{equation*}
$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$ u^n_q = A^n e^{ikq\Delta x}$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{equation}
A = (1  + 4C\sin^2p)^{-1}
\tag{18}
\end{equation}
$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{equation}
u^n_q = (1  + 4C\sin^2p)^{-n}e^{ikq\Delta x}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Stability  <a name="___sec49"></a></h2>

<p>
We see from <a href="#mjx-eqn-18">(18)</a> that \( |A| < 1 \) for all \( \Delta t>0 \)
and that \( A>0 \) (no oscillations).

<p>

</section>


<section class="slide">

<h2>Analysis of the Crank-Nicolson scheme <a name="diffu:pde1:analysis:CN"></a></h2>

<p>
The scheme

<p>&nbsp;<br>
$$ [D_t u = \dfc D_xD_x \overline{u}^x]^{n+\half}_q$$
<p>&nbsp;<br>

leads to

<p>&nbsp;<br>
$$
\begin{equation}
A = \frac{ 1 - 2C\sin^2p}{1 + 2C\sin^2p}
\end{equation}
$$
<p>&nbsp;<br>


<p>&nbsp;<br>
$$
\begin{equation}
u^n_q = \left(\frac{ 1 - 2C\sin^2p}{1 + 2C\sin^2p}\right)^ne^{ikp\Delta x}
\end{equation}
$$
<p>&nbsp;<br>


<p>

</section>


<section class="slide">

<h2>Stability  <a name="___sec51"></a></h2>

<p>
The criteria \( A>-1 \) and \( A < 1 \) are fulfilled for any \( \Delta t >0 \).

<p>

</section>


<section class="slide">

<h2>Summary of accuracy of amplification factors; large time steps  <a name="___sec52"></a></h2>

<p>
<center><p><img src="fig-diffu/diffusion_A_Fo20_Fo2_FDM.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h2>Summary of accuracy of amplification factors; time steps around the Forward Euler stability limit  <a name="___sec53"></a></h2>

<p>
<center><p><img src="fig-diffu/diffusion_A_Fo05_Fo025_FDM.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h2>Summary of accuracy of amplification factors; small time steps  <a name="___sec54"></a></h2>

<p>
<center><p><img src="fig-diffu/diffusion_A_Fo01_Fo001_FDM.png" align="bottom" width=800,></p></center>

<p>

</section>


<section class="slide">

<h2>Observations  <a name="___sec55"></a></h2>

<ul>
 <p><li> Crank-Nicolson gives oscillations and not much damping of short waves
   for increasing \( C \).</li>
 <p><li> These waves will manifest themselves as high frequency
   oscillatory noise in the solution.</li>
 <p><li> All schemes fail to dampen short waves enough</li>
</ul>
<p>

The problems of correct damping for \( u_t = u_{xx} \) is partially
manifested in the similar time discretization schemes for \( u'(t)=-\dfc u(t) \).


</section>




<footer>
<!-- Here goes a footer -->
</footer>

<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>
-->

<!-- deck.goto snippet
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>
-->

<!-- deck.hash snippet
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>
-->

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="deck.js/jquery.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/hash/deck.hash.js"></script>
<script src="deck.js/extensions/menu/deck.menu.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/status/deck.status.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>
<script src="deck.js/extensions/notes/deck.notes.js"></script>

<!-- From https://github.com/mikeharris100/deck.pointer.js -->
<script src="deck.js/extensions/pointer/deck.pointer.js"></script>

<!-- From https://github.com/stvnwrgs/presenterview
<script type="text/javascript" src="deck.js/extensions/presenterview/deck.presenterview.js"></script> -->

<!-- From https://github.com/nemec/deck.annotate.js
<script type="text/javascript" src="deck.js/extensions/deck.annotate.js/deck.annotate.js"></script>
-->


<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>


</body>
</html>
