<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Finite difference schemes for diffusion processes">
<meta name="keywords" content="diffusion equation, 1D,heat equation, 1D,mesh finite differences,stencil 1D diffusion equation,mesh function">

<title>Study guide: Finite difference schemes for diffusion processes</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' The 1D diffusion equation ', 1, None, '___sec0'),
              (' The initial-boundary value problem for 1D diffusion ',
               2,
               None,
               '___sec1'),
              (' Step 1: Discretizing the domain ',
               2,
               'diffu:1D:mesh',
               'diffu:1D:mesh'),
              (' The discrete solution ',
               2,
               'diffu:1D:numerical:sol',
               'diffu:1D:numerical:sol'),
              (' Step 2: Fulfilling the equation at the mesh points ',
               2,
               'diffu:1D:samplingPDE',
               'diffu:1D:samplingPDE'),
              (' Step 3: Replacing derivatives by finite differences ',
               2,
               'diffu:1D:fd',
               'diffu:1D:fd'),
              (' Step 4: Formulating a recursive algorithm ',
               2,
               'diffu:1D:alg',
               'diffu:1D:alg'),
              (' The mesh Fourier number ', 2, None, '___sec7'),
              (' The finite difference stencil ', 2, None, '___sec8'),
              (' The computational algorithm for the Forward Euler scheme ',
               2,
               None,
               '___sec9'),
              (' The Python implementation of the computational algorithm ',
               2,
               None,
               '___sec10'),
              (' Moving finite difference stencil ', 2, None, '___sec11'),
              (' Demo program ', 2, None, '___sec12'),
              (' Forward Euler applied to an initial plug profile ',
               2,
               None,
               '___sec13'),
              (' Forward Euler applied to a Gaussian profile ',
               2,
               None,
               '___sec14'),
              (' Backward Euler scheme ',
               2,
               'diffu:pde1:BE',
               'diffu:pde1:BE'),
              (" Let's write out the equations for $N_x=3$ ",
               2,
               None,
               '___sec16'),
              (' Two classes of discretization methods: explicit and implicit ',
               2,
               None,
               '___sec17'),
              (' The linear system for a general $N_x$ ',
               2,
               None,
               '___sec18'),
              (' $A$ is very sparse: a tridiagonal matrix ',
               2,
               None,
               '___sec19'),
              (' Detailed expressions for the matrix entries ',
               2,
               None,
               '___sec20'),
              (' The right-hand side ', 2, None, '___sec21'),
              (' Naive Python implementation with a dense $(N_x+1)\\times(N_x+1)$ matrix ',
               2,
               None,
               '___sec22'),
              (' A sparse matrix representation will dramatically reduce the computational complexity ',
               2,
               'diffu:pde1:impl:sparse',
               'diffu:pde1:impl:sparse'),
              (' Computing the sparse matrix ', 2, None, '___sec24'),
              (' Backward Euler applied to a plug profile ',
               2,
               None,
               '___sec25'),
              (' Backward Euler applied to a Gaussian profile ',
               2,
               None,
               '___sec26'),
              (' Crank-Nicolson scheme ', 2, None, '___sec27'),
              (' Averaging in time is necessary in the Crank-Nicolson scheme ',
               2,
               None,
               '___sec28'),
              (' Crank-Nicolsoon scheme written out ', 2, None, '___sec29'),
              (' Crank-Nicolson applied to a plug profile ',
               2,
               None,
               '___sec30'),
              (' Crank-Nicolson applied to a Gaussian profile ',
               2,
               None,
               '___sec31'),
              (' The $\\theta$ rule ',
               2,
               'diffu:pde1:theta',
               'diffu:pde1:theta'),
              (' The Laplace and Poisson equation ', 2, None, '___sec33'),
              (' We can solve 1D Poisson/Laplace equation by going to infinity in time-dependent diffusion equations ',
               2,
               None,
               '___sec34'),
              (' Extensions ', 2, None, '___sec35'),
              (' Analysis of schemes for the diffusion equation ',
               1,
               None,
               '___sec36'),
              (' Properties of the solution ',
               2,
               'diffu:pde1:analysis:uex',
               'diffu:pde1:analysis:uex'),
              (' Example ', 2, None, '___sec38'),
              (' Visualization of the damping in the diffusion equation ',
               2,
               None,
               '___sec39'),
              (' Damping of a discontinuity; problem and model ',
               2,
               None,
               '___sec40'),
              (' Damping of a discontinuity; Backward Euler simulation ',
               2,
               None,
               '___sec41'),
              (' Damping of a discontinuity; Forward Euler simulation ',
               2,
               None,
               '___sec42'),
              (' Damping of a discontinuity; Crank-Nicolson simulation ',
               2,
               None,
               '___sec43'),
              (' Fourier representation ', 2, None, '___sec44'),
              (' Analysis of the finite difference schemes ',
               2,
               'diffu:pde1:analysis',
               'diffu:pde1:analysis'),
              (' Analysis of the Forward Euler scheme ',
               2,
               'diffu:pde1:analysis:FE',
               'diffu:pde1:analysis:FE'),
              (' Results for stability ', 2, None, '___sec47'),
              (' Analysis of the Backward Euler scheme ',
               2,
               'diffu:pde1:analysis:BE',
               'diffu:pde1:analysis:BE'),
              (' Stability ', 2, None, '___sec49'),
              (' Analysis of the Crank-Nicolson scheme ',
               2,
               'diffu:pde1:analysis:CN',
               'diffu:pde1:analysis:CN'),
              (' Stability ', 2, None, '___sec51'),
              (' Summary of accuracy of amplification factors; large time steps ',
               2,
               None,
               '___sec52'),
              (' Summary of accuracy of amplification factors; time steps around the Forward Euler stability limit ',
               2,
               None,
               '___sec53'),
              (' Summary of accuracy of amplification factors; small time steps ',
               2,
               None,
               '___sec54'),
              (' Observations ', 2, None, '___sec55')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
$$




    
<!-- ------------------- main content ---------------------- -->



<center><h1>Study guide: Finite difference schemes for diffusion processes</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>


<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<p>
<center><h4>Oct 5, 2014</h4></center> <!-- date -->
<p>
<!-- !split --><br><br><br><br><br>

<h2>Table of contents</h2>

<p>
<a href="#___sec0"> The 1D diffusion equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec1"> The initial-boundary value problem for 1D diffusion </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:1D:mesh"> Step 1: Discretizing the domain </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:1D:numerical:sol"> The discrete solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:1D:samplingPDE"> Step 2: Fulfilling the equation at the mesh points </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:1D:fd"> Step 3: Replacing derivatives by finite differences </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:1D:alg"> Step 4: Formulating a recursive algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> The mesh Fourier number </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> The finite difference stencil </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec9"> The computational algorithm for the Forward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> The Python implementation of the computational algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> Moving finite difference stencil </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec12"> Demo program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> Forward Euler applied to an initial plug profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> Forward Euler applied to a Gaussian profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:BE"> Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec16"> Let's write out the equations for \( N_x=3 \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> Two classes of discretization methods: explicit and implicit </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> The linear system for a general \( N_x \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> \( A \) is very sparse: a tridiagonal matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec20"> Detailed expressions for the matrix entries </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec21"> The right-hand side </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec22"> Naive Python implementation with a dense \( (N_x+1)\times(N_x+1) \) matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:impl:sparse"> A sparse matrix representation will dramatically reduce the computational complexity </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Computing the sparse matrix </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> Backward Euler applied to a plug profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec26"> Backward Euler applied to a Gaussian profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec28"> Averaging in time is necessary in the Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec29"> Crank-Nicolsoon scheme written out </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec30"> Crank-Nicolson applied to a plug profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec31"> Crank-Nicolson applied to a Gaussian profile </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:theta"> The \( \theta \) rule </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec33"> The Laplace and Poisson equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec34"> We can solve 1D Poisson/Laplace equation by going to infinity in time-dependent diffusion equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec35"> Extensions </a><br>
<a href="#___sec36"> Analysis of schemes for the diffusion equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:analysis:uex"> Properties of the solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec38"> Example </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec39"> Visualization of the damping in the diffusion equation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec40"> Damping of a discontinuity; problem and model </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec41"> Damping of a discontinuity; Backward Euler simulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec42"> Damping of a discontinuity; Forward Euler simulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec43"> Damping of a discontinuity; Crank-Nicolson simulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec44"> Fourier representation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:analysis"> Analysis of the finite difference schemes </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:analysis:FE"> Analysis of the Forward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec47"> Results for stability </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:analysis:BE"> Analysis of the Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> Stability </a><br>
&nbsp; &nbsp; &nbsp; <a href="#diffu:pde1:analysis:CN"> Analysis of the Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec51"> Stability </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec52"> Summary of accuracy of amplification factors; large time steps </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> Summary of accuracy of amplification factors; time steps around the Forward Euler stability limit </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec54"> Summary of accuracy of amplification factors; small time steps </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec55"> Observations </a><br>
</p>
<p>
<!-- !split --><br><br><br><br><br>

<h1>The 1D diffusion equation  <a name="___sec0"></a></h1>

<p>
The famous <em>diffusion equation</em>, also known as the <em>heat equation</em>,
reads

$$ \frac{\partial u}{\partial t} =
\dfc \frac{\partial^2 u}{\partial x^2}
$$


<p>
Here,

<ul>
 <p><li> \( u(x,t) \): unknown</li>
 <p><li> \( \dfc \): <em>diffusion coefficient</em></li>
</ul>

Alternative, compact notation:

$$ u_t = \dfc u_{xx} $$


<p>
<!-- !split --><br><br><br><br><br>

<h2>The initial-boundary value problem for 1D diffusion  <a name="___sec1"></a></h2>

$$
\begin{align}
\frac{\partial u}{\partial t} &=
\dfc \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]
\label{diffu:pde1}\\ 
u(x,0) &= I(x), \quad  x\in [0,L]
\label{diffu:pde1:ic:u}\\ 
u(0,t) & = 0, \quad  t>0,
\label{diffu:pde1:bc:0}\\ 
u(L,t) & = 0, \quad  t>0\tp
\label{diffu:pde1:bc:L}
\end{align}
$$


<p>
Note:

<ul>
 <p><li> First-order derivative in time: one initial condition</li>
 <p><li> Second-order derivative in space: a boundary condition at each
   point of the boundary (2 points in 1D)</li>
 <p><li> Numerous applications throughout physics and biology</li>
</ul>

<!-- !split --><br><br><br><br><br>

<h2>Step 1: Discretizing the domain <a name="diffu:1D:mesh"></a></h2>

<p>
Mesh in time:

$$
\begin{equation}
0 = t_0 < t_1 < t_2 < \cdots < t_{N_t-1} < t_{N_t} = T   \end{equation}
$$


<p>
Mesh in space:

$$
\begin{equation}
0 = x_0 < x_1 < x_2 < \cdots < x_{N_x-1} < x_{N_x} = L   \end{equation}
$$


<p>
Uniform mesh with constant mesh spacings \( \Delta t \) and \( \Delta x \):

$$
\begin{equation}
x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
t_i = n\Delta t,\ n=0,\ldots,N_t
\end{equation}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>The discrete solution <a name="diffu:1D:numerical:sol"></a></h2>

<ul>
 <p><li> The numerical solution is a mesh function: \( u_i^n \approx \uex(x_i,t_n) \)</li>
 <p><li> Finite difference stencil (or scheme): equation for \( u^n_i \) involving
   neighboring space-time points</li>
</ul>

<center><p><img src="mov-diffu/diffu1D_PDE_FE_Dirichlet_stencil_gpl/stencil_n_interior.png" align="bottom" width=500></p></center>

<p>
<!-- !split --><br><br><br><br><br>

<h2>Step 2: Fulfilling the equation at the mesh points <a name="diffu:1D:samplingPDE"></a></h2>

<p>
Require the PDE \eqref{diffu:pde1} to be fulfilled at an arbitrary
<em>interior mesh point</em> \( (x_i,t_n) \)
leads to

$$
\begin{equation}
\frac{\partial}{\partial t} u(x_i, t_n) =
\dfc\frac{\partial^2}{\partial x^2} u(x_i, t_n)
\label{diffu:pde1:step2}
\end{equation}
$$


<p>
Applies to all interior mesh points: \( i=1,\ldots,N_x-1 \) and \( n=1,\ldots,N_t-1 \)

<p>
For \( n=0 \) we have the initial conditions \( u=I(x) \) and \( u_t=0 \)

<p>
At the boundaries \( i=0,N_x \) we have the boundary condition \( u=0 \).

<p>
<!-- !split --><br><br><br><br><br>

<h2>Step 3: Replacing derivatives by finite differences <a name="diffu:1D:fd"></a></h2>

<p>
Use a forward difference in time and a centered difference in space
(<em>Forward Euler</em> scheme):

$$
\begin{equation}
[D_t^+ u = \dfc D_xD_x u]^n_i
\label{diffu:pde1:step3a}
\end{equation}
$$


<p>
Written out,

$$
\begin{equation}
\frac{u^{n+1}_i-u^n_i}{\Delta t} = \dfc \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}
\label{diffu:pde1:step3b}
\end{equation}
$$


<p>
Initial condition: \( u^0_i = I(x_i) \), \( i=0,1,\ldots,N_x \).

<p>
<!-- !split --><br><br><br><br><br>

<h2>Step 4: Formulating a recursive algorithm <a name="diffu:1D:alg"></a></h2>

<ul>
 <p><li> Nature of the algorithm: compute \( u \) in space at \( t=\Delta t, 2\Delta t, 3\Delta t,... \)</li>
 <p><li> Two time levels are involved in the general discrete equation:
   \( n+1 \) and \( n \)</li>
 <p><li> \( u^n_i \) is already computed for \( i=0,\ldots,N_x \),
   and \( u^{n+1}_i \) is the unknown quantity</li>
</ul>

Solve the discretized PDE for the unknown \( u^{n+1}_i \):

$$
\begin{equation}
u^{n+1}_i = u^n_i + Fo\left(
u^{n}_{i+1} - 2u^n_i + u^n_{i-1}\right)
\label{diffu:pde1:step4}
\end{equation}
$$


<p>
where

$$ Fo = \dfc\frac{\Delta t}{\Delta x^2} $$


<p>
<!-- !split --><br><br><br><br><br>

<h2>The mesh Fourier number  <a name="___sec7"></a></h2>

$$ Fo = \dfc\frac{\Delta t}{\Delta x^2} $$


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Observe.</b>
<p>
There is only one parameter, \( Fo \), in the discrete model:
\( Fo \) lumps mesh parameters \( \Delta t \) and \( \Delta x \)
with the only physical parameter, the diffusion coefficient
\( \dfc \).
The value \( Fo \) and the smoothness of \( I(x) \)
govern the quality of the numerical solution.
</div>


<p>
<!-- !split --><br><br><br><br><br>

<h2>The finite difference stencil  <a name="___sec8"></a></h2>

<p>
<center><p><img src="mov-diffu/diffu1D_PDE_FE_Dirichlet_stencil_gpl/stencil_n_interior.png" align="bottom" width=500></p></center>

<p>
<!-- !split --><br><br><br><br><br>

<h2>The computational algorithm for the Forward Euler scheme  <a name="___sec9"></a></h2>

<ol>
 <p><li> compute \( u^0_i=I(x_i) \), \( i=0,\ldots,N_x \)</li>
 <p><li> for \( n=0,1,\ldots,N_t \):</li>

<ol>
   <p><li> compute \( u^{n+1}_i \) from \eqref{diffu:pde1:step4} for all the internal
      spatial points \( i=1,\ldots,N_x-1 \)</li>
   <p><li> set the boundary values
      \( u^{n+1}_i=0 \) for \( i=0 \) and \( i=N_x \)</li>
</ol>

</ol>

<div class="alert alert-block alert-notice alert-text-normal">
<b>Notice.</b>
<p>
We visit one mesh point \( (x_i,t_{n+1}) \) at a time,
and we have an explicit formula
for computing the associated \( u^{n+1}_i \) value.
The spatial points can be updated in any sequence, but the
time levels \( t_n \) must be updated in cronological order: \( t_n \) before
\( t_{n+1} \).
</div>


<p>
<!-- !split --><br><br><br><br><br>

<h2>The Python implementation of the computational algorithm  <a name="___sec10"></a></h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)    <span style="color: #228B22"># mesh points in space</span>
dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)    <span style="color: #228B22"># mesh points in time</span>
dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]
Fo = a*dt/dx**<span style="color: #B452CD">2</span>
u   = zeros(Nx+<span style="color: #B452CD">1</span>)
u_1 = zeros(Nx+<span style="color: #B452CD">1</span>)

<span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
    <span style="color: #228B22"># Compute u at inner mesh points</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        u[i] = u_1[i] + Fo*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])

    <span style="color: #228B22"># Insert boundary conditions</span>
    u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>

    <span style="color: #228B22"># Update u_1 before next step</span>
    u_1[:]= u
    <span style="color: #228B22"># or more efficient switch of references</span>
    <span style="color: #228B22">#u_1, u = u, u_1</span>
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br>

<h2>Moving finite difference stencil  <a name="___sec11"></a></h2>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_PDE_FE_Dirichlet_stencil_gpl/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<a href="http://tinyurl.com/opdfafk/pub/mov-diffu/diffu1D_PDE_FE_Dirichlet_stencil_gpl/index.html" target="_self">web page</a>
or a <a href="http://tinyurl.com/opdfafk/pub/mov-diffu/diffu1D_PDE_FE_Dirichlet_stencil_gpl/movie.ogg" target="_self">movie file</a>.

<p>
<!-- !split --><br><br><br><br><br>

<h2>Demo program  <a name="___sec12"></a></h2>

<ul>
 <p><li> Program: <a href="http://tinyurl.com/nm5587k/diffu/diff1D_u0.py" target="_self"><tt>diffu1D_u0.py</tt></a></li>
 <p><li> Produces animation on the screen</li>
 <p><li> Each frame stored in <code>tmp_frame%04d.png</code> files<br />
   <code>tmp_frame0000.png</code>, <code>tmp_frame0001.png</code>, ...</li>
</ul>

How to make movie file in modern formats:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; name=tmp_frame%04d.png
Terminal&gt; fps=8  # frames per second in movie
Terminal&gt; avconv -r $fps -i $name -vcodec flv       movie.flv
Terminal&gt; avconv -r $fps -i $name -vcodec libx64    movie.mp4
Terminal&gt; avconv -r $fps -i $name -vcodec libvpx    movie.webm
Terminal&gt; avconv -r $fps -i $name -vcodec libtheora movie.ogg
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br>

<h2>Forward Euler applied to an initial plug profile  <a name="___sec13"></a></h2>

<p>
\( N_x=50 \). The method results in a growing, unstable solution if \( Fo>0.5 \).

<p>
<!-- !bslidecell 00 -->
Choosing \( Fo=0.5 \) gives a strange saw tooth-like curve.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- !eslidecell -->

<p>
<!-- !bslidecell 01 -->
Lowering \( Fo \) to 0.25 gives a smooth (expected) solution.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_Fo025/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_Fo025/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_plug_Fo025/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- !eslidecell -->

<p>
<!-- !split --><br><br><br><br><br>

<h2>Forward Euler applied to a Gaussian profile  <a name="___sec14"></a></h2>

<p>
\( N_x=50 \). \( Fo=0.5 \).

<p>
<!-- !bslidecell 00 -->

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- !eslidecell -->

<p>
<!-- !bslidecell 01 -->

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian2/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian2/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_FE_gaussian2/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- !eslidecell -->

<p>
<!-- !split --><br><br><br><br><br>

<h2>Backward Euler scheme <a name="diffu:pde1:BE"></a></h2>

<p>
Backward difference in time, centered difference in space:

$$
\begin{equation}
[D_t^- u = D_xD_x u]^n_i
\label{diffu:pde1:step3aBE}
\end{equation}
$$


<p>
Written out:

$$
\begin{equation}
\frac{u^{n}_i-u^{n-1}_i}{\Delta t} = \dfc\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}
\label{diffu:pde1:step3bBE}
\end{equation}
$$


<p>
Assumption: \( u^{n-1}_i \) is computed, but all quantities at the new
time level \( t_n \) are unknown.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Notice.</b>
<p>
We cannot solve wrt \( u^n_i \) because that unknown value is coupled to
two other unknown values: \( u^n_{i-1} \) and \( u^n_{i+1} \).
That is, all the new unknown values are coupled to each other
in a <em>linear system of algebraic equations</em>.
</div>


<p>
<!-- !split --><br><br><br><br><br>

<h2>Let's write out the equations for \( N_x=3 \)  <a name="___sec16"></a></h2>

<p>
Equation \eqref{diffu:pde1:step3bBE} written for \( i=1,\ldots,Nx-1= 1,2 \) becomes

$$
\begin{align}
\frac{u^{n}_1-u^{n-1}_1}{\Delta t} &= \dfc\frac{u^{n}_{2} - 2u^n_1 + u^n_{0}}{\Delta x^2}\\ 
\frac{u^{n}_2-u^{n-1}_2}{\Delta t} &= \dfc\frac{u^{n}_{3} - 2u^n_2 + u^n_{1}}{\Delta x^2}
\end{align}
$$


<p>
(The boundary values \( u^n_0 \) and \( u^n_3 \) are known as zero.)

<p>
Collecting the unknown new values  on the left-hand side and writing
as \( 2\times 2 \) matrix system:

$$ \left(\begin{array}{cc}
1+  2Fo &   - Fo\\ 
- Fo    & 1+  2Fo
\end{array}\right)
\left(\begin{array}{c}
u^{n}_1\\ 
u^{n}_{2}\\ 
\end{array}\right)
=
\left(\begin{array}{c}
u^{n-1}_1\\ 
u^{n-1}_2
\end{array}\right)
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Two classes of discretization methods: explicit and implicit  <a name="___sec17"></a></h2>

<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Implicit.</b>
<p>
Discretization methods that lead linear systems are known
as <em>implicit methods</em>.
</div>


<p>
<div class="alert alert-block alert-block alert-text-normal">
<b>Explicit.</b>
<p>
Discretization methods that avoid linear systems and have
an explicit formula for each new value of the unknown are called
<em>explicit methods</em>.
</div>


<p>
<!-- !split --><br><br><br><br><br>

<h2>The linear system for a general \( N_x \)  <a name="___sec18"></a></h2>

$$
\begin{equation}
- F_o u^n_{i-1} + \left(1+  2F_o \right) u^{n}_i - F_o u^n_{i+1} =
u_{i-1}^{n-1}
\label{diffu:pde1:step4BE}
\end{equation}
$$

for \( i=1,\ldots,Nx-1 \).

<p>
What are the unknowns in the linear system?

<ol>
<p><li> either \( u^n_i \) for \( i=1,\ldots,N_x-1 \) (all <em>internal</em> spatial mesh points)</li>
<p><li> or \( u^n_i \), \( i=0,\ldots,N_x \) (all spatial points)</li>
</ol>

The linear system in matrix notation:

$$
\begin{equation*} AU = b,\quad U=(u^n_0,\ldots,u^n_{N_x})
\end{equation*}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>\( A \) is very sparse: a tridiagonal matrix  <a name="___sec19"></a></h2>

$$
\begin{equation}
A =
\left(
\begin{array}{cccccccccc}
A_{0,0} & A_{0,1} & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
A_{1,0} & A_{1,1} & 0 & \ddots &   & &  & &  \vdots \\ 
0 & A_{2,1} & A_{2,2} & A_{2,3} &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & A_{i,i-1} & A_{i,i} & A_{i,i+1} & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & A_{N_x-1,N_x} \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & A_{N_x,N_x-1} & A_{N_x,N_x}
\end{array}
\right)
\label{diffu:pde1:matrix:sparsity}
\end{equation}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Detailed expressions for the matrix entries  <a name="___sec20"></a></h2>

<p>
The nonzero elements are given by

$$
\begin{align}
A_{i,i-1} &= -F_o\\ 
A_{i,i} &= 1+ 2F_o\\ 
A_{i,i+1} &= -F_o
\end{align}
$$


<p>
for \( i=1,\ldots,N_x-1 \).

<p>
The equations for the boundary points correspond to

$$
A_{0,0} = 1,\quad A_{0,1} = 0,\quad A_{N_x,N_x-1} = 0,\quad
A_{N_x,N_x} = 1
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>The right-hand side  <a name="___sec21"></a></h2>

$$
\begin{equation}
b = \left(\begin{array}{c}
b_0\\ 
b_1\\ 
\vdots\\ 
b_i\\ 
\vdots\\ 
b_{N_x}
\end{array}\right)
\end{equation}
$$


<p>
with

$$
\begin{align}
b_0 &= 0\\ 
b_i &= u^{n-1}_i,\quad i=1,\ldots,N_x-1\\ 
b_{N_x} &= 0
\end{align}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Naive Python implementation with a dense \( (N_x+1)\times(N_x+1) \) matrix  <a name="___sec22"></a></h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># mesh points in space</span>
dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
t = linspace(<span style="color: #B452CD">0</span>, T, N+<span style="color: #B452CD">1</span>)    <span style="color: #228B22"># mesh points in time</span>
u   = zeros(Nx+<span style="color: #B452CD">1</span>)
u_1 = zeros(Nx+<span style="color: #B452CD">1</span>)

<span style="color: #228B22"># Data structures for the linear system</span>
A = zeros((Nx+<span style="color: #B452CD">1</span>, Nx+<span style="color: #B452CD">1</span>))
b = zeros(Nx+<span style="color: #B452CD">1</span>)

<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    A[i,i-<span style="color: #B452CD">1</span>] = -Fo
    A[i,i+<span style="color: #B452CD">1</span>] = -Fo
    A[i,i] = <span style="color: #B452CD">1</span> + <span style="color: #B452CD">2</span>*Fo
A[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>] = A[Nx,Nx] = <span style="color: #B452CD">1</span>

<span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scipy.linalg</span>

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
    <span style="color: #228B22"># Compute b and solve linear system</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        b[i] = -u_1[i]
    b[<span style="color: #B452CD">0</span>] = b[Nx] = <span style="color: #B452CD">0</span>
    u[:] = scipy.linalg.solve(A, b)

    <span style="color: #228B22"># Update u_1 before next step</span>
    u_1, u = u, u_1
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br>

<h2>A sparse matrix representation will dramatically reduce the computational complexity <a name="diffu:pde1:impl:sparse"></a></h2>

<ul>
 <p><li> With a dense matrix, the algorithm leads to \( \Oof{N_x^3} \) operations</li>
 <p><li> Utilizing the sparsity, the algorithm has complexity \( \Oof{N_x} \)!</li>
 <p><li> <code>scipy.sparse</code> enables storage and calculations with the three
   nonzero diagonals only</li>
</ul>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Representation of sparse matrix and right-hand side</span>
diagonal  = zeros(Nx+<span style="color: #B452CD">1</span>)
lower     = zeros(Nx)
upper     = zeros(Nx)
b         = zeros(Nx+<span style="color: #B452CD">1</span>)
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br>

<h2>Computing the sparse matrix  <a name="___sec24"></a></h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Precompute sparse matrix</span>
diagonal[:] = <span style="color: #B452CD">1</span> + <span style="color: #B452CD">2</span>*Fo
lower[:] = -Fo  <span style="color: #228B22">#1</span>
upper[:] = -Fo  <span style="color: #228B22">#1</span>
<span style="color: #228B22"># Insert boundary conditions</span>
diagonal[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">1</span>
upper[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>
diagonal[Nx] = <span style="color: #B452CD">1</span>
lower[-<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">0</span>

<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scipy.sparse</span>
A = scipy.sparse.diags(
    diagonals=[main, lower, upper],
    offsets=[<span style="color: #B452CD">0</span>, -<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>], shape=(Nx+<span style="color: #B452CD">1</span>, Nx+<span style="color: #B452CD">1</span>),
    format=<span style="color: #CD5555">&#39;csr&#39;</span>)

<span style="color: #228B22"># Set initial condition</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):
    b = u_1
    b[<span style="color: #B452CD">0</span>] = b[-<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">0.0</span>  <span style="color: #228B22"># boundary conditions</span>
    u[:] = scipy.sparse.linalg.spsolve(A, b)
    <span style="color: #228B22"># Switch variables before next step</span>
    u_1, u = u, u_1
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br>

<h2>Backward Euler applied to a plug profile  <a name="___sec25"></a></h2>

<p>
\( N_x=50 \).
\( Fo=0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_BE_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_BE_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_BE_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<!-- !split --><br><br><br><br><br>

<h2>Backward Euler applied to a Gaussian profile  <a name="___sec26"></a></h2>

<p>
\( N_x=50 \).

<p>
<!-- !bslidecell 00 -->

<p>
\( Fo=0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- !eslidecell -->

<p>
<!-- !bslidecell 01 -->
\( Fo=5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1_Fo5/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1_Fo5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_BE_gaussian1_Fo5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- !eslidecell -->

<p>
<!-- !split --><br><br><br><br><br>

<h2>Crank-Nicolson scheme  <a name="___sec27"></a></h2>

<p>
The PDE is sampled at points \( (x_i,t_{n+\half}) \) (at the spatial
mesh points, but in between two temporal mesh points).

$$
\frac{\partial}{\partial t} u(x_i, t_{n+\half}) =
\dfc\frac{\partial^2}{\partial x^2}u(x_i, t_{n+\half})
$$

for \( i=1,\ldots,N_x-1 \) and \( n=0,\ldots, N_t-1 \).

<p>
Centered differences in space and time:

$$ [D_t u = \dfc D_xD_x u]^{n+\half}_i$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Averaging in time is necessary in the Crank-Nicolson scheme  <a name="___sec28"></a></h2>

<p>
Right-hand side term:

$$ \frac{1}{\Delta x^2}\left(u^{n+\half}_{i-1} - 2u^{n+\half}_i + u^{n+\half}_{i+1}\right)$$


<p>
Problem: \( u^{n+\half}_i \) is not one of
the unknowns we compute.

<p>
Solution: replace \( u^{n+\half}_i \) by an arithmetic average:

$$ u^{n+\half}_i\approx
\half\left(u^{n}_i +u^{n+1}_{i}\right)
$$


<p>
In compact notation (arithmetic average in time \( \overline{u}^t \)):

$$ [D_t u = \dfc D_xD_x \overline{u}^t]^{n+\half}_i$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Crank-Nicolsoon scheme written out  <a name="___sec29"></a></h2>

$$
\begin{equation}
u^{n+1}_i - \half Fo(u^{n+1}_{i-1} - 2u^{n+1}_i + u^{n+1}_{i+1})
= u^{n}_i + \half Fo(u^{n}_{i-1} - 2u^{n}_i + u^{n}_{i+1})
\end{equation}
$$


<p>
Observe:

<ul>
 <p><li> The unknowns are \( u^{n+1}_{i-1}, u^{n+1}_{i}, u^{n+1}_{i+1} \)</li>
 <p><li> These unknowns are coupled to each other (in a linear system)</li>
 <p><li> Must solve \( AU=b \) at each time level</li>
</ul>

Now,

$$
\begin{align}
A_{i,i-1} &= -\half F_o\\ 
A_{i,i} &= \half + F_o\\ 
A_{i,i+1} &= -\half F_o
\end{align}
$$


<p>
for internal points. For boundary points,

$$
\begin{align}
A_{0,0} &= 1\\ 
A_{0,1} &= 0\\ 
A_{N_x,N_x-1} &= 0\\ 
A_{N_x,N_x} &= 1
\end{align}
$$


<p>
Right-hand side:

$$
\begin{align}
b_0 &= 0\\ 
b_i &= u^{n-1}_i,\quad i=1,\ldots,N_x-1\\ 
b_{N_x} &= 0   \end{align}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Crank-Nicolson applied to a plug profile  <a name="___sec30"></a></h2>

<p>
Crank-Nicolson never blows up, so any \( Fo \) can be used
(modulo loss of accuracy).

<p>
<!-- !bslidecell 00 -->
\( N_x=50 \).
\( Fo=5 \) gives instabilities.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_plug_Fo5/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug_Fo5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug_Fo5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- !eslidecell -->

<p>
<!-- !bslidecell 01 -->
\( N_x=50 \).
\( Fo=0.5 \) gives a smooth solution.

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_plug/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_plug/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- !eslidecell -->

<p>
<!-- !split --><br><br><br><br><br>

<h2>Crank-Nicolson applied to a Gaussian profile  <a name="___sec31"></a></h2>

<p>
\( N_x=50 \).

<p>
<!-- !bslidecell 00 -->

<p>
\( Fo=0.5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- !eslidecell -->

<p>
<!-- !bslidecell 01 -->
\( Fo=5 \).

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1_Fo5/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1_Fo5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/diffu1D_u0_theta_gaussian1_Fo5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- !eslidecell -->

<p>
<!-- !split --><br><br><br><br><br>

<h2>The \( \theta \) rule <a name="diffu:pde1:theta"></a></h2>

<p>
The \( \theta \) rule condenses a family of finite difference approximations
in time to one formula

<ul>
 <p><li> \( \theta=0 \) gives the Forward Euler scheme in time</li>
 <p><li> \( \theta=1 \) gives the Backward Euler scheme in time</li>
 <p><li> \( \theta=\half \) gives the Crank-Nicolson scheme in time</li>
</ul>

Applied to \( u_t=\dfc u_{xx} \):

$$ \frac{u^{n+1}_i-u^n_i}{\Delta t} =
\dfc\left( \theta \frac{u^{n+1}_{i+1} - 2u^{n+1}_i + u^{n+1}_{i-1}}{\Delta x^2}
+ (1-\theta) \frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}\right)
$$


<p>
Matrix entries:

$$ A_{i,i-1} = -F_o\theta,\quad A_{i,i} = 1+2F_o\theta\quad,
A_{i,i+1} = -F_o\theta$$


<p>
Right-hand side:

$$ b_i = u^n_{i} + F_o(1-\theta)
\frac{u^{n}_{i+1} - 2u^n_i + u^n_{i-1}}{\Delta x^2}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>The Laplace and Poisson equation  <a name="___sec33"></a></h2>

<p>
Laplace equation:

$$ \nabla^2 u = 0,\quad \mbox{1D: } u''(x)=0$$


<p>
Poisson equation:

$$ -\nabla^2 u = f,\quad \mbox{1D: } -u''(x)=f(x)$$


<p>
These are limiting behavior of time-dependent diffusion equations if

$$ \lim_{t\rightarrow\infty}\frac{\partial u}{\partial t} = 0$$


<p>
Then \( u_t = \dfc u_{xx} + 0 \) in the limit \( t\rightarrow\infty \)
reduces to

$$ u_{xx} + f = 0$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>We can solve 1D Poisson/Laplace equation by going to infinity in time-dependent diffusion equations  <a name="___sec34"></a></h2>

<p>
Looking at the numerical schemes, \( Fo\rightarrow\infty \) leads to the
Laplace or Poisson equations (without \( f \) or with \( f \), resp.).

<p>
Good news: choose \( Fo \) large in the BE or CN schemes and <em>one
time step</em> is enough to produce the stationary solution for
\( t\rightarrow\infty \).

<p>
<!-- Need example, but with nonzero boundary conditions -->

<p>
<!-- !split --><br><br><br><br><br>

<h2>Extensions  <a name="___sec35"></a></h2>

<p>
These extensions are performed exactly as for a wave equation as they
only affect the spatial derivatives (which are the same as in the
wave equation).

<ul>
 <p><li> Variable coefficients</li>
 <p><li> Neumann and Robin conditions</li>
 <p><li> 2D and 3D</li>
</ul>

Future versions of this document will for completeness and
independence of the wave equation document feature info on the three
points. The Robin condition is new, but straightforward to handle:

$$ -\dfc\frac{\partial u}{\partial n} = h_T(u-U_s),\quad
[-\dfc D_x u = h_T(u-U_s)]^n_i
$$

<h1>Analysis of schemes for the diffusion equation  <a name="___sec36"></a></h1>

<p>
<!-- !split --><br><br><br><br><br>

<h2>Properties of the solution <a name="diffu:pde1:analysis:uex"></a></h2>

<p>
The PDE

$$
\begin{equation}
u_t = \dfc u_{xx}
\label{diffu:pde1:eq}
\end{equation}
$$

admits solutions

$$
\begin{equation}
u(x,t) = Qe^{-\dfc k^2 t}\sin\left( kx\right)
\label{diffu:pde1:sol1}
\end{equation}
$$


<p>
Observations from this solution:

<ul>
 <p><li> The initial shape \( I(x)=Q\sin kx \)
   undergoes a damping \( \exp{(-\dfc k^2t)} \)</li>
 <p><li> The damping is very strong for short waves (large \( k \))</li>
 <p><li> The damping is weak for long waves (small \( k \))</li>
 <p><li> Consequence: \( u \) is smoothened with time</li>
</ul>

<!-- !split --><br><br><br><br><br>

<h2>Example  <a name="___sec38"></a></h2>

<p>
Test problem:

$$
\begin{align*}
u_t &= u_{xx},\quad &x\in (0,1),\ t\in (0,T]\\ 
u(0,t) &= u(1,t) = 0,\quad &t\in (0,T]\\ 
u(x,0) & = \sin (\pi x) + 0.1\sin(100\pi x)
\end{align*}
$$


<p>
Exact solution:

$$
\begin{equation}
u(x,t) = e^{-\pi^2 t}\sin (\pi x) + 0.1e^{-\pi^2 10^4 t}\sin (100\pi x)
\label{diffu:pde1:sol2}
\end{equation}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Visualization of the damping in the diffusion equation  <a name="___sec39"></a></h2>

<p>
<center><p><img src="fig-diffu/diffusion_damping.png" align="bottom" width=800></p></center>

<p>
<!-- !split --><br><br><br><br><br>

<h2>Damping of a discontinuity; problem and model  <a name="___sec40"></a></h2>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Problem.</b>
<p>
Two pieces of a material, at different temperatures, are brought
in contact at \( t=0 \). Assume the end points of the pieces are
kept at the initial temperature. How does the heat flow from
the hot to the cold piece?
</div>


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Solution.</b>
<p>

<p>
Assume a 1D model is sufficient (insulated rod):

$$
u(x,0)=\left\lbrace
\begin{array}{ll}
U_L, & x < L/2\\ 
U_R,& x\geq L/2
\end{array}\right.
$$


$$ \frac{\partial u}{\partial t} = \dfc
\frac{\partial^2 u}{\partial x^2},\quad u(0,t)=U_L,\ u(L,t)=U_R$$
</div>


<p>
<!-- !split --><br><br><br><br><br>

<h2>Damping of a discontinuity; Backward Euler simulation  <a name="___sec41"></a></h2>

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-diffu/BE_C0.5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/BE_C0.5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<!-- !split --><br><br><br><br><br>

<h2>Damping of a discontinuity; Forward Euler simulation  <a name="___sec42"></a></h2>

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-diffu/FE_C0.5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/FE_C0.5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<!-- !split --><br><br><br><br><br>

<h2>Damping of a discontinuity; Crank-Nicolson simulation  <a name="___sec43"></a></h2>

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-diffu/CN_C5/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-diffu/CN_C5/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>


<p>
<!-- !split --><br><br><br><br><br>

<h2>Fourier representation  <a name="___sec44"></a></h2>

<p>
Represent \( I(x) \) as a Fourier series

$$
\begin{equation}
I(x) \approx \sum_{k\in K} b_k e^{ikx}
\end{equation}
$$


<p>
The corresponding sum for \( u \) is

$$
\begin{equation}
u(x,t) \approx \sum_{k\in K} b_k e^{-\dfc k^2t}e^{ikx}
\label{diffu:pde1:u:Fourier}
\tp
\end{equation}
$$


<p>
Such solutions are also accepted by the numerical schemes, but
with an amplification factor \( A \) different from \( \exp{({-\dfc k^2t})} \):

$$
\begin{equation}
u^n_q = A^n e^{ikq\Delta x} = A^ne^{ikx}
\label{diffu:pde1:analysis:uni}
\end{equation}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Analysis of the finite difference schemes <a name="diffu:pde1:analysis"></a></h2>

<p>
Stability:

<ul>
  <p><li> \( |A| < 1 \): decaying numerical solutions (as we want)</li>
  <p><li> \( A < 0 \): <em>oscillating</em> numerical solutions (as we do not want)</li>
</ul>

Accuracy:

<ul>
  <p><li> Compare numerical and exact amplification factor: \( A \) vs \( \Aex = \exp{(-\dfc k^2 \Delta t)} \)</li>
</ul>

<!-- !split --><br><br><br><br><br>

<h2>Analysis of the Forward Euler scheme <a name="diffu:pde1:analysis:FE"></a></h2>

$$
\begin{equation*} [D_t^+ u = \dfc D_xD_x u]^n_q \end{equation*}
$$


<p>
Inserting

$$ u^n_q = A^n e^{ikq\Delta x}$$

leads to

$$
\begin{equation}
A = 1 -4C\sin^2\left(
\frac{k\Delta x}{2}\right),\quad
C = \frac{\dfc\Delta t}{\Delta x^2}
\end{equation}
$$


<p>
The complete numerical solution is

$$
\begin{equation}
u^n_q = (1 -4C\sin^2 p)^ne^{ikq\Delta x},\quad
p = k\Delta x/2
\end{equation}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Results for stability  <a name="___sec47"></a></h2>

<p>
We always have \( A\leq 1 \). The condition \( A\geq -1 \) implies

$$ 4C\sin^2p\leq 2 $$

The worst case is when \( \sin^2 p=1 \), so a sufficient criterion for
stability is

$$
\begin{equation}
C\leq {\half}
\end{equation}
$$

or:

$$
\begin{equation}
\Delta t\leq \frac{\Delta x^2}{2\dfc}
\end{equation}
$$


<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Implications of the stability result.</b>
<p>
Less favorable criterion than for \( u_{tt}=c^2u_{xx} \): halving \( \Delta x \)
implies time step \( \frac{1}{4}\Delta t \) (not just \( \half\Delta t \)
as in a wave equation). Need very small time steps for fine spatial
meshes!
</div>


<p>
<!-- !split --><br><br><br><br><br>

<h2>Analysis of the Backward Euler scheme <a name="diffu:pde1:analysis:BE"></a></h2>

$$
\begin{equation*} [D_t^- u = \dfc D_xD_x u]^n_q\end{equation*}
$$


$$ u^n_q = A^n e^{ikq\Delta x}$$


$$
\begin{equation}
A = (1  + 4C\sin^2p)^{-1}
\label{diffu:pde1:analysis:BE:A}
\end{equation}
$$


$$
\begin{equation}
u^n_q = (1  + 4C\sin^2p)^{-n}e^{ikq\Delta x}
\end{equation}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Stability  <a name="___sec49"></a></h2>

<p>
We see from \eqref{diffu:pde1:analysis:BE:A} that \( |A| < 1 \) for all \( \Delta t>0 \)
and that \( A>0 \) (no oscillations).

<p>
<!-- !split --><br><br><br><br><br>

<h2>Analysis of the Crank-Nicolson scheme <a name="diffu:pde1:analysis:CN"></a></h2>

<p>
The scheme

$$ [D_t u = \dfc D_xD_x \overline{u}^x]^{n+\half}_q$$

leads to

$$
\begin{equation}
A = \frac{ 1 - 2C\sin^2p}{1 + 2C\sin^2p}
\end{equation}
$$


$$
\begin{equation}
u^n_q = \left(\frac{ 1 - 2C\sin^2p}{1 + 2C\sin^2p}\right)^ne^{ikp\Delta x}
\end{equation}
$$


<p>
<!-- !split --><br><br><br><br><br>

<h2>Stability  <a name="___sec51"></a></h2>

<p>
The criteria \( A>-1 \) and \( A < 1 \) are fulfilled for any \( \Delta t >0 \).

<p>
<!-- !split --><br><br><br><br><br>

<h2>Summary of accuracy of amplification factors; large time steps  <a name="___sec52"></a></h2>

<p>
<center><p><img src="fig-diffu/diffusion_A_Fo20_Fo2_FDM.png" align="bottom" width=800,></p></center>

<p>
<!-- !split --><br><br><br><br><br>

<h2>Summary of accuracy of amplification factors; time steps around the Forward Euler stability limit  <a name="___sec53"></a></h2>

<p>
<center><p><img src="fig-diffu/diffusion_A_Fo05_Fo025_FDM.png" align="bottom" width=800,></p></center>

<p>
<!-- !split --><br><br><br><br><br>

<h2>Summary of accuracy of amplification factors; small time steps  <a name="___sec54"></a></h2>

<p>
<center><p><img src="fig-diffu/diffusion_A_Fo01_Fo001_FDM.png" align="bottom" width=800,></p></center>

<p>
<!-- !split --><br><br><br><br><br>

<h2>Observations  <a name="___sec55"></a></h2>

<ul>
 <p><li> Crank-Nicolson gives oscillations and not much damping of short waves
   for increasing \( C \).</li>
 <p><li> These waves will manifest themselves as high frequency
   oscillatory noise in the solution.</li>
 <p><li> All schemes fail to dampen short waves enough</li>
</ul>

The problems of correct damping for \( u_t = u_{xx} \) is partially
manifested in the similar time discretization schemes for \( u'(t)=-\dfc u(t) \).

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

