<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to finite element methods">
<meta name="keywords" content="approximation of vectors in the plane,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation,approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,residual,variational formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements">




<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="http://www.peterhaschke.com/assets/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Approximation of vectors ',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              (' Approximation of planar vectors ',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              (' The least squares method ', 3, None, '___sec2'),
              (' The projection method ', 3, None, '___sec3'),
              (' Approximation of general vectors ',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              (' The least squares method ', 3, None, '___sec5'),
              (' The Galerkin or projection method ', 3, None, '___sec6'),
              (' Approximation of functions ',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              (' The least squares method ',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              (' The projection (or Galerkin) method ', 2, None, '___sec9'),
              (' Example: linear approximation ',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              (' Implementation of the least squares method ',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              (' Perfect approximation ',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              (' Ill-conditioning ',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              (' Fourier series ',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              (' Orthogonal basis functions ',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              (' Numerical computations ', 2, None, '___sec16'),
              (' The interpolation (or collocation) method ',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              (' Example ', 3, None, '___sec18'),
              (' Lagrange polynomials ',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              (' Approximation of a polynomial ', 3, None, '___sec20'),
              (' Successful example ', 3, None, '___sec21'),
              (' Less successful example ', 3, None, '___sec22'),
              (' Remedy for strong oscillations ', 3, None, '___sec23'),
              (' Finite element basis functions ',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              (' Elements and nodes ',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              (' Example ', 3, None, '___sec26'),
              (' The basis functions ', 2, None, '___sec27'),
              (' Construction principles ', 3, None, '___sec28'),
              (' Properties of $\\basphi_i$ ', 3, None, '___sec29'),
              (' Example on piecewise quadratic finite element functions ',
               2,
               None,
               '___sec30'),
              (' Example on piecewise linear finite element functions ',
               2,
               None,
               '___sec31'),
              (' Example on piecewise cubic finite element basis functions ',
               2,
               None,
               '___sec32'),
              (' Calculating the linear system ',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              (' Calculating a specific matrix entry ', 3, None, '___sec34'),
              (' Calculating a general row in the matrix ',
               3,
               None,
               '___sec35'),
              (' Assembly of elementwise computations ',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              (' Mapping to a reference element ',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              (' Example: Integration over a reference element ',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              (' Implementation ',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              (' Integration ',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              (' Linear system assembly and solution ',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              (' Example on computing symbolic approximations ',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              (' Comparison with finite elements and interpolation/collocation ',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              (' Example on computing numerical approximations ',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              (' The structure of the coefficient matrix ',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              (' Applications ',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              (' Sparse matrix storage and solution ',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              (' Comparison of finite element and finite difference approximation ',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              (' Finite difference approximation of given functions ',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              (' Finite difference interpretation of a finite element approximation ',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              (' Making finite elements behave as finite differences ',
               2,
               None,
               '___sec51'),
              (' Computations in physical space ', 3, None, '___sec52'),
              (' Elementwise computations ', 3, None, '___sec53'),
              (' Terminology ', 3, None, '___sec54'),
              (' A generalized element concept ',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              (' Cells, vertices, and degrees of freedom ',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              (' Extended finite element concept ',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              (' Implementation ',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              (' Computing the error of the approximation ',
               2,
               'fem:approx:fe:element:impl:error',
               'fem:approx:fe:element:impl:error'),
              (' Example: Cubic Hermite polynomials ',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              (' Numerical integration ', 1, None, '___sec61'),
              (' Newton-Cotes rules ',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              (' Gauss-Legendre rules with optimized points ',
               2,
               None,
               '___sec63'),
              (' Approximation of functions in 2D ',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              (' 2D basis functions as tensor products of 1D functions ',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              (' Example: Polynomial basis in 2D ', 2, None, '___sec66'),
              (' Implementation ',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              (' Extension to 3D ',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              (' Finite elements in 2D and 3D ', 1, None, '___sec69'),
              (' Basis functions over triangles in the physical domain ',
               2,
               None,
               '___sec70'),
              (' Element matrices and vectors ', 3, None, '___sec71'),
              (' Basis functions over triangles in the reference cell ',
               2,
               None,
               '___sec72'),
              (' Affine mapping of the reference cell ', 2, None, '___sec73'),
              (' Isoparametric mapping of the reference cell ',
               2,
               None,
               '___sec74'),
              (' Computing integrals ', 2, None, '___sec75'),
              (' Exercises ', 1, None, '___sec76'),
              (' Exercise 1: Linear algebra refresher I ',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              (' Exercise 2: Linear algebra refresher II ',
               2,
               'fem:approx:exer:linalg2',
               'fem:approx:exer:linalg2'),
              (' Exercise 3: Approximate a three-dimensional vector in a plane ',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              (' Exercise 4: Approximate the exponential function by power functions ',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              (' Exercise 5: Approximate the sine function by power functions ',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              (' Exercise 6: Approximate a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              (' Exercise 7: Animate the approximation of a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine2',
               'fem:approx:exer:tanh:sine2'),
              (' Exercise 8: Fourier series as a least squares approximation ',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              (' Exercise 9: Approximate a steep function by Lagrange polynomials ',
               2,
               'fem:approx:exer:tanh',
               'fem:approx:exer:tanh'),
              (' Exercise 10: Define nodes and elements ',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              (' Exercise 11: Define vertices, cells, and dof maps ',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              (' Exercise 12: Construct matrix sparsity patterns ',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              (' Exercise 13: Perform symbolic finite element computations ',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              (' Exercise 14: Approximate a steep function by P1 and P2 elements ',
               2,
               'fem:approx:exer:tanh',
               'fem:approx:exer:tanh'),
              (' Exercise 15: Approximate a steep function by P3 and P4 elements ',
               2,
               'fem:approx:exer:tanh2',
               'fem:approx:exer:tanh2'),
              (' Exercise 16: Investigate the approximation error in finite elements ',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              (' Exercise 17: Approximate a step function by finite elements ',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              (' Exercise 18: 2D approximation with orthogonal functions ',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              (' Exercise 19: Use the Trapezoidal rule and P1 elements ',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              (' Problem 20: Compare P1 elements and interpolation ',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              (' Exercise 21: Implement 3D computations with global basis functions ',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              (" Exercise 22: Use Simpson's rule and P2 elements ",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              (' Basic principles for approximating differential equations ',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              (' Differential equation models ',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              (' Simple model problems ',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              (' Forming the residual ',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              (' The least squares method ', 2, None, '___sec103'),
              (' The Galerkin method ', 2, None, '___sec104'),
              (' The Method of Weighted Residuals ', 2, None, '___sec105'),
              (' Test and Trial Functions ', 2, None, '___sec106'),
              (' The collocation method ', 2, None, '___sec107'),
              (' The subdomain collocation method ', 3, None, '___sec108'),
              (' Examples on using the principles ',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              (' The model problem ', 3, None, '___sec110'),
              (' Basis functions ', 3, None, '___sec111'),
              (' The residual ', 3, None, '___sec112'),
              (' The least squares method ', 3, None, '___sec113'),
              (' The Galerkin method ', 3, None, '___sec114'),
              (' The collocation method ', 3, None, '___sec115'),
              (' Comparison ', 3, None, '___sec116'),
              (' Integration by parts ',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              (' Weak form ', 3, None, '___sec118'),
              (' Boundary function ',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              (' Abstract notation for variational formulations ',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              (' Variational problems and optimization of functionals ',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              (' Examples on variational formulations ',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              (' Variable coefficient ', 2, None, '___sec123'),
              (' First-order derivative in the equation and boundary condition ',
               2,
               None,
               '___sec124'),
              (' Nonlinear coefficient ', 2, None, '___sec125'),
              (' Computing with Dirichlet and Neumann conditions ',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              (' When the numerical method is exact ', 2, None, '___sec127'),
              (' Computing with finite elements ',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              (' Finite element mesh and basis functions ',
               2,
               None,
               '___sec129'),
              (' Computation in the global physical domain ',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              (' Comparison with a finite difference discretization ',
               2,
               None,
               '___sec131'),
              (' Cellwise computations ',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              (' The integral for the element matrix ', 3, None, '___sec133'),
              (' The integral for the element vector ', 3, None, '___sec134'),
              (' Detailed calculations of the element matrix and vector ',
               3,
               None,
               '___sec135'),
              (' Contributions from the first and last cell ',
               3,
               None,
               '___sec136'),
              (' Assembly ', 3, None, '___sec137'),
              (' Boundary conditions: specified nonzero value ',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              (' General construction of a boundary function ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              (' Example on computing with finite element-based a boundary function ',
               2,
               None,
               '___sec140'),
              (' Computations in physical coordinates ',
               3,
               None,
               '___sec141'),
              (' Cellwise computations on the reference element ',
               3,
               None,
               '___sec142'),
              (' Modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (' Computations in the physical system ', 3, None, '___sec144'),
              (' Symmetric modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (' Modification of the element matrix and vector ',
               2,
               None,
               '___sec146'),
              (' Boundary conditions: specified derivative ',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              (' The variational formulation ', 2, None, '___sec148'),
              (' Boundary term vanishes because of the test functions ',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              (' Boundary term vanishes because of linear system modifications ',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              (' Direct computation of the global linear system ',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              (' Cellwise computations ', 2, None, '___sec152'),
              (' Implementation ',
               1,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              (' Global basis functions ', 2, None, '___sec154'),
              (' Example: constant right-hand side ', 2, None, '___sec155'),
              (' Finite elements ', 2, None, '___sec156'),
              (' Variational formulations in 2D and 3D ',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              (' Transformation to a reference cell in 2D and 3D ',
               2,
               None,
               '___sec158'),
              (' Numerical integration ', 2, None, '___sec159'),
              (' Convenient formulas for P1 elements in 2D ',
               2,
               None,
               '___sec160'),
              (' Summary ', 1, None, '___sec161'),
              (' Time-dependent problems ',
               1,
               'fem:deq:timedep',
               'fem:deq:timedep'),
              (' Discretization in time by a Forward Euler scheme ',
               2,
               'fem:deq:diffu:FE',
               'fem:deq:diffu:FE'),
              (' Time discretization ', 3, None, '___sec164'),
              (' Space discretization ', 3, None, '___sec165'),
              (' Variational forms ', 2, None, '___sec166'),
              (' Simplified notation for the solution at recent time levels ',
               2,
               None,
               '___sec167'),
              (' Deriving the linear systems ', 2, None, '___sec168'),
              (' Computational algorithm ', 2, None, '___sec169'),
              (' Comparing P1 elements with the finite difference method ',
               2,
               'fem:deq:diffu:FE:fdvsP1fe',
               'fem:deq:diffu:FE:fdvsP1fe'),
              (' Lumping the mass matrix ', 3, None, '___sec171'),
              (' Discretization in time by a Backward Euler scheme ',
               2,
               'fem:deq:diffu:BE',
               'fem:deq:diffu:BE'),
              (' Time discretization ', 3, None, '___sec173'),
              (' Variational forms ', 3, None, '___sec174'),
              (' Linear systems ', 3, None, '___sec175'),
              (' Dirichlet boundary conditions ',
               2,
               'fem:deq:diffu:Dirichlet',
               'fem:deq:diffu:Dirichlet'),
              (' Boundary function ', 3, None, '___sec177'),
              (' Finite element basis functions ', 3, None, '___sec178'),
              (' Modification of the linear system ', 3, None, '___sec179'),
              (' Example: Oscillating Dirichlet boundary condition ',
               2,
               'fem:deq:diffu:Dirichlet:ex',
               'fem:deq:diffu:Dirichlet:ex'),
              (' Analysis of the discrete equations ',
               2,
               'fem:deq:diffu:anal',
               'fem:deq:diffu:anal'),
              (' Forward Euler discretization ', 3, None, '___sec182'),
              (' Backward Euler discretization ', 3, None, '___sec183'),
              (' Comparing amplification factors ', 3, None, '___sec184'),
              (' Systems of differential equations ',
               1,
               'fem:sys',
               'fem:sys'),
              (' Variational forms ', 2, 'fem:sys:vform', 'fem:sys:vform'),
              (' A worked example ', 2, 'fem:sys:uT:ex', 'fem:sys:uT:ex'),
              (' Identical function spaces for the unknowns ',
               2,
               None,
               '___sec188'),
              (' Variational form of each individual PDE ',
               3,
               None,
               '___sec189'),
              (' Compound scalar variational form ', 3, None, '___sec190'),
              (' Decoupled linear systems ', 3, None, '___sec191'),
              (' Coupled linear systems ', 3, None, '___sec192'),
              (' Different function spaces for the unknowns ',
               2,
               None,
               '___sec193'),
              (' Computations in 1D ', 2, None, '___sec194'),
              (' Exercises ', 1, None, '___sec195'),
              (' Exercise 23: Refactor functions into a more general class ',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              (' Exercise 24: Compute the deflection of a cable with sine functions ',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              (' Exercise 25: Check integration by parts ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 26: Compute the deflection of a cable with 2 P1 elements ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 27: Compute the deflection of a cable with 1 P2 element ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 28: Compute the deflection of a cable with a step load ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 29: Show equivalence between linear systems ',
               2,
               'fem:deq:exer:Aub:essbc:equiv',
               'fem:deq:exer:Aub:essbc:equiv'),
              (' Exercise 30: Compute with a non-uniform mesh ',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              (' Problem 31: Solve a 1D finite element problem by hand ',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              (' Exercise 32: Compare finite elements and differences for a radially symmetric Poisson equation ',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              (' Exercise 33: Compute with variable coefficients and P1 elements by hand ',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              (' Exercise 34: Solve a 2D Poisson equation using polynomials and sines ',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              (' Exercise 35: Analyze a Crank-Nicolson scheme for the diffusion equation ',
               2,
               'fem:deq:exer:diffu:analysis:CN',
               'fem:deq:exer:diffu:analysis:CN'),
              (' Bibliography ', 1, None, '___sec209')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0002"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_fem-solarized001.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_fem-solarized003.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1>Approximation of vectors <a name="fem:approx:vec"></a></h1>

We shall start with introducing two fundamental methods for
determining the coefficients \( c_i \) in <a href="._main_fem-solarized001.html#mjx-eqn-1">(1)</a> and illustrate
the methods on approximation of vectors, because vectors in vector
spaces give a more intuitive understanding than starting directly
with approximation of functions in function spaces.
The extension from vectors to functions will be trivial as soon as
the fundamental ideas are understood.

<p>
The first method of approximation is called the <em>least squares method</em>
and consists in finding \( c_i \) such that the difference \( u-f \), measured
in some norm, is minimized. That is, we aim at finding the best
approximation \( u \) to \( f \) (in some norm). The second method is not
as intuitive: we find \( u \) such that the error \( u-f \) is orthogonal to
the space where we seek \( u \). This is known as <em>projection</em>, or
we may also call it a <em>Galerkin method</em>.
When approximating vectors and functions, the two methods are
equivalent, but this is no longer the case when applying the
principles to differential equations.

<h2>Approximation of planar vectors <a name="fem:approx:vec:plane"></a></h2>

Suppose we have given a vector \( \f = (3,5) \) in the \( xy \) plane
and that we want to approximate this vector by a vector aligned
in the direction of the vector \( (a,b) \). Figure <a href="#fem:approx:vec:plane:fig">2</a>
depicts the situation.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Approximation of a two-dimensional vector by a one-dimensional vector. <a name="fem:approx:vec:plane:fig"></a> </p></center>
<p><img src="fig-fem/vecapprox_plane.png" align="bottom" width=400></p>
</center>

<p>
We introduce the vector space \( V \)
spanned by the vector \( \psib_0=(a,b) \):

$$
\begin{equation}
V = \mbox{span}\,\{ \psib_0\}\tp  \end{equation}
$$

We say that \( \psib_0 \) is a basis vector in the space \( V \).
Our aim is to find the vector \( \u = c_0\psib_0\in V \) which best approximates
the given vector \( \f = (3,5) \). A reasonable criterion for a best
approximation could be to minimize the length of the difference between
the approximate \( \u \) and the given \( \f \). The difference, or error
\( \e = \f -\u \), has its length given by the <em>norm</em>

$$
\begin{equation*} ||\e|| = (\e,\e)^{\half},\end{equation*}
$$

where \( (\e,\e) \) is the <em>inner product</em> of \( \e \) and itself. The inner
product, also called <em>scalar product</em> or <em>dot product</em>, of two vectors
\( \u=(u_0,u_1) \) and \( \v =(v_0,v_1) \) is defined as

$$
\begin{equation}
(\u, \v) = u_0v_0 + u_1v_1\tp  \end{equation}
$$


<p>
<b>Remark 1.</b>
We should point out that we use the notation
\( (\cdot,\cdot) \) for two different things: \( (a,b) \) for scalar
quantities \( a \) and \( b \) means the vector starting in the origin and
ending in the point \( (a,b) \), while \( (\u,\v) \) with vectors \( \u \) and
\( \v \) means the inner product of these vectors.  Since vectors are here
written in boldface font there should be no confusion.  We may add
that the norm associated with this inner product is the usual
Eucledian length of a vector.

<p>
<b>Remark 2.</b>
It might be wise to refresh some basic linear algebra by consulting a
textbook.  <a href="._main_fem-solarized011.html#fem:approx:exer:linalg1">Exercise 1: Linear algebra refresher I</a> and
<a href="._main_fem-solarized011.html#fem:approx:exer:linalg2">Exercise 2: Linear algebra refresher II</a> suggest specific tasks to regain
familiarity with fundamental operations on inner product vector
spaces.

<h3>The least squares method  <a name="___sec2"></a></h3>

We now want to find \( c_0 \) such that it minimizes \( ||\e|| \). The algebra
is simplified if we minimize the square of the norm, \( ||\e||^2 = (\e, \e) \),
instead of the norm itself.
Define the function

$$
\begin{equation}
E(c_0) = (\e,\e) = (\f - c_0\psib_0, \f - c_0\psib_0)
\tp
\end{equation}
$$

We can rewrite the expressions of the right-hand side in a more
convenient form for further work:

$$
\begin{equation}
E(c_0) = (\f,\f) - 2c_0(\f,\psib_0) + c_0^2(\psib_0,\psib_0)\tp
\tag{2}
\end{equation}
$$

The rewrite results from using the following fundamental rules for inner
product spaces:

$$
\begin{equation}
(\alpha\u,\v)=\alpha(\u,\v),\quad \alpha\in\Real,
\tag{3}
\end{equation}
$$


$$
\begin{equation}
(\u +\v,\w) = (\u,\w) + (\v, \w),
\tag{4}
\end{equation}
$$


$$
\begin{equation}
(\u, \v) = (\v, \u)\tp  \end{equation}
\tag{5}
$$


<p>
Minimizing \( E(c_0) \) implies finding \( c_0 \) such that

$$
\begin{equation*} \frac{\partial E}{\partial c_0} = 0\tp  \end{equation*}
$$

Differentiating <a href="#mjx-eqn-2">(2)</a> with respect to \( c_0 \) gives

$$
\begin{equation}
\frac{\partial E}{\partial c_0} = -2(\f,\psib_0) + 2c_0 (\psib_0,\psib_0)
\tp
\tag{6}
\end{equation}
$$

Setting the above expression equal to zero and solving for \( c_0 \) gives

$$
\begin{equation}
c_0 = \frac{(\f,\psib_0)}{(\psib_0,\psib_0)},
\tag{7}
\end{equation}
$$

which in the present case with \( \psib_0=(a,b) \) results in

$$
\begin{equation}
c_0 = \frac{3a + 5b}{a^2 + b^2}\tp  \end{equation}
$$


<p>
For later, it is worth mentioning that setting
the key equation <a href="#mjx-eqn-6">(6)</a> to zero can be rewritten
as

$$
(\f-c0\psib_0,\psib_0) = 0,
$$

or

$$
\begin{equation}
(\e, \psib_0) = 0
\tp
\tag{8}
\end{equation}
$$

<h3>The projection method  <a name="___sec3"></a></h3>

We shall now show that minimizing \( ||\e||^2 \) implies that \( \e \) is
orthogonal to <em>any</em> vector \( \v \) in the space \( V \). This result is
visually quite clear from Figure <a href="#fem:approx:vec:plane:fig">2</a> (think of
other vectors along the line \( (a,b) \): all of them will lead to
a larger distance between the approximation and \( \f \)).
To see this result mathematically, we
express any \( \v\in V \) as \( \v=s\psib_0 \) for any scalar parameter \( s \),
recall that two vectors are orthogonal when their inner product vanishes,
and calculate the inner product
$$
\begin{align*}
(\e, s\psib_0) &= (\f - c_0\psib_0, s\psib_0)\\ 
&= (\f,s\psib_0) - (c_0\psib_0, s\psib_0)\\ 
&= s(\f,\psib_0) - sc_0(\psib_0, \psib_0)\\ 
&= s(\f,\psib_0) - s\frac{(\f,\psib_0)}{(\psib_0,\psib_0)}(\psib_0,\psib_0)\\ 
&= s\left( (\f,\psib_0) - (\f,\psib_0)\right)\\ 
&=0\tp
\end{align*}
$$

Therefore, instead of minimizing the square of the norm, we could
demand that \( \e \) is orthogonal to any vector in \( V \).
This method is known as <em>projection</em>, because it is the same as
projecting the vector onto the subspace.
(The approach can also be referred to as a Galerkin method as
explained at the end of the section <a href="#fem:approx:vec:Np1dim">Approximation of general vectors</a>.)

<p>
Mathematically the projection method is stated
by the equation

$$
\begin{equation}
(\e, \v) = 0,\quad\forall\v\in V\tp
\tag{9}
\end{equation}
$$

An arbitrary \( \v\in V \) can be expressed as
\( s\psib_0 \), \( s\in\Real \), and therefore
<a href="#mjx-eqn-9">(9)</a> implies

$$
\begin{equation*} (\e,s\psib_0) = s(\e, \psib_0) = 0,\end{equation*}
$$

which means that the error must be orthogonal to the basis vector in
the space \( V \):

$$
\begin{equation*}
(\e, \psib_0)=0\quad\hbox{or}\quad
(\f - c_0\psib_0, \psib_0)=0
\tp
\end{equation*}
$$

The latter equation gives <a href="#mjx-eqn-7">(7)</a> and it
also arose from least squares computations in
<a href="#mjx-eqn-8">(8)</a>.

<h2>Approximation of general vectors <a name="fem:approx:vec:Np1dim"></a></h2>

Let us generalize the vector approximation from the previous section
to vectors in spaces with arbitrary dimension. Given some vector \( \f \),
we want to find the best approximation to this vector in
the space

$$
\begin{equation*}
V = \hbox{span}\,\{\psib_0,\ldots,\psib_N\}
\tp
\end{equation*}
$$

We assume that the <em>basis vectors</em> \( \psib_0,\ldots,\psib_N \) are
linearly independent so that none of them are redundant and
the space has dimension \( N+1 \).
Any vector \( \u\in V \) can be written as a linear combination
of the basis vectors,

$$
\begin{equation*} \u = \sum_{j=0}^N c_j\psib_j,\end{equation*}
$$

where \( c_j\in\Real \) are scalar coefficients to be determined.

<h3>The least squares method  <a name="___sec5"></a></h3>

Now we want to find \( c_0,\ldots,c_N \), such that \( \u \) is the best
approximation to \( \f \) in the sense that the distance (error)
\( \e = \f - \u \) is minimized. Again, we define
the squared distance as a function of the free parameters
\( c_0,\ldots,c_N \),

$$
\begin{align}
E(c_0,\ldots,c_N) &= (\e,\e) = (\f -\sum_jc_j\psib_j,\f -\sum_jc_j\psib_j)
\nonumber\\ 
&= (\f,\f) - 2\sum_{j=0}^N c_j(\f,\psib_j) +
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\psib_p,\psib_q)\tp
\tag{10}
\end{align}
$$

Minimizing this \( E \) with respect to the independent variables
\( c_0,\ldots,c_N \) is obtained by requiring

$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N
\tp
\end{equation*}
$$

The second term in <a href="#mjx-eqn-10">(10)</a> is differentiated as follows:

$$
\begin{equation}
\frac{\partial}{\partial c_i}
\sum_{j=0}^N c_j(\f,\psib_j) = (\f,\psib_i),
\end{equation}
$$

since the expression to be differentiated is a sum and only one term,
\( c_i(\f,\psib_i) \),
contains \( c_i \) and this term is linear in \( c_i \).
To understand this differentiation in detail, write out the sum specifically for,
e.g, \( N=3 \) and \( i=1 \).

<p>
The last term in <a href="#mjx-eqn-10">(10)</a>
is more tedious to differentiate. We start with

$$
\begin{align}
\frac{\partial}{\partial c_i}
c_pc_q =
\left\lbrace\begin{array}{ll}
0, & \hbox{ if } p\neq i\hbox{ and } q\neq i,\\ 
c_q, & \hbox{ if } p=i\hbox{ and } q\neq i,\\ 
c_p, & \hbox{ if } p\neq i\hbox{ and } q=i,\\ 
2c_i, & \hbox{ if } p=q= i,\\ 
\end{array}\right.
\end{align}
$$

Then

$$
\begin{equation*} \frac{\partial}{\partial c_i}
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\psib_p,\psib_q)
= \sum_{p=0, p\neq i}^N c_p(\psib_p,\psib_i)
+ \sum_{q=0, q\neq i}^N c_q(\psib_q,\psib_i)
+2c_i(\psib_i,\psib_i)\tp  \end{equation*}
$$

The last term can be included in the other two sums, resulting in

$$
\begin{equation}
\frac{\partial}{\partial c_i}
\sum_{p=0}^N\sum_{q=0}^N c_pc_q(\psib_p,\psib_q)
= 2\sum_{j=0}^N c_i(\psib_j,\psib_i)\tp  \end{equation}
$$

It then follows that setting

$$
\begin{equation*}
\frac{\partial E}{\partial c_i} = 0,\quad i=0,\ldots,N,\end{equation*}
$$

leads to a linear system
for \( c_0,\ldots,c_N \):

$$
\begin{equation}
\sum_{j=0}^N A_{i,j} c_j = b_i, \quad i=0,\ldots,N,
\tag{11}
\end{equation}
$$

where

$$
\begin{align}
A_{i,j} &= (\psib_i,\psib_j),\\ 
b_i &= (\psib_i, \f)\tp  \end{align}
$$

We have changed the order of the two vectors in the inner
product according to <a href="#mjx-eqn-5">(5)</a>:

$$ A_{i,j} = (\psib_j,\psib_i) = (\psib_i,\psib_j),$$

simply because the sequence \( i \)-$j$ looks more aesthetic.

<h3>The Galerkin or projection method  <a name="___sec6"></a></h3>

In analogy with the "one-dimensional" example in
the section <a href="#fem:approx:vec:plane">Approximation of planar vectors</a>, it holds also here in the general
case that minimizing the distance
(error) \( \e \) is equivalent to demanding that \( \e \) is orthogonal to
all \( \v\in V \):

$$
\begin{equation}
(\e,\v)=0,\quad \forall\v\in V\tp
\tag{12}
\end{equation}
$$

Since any \( \v\in V \) can be written as \( \v =\sum_{i=0}^N c_i\psib_i \),
the statement <a href="#mjx-eqn-12">(12)</a> is equivalent to
saying that

$$
\begin{equation*} (\e, \sum_{i=0}^N c_i\psib_i) = 0,\end{equation*}
$$

for any choice of coefficients \( c_0,\ldots,c_N \).
The latter equation can be rewritten as

$$
\begin{equation*} \sum_{i=0}^N c_i (\e,\psib_i) =0\tp  \end{equation*}
$$

If this is to hold for arbitrary values of \( c_0,\ldots,c_N \)
we must require that each term in the sum vanishes,

$$
\begin{equation}
(\e,\psib_i)=0,\quad i=0,\ldots,N\tp
\tag{13}
\end{equation}
$$

These \( N+1 \) equations result in the same linear system as
<a href="#mjx-eqn-11">(11)</a>:

$$ (\f - \sum_{j=0}^N c_j\psib_j, \psib_i) = (\f, \psib_i) - \sum_{j\in\If}
(\psib_i,\psib_j)c_j = 0,$$

and hence

$$ \sum_{j=0}^N (\psib_i,\psib_j)c_j = (\f, \psib_i),\quad i=0,\ldots, N
\tp
$$

So, instead of differentiating the
\( E(c_0,\ldots,c_N) \) function, we could simply use
<a href="#mjx-eqn-12">(12)</a> as the principle for
determining \( c_0,\ldots,c_N \), resulting in the \( N+1 \)
equations <a href="#mjx-eqn-13">(13)</a>.

<p>
The names <em>least squares method</em> or <em>least squares approximation</em>
are natural since the calculations consists of
minimizing \( ||\e||^2 \), and \( ||\e||^2 \) is a sum of squares
of differences between the components in \( \f \) and \( \u \).
We find \( \u \) such that this sum of squares is minimized.

<p>
The principle <a href="#mjx-eqn-12">(12)</a>,
or the equivalent form <a href="#mjx-eqn-13">(13)</a>,
is known as <em>projection</em>. Almost the same mathematical idea
was used by the Russian mathematician <a href="http://en.wikipedia.org/wiki/Boris_Galerkin" target="_self">Boris Galerkin</a> to solve
differential equations, resulting in what is widely known as
<em>Galerkin's method</em>.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_fem-solarized001.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_fem-solarized003.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

