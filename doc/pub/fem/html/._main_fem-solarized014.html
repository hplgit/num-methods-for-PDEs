<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to finite element methods">
<meta name="keywords" content="approximation of vectors in the plane,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation,approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,residual,variational formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements">




<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="http://www.peterhaschke.com/assets/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Approximation of vectors ',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              (' Approximation of planar vectors ',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              (' The least squares method ', 3, None, '___sec2'),
              (' The projection method ', 3, None, '___sec3'),
              (' Approximation of general vectors ',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              (' The least squares method ', 3, None, '___sec5'),
              (' The Galerkin or projection method ', 3, None, '___sec6'),
              (' Approximation of functions ',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              (' The least squares method ',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              (' The projection (or Galerkin) method ', 2, None, '___sec9'),
              (' Example: linear approximation ',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              (' Implementation of the least squares method ',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              (' Perfect approximation ',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              (' Ill-conditioning ',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              (' Fourier series ',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              (' Orthogonal basis functions ',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              (' Numerical computations ', 2, None, '___sec16'),
              (' The interpolation (or collocation) method ',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              (' Example ', 3, None, '___sec18'),
              (' Lagrange polynomials ',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              (' Approximation of a polynomial ', 3, None, '___sec20'),
              (' Successful example ', 3, None, '___sec21'),
              (' Less successful example ', 3, None, '___sec22'),
              (' Remedy for strong oscillations ', 3, None, '___sec23'),
              (' Finite element basis functions ',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              (' Elements and nodes ',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              (' Example ', 3, None, '___sec26'),
              (' The basis functions ', 2, None, '___sec27'),
              (' Construction principles ', 3, None, '___sec28'),
              (' Properties of $\\basphi_i$ ', 3, None, '___sec29'),
              (' Example on piecewise quadratic finite element functions ',
               2,
               None,
               '___sec30'),
              (' Example on piecewise linear finite element functions ',
               2,
               None,
               '___sec31'),
              (' Example on piecewise cubic finite element basis functions ',
               2,
               None,
               '___sec32'),
              (' Calculating the linear system ',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              (' Calculating a specific matrix entry ', 3, None, '___sec34'),
              (' Calculating a general row in the matrix ',
               3,
               None,
               '___sec35'),
              (' Assembly of elementwise computations ',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              (' Mapping to a reference element ',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              (' Example: Integration over a reference element ',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              (' Implementation ',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              (' Integration ',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              (' Linear system assembly and solution ',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              (' Example on computing symbolic approximations ',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              (' Comparison with finite elements and interpolation/collocation ',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              (' Example on computing numerical approximations ',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              (' The structure of the coefficient matrix ',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              (' Applications ',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              (' Sparse matrix storage and solution ',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              (' Comparison of finite element and finite difference approximation ',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              (' Finite difference approximation of given functions ',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              (' Finite difference interpretation of a finite element approximation ',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              (' Making finite elements behave as finite differences ',
               2,
               None,
               '___sec51'),
              (' Computations in physical space ', 3, None, '___sec52'),
              (' Elementwise computations ', 3, None, '___sec53'),
              (' Terminology ', 3, None, '___sec54'),
              (' A generalized element concept ',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              (' Cells, vertices, and degrees of freedom ',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              (' Extended finite element concept ',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              (' Implementation ',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              (' Computing the error of the approximation ',
               2,
               'fem:approx:fe:element:impl:error',
               'fem:approx:fe:element:impl:error'),
              (' Example: Cubic Hermite polynomials ',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              (' Numerical integration ', 1, None, '___sec61'),
              (' Newton-Cotes rules ',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              (' Gauss-Legendre rules with optimized points ',
               2,
               None,
               '___sec63'),
              (' Approximation of functions in 2D ',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              (' 2D basis functions as tensor products of 1D functions ',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              (' Example: Polynomial basis in 2D ', 2, None, '___sec66'),
              (' Implementation ',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              (' Extension to 3D ',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              (' Finite elements in 2D and 3D ', 1, None, '___sec69'),
              (' Basis functions over triangles in the physical domain ',
               2,
               None,
               '___sec70'),
              (' Element matrices and vectors ', 3, None, '___sec71'),
              (' Basis functions over triangles in the reference cell ',
               2,
               None,
               '___sec72'),
              (' Affine mapping of the reference cell ', 2, None, '___sec73'),
              (' Isoparametric mapping of the reference cell ',
               2,
               None,
               '___sec74'),
              (' Computing integrals ', 2, None, '___sec75'),
              (' Exercises ', 1, None, '___sec76'),
              (' Exercise 1: Linear algebra refresher I ',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              (' Exercise 2: Linear algebra refresher II ',
               2,
               'fem:approx:exer:linalg2',
               'fem:approx:exer:linalg2'),
              (' Exercise 3: Approximate a three-dimensional vector in a plane ',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              (' Exercise 4: Approximate the exponential function by power functions ',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              (' Exercise 5: Approximate the sine function by power functions ',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              (' Exercise 6: Approximate a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              (' Exercise 7: Animate the approximation of a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine2',
               'fem:approx:exer:tanh:sine2'),
              (' Exercise 8: Fourier series as a least squares approximation ',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              (' Exercise 9: Approximate a steep function by Lagrange polynomials ',
               2,
               'fem:approx:exer:tanh',
               'fem:approx:exer:tanh'),
              (' Exercise 10: Define nodes and elements ',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              (' Exercise 11: Define vertices, cells, and dof maps ',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              (' Exercise 12: Construct matrix sparsity patterns ',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              (' Exercise 13: Perform symbolic finite element computations ',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              (' Exercise 14: Approximate a steep function by P1 and P2 elements ',
               2,
               'fem:approx:exer:tanh',
               'fem:approx:exer:tanh'),
              (' Exercise 15: Approximate a steep function by P3 and P4 elements ',
               2,
               'fem:approx:exer:tanh2',
               'fem:approx:exer:tanh2'),
              (' Exercise 16: Investigate the approximation error in finite elements ',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              (' Exercise 17: Approximate a step function by finite elements ',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              (' Exercise 18: 2D approximation with orthogonal functions ',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              (' Exercise 19: Use the Trapezoidal rule and P1 elements ',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              (' Problem 20: Compare P1 elements and interpolation ',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              (' Exercise 21: Implement 3D computations with global basis functions ',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              (" Exercise 22: Use Simpson's rule and P2 elements ",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              (' Basic principles for approximating differential equations ',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              (' Differential equation models ',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              (' Simple model problems ',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              (' Forming the residual ',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              (' The least squares method ', 2, None, '___sec103'),
              (' The Galerkin method ', 2, None, '___sec104'),
              (' The Method of Weighted Residuals ', 2, None, '___sec105'),
              (' Test and Trial Functions ', 2, None, '___sec106'),
              (' The collocation method ', 2, None, '___sec107'),
              (' The subdomain collocation method ', 3, None, '___sec108'),
              (' Examples on using the principles ',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              (' The model problem ', 3, None, '___sec110'),
              (' Basis functions ', 3, None, '___sec111'),
              (' The residual ', 3, None, '___sec112'),
              (' The least squares method ', 3, None, '___sec113'),
              (' The Galerkin method ', 3, None, '___sec114'),
              (' The collocation method ', 3, None, '___sec115'),
              (' Comparison ', 3, None, '___sec116'),
              (' Integration by parts ',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              (' Weak form ', 3, None, '___sec118'),
              (' Boundary function ',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              (' Abstract notation for variational formulations ',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              (' Variational problems and optimization of functionals ',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              (' Examples on variational formulations ',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              (' Variable coefficient ', 2, None, '___sec123'),
              (' First-order derivative in the equation and boundary condition ',
               2,
               None,
               '___sec124'),
              (' Nonlinear coefficient ', 2, None, '___sec125'),
              (' Computing with Dirichlet and Neumann conditions ',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              (' When the numerical method is exact ', 2, None, '___sec127'),
              (' Computing with finite elements ',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              (' Finite element mesh and basis functions ',
               2,
               None,
               '___sec129'),
              (' Computation in the global physical domain ',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              (' Comparison with a finite difference discretization ',
               2,
               None,
               '___sec131'),
              (' Cellwise computations ',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              (' The integral for the element matrix ', 3, None, '___sec133'),
              (' The integral for the element vector ', 3, None, '___sec134'),
              (' Detailed calculations of the element matrix and vector ',
               3,
               None,
               '___sec135'),
              (' Contributions from the first and last cell ',
               3,
               None,
               '___sec136'),
              (' Assembly ', 3, None, '___sec137'),
              (' Boundary conditions: specified nonzero value ',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              (' General construction of a boundary function ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              (' Example on computing with finite element-based a boundary function ',
               2,
               None,
               '___sec140'),
              (' Computations in physical coordinates ',
               3,
               None,
               '___sec141'),
              (' Cellwise computations on the reference element ',
               3,
               None,
               '___sec142'),
              (' Modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (' Computations in the physical system ', 3, None, '___sec144'),
              (' Symmetric modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (' Modification of the element matrix and vector ',
               2,
               None,
               '___sec146'),
              (' Boundary conditions: specified derivative ',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              (' The variational formulation ', 2, None, '___sec148'),
              (' Boundary term vanishes because of the test functions ',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              (' Boundary term vanishes because of linear system modifications ',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              (' Direct computation of the global linear system ',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              (' Cellwise computations ', 2, None, '___sec152'),
              (' Implementation ',
               1,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              (' Global basis functions ', 2, None, '___sec154'),
              (' Example: constant right-hand side ', 2, None, '___sec155'),
              (' Finite elements ', 2, None, '___sec156'),
              (' Variational formulations in 2D and 3D ',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              (' Transformation to a reference cell in 2D and 3D ',
               2,
               None,
               '___sec158'),
              (' Numerical integration ', 2, None, '___sec159'),
              (' Convenient formulas for P1 elements in 2D ',
               2,
               None,
               '___sec160'),
              (' Summary ', 1, None, '___sec161'),
              (' Time-dependent problems ',
               1,
               'fem:deq:timedep',
               'fem:deq:timedep'),
              (' Discretization in time by a Forward Euler scheme ',
               2,
               'fem:deq:diffu:FE',
               'fem:deq:diffu:FE'),
              (' Time discretization ', 3, None, '___sec164'),
              (' Space discretization ', 3, None, '___sec165'),
              (' Variational forms ', 2, None, '___sec166'),
              (' Simplified notation for the solution at recent time levels ',
               2,
               None,
               '___sec167'),
              (' Deriving the linear systems ', 2, None, '___sec168'),
              (' Computational algorithm ', 2, None, '___sec169'),
              (' Comparing P1 elements with the finite difference method ',
               2,
               'fem:deq:diffu:FE:fdvsP1fe',
               'fem:deq:diffu:FE:fdvsP1fe'),
              (' Lumping the mass matrix ', 3, None, '___sec171'),
              (' Discretization in time by a Backward Euler scheme ',
               2,
               'fem:deq:diffu:BE',
               'fem:deq:diffu:BE'),
              (' Time discretization ', 3, None, '___sec173'),
              (' Variational forms ', 3, None, '___sec174'),
              (' Linear systems ', 3, None, '___sec175'),
              (' Dirichlet boundary conditions ',
               2,
               'fem:deq:diffu:Dirichlet',
               'fem:deq:diffu:Dirichlet'),
              (' Boundary function ', 3, None, '___sec177'),
              (' Finite element basis functions ', 3, None, '___sec178'),
              (' Modification of the linear system ', 3, None, '___sec179'),
              (' Example: Oscillating Dirichlet boundary condition ',
               2,
               'fem:deq:diffu:Dirichlet:ex',
               'fem:deq:diffu:Dirichlet:ex'),
              (' Analysis of the discrete equations ',
               2,
               'fem:deq:diffu:anal',
               'fem:deq:diffu:anal'),
              (' Forward Euler discretization ', 3, None, '___sec182'),
              (' Backward Euler discretization ', 3, None, '___sec183'),
              (' Comparing amplification factors ', 3, None, '___sec184'),
              (' Systems of differential equations ',
               1,
               'fem:sys',
               'fem:sys'),
              (' Variational forms ', 2, 'fem:sys:vform', 'fem:sys:vform'),
              (' A worked example ', 2, 'fem:sys:uT:ex', 'fem:sys:uT:ex'),
              (' Identical function spaces for the unknowns ',
               2,
               None,
               '___sec188'),
              (' Variational form of each individual PDE ',
               3,
               None,
               '___sec189'),
              (' Compound scalar variational form ', 3, None, '___sec190'),
              (' Decoupled linear systems ', 3, None, '___sec191'),
              (' Coupled linear systems ', 3, None, '___sec192'),
              (' Different function spaces for the unknowns ',
               2,
               None,
               '___sec193'),
              (' Computations in 1D ', 2, None, '___sec194'),
              (' Exercises ', 1, None, '___sec195'),
              (' Exercise 23: Refactor functions into a more general class ',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              (' Exercise 24: Compute the deflection of a cable with sine functions ',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              (' Exercise 25: Check integration by parts ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 26: Compute the deflection of a cable with 2 P1 elements ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 27: Compute the deflection of a cable with 1 P2 element ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 28: Compute the deflection of a cable with a step load ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 29: Show equivalence between linear systems ',
               2,
               'fem:deq:exer:Aub:essbc:equiv',
               'fem:deq:exer:Aub:essbc:equiv'),
              (' Exercise 30: Compute with a non-uniform mesh ',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              (' Problem 31: Solve a 1D finite element problem by hand ',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              (' Exercise 32: Compare finite elements and differences for a radially symmetric Poisson equation ',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              (' Exercise 33: Compute with variable coefficients and P1 elements by hand ',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              (' Exercise 34: Solve a 2D Poisson equation using polynomials and sines ',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              (' Exercise 35: Analyze a Crank-Nicolson scheme for the diffusion equation ',
               2,
               'fem:deq:exer:diffu:analysis:CN',
               'fem:deq:exer:diffu:analysis:CN'),
              (' Bibliography ', 1, None, '___sec209')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0014"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_fem-solarized013.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_fem-solarized015.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1>Computing with finite elements <a name="fem:deq:1D:fem1"></a></h1>

The purpose of this section is to demonstrate in detail how
the finite element method can the be applied to the model problem

$$ -u''(x) = 2,\quad x\in (0,L),\ u(0)=u(L)=0,$$

with variational formulation

$$ (u',v') = (2,v)\quad\forall v\in V\tp  $$

The variational formulation is derived in
the section <a href="._main_fem-solarized012.html#fem:deq:1D:varform">Integration by parts</a>.

<h2>Finite element mesh and basis functions  <a name="___sec129"></a></h2>

We introduce a finite element mesh with \( N_e \) cells, all
with length \( h \), and number
the cells from left to right.
global nodes. Choosing P1 elements, there are two
nodes per cell, and the coordinates of the nodes become

$$
\begin{equation*}
\xno{i} = i h,\quad h=L/N_e,\quad i=0,\ldots,N_n=N_e+1,
\end{equation*}
$$

provided we number the nodes from left to right.

<p>
Each of the nodes, \( i \), is associated a finite element basis function
\( \basphi_i(x) \).  When approximating a given function \( f \) by a finite
element function \( u \), we expand \( u \) using finite element basis
functions associated with <em>all</em> nodes in the mesh, i.e., \( N=N_n \).
However, when solving differential equations we will often have
\( N<N_n \) because of Dirichlet boundary conditions. Why this is the case
will now be explained in detail.

<p>
In our case with homogeneous Dirichlet boundary conditions we do not
need any boundary function \( B(x) \) and can work with the expansion

$$
\begin{equation}
u(x) = \sum_{j\in\If} c_j\baspsi_j(x)\tp
\tag{72}
\end{equation}
$$

Because of the boundary conditions, we must demand
\( \baspsi_i(0)=\baspsi_i(L)=0 \), \( i\in\If \). When \( \baspsi_i \),
\( i=0,\ldots,N \), is to be selected among the finite element basis
functions \( \basphi_j \), \( i=0,\ldots,N_n \), we have to avoid using
\( \basphi_j \) functions that do not vanish at \( \xno{0}=0 \) and
\( \xno{N_n}=L \). However, all \( \basphi_j \) vanish at these two nodes for
\( j=1,\ldots,N_n \).  Only basis functions associated with the end nodes,
\( \basphi_0 \) and \( \basphi_{N_n} \), violate the boundary conditions of
our differential equation. Therefore, we select the basis functions
\( \basphi_i \) to be the set of finite element basis functions associated
with all the interior nodes in the mesh:

$$ \baspsi_i=\basphi_{i+1},\quad i=0,\ldots,N\tp$$

Here, \( N=N_n-2 \).

<p>
In the general case, the nodes are not necessarily numbered from left
to right, so we introduce a mapping from the node numbering, or more
precisely the degree of freedom numbering, to the numbering of
the unknowns in the final equation system. These unknowns take on
the numbers \( 0,\ldots,N \). Unknown number \( j \) in the linear system
corresponds to degree of freedom number \( \nu (j) \), \( j\in\If \).
We can then write

$$ \baspsi_i=\basphi_{\nu(i)},\quad i=0,\ldots,N\tp$$

With a regular numbering as in the present example,
\( \nu(j) = j+1 \), \( j=1,\ldots,N=N_n-2 \).

<h2>Computation in the global physical domain <a name="fem:deq:1D:comp:global"></a></h2>

We shall first perform a computation in the \( x \)
coordinate system because the integrals can be easily computed
here by simple, visual,
geometric considerations. This is called a global approach
since we work in the \( x \) coordinate system and compute integrals on
the global domain \( [0,L] \).

<p>
The entries in the coefficient matrix and right-hand side are

$$
\begin{equation*}
A_{i,j}=\int_0^L\baspsi_i'(x)\baspsi_j'(x) \dx,\quad
b_i=\int_0^L2\baspsi_i(x) \dx, \quad i,j\in\If\tp
\end{equation*}
$$

Expressed in terms of finite element basis functions \( \basphi_i \) we
get the alternative expressions

$$
\begin{equation*}
A_{i,j}=\int_0^L\basphi_{i+1}'(x)\basphi_{j+1}'(x) \dx,\quad
b_i=\int_0^L2\basphi_{i+1}(x) \dx,\quad i,j\in\If\tp
\end{equation*}
$$

For the following calculations the subscripts on the finite
element basis functions are more conveniently written as
\( i \) and \( j \) instead of \( i+1 \) and \( j+1 \), so our notation becomes

$$
\begin{equation*}
A_{i-1,j-1}=\int_0^L\basphi_{i}'(x)\basphi_{j}'(x) \dx,\quad
b_{i-1}=\int_0^L2\basphi_{i}(x) \dx,
\end{equation*}
$$

where the \( i \) and \( j \) indices run as \( i,j=1,\ldots,N_n-1=N+1 \).

<p>
The \( \basphi_i(x) \) function is a hat function with peak at \( x=\xno{i} \)
and a linear variation in \( [\xno{i-1},\xno{i}] \) and
\( [\xno{i},\xno{i+1}] \).
The derivative is \( 1/h \) to the left of \( \xno{i} \) and \( -1/h \) to
the right, or more formally,

$$
\begin{equation}
\basphi_i'(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\ 
h^{-1},
& \xno{i-1} \leq x < \xno{i},\\ 
-h^{-1},
& \xno{i} \leq x < \xno{i+1},\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
\tag{73}
\end{equation}
$$

Figure <a href="#fem:approx:fe:fig:dP1">47</a> shows \( \basphi_1'(x) \) and \( \basphi_2'(x) \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 47:  Illustration of the derivative of piecewise linear basis functions associated with nodes in cell 2.  <a name="fem:approx:fe:fig:dP1"></a> </p></center>
<p><img src="fig-fem/fe_mesh1D_dphi_2_3.png" align="bottom" width=400></p>
</center>

<p>
<!-- FIGURE: [fig-fem/phi/mpl_fe_dbasis_p1_4e_lab, width=600]  Illustration of the derivative of piecewise linear basis functions associated with nodes in cell 1.  <a name="fem:approx:fe:fig:dP1"></a> -->

<p>
We realize that \( \basphi_i' \) and \( \basphi_j' \) has no overlap, and hence their
product vanishes, unless \( i \) and \( j \) are nodes belonging to the same
cell. The only nonzero contributions to the coefficient matrix are
therefore

$$
\begin{align*}
A_{i-1,i-2} &=\int_0^L\basphi_i'(x) \basphi_{i-1}'(x) \dx,\\ 
A_{i-1,i-1}&=\int_0^L\basphi_{i}'(x)^2 \dx, \\ 
A_{i-1,i}&=\int_0^L\basphi_{i}'(x)\basphi_{i+1}'(x) \dx,
\end{align*}
$$

for \( i=1,\ldots,N_n-1 \), but for \( i=1 \), \( A_{i-1,i-2} \) is not defined,
and for \( i=N_n-1 \), \( A_{i-1,i} \) is not defined.

<p>
We see that \( \basphi_{i-1}'(x) \) and \( \basphi_i'(x) \) have overlap of one
cell \( \Omega^{(i-1)}=[\xno{i-1},\xno{i}] \) and that their product
then is \( -1/h^{2} \). The integrand is constant and therefore
\( A_{i-1,i-2}=-h^{-2}h=-h^{-1} \).
A similar reasoning can be applied to
\( A_{i-1,i} \), which also becomes \( -h^{-1} \). The integral of
\( \basphi_i'(x)^2 \) gets contributions from two cells,
\( \Omega^{(i-1)}=[\xno{i-1},\xno{i}] \) and
\( \Omega^{(i)}=[\xno{i},\xno{i+1}] \), but \( \basphi_i'(x)^2=h^{-2} \) in
both cells, and the length of the integration interval is \( 2h \) so
we get
\( A_{i-1,i-1}=2h^{-1} \).

<p>
The right-hand side involves an integral of \( 2\basphi_i(x) \),
\( i=1,\ldots,N_n-1 \),
which is just the area under a hat function of height 1 and width
\( 2h \), i.e., equal to \( h \). Hence, \( b_{i-1}=2h \).

<p>
To summarize the linear system, we switch from \( i \) to \( i+1 \) such that
we can write

$$ A_{i,i-1}=A_{i,i-1}=-h^{-1},\quad A_{i,i}=2h^{-1},\quad
b_i = 2h\tp$$


<p>
The equation system to be solved only involves the unknowns
\( c_i \) for \( i\in\If \). With our numbering of unknowns and
nodes, we have that \( c_i \) equals \( u(\xno{i+1}) \).
The complete matrix system that takes the following form:

$$
\begin{equation}
\frac{1}{h}\left(
\begin{array}{ccccccccc}
2 & -1 & 0
&\cdots &
\cdots & \cdots & \cdots &
\cdots & 0 \\ 
-1 & 2 & -1 & \ddots &   & &  & &  \vdots \\ 
0 & -1 & 2 & -1 &
\ddots & &  &  & \vdots \\ 
\vdots & \ddots &  & \ddots & \ddots & 0 &  & & \vdots \\ 
\vdots &  & \ddots & \ddots & \ddots & \ddots & \ddots & & \vdots \\ 
\vdots & &  & 0 & -1 & 2 & -1 & \ddots & \vdots \\ 
\vdots & & &  & \ddots & \ddots & \ddots &\ddots  & 0 \\ 
\vdots & & & &  &\ddots  & \ddots &\ddots  & -1 \\ 
0 &\cdots & \cdots &\cdots & \cdots & \cdots  & 0 & -1 & 2
\end{array}
\right)
\left(
\begin{array}{c}
c_0 \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
c_{N}
\end{array}
\right)
=
\left(
\begin{array}{c}
2h \\ 
\vdots\\ 
\vdots\\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots \\ 
\vdots\\ 
2h
\end{array}
\right)
\tag{74}
\end{equation}
$$

<h2>Comparison with a finite difference discretization  <a name="___sec131"></a></h2>

A typical row in the matrix system can be written as

$$
\begin{equation}
-\frac{1}{h}c_{i-1} + \frac{2}{h}c_{i} - \frac{1}{h}c_{i+1} = 2h\tp
\tag{75}
\end{equation}
$$

Let us introduce the notation \( u_j \) for the value of \( u \) at node \( j \):
\( u_j=u(\xno{j}) \) since we have the interpretation
\( u(\xno{j})=\sum_jc_j\basphi(\xno{j})=\sum_j c_j\delta_{ij}=c_j \).
The unknowns \( c_0,\ldots,c_N \) are \( u_1,\ldots,u_{N_n} \).
Shifting \( i \) with \( i+1 \) in <a href="#mjx-eqn-75">(75)</a> and inserting
\( u_i = c_{i-1} \), we get

$$
\begin{equation}
-\frac{1}{h}u_{i-1} + \frac{2}{h}u_{i} - \frac{1}{h}u_{i+1} = 2h,
\tag{76}
\end{equation}
$$


<p>
A finite difference discretization of \( -u''(x)=2 \) by a centered,
second-order finite difference approximation \( u''(x_i)\approx [D_x D_x u]_i \)
with \( \Delta x = h \)
yields

$$
\begin{equation}
-\frac{u_{i-1} - 2u_{i} + u_{i+1}}{h^2} = 2,
\end{equation}
$$

which is, in fact, equivalent to <a href="#mjx-eqn-76">(76)</a> if
<a href="#mjx-eqn-76">(76)</a> is divided by \( h \).
Therefore, the finite difference and the finite element method are
equivalent in this simple test problem.

<p>
Sometimes a finite element method generates the finite difference
equations on a uniform mesh, and sometimes the finite element method
generates equations that are different.  The differences are modest,
but may influence the numerical quality of the solution significantly,
especially in time-dependent problems.
<!-- There will be many examples illustrating this point. -->

<h2>Cellwise computations <a name="fem:deq:1D:comp:elmwise"></a></h2>

We now employ the cell by cell computational procedure where
an element matrix and vector are calculated for each cell and
assembled in the global linear system.
<!-- the sections <a href="._main_fem-solarized004.html#fem:approx:fe:elementwise">Assembly of elementwise computations</a>, <a href="._main_fem-solarized004.html#fem:approx:fe:mapping">Mapping to a reference element</a>, -->
<!-- and <a href="._main_fem-solarized004.html#fem:approx:fe:intg:ref">Example: Integration over a reference element</a>. -->
All integrals are mapped to the local reference coordinate system
\( X\in [-1,1] \).
<!-- according to the section <a href="._main_fem-solarized004.html#fem:approx:fe:mapping">Mapping to a reference element</a>. -->
In the present case, the matrix entries contain derivatives
with respect to \( x \),

$$
\begin{equation*}
A_{i-1,j-1}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) \dx
= \int_{-1}^1 \frac{d}{dx}\refphi_r(X)\frac{d}{dx}\refphi_s(X)
\frac{h}{2} \dX,
\end{equation*}
$$

where the global degree of freedom \( i \) is related to the local
degree of freedom \( r \) through \( i=q(e,r) \). Similarly,
\( j=q(e,s) \). The local degrees of freedom run as \( r,s=0,1 \) for a P1
element.

<h3>The integral for the element matrix  <a name="___sec133"></a></h3>

There are simple formulas for the basis functions \( \refphi_r(X) \) as
functions of \( X \).
However, we now
need to find the derivative of \( \refphi_r(X) \) with respect to \( x \).
Given

$$ \refphi_0(X)=\half(1-X),\quad\refphi_1(X)=\half(1+X), $$

we can easily compute \( d\refphi_r/ dX \):

$$
\frac{d\refphi_0}{dX} = -\half,\quad  \frac{d\refphi_1}{dX} = \half\tp
$$

From the chain rule,

$$
\begin{equation}
\frac{d\refphi_r}{dx} = \frac{d\refphi_r}{dX}\frac{dX}{dx}
= \frac{2}{h}\frac{d\refphi_r}{dX}\tp  \end{equation}
$$

The transformed integral is then

$$
\begin{equation*}
A_{i-1,j-1}^{(e)}=\int_{\Omega^{(e)}} \basphi_i'(x)\basphi_j'(x) \dx
= \int_{-1}^1 \frac{2}{h}\frac{d\refphi_r}{dX}\frac{2}{h}\frac{d\refphi_s}{dX}
\frac{h}{2} \dX
\tp
\end{equation*}
$$

<h3>The integral for the element vector  <a name="___sec134"></a></h3>

The right-hand side is transformed according to

$$
\begin{equation*}
b_{i-1}^{(e)} = \int_{\Omega^{(e)}} 2\basphi_i(x) \dx =
\int_{-1}^12\refphi_r(X)\frac{h}{2} \dX,\quad i=q(e,r),\ r=0,1
\tp
\end{equation*}
$$

<h3>Detailed calculations of the element matrix and vector  <a name="___sec135"></a></h3>

Specifically for P1 elements we arrive at the following calculations for
the element matrix entries:

$$
\begin{align*}
\tilde A_{0,0}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(-\half\right)
\frac{2}{h}\left(-\half\right)\frac{2}{h} \dX = \frac{1}{h}\\ 
\tilde A_{0,1}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(-\half\right)
\frac{2}{h}\left(\half\right)\frac{2}{h} \dX = -\frac{1}{h}\\ 
\tilde A_{1,0}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(\half\right)
\frac{2}{h}\left(-\half\right)\frac{2}{h} \dX = -\frac{1}{h}\\ 
\tilde A_{1,1}^{(e)} &= \int_{-1}^1\frac{2}{h}\left(\half\right)
\frac{2}{h}\left(\half\right)\frac{2}{h} \dX = \frac{1}{h}
\end{align*}
$$

The element vector entries become
$$
\begin{align*}
\tilde b_0^{(e)} &= \int_{-1}^12\half(1-X)\frac{h}{2} \dX = h\\ 
\tilde b_1^{(e)} &= \int_{-1}^12\half(1+X)\frac{h}{2} \dX = h\tp
\end{align*}
$$

Expressing these entries in matrix and vector notation, we have

$$
\begin{equation}
\tilde A^{(e)} =\frac{1}{h}\left(\begin{array}{rr}
1 & -1\\ 
-1 & 1
\end{array}\right),\quad
\tilde b^{(e)} = h\left(\begin{array}{c}
1\\ 
1
\end{array}\right)\tp
\tag{77}
\end{equation}
$$

<h3>Contributions from the first and last cell  <a name="___sec136"></a></h3>

The first and last cell involve only one unknown and one basis function
because of the Dirichlet boundary conditions at the first and last
node.
The element matrix therefore becomes a \( 1\times 1 \) matrix and there
is only one entry in the element vector. On cell 0, only \( \baspsi_0=\basphi_1 \)
is involved, corresponding to integration with \( \refphi_1 \). On cell \( N_e \),
only \( \baspsi_N=\basphi_{N_n-1} \) is involved, corresponding to
integration with \( \refphi_0 \).
We then get the special end-cell contributions

$$
\begin{equation}
\tilde A^{(e)} =\frac{1}{h}\left(\begin{array}{r}
1
\end{array}\right),\quad
\tilde b^{(e)} = h\left(\begin{array}{c}
1
\end{array}\right),
\tag{93}
\end{equation}
$$

for \( e=0 \) and \( e=N_e \). In these cells, we have only one degree of
freedom, not two as in the interior cells.

<h3>Assembly  <a name="___sec137"></a></h3>

The next step is to assemble the contributions from the various cells.
The assembly of an element matrix and vector into the global matrix
and right-hand side can be expressed as

$$
A_{q(e,r),q(e,s)} = A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
b_{q(e,r)} = b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
$$

for \( r \) and \( s \) running over all local degrees of freedom in cell \( e \).

<p>
To make the assembly algorithm more precise, it is convenient to set up
Python data structures and a code snippet for carrying out all details
of the algorithm.
For a mesh of four equal-sized P1 elements and \( L=2 \) we have

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">vertices = [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">1.5</span>, <span style="color: #B452CD">2</span>]
cells = [[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">2</span>, <span style="color: #B452CD">3</span>], [<span style="color: #B452CD">3</span>, <span style="color: #B452CD">4</span>]]
dof_map = [[<span style="color: #B452CD">0</span>], [<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">2</span>], [<span style="color: #B452CD">2</span>]]
</pre></div>
<p>
The total number of degrees of freedom is 3, being the function
values at the internal 3 nodes where \( u \) is unknown.
In cell 0 we have global degree of freedom 0, the next
cell has \( u \) unknown at its two nodes, which become
global degrees of freedom 0 and 1, and so forth according to
the <code>dof_map</code> list. The mathematical \( q(e,r) \) quantity is nothing
but the <code>dof_map</code> list.

<p>
Assume all element matrices are stored in a list <code>Ae</code> such that
<code>Ae[e][i,j]</code> is \( \tilde A_{i,j}^{(e)} \). A corresponding list
for the element vectors is named <code>be</code>, where <code>be[e][r]</code> is
\( \tilde b_r^{(e)} \).
A Python code snippet
illustrates all details of the assembly algorithm:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># A[i,j]: coefficient matrix, b[i]: right-hand side</span>
<span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(Ae)):
    <span style="color: #8B008B; font-weight: bold">for</span> r <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Ae[e].shape[<span style="color: #B452CD">0</span>]):
        <span style="color: #8B008B; font-weight: bold">for</span> s <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Ae[e].shape[<span style="color: #B452CD">1</span>]):
            A[dof_map[e,r],dof_map[e,s]] += Ae[e][i,j]
        b[dof_map[e,r]] += be[e][i,j]
</pre></div>
<p>
The general case with <code>N_e</code> P1 elements of length <code>h</code> has

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">N_n = N_e + <span style="color: #B452CD">1</span>
vertices = [i*h <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N_n)]
cells = [[e, e+<span style="color: #B452CD">1</span>] <span style="color: #8B008B; font-weight: bold">for</span> e <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(N_e)]
dof_map = [[<span style="color: #B452CD">0</span>]] + [[e-<span style="color: #B452CD">1</span>, e] <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, N_e)] + [[N_n-<span style="color: #B452CD">2</span>]]
</pre></div>
<p>
Carrying out the assembly results in a linear system that is identical
to <a href="#mjx-eqn-74">(74)</a>, which is not surprising since
the procedures is mathematically equivalent to the calculations
in the physical domain.

<p>
A fundamental problem with the matrix system we have assembled is that
the boundary conditions are not incorporated if \( u(0) \) or \( u(L) \)
are different from zero. The next sections deals with this issue.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_fem-solarized013.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_fem-solarized015.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

