<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Introduction to finite element methods">
<meta name="keywords" content="approximation of vectors in the plane,least squreas method vectors,Galerkin method vectors,projection vectors,approximation of general vectors,Galerkin method vectors,projection vectors,approximation of functions,Galerkin method functions,projection functions,approximation by sines,collocation method (approximation),approximation collocation,interpolation,approximation interpolation,Lagrange (interpolating) polynomial,Kronecker delta,Runge's phenomenon,Chebyshev nodes,finite element mesh,mesh finite elements,Kronecker delta,chapeau function,hat function,finite element basis function,linear elements,quadratic elements,P1 element,P2 element,element matrix,assembly,affine mapping,mapping of reference cells affine mapping,sparse matrices,mass matrix,mass lumping,lumped mass matrix,cell,vertex,degree of freedom,reference cell,finite element, definition,dof map,finite element expansion reference element,Hermite polynomials,numerical integration Midpoint rule,numerical integration Trapezoidal rule,numerical integration Simpson's rule,numerical integration Newton-Cotes formulas,Midpoint rule,Trapezoidal rule,Simpson's rule,Newton-Cotes rules,Gauss-Legendre quadrature,tensor product,simplex elements,simplices,faces,edges,affine mapping,isoparametric mapping,mapping of reference cells isoparametric mapping,residual,variational formulation,trial function,test function,trial space,test space,integration by parts,weak form,strong form,natural boundary condition,essential boundary condition,mass matrix,stiffness matrix,mass matrix,mass lumping,lumped mass matrix,mixed finite elements">

<title>Introduction to finite element methods</title>

<!-- Bootstrap style: bootstrap_FlatUI -->
<link href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<link href="https://raw.github.com/hplgit/doconce/master/bundled/html_styles/style_bootstrap/css/bootstrap_FlatUI.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Approximation of vectors ',
               1,
               'fem:approx:vec',
               'fem:approx:vec'),
              (' Approximation of planar vectors ',
               2,
               'fem:approx:vec:plane',
               'fem:approx:vec:plane'),
              (' The least squares method ', 3, None, '___sec2'),
              (' The projection method ', 3, None, '___sec3'),
              (' Approximation of general vectors ',
               2,
               'fem:approx:vec:Np1dim',
               'fem:approx:vec:Np1dim'),
              (' The least squares method ', 3, None, '___sec5'),
              (' The Galerkin or projection method ', 3, None, '___sec6'),
              (' Approximation of functions ',
               1,
               'fem:approx:global',
               'fem:approx:global'),
              (' The least squares method ',
               2,
               'fem:approx:LS',
               'fem:approx:LS'),
              (' The projection (or Galerkin) method ', 2, None, '___sec9'),
              (' Example: linear approximation ',
               2,
               'fem:approx:global:linear',
               'fem:approx:global:linear'),
              (' Implementation of the least squares method ',
               2,
               'fem:approx:global:LS:code',
               'fem:approx:global:LS:code'),
              (' Symbolic integration ', 3, None, '___sec12'),
              (' Fallback on numerical integration ', 3, None, '___sec13'),
              (' Plotting the approximation ', 3, None, '___sec14'),
              (' Perfect approximation ',
               2,
               'fem:approx:global:exact',
               'fem:approx:global:exact'),
              (' Ill-conditioning ',
               2,
               'fem:approx:global:illconditioning',
               'fem:approx:global:illconditioning'),
              (' Fourier series ',
               2,
               'fem:approx:global:Fourier',
               'fem:approx:global:Fourier'),
              (' Orthogonal basis functions ',
               2,
               'fem:approx:global:orth',
               'fem:approx:global:orth'),
              (' Numerical computations ', 2, None, '___sec19'),
              (' The interpolation (or collocation) method ',
               2,
               'fem:approx:global:interp',
               'fem:approx:global:interp'),
              (' Example ', 3, None, '___sec21'),
              (' Lagrange polynomials ',
               2,
               'fem:approx:global:Lagrange',
               'fem:approx:global:Lagrange'),
              (' Approximation of a polynomial ', 3, None, '___sec23'),
              (' Successful example ', 3, None, '___sec24'),
              (' Less successful example ', 3, None, '___sec25'),
              (' Remedy for strong oscillations ', 3, None, '___sec26'),
              (' Finite element basis functions ',
               1,
               'fem:approx:fe',
               'fem:approx:fe'),
              (' Elements and nodes ',
               2,
               'fem:approx:fe:def:elements:nodes',
               'fem:approx:fe:def:elements:nodes'),
              (' Example ', 3, None, '___sec29'),
              (' The basis functions ', 2, None, '___sec30'),
              (' Construction principles ', 3, None, '___sec31'),
              (' Properties of $\\basphi_i$ ', 3, None, '___sec32'),
              (' Example on piecewise quadratic finite element functions ',
               2,
               None,
               '___sec33'),
              (' Example on piecewise linear finite element functions ',
               2,
               None,
               '___sec34'),
              (' Example on piecewise cubic finite element basis functions ',
               2,
               None,
               '___sec35'),
              (' Calculating the linear system ',
               2,
               'fem:approx:global:linearsystem',
               'fem:approx:global:linearsystem'),
              (' Calculating a specific matrix entry ', 3, None, '___sec37'),
              (' Calculating a general row in the matrix ',
               3,
               None,
               '___sec38'),
              (' Assembly of elementwise computations ',
               2,
               'fem:approx:fe:elementwise',
               'fem:approx:fe:elementwise'),
              (' Mapping to a reference element ',
               2,
               'fem:approx:fe:mapping',
               'fem:approx:fe:mapping'),
              (' Example: Integration over a reference element ',
               2,
               'fem:approx:fe:intg:ref',
               'fem:approx:fe:intg:ref'),
              (' Implementation ',
               1,
               'fem:approx:fe:impl',
               'fem:approx:fe:impl'),
              (' Integration ',
               2,
               'fem:approx:fe:impl:intg',
               'fem:approx:fe:impl:intg'),
              (' Linear system assembly and solution ',
               2,
               'fem:approx:fe:impl:linsys',
               'fem:approx:fe:impl:linsys'),
              (' Example on computing symbolic approximations ',
               2,
               'fem:approx:fe:impl:ex1:symbolic',
               'fem:approx:fe:impl:ex1:symbolic'),
              (' Comparison with finite elements and interpolation/collocation ',
               2,
               'fem:approx:fe:impl:ex1:collocation',
               'fem:approx:fe:impl:ex1:collocation'),
              (' Example on computing numerical approximations ',
               2,
               'fem:approx:fe:impl:ex1:numeric',
               'fem:approx:fe:impl:ex1:numeric'),
              (' The structure of the coefficient matrix ',
               2,
               'fem:approx:fe:A:structure',
               'fem:approx:fe:A:structure'),
              (' Applications ',
               2,
               'fem:approx:fe:impl:ex2',
               'fem:approx:fe:impl:ex2'),
              (' Sparse matrix storage and solution ',
               2,
               'fem:approx:fe:impl:sparse',
               'fem:approx:fe:impl:sparse'),
              (' Comparison of finite element and finite difference approximation ',
               1,
               'fem:approx:fe:fd',
               'fem:approx:fe:fd'),
              (' Finite difference approximation of given functions ',
               2,
               'fem:approx:fe:fd:fdproj',
               'fem:approx:fe:fd:fdproj'),
              (' Finite difference interpretation of a finite element approximation ',
               2,
               'fem:approx:fe:fd:feproj',
               'fem:approx:fe:fd:feproj'),
              (' Making finite elements behave as finite differences ',
               2,
               None,
               '___sec54'),
              (' Computations in physical space ', 3, None, '___sec55'),
              (' Elementwise computations ', 3, None, '___sec56'),
              (' Terminology ', 3, None, '___sec57'),
              (' A generalized element concept ',
               1,
               'fem:approx:fe:element',
               'fem:approx:fe:element'),
              (' Cells, vertices, and degrees of freedom ',
               2,
               'fem:approx:fe:element:terminology',
               'fem:approx:fe:element:terminology'),
              (' Extended finite element concept ',
               2,
               'fem:approx:fe:element:def',
               'fem:approx:fe:element:def'),
              (' Implementation ',
               2,
               'fem:approx:fe:element:impl',
               'fem:approx:fe:element:impl'),
              (' Computing the error of the approximation ',
               2,
               'fem:approx:fe:element:impl:error',
               'fem:approx:fe:element:impl:error'),
              (' Example: Cubic Hermite polynomials ',
               2,
               'fem:approx:fe:element:impl:Hermite',
               'fem:approx:fe:element:impl:Hermite'),
              (' Numerical integration ', 1, None, '___sec64'),
              (' Newton-Cotes rules ',
               2,
               'fem:approx:fe:numint1',
               'fem:approx:fe:numint1'),
              (' Gauss-Legendre rules with optimized points ',
               2,
               None,
               '___sec66'),
              (' Approximation of functions in 2D ',
               1,
               'fem:approx:2D',
               'fem:approx:2D'),
              (' 2D basis functions as tensor products of 1D functions ',
               2,
               'fem:approx:2D:global',
               'fem:approx:2D:global'),
              (' Example: Polynomial basis in 2D ', 2, None, '___sec69'),
              (' Implementation ',
               2,
               'fem:approx:2D:global:code',
               'fem:approx:2D:global:code'),
              (' Extension to 3D ',
               2,
               'fem:approx:3D:global',
               'fem:approx:3D:global'),
              (' Finite elements in 2D and 3D ', 1, None, '___sec72'),
              (' Basis functions over triangles in the physical domain ',
               2,
               None,
               '___sec73'),
              (' Element matrices and vectors ', 3, None, '___sec74'),
              (' Basis functions over triangles in the reference cell ',
               2,
               None,
               '___sec75'),
              (' Affine mapping of the reference cell ', 2, None, '___sec76'),
              (' Isoparametric mapping of the reference cell ',
               2,
               None,
               '___sec77'),
              (' Computing integrals ', 2, None, '___sec78'),
              (' Exercises ', 1, None, '___sec79'),
              (' Exercise 1: Linear algebra refresher I ',
               2,
               'fem:approx:exer:linalg1',
               'fem:approx:exer:linalg1'),
              (' Exercise 2: Linear algebra refresher II ',
               2,
               'fem:approx:exer:linalg2',
               'fem:approx:exer:linalg2'),
              (' Exercise 3: Approximate a three-dimensional vector in a plane ',
               2,
               'fem:approx:exer:vec:3Dby2D',
               'fem:approx:exer:vec:3Dby2D'),
              (' Exercise 4: Approximate the exponential function by power functions ',
               2,
               'fem:approx:exer:exp:powers',
               'fem:approx:exer:exp:powers'),
              (' Exercise 5: Approximate the sine function by power functions ',
               2,
               'fem:approx:exer:sin:powers',
               'fem:approx:exer:sin:powers'),
              (' Exercise 6: Approximate a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine1',
               'fem:approx:exer:tanh:sine1'),
              (' Remarks ', 3, None, '___sec86'),
              (' Exercise 7: Animate the approximation of a steep function by sines ',
               2,
               'fem:approx:exer:tanh:sine2',
               'fem:approx:exer:tanh:sine2'),
              (' Exercise 8: Fourier series as a least squares approximation ',
               2,
               'fem:approx:exer:Fourier',
               'fem:approx:exer:Fourier'),
              (' Exercise 9: Approximate a steep function by Lagrange polynomials ',
               2,
               'fem:approx:exer:tanh',
               'fem:approx:exer:tanh'),
              (' Exercise 10: Define nodes and elements ',
               2,
               'fem:approx:fe:exer:mesh1',
               'fem:approx:fe:exer:mesh1'),
              (' Exercise 11: Define vertices, cells, and dof maps ',
               2,
               'fem:approx:fe:exer:mesh2',
               'fem:approx:fe:exer:mesh2'),
              (' Exercise 12: Construct matrix sparsity patterns ',
               2,
               'fem:approx:fe:exer:defmesh:sparsity',
               'fem:approx:fe:exer:defmesh:sparsity'),
              (' Exercise 13: Perform symbolic finite element computations ',
               2,
               'fem:approx:fe:exer:Asinwt:symbolic',
               'fem:approx:fe:exer:Asinwt:symbolic'),
              (' Exercise 14: Approximate a steep function by P1 and P2 elements ',
               2,
               'fem:approx:exer:tanh',
               'fem:approx:exer:tanh'),
              (' Exercise 15: Approximate a steep function by P3 and P4 elements ',
               2,
               'fem:approx:exer:tanh2',
               'fem:approx:exer:tanh2'),
              (' Exercise 16: Investigate the approximation error in finite elements ',
               2,
               'fem:approx:fe:exer:Asinwt:interpol:error',
               'fem:approx:fe:exer:Asinwt:interpol:error'),
              (' Exercise 17: Approximate a step function by finite elements ',
               2,
               'fem:approx:fe:exer:Heaviside',
               'fem:approx:fe:exer:Heaviside'),
              (' Exercise 18: 2D approximation with orthogonal functions ',
               2,
               'fem:approx:fe:exer:2Dsines:symbolic',
               'fem:approx:fe:exer:2Dsines:symbolic'),
              (' Exercise 19: Use the Trapezoidal rule and P1 elements ',
               2,
               'fem:approx:fe:exer:1D:trapez',
               'fem:approx:fe:exer:1D:trapez'),
              (' Problem 20: Compare P1 elements and interpolation ',
               2,
               'fem:approx:fe:exer:1D:P1:vs:interp',
               'fem:approx:fe:exer:1D:P1:vs:interp'),
              (' Exercise 21: Implement 3D computations with global basis functions ',
               2,
               'fem:approx:fe:exer:3D:approx3D',
               'fem:approx:fe:exer:3D:approx3D'),
              (" Exercise 22: Use Simpson's rule and P2 elements ",
               2,
               'fem:approx:fe:exer:1D:simpson',
               'fem:approx:fe:exer:1D:simpson'),
              (' Basic principles for approximating differential equations ',
               1,
               'fem:deq:1D:principles',
               'fem:deq:1D:principles'),
              (' Differential equation models ',
               2,
               'fem:deq:1D:models',
               'fem:deq:1D:models'),
              (' Simple model problems ',
               2,
               'fem:deq:1D:models:simple',
               'fem:deq:1D:models:simple'),
              (' Forming the residual ',
               2,
               'fem:deq:1D:residual:min',
               'fem:deq:1D:residual:min'),
              (' The least squares method ', 2, None, '___sec107'),
              (' The Galerkin method ', 2, None, '___sec108'),
              (' The Method of Weighted Residuals ', 2, None, '___sec109'),
              (' Test and Trial Functions ', 2, None, '___sec110'),
              (' The collocation method ', 2, None, '___sec111'),
              (' The subdomain collocation method ', 3, None, '___sec112'),
              (' Examples on using the principles ',
               2,
               'fem:deq:1D:ex:sines',
               'fem:deq:1D:ex:sines'),
              (' The model problem ', 3, None, '___sec114'),
              (' Basis functions ', 3, None, '___sec115'),
              (' The residual ', 3, None, '___sec116'),
              (' The least squares method ', 3, None, '___sec117'),
              (' The Galerkin method ', 3, None, '___sec118'),
              (' The collocation method ', 3, None, '___sec119'),
              (' Comparison ', 3, None, '___sec120'),
              (' Integration by parts ',
               2,
               'fem:deq:1D:varform',
               'fem:deq:1D:varform'),
              (' Weak form ', 3, None, '___sec122'),
              (' Boundary function ',
               2,
               'fem:deq:1D:essBC:Bfunc',
               'fem:deq:1D:essBC:Bfunc'),
              (' Abstract notation for variational formulations ',
               2,
               'fem:deq:1D:varform:abstract',
               'fem:deq:1D:varform:abstract'),
              (' Variational problems and optimization of functionals ',
               2,
               'fem:deq:1D:optimization',
               'fem:deq:1D:optimization'),
              (' Examples on variational formulations ',
               1,
               'fem:deq:1D:varform:ex',
               'fem:deq:1D:varform:ex'),
              (' Variable coefficient ', 2, None, '___sec127'),
              (' First-order derivative in the equation and boundary condition ',
               2,
               None,
               '___sec128'),
              (' Nonlinear coefficient ', 2, None, '___sec129'),
              (' Computing with Dirichlet and Neumann conditions ',
               2,
               'fem:deq:1D:varform:ex:DN:case',
               'fem:deq:1D:varform:ex:DN:case'),
              (' When the numerical method is exact ', 2, None, '___sec131'),
              (' Computing with finite elements ',
               1,
               'fem:deq:1D:fem1',
               'fem:deq:1D:fem1'),
              (' Finite element mesh and basis functions ',
               2,
               None,
               '___sec133'),
              (' Computation in the global physical domain ',
               2,
               'fem:deq:1D:comp:global',
               'fem:deq:1D:comp:global'),
              (' Comparison with a finite difference discretization ',
               2,
               None,
               '___sec135'),
              (' Cellwise computations ',
               2,
               'fem:deq:1D:comp:elmwise',
               'fem:deq:1D:comp:elmwise'),
              (' The integral for the element matrix ', 3, None, '___sec137'),
              (' The integral for the element vector ', 3, None, '___sec138'),
              (' Detailed calculations of the element matrix and vector ',
               3,
               None,
               '___sec139'),
              (' Contributions from the first and last cell ',
               3,
               None,
               '___sec140'),
              (' Assembly ', 3, None, '___sec141'),
              (' Boundary conditions: specified nonzero value ',
               1,
               'fem:deq:1D:essBC',
               'fem:deq:1D:essBC'),
              (' General construction of a boundary function ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc',
               'fem:deq:1D:fem:essBC:Bfunc'),
              (' Example on computing with finite element-based a boundary function ',
               2,
               None,
               '___sec144'),
              (' Computations in physical coordinates ',
               3,
               None,
               '___sec145'),
              (' Cellwise computations on the reference element ',
               3,
               None,
               '___sec146'),
              (' Modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys',
               'fem:deq:1D:fem:essBC:Bfunc:modsys'),
              (' Computations in the physical system ', 3, None, '___sec148'),
              (' Symmetric modification of the linear system ',
               2,
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm',
               'fem:deq:1D:fem:essBC:Bfunc:modsys:symm'),
              (' Modification of the element matrix and vector ',
               2,
               None,
               '___sec150'),
              (' Boundary conditions: specified derivative ',
               1,
               'fem:deq:1D:BC:nat',
               'fem:deq:1D:BC:nat'),
              (' The variational formulation ', 2, None, '___sec152'),
              (' Boundary term vanishes because of the test functions ',
               2,
               'fem:deq:1D:BC:nat:uLtest',
               'fem:deq:1D:BC:nat:uLtest'),
              (' Boundary term vanishes because of linear system modifications ',
               2,
               'fem:deq:1D:BC:nat:uLmod',
               'fem:deq:1D:BC:nat:uLmod'),
              (' Direct computation of the global linear system ',
               2,
               'fem:deq:1D:BC:nat:Aub',
               'fem:deq:1D:BC:nat:Aub'),
              (' Cellwise computations ', 2, None, '___sec156'),
              (' Implementation ',
               1,
               'fem:deq:1D:code:global',
               'fem:deq:1D:code:global'),
              (' Global basis functions ', 2, None, '___sec158'),
              (' Example: constant right-hand side ', 2, None, '___sec159'),
              (' Finite elements ', 2, None, '___sec160'),
              (' Variational formulations in 2D and 3D ',
               1,
               'fem:deq:2D:varform',
               'fem:deq:2D:varform'),
              (' Transformation to a reference cell in 2D and 3D ',
               2,
               None,
               '___sec162'),
              (' Numerical integration ', 2, None, '___sec163'),
              (' Convenient formulas for P1 elements in 2D ',
               2,
               None,
               '___sec164'),
              (' Summary ', 1, None, '___sec165'),
              (' Time-dependent problems ',
               1,
               'fem:deq:timedep',
               'fem:deq:timedep'),
              (' Discretization in time by a Forward Euler scheme ',
               2,
               'fem:deq:diffu:FE',
               'fem:deq:diffu:FE'),
              (' Time discretization ', 3, None, '___sec168'),
              (' Space discretization ', 3, None, '___sec169'),
              (' Variational forms ', 2, None, '___sec170'),
              (' Simplified notation for the solution at recent time levels ',
               2,
               None,
               '___sec171'),
              (' Deriving the linear systems ', 2, None, '___sec172'),
              (' Computational algorithm ', 2, None, '___sec173'),
              (' Comparing P1 elements with the finite difference method ',
               2,
               'fem:deq:diffu:FE:fdvsP1fe',
               'fem:deq:diffu:FE:fdvsP1fe'),
              (' Lumping the mass matrix ', 3, None, '___sec175'),
              (' Discretization in time by a Backward Euler scheme ',
               2,
               'fem:deq:diffu:BE',
               'fem:deq:diffu:BE'),
              (' Time discretization ', 3, None, '___sec177'),
              (' Variational forms ', 3, None, '___sec178'),
              (' Linear systems ', 3, None, '___sec179'),
              (' Dirichlet boundary conditions ',
               2,
               'fem:deq:diffu:Dirichlet',
               'fem:deq:diffu:Dirichlet'),
              (' Boundary function ', 3, None, '___sec181'),
              (' Finite element basis functions ', 3, None, '___sec182'),
              (' Modification of the linear system ', 3, None, '___sec183'),
              (' Example: Oscillating Dirichlet boundary condition ',
               2,
               'fem:deq:diffu:Dirichlet:ex',
               'fem:deq:diffu:Dirichlet:ex'),
              (' Analysis of the discrete equations ',
               2,
               'fem:deq:diffu:anal',
               'fem:deq:diffu:anal'),
              (' Forward Euler discretization ', 3, None, '___sec186'),
              (' Backward Euler discretization ', 3, None, '___sec187'),
              (' Comparing amplification factors ', 3, None, '___sec188'),
              (' Systems of differential equations ',
               1,
               'fem:sys',
               'fem:sys'),
              (' Variational forms ', 2, 'fem:sys:vform', 'fem:sys:vform'),
              (' A worked example ', 2, 'fem:sys:uT:ex', 'fem:sys:uT:ex'),
              (' Identical function spaces for the unknowns ',
               2,
               None,
               '___sec192'),
              (' Variational form of each individual PDE ',
               3,
               None,
               '___sec193'),
              (' Compound scalar variational form ', 3, None, '___sec194'),
              (' Decoupled linear systems ', 3, None, '___sec195'),
              (' Coupled linear systems ', 3, None, '___sec196'),
              (' Different function spaces for the unknowns ',
               2,
               None,
               '___sec197'),
              (' Computations in 1D ', 2, None, '___sec198'),
              (' Exercises ', 1, None, '___sec199'),
              (' Exercise 23: Refactor functions into a more general class ',
               2,
               'fem:deq:exer:BVP1D:class',
               'fem:deq:exer:BVP1D:class'),
              (' Exercise 24: Compute the deflection of a cable with sine functions ',
               2,
               'fem:deq:exer:tension:cable',
               'fem:deq:exer:tension:cable'),
              (' Exercise 25: Check integration by parts ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 26: Compute the deflection of a cable with 2 P1 elements ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 27: Compute the deflection of a cable with 1 P2 element ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 28: Compute the deflection of a cable with a step load ',
               2,
               'fem:deq:exer:intg:parts',
               'fem:deq:exer:intg:parts'),
              (' Exercise 29: Show equivalence between linear systems ',
               2,
               'fem:deq:exer:Aub:essbc:equiv',
               'fem:deq:exer:Aub:essbc:equiv'),
              (' Exercise 30: Compute with a non-uniform mesh ',
               2,
               'fem:deq:exer:1D:mesh:nonuniform',
               'fem:deq:exer:1D:mesh:nonuniform'),
              (' Problem 31: Solve a 1D finite element problem by hand ',
               2,
               'fem:deq:exer:1D:gen:problem1',
               'fem:deq:exer:1D:gen:problem1'),
              (' Exercise 32: Compare finite elements and differences for a radially symmetric Poisson equation ',
               2,
               'fem:deq:exer:1D:Poisson:polar',
               'fem:deq:exer:1D:Poisson:polar'),
              (' Exercise 33: Compute with variable coefficients and P1 elements by hand ',
               2,
               'fem:deq:exer:1D:gen:problem2',
               'fem:deq:exer:1D:gen:problem2'),
              (' Exercise 34: Solve a 2D Poisson equation using polynomials and sines ',
               2,
               'fem:deq:exer:2D:torsion:xy:sin',
               'fem:deq:exer:2D:torsion:xy:sin'),
              (' Exercise 35: Analyze a Crank-Nicolson scheme for the diffusion equation ',
               2,
               'fem:deq:exer:diffu:analysis:CN',
               'fem:deq:exer:diffu:analysis:CN'),
              (' Bibliography ', 1, None, '___sec213')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Aex}{{A_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\newcommand{\X}{\boldsymbol{X}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\w}{\boldsymbol{w}}
\newcommand{\V}{\boldsymbol{V}}
\newcommand{\e}{\boldsymbol{e}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\If}{\mathcal{I}_s}     % for FEM
\newcommand{\Ifd}{{I_d}}  % for FEM
\newcommand{\Ifb}{{I_b}}  % for FEM
\newcommand{\sequencei}[1]{\left\{ {#1}_i \right\}_{i\in\If}}
\newcommand{\basphi}{\varphi}
\newcommand{\baspsi}{\psi}
\newcommand{\refphi}{\tilde\basphi}
\newcommand{\psib}{\boldsymbol{\psi}}
\newcommand{\sinL}[1]{\sin\left((#1+1)\pi\frac{x}{L}\right)}
\newcommand{\xno}[1]{x_{#1}}
\newcommand{\Xno}[1]{X_{(#1)}}
\newcommand{\yno}[1]{y_{#1}}
\newcommand{\xdno}[1]{\boldsymbol{x}_{#1}}
\newcommand{\dX}{\, \mathrm{d}X}
\newcommand{\dx}{\, \mathrm{d}x}
\newcommand{\ds}{\, \mathrm{d}s}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="main_fem.html">Introduction to finite element methods</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0004"></a>
<!-- !split -->

<h1 id="fem:approx:fe">Finite element basis functions<a name="fem:approx:fe"></a></h1>

The specific basis functions exemplified in the section <a href="._main_fem003.html#fem:approx:global">Approximation of functions</a> are in general nonzero on the entire domain
\( \Omega \), see Figure <a href="#fem:approx:fe:fig:u:sin">13</a> for an example
where we plot \( \psi_0(x)=\sin\half\pi x \) and
\( \psi_1(x)=\sin 2\pi x \) together with a possible sum
\( u(x)=4\psi_0(x) - \half\psi_1(x) \). We shall
now turn the attention to basis functions that have <em>compact support</em>,
meaning that they are nonzero on only a small portion of
\( \Omega \). Moreover, we shall restrict the functions to be <em>piecewise
polynomials</em>. This means that the domain is split into subdomains and
the function is a polynomial on one or more subdomains, see Figure
<a href="#fem:approx:fe:fig:u:fe">14</a> for a sketch involving locally defined
hat functions that make \( u=\sum_jc_j\baspsi_j \) piecewise linear. At
the boundaries between subdomains one normally forces continuity of
the function only so that when connecting two polynomials from two
subdomains, the derivative becomes discontinuous. These type
of basis functions are fundamental in the finite element method.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 13:  A function resulting from adding two sine basis functions. <a name="fem:approx:fe:fig:u:sin"></a> </p></center>
<p><img src="fig-fem/u_example_sin.png" align="bottom" width=600></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 14:  A function resulting from adding three local piecewise linear (hat) functions. <a name="fem:approx:fe:fig:u:fe"></a> </p></center>
<p><img src="fig-fem/u_example_P1.png" align="bottom" width=600></p>
</center>

<p>
We first introduce the concepts of elements and nodes in a simplistic fashion
as often met in the literature. Later, we shall generalize the concept
of an element, which is a necessary step to treat a wider class of
approximations within the family of finite element methods.
The generalization is also compatible with
the concepts used in the <a href="http://fenicsproject.org" target="_self">FEniCS</a> finite
element software.

<h2 id="fem:approx:fe:def:elements:nodes">Elements and nodes<a name="fem:approx:fe:def:elements:nodes"></a></h2>

Let us divide the interval \( \Omega \) on which \( f \) and \( u \) are defined
into non-overlapping subintervals \( \Omega^{(e)} \), \( e=0,\ldots,N_e \):

$$
\begin{equation}
\Omega = \Omega^{(0)}\cup \cdots \cup \Omega^{(N_e)}\tp  \end{equation}
$$

We shall for now
refer to \( \Omega^{(e)} \) as an <em>element</em>, having number \( e \).
On each element we introduce a set of points called <em>nodes</em>.
For now we assume that the nodes are uniformly spaced throughout the
element and that the boundary points of the elements are also nodes.
The nodes are given numbers both within an element and in the global
domain. These are
referred to as <em>local</em> and <em>global</em> node numbers, respectively.
Figure <a href="#fem:approx:fe:def:elements:nodes:fig:P1">15</a> shows
element boundaries with small vertical lines, nodes as small disks,
element numbers in circles, and global node numbers under the nodes.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 15:  Finite element mesh with 5 elements and 6 nodes. <a name="fem:approx:fe:def:elements:nodes:fig:P1"></a> </p></center>
<p><img src="fig-fem/fe_mesh1D.png" align="bottom" width=500></p>
</center>

<p>
Nodes and elements uniquely define a <em>finite element mesh</em>, which is our
discrete representation of the domain in the computations.
A common special case is that of a <em>uniformly partitioned mesh</em> where
each element has the same length and the distance between nodes is constant.

<h3 id="___sec29">Example <a name="___sec29"></a></h3>

On \( \Omega =[0,1] \) we may introduce two elements,
\( \Omega^{(0)}=[0,0.4] \) and \( \Omega^{(1)}=[0.4,1] \). Furthermore,
let us introduce three nodes
per element, equally spaced within each element.
Figure <a href="#fem:approx:fe:def:elements:nodes:fig:P2">16</a> shows the
mesh.
The three nodes in element number 0 are \( x_0=0 \), \( x_1=0.2 \), and \( x_2=0.4 \).
The local and global node numbers are here equal.
In element number 1, we have the local nodes \( x_0=0.4 \), \( x_1=0.7 \), and \( x_2=1 \)
and the corresponding
global nodes \( x_2=0.4 \), \( x_3=0.7 \), and \( x_4=1 \). Note that
the global node \( x_2=0.4 \) is shared by the two elements.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 16:  Finite element mesh with 2 elements and 5 nodes. <a name="fem:approx:fe:def:elements:nodes:fig:P2"></a> </p></center>
<p><img src="fig-fem/fe_mesh1D_P2.png" align="bottom" width=500></p>
</center>

<p>
For the purpose of implementation, we introduce two lists or arrays:
<code>nodes</code> for storing the coordinates of the nodes, with the
global node numbers as indices, and <code>elements</code> for holding
the global node numbers in each element, with the local node numbers
as indices. The <code>nodes</code> and <code>elements</code> lists for the sample mesh
above take the form

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.2</span>, <span style="color: #666666">0.4</span>, <span style="color: #666666">0.7</span>, <span style="color: #666666">1</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>]]
</pre></div>
<p>
Looking up the coordinate of local node number 2 in element 1
is here done by <code>nodes[elements[1][2]]</code> (recall that nodes and
elements start their numbering at 0).

<p>
The numbering of elements and nodes does not need to be regular.
Figure <a href="#fem:approx:fe:def:elements:nodes:fig:P1:irregular">17</a> shows
and example corresponding to

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nodes <span style="color: #666666">=</span> [<span style="color: #666666">1.5</span>, <span style="color: #666666">5.5</span>, <span style="color: #666666">4.2</span>, <span style="color: #666666">0.3</span>, <span style="color: #666666">2.2</span>, <span style="color: #666666">3.1</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">2</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>], [<span style="color: #666666">0</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">3</span>, <span style="color: #666666">0</span>], [<span style="color: #666666">5</span>, <span style="color: #666666">2</span>]]
</pre></div>
<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 17:  Example on irregular numbering of elements and nodes. <a name="fem:approx:fe:def:elements:nodes:fig:P1:irregular"></a> </p></center>
<p><img src="fig-fem/fe_mesh1D_random_numbering.png" align="bottom" width=500></p>
</center>

<h2 id="___sec30">The basis functions <a name="___sec30"></a></h2>

<h3 id="___sec31">Construction principles <a name="___sec31"></a></h3>

Finite element basis functions are in this text recognized by
the notation \( \basphi_i(x) \), where the index now in the beginning corresponds to
a global node number. In the current approximation problem we shall
simply take \( \baspsi_i = \basphi_i \).

<p>
Let \( i \) be the global node number corresponding to local node \( r \) in
element number \( e \).  The finite element basis functions \( \basphi_i \)
are now defined as follows.

<ul>
  <li> If local node number \( r \) is not on the boundary of the element,
    take \( \basphi_i(x) \) to be the Lagrange
    polynomial that is 1 at the local node number \( r \) and zero
    at all other nodes in the element. On all other elements, \( \basphi_i=0 \).</li>
  <li> If local node number \( r \) is on the boundary of the element,
    let \( \basphi_i \) be made up of the Lagrange polynomial over element \( e \)
    that is 1 at node \( i \), combined with the Lagrange polynomial over
    element \( e+1 \) that is also 1 at node \( i \).
    On all other elements, \( \basphi_i=0 \).</li>
</ul>

A visual impression of three such basis functions are given in
Figure <a href="#fem:approx:fe:fig:P2">18</a>.

<p>
<!-- Sometimes we refer to a Lagrange polynomial on an element \( e \), which -->
<!-- means the basis function \( \basphi_i(x) \) when \( x\in\Omega^{(e)} \), and -->
<!-- \( \basphi_i(x)=0 \) when \( x\notin\Omega^{(e)} \). -->

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 18:  Illustration of the piecewise quadratic basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P2"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p2_4e_lab.png" align="bottom" width=600></p>
</center>

<h3 id="___sec32">Properties of \( \basphi_i \) <a name="___sec32"></a></h3>

The construction of basis functions according to the principles above
lead to two important properties of \( \basphi_i(x) \). First,

$$
\begin{equation}
\basphi_i(\xno{j}) =\delta_{ij},\quad \delta_{ij} =
\left\lbrace\begin{array}{ll}
1, & i=j,\\ 
0, & i\neq j,
\end{array}\right.
\tag{23}
\end{equation}
$$

when \( \xno{j} \) is a node in the mesh with global node number \( j \).
The
result \( \basphi_i(\xno{j}) =\delta_{ij} \) arises
because the Lagrange polynomials are constructed to have
exactly this property.
The property also implies a convenient interpretation of \( c_i \)
as the value of \( u \) at node \( i \). To show this, we expand \( u \)
in the usual way as \( \sum_jc_j\baspsi_j \) and choose \( \baspsi_i = \basphi_i \):

$$
u(\xno{i}) = \sum_{j\in\If} c_j \baspsi_j (\xno{i}) =
\sum_{j\in\If} c_j \basphi_j (\xno{i}) = c_i \basphi_i (\xno{i}) = c_i
\tp
$$

Because of this interpretation,
the coefficient \( c_i \) is by many named \( u_i \) or \( U_i \).

<p>
<!-- 2DO: switch to U_j? -->

<p>
Second,
\( \basphi_i(x) \) is mostly zero throughout the domain:

<ul>
 <li> \( \basphi_i(x) \neq 0 \) only on those elements that contain global node \( i \),</li>
 <li> \( \basphi_i(x)\basphi_j(x) \neq 0 \) if and only if \( i \) and \( j \) are global node
   numbers in the same element.</li>
</ul>

Since \( A_{i,j} \) is the integral of
\( \basphi_i\basphi_j \) it means that
<em>most of the elements in the coefficient matrix will be zero</em>.
We will come back to these properties and use
them actively in computations to save memory and CPU time.

<p>
We let each element have \( d+1 \) nodes, resulting in local Lagrange
polynomials of degree \( d \). It is not a requirement to have the same
\( d \) value in each element, but for now we will assume so.

<h2 id="___sec33">Example on piecewise quadratic finite element functions <a name="___sec33"></a></h2>

Figure <a href="#fem:approx:fe:fig:P2">18</a> illustrates how piecewise
quadratic basis functions can look like (\( d=2 \)). We work with the
domain \( \Omega = [0,1] \) divided into four equal-sized elements, each having
three nodes.
The <code>nodes</code> and <code>elements</code> lists in this particular example become

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">nodes <span style="color: #666666">=</span> [<span style="color: #666666">0</span>, <span style="color: #666666">0.125</span>, <span style="color: #666666">0.25</span>, <span style="color: #666666">0.375</span>, <span style="color: #666666">0.5</span>, <span style="color: #666666">0.625</span>, <span style="color: #666666">0.75</span>, <span style="color: #666666">0.875</span>, <span style="color: #666666">1.0</span>]
elements <span style="color: #666666">=</span> [[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">2</span>], [<span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>, <span style="color: #666666">6</span>], [<span style="color: #666666">6</span>, <span style="color: #666666">7</span>, <span style="color: #666666">8</span>]]
</pre></div>
<p>
Figure <a href="#fem:approx:fe:fig:P2:mesh">19</a> sketches the mesh and the
numbering.
Nodes are marked with circles on the \( x \) axis and
element boundaries are marked with vertical dashed lines
in Figure <a href="#fem:approx:fe:fig:P2">18</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 19:  Sketch of mesh with 4 elements and 3 nodes per element.  <a name="fem:approx:fe:fig:P2:mesh"></a> </p></center>
<p><img src="fig-fem/fe_mesh1D_P2_4e.png" align="bottom" width=500></p>
</center>

<p>
Let us explain in detail how the basis functions are constructed
according to the principles.
Consider element number 1 in Figure <a href="#fem:approx:fe:fig:P2">18</a>,
\( \Omega^{(1)}=[0.25, 0.5] \), with local nodes
0, 1, and 2 corresponding to global nodes 2, 3, and 4.
The coordinates of these nodes are
\( 0.25 \), \( 0.375 \), and \( 0.5 \), respectively.
We define three Lagrange
polynomials on this element:

<ol>
<li> The polynomial that is 1 at local node 1
   (\( x=0.375 \), global node 3) makes up the basis function
   \( \basphi_3(x) \) over this element,
   with \( \basphi_3(x)=0 \) outside the element.</li>
<li> The Lagrange polynomial that is 1 at local node 0 is the "right
   part" of the global basis function
   \( \basphi_2(x) \). The "left part" of \( \basphi_2(x) \) consists of
   a Lagrange polynomial associated with local node 2 in
   the neighboring element \( \Omega^{(0)}=[0, 0.25] \).</li>
<li> Finally, the polynomial that is 1 at local node 2 (global node 4)
   is the "left part" of the global basis function \( \basphi_4(x) \).
   The "right part" comes from the Lagrange polynomial that is 1 at
   local node 0 in the neighboring element \( \Omega^{(2)}=[0.5, 0.75] \).</li>
</ol>

As mentioned earlier,
any global basis function \( \basphi_i(x) \) is zero on elements that
do not contain the node with global node number \( i \).

<p>
The other global functions associated with internal
nodes, \( \basphi_1 \), \( \basphi_5 \), and \( \basphi_7 \), are all of the
same shape as the drawn \( \basphi_3 \), while the global basis functions
associated with shared nodes also have the same shape, provided the
elements are of the same length.

<p>
<!-- This was difficult to follow: -->
<!-- The basis function \( \basphi_2(x) \), corresponding to a node on the -->
<!-- boundary of element 0 and 1, is made up of two pieces: (i) the Lagrange -->
<!-- polynomial on element 1 that is 1 at local node 0 (global node 2) -->
<!-- and zero at all other nodes in element 1, and (ii) -->
<!-- the Lagrange -->
<!-- polynomial on element 1 that is 1 at local node 2 (global node 2) -->
<!-- and zero at all other nodes in element 0. Outside the elements that -->
<!-- share global node 2, \( \basphi_2(x)=0 \). The same reasoning is applied to -->
<!-- the construction of \( \basphi_4(x) \) and \( \basphi_6(x) \). -->

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 1</b>: Karen suggested we begin with P1 and not P2.)</font>
<!-- end inline comment -->


<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 20:  Illustration of the piecewise linear basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P1"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p1_4e_lab.png" align="bottom" width=600></p>
</center>

<h2 id="___sec34">Example on piecewise linear finite element functions <a name="___sec34"></a></h2>

Figure <a href="#fem:approx:fe:fig:P1">20</a> shows
piecewise linear basis functions (\( d=1 \)). Also here we have four elements on
\( \Omega = [0,1] \). Consider the element \( \Omega^{(1)}=[0.25,0.5] \).
Now there are no internal nodes in the elements so that all basis
functions are associated with nodes at the element boundaries and hence
made up of two Lagrange polynomials from neighboring elements.
For example, \( \basphi_1(x) \) results from the Lagrange polynomial in
element 0 that is 1 at local node 1 and 0 at local node 0, combined with
the Lagrange polynomial in
element 1 that is 1 at local node 0 and 0 at local node 1.
The other basis functions are constructed similarly.

<p>
Explicit mathematical formulas are needed for \( \basphi_i(x) \) in computations.
In the
piecewise linear case, one can show that

$$
\begin{equation}
\basphi_i(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\ 
(x - \xno{i-1})/(\xno{i} - \xno{i-1}),
& \xno{i-1} \leq x < \xno{i},\\ 
1 -
(x - x_{i})/(\xno{i+1} - x_{i}),
& \xno{i} \leq x < \xno{i+1},\\ 
0, & x\geq \xno{i+1}\tp  \end{array}
\right.
\tag{24}
\end{equation}
$$

Here, \( \xno{j} \), \( j=i-1,i,i+1 \), denotes the coordinate of node \( j \).
For elements of equal length \( h \) the formulas can be simplified to

$$
\begin{equation}
\basphi_i(x) = \left\lbrace\begin{array}{ll}
0, & x < \xno{i-1},\\ 
(x - \xno{i-1})/h,
& \xno{i-1} \leq x < \xno{i},\\ 
1 -
(x - x_{i})/h,
& \xno{i} \leq x < \xno{i+1},\\ 
0, & x\geq \xno{i+1}
\end{array}
\right.
\tag{25}
\end{equation}
$$

<h2 id="___sec35">Example on piecewise cubic finite element basis functions <a name="___sec35"></a></h2>

Piecewise cubic basis functions can be defined by introducing four
nodes per element. Figure <a href="#fem:approx:fe:fig:P3">21</a> shows
examples on \( \basphi_i(x) \), \( i=3,4,5,6 \), associated with element number 1.
Note that \( \basphi_4 \) and \( \basphi_5 \) are nonzero on element number 1,
while
\( \basphi_3 \) and \( \basphi_6 \) are made up of Lagrange polynomials on two
neighboring elements.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 21:  Illustration of the piecewise cubic basis functions associated with nodes in element 1.  <a name="fem:approx:fe:fig:P3"></a> </p></center>
<p><img src="fig-fem/phi/mpl_fe_basis_p3_4e.png" align="bottom" width=600,></p>
</center>

<p>
We see that all the piecewise linear basis functions have the same
"hat" shape. They are naturally referred to as <em>hat functions</em>,
also called <em>chapeau functions</em>.
The piecewise quadratic functions in Figure <a href="#fem:approx:fe:fig:P2">18</a>
are seen to be of two types. "Rounded hats" associated with internal
nodes in the elements and some more "sombrero" shaped hats associated
with element boundary nodes. Higher-order basis functions also have
hat-like shapes, but the functions have pronounced oscillations in addition,
as illustrated in Figure <a href="#fem:approx:fe:fig:P3">21</a>.

<p>
A common terminology is to speak about <em>linear elements</em> as
elements with two local nodes associated with
piecewise linear basis functions. Similarly, <em>quadratic elements</em> and
<em>cubic elements</em> refer to piecewise quadratic or cubic functions
over elements with three or four local nodes, respectively.
Alternative names, frequently used later, are P1 elements for linear
elements, P2 for quadratic elements, and so forth: Pd signifies
degree \( d \) of the polynomial basis functions.

<h2 id="fem:approx:global:linearsystem">Calculating the linear system<a name="fem:approx:global:linearsystem"></a></h2>

The elements in the coefficient matrix and right-hand side are given
by the formulas <a href="._main_fem003.html#mjx-eqn-17">(17)</a> and <a href="._main_fem003.html#mjx-eqn-18">(18)</a>, but
now the choice of \( \baspsi_i \) is \( \basphi_i \).
Consider P1 elements where \( \basphi_i(x) \) piecewise linear. Nodes and elements
numbered consecutively from left to right in a uniformly partitioned
mesh imply the nodes

$$ x_i=i h,\quad i=0,\ldots,N,$$

and the elements

$$
\begin{equation}
\Omega^{(i)} = [\xno{i},\xno{i+1}] = [i h, (i+1)h],\quad
i=0,\ldots,N_e=N-1
\tp
\end{equation}
$$

We have in this case \( N \) elements and \( N+1 \) nodes,
and \( \Omega=[\xno{0},\xno{N}] \).
The formula for \( \basphi_i(x) \) is given by
<a href="#mjx-eqn-25">(25)</a> and a graphical illustration is
provided in Figures <a href="#fem:approx:fe:fig:P1">20</a> and
<a href="#fem:approx:fe:fig:phi:i:im1">23</a>. First we clearly see
from the figures the very important property
\( \basphi_i(x)\basphi_j(x)\neq 0 \) if and only if \( j=i-1 \), \( j=i \), or
\( j=i+1 \), or alternatively expressed, if and only if \( i \) and \( j \) are
nodes in the same element. Otherwise, \( \basphi_i \) and \( \basphi_j \) are
too distant to have an overlap and consequently their product vanishes.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 22:  Illustration of the piecewise linear basis functions corresponding to global node 2 and 3.  <a name="fem:approx:fe:fig:phi:2:3"></a> </p></center>
<p><img src="fig-fem/fe_mesh1D_phi_2_3.png" align="bottom" width=500></p>
</center>

<h3 id="___sec37">Calculating a specific matrix entry <a name="___sec37"></a></h3>

Let us calculate the specific matrix entry \( A_{2,3} = \int_\Omega
\basphi_2\basphi_3\dx \). Figure <a href="#fem:approx:fe:fig:phi:2:3">22</a>
shows how \( \basphi_2 \) and \( \basphi_3 \) look like. We realize
from this figure that the product \( \basphi_2\basphi_3\neq 0 \)
only over element 2, which contains node 2 and 3.
The particular formulas for \( \basphi_{2}(x) \) and \( \basphi_3(x) \) on
\( [\xno{2},\xno{3}] \) are found from <a href="#mjx-eqn-25">(25)</a>.
The function
\( \basphi_3 \) has positive slope over \( [\xno{2},\xno{3}] \) and corresponds
to the interval \( [\xno{i-1},\xno{i}] \) in
<a href="#mjx-eqn-25">(25)</a>. With \( i=3 \) we get

$$ \basphi_3(x) = (x-x_2)/h,$$

while \( \basphi_2(x) \) has negative slope over \( [\xno{2},\xno{3}] \)
and corresponds to setting \( i=2 \) in <a href="#mjx-eqn-25">(25)</a>,

$$ \basphi_2(x) = 1- (x-x_2)/h\tp$$

We can now easily integrate,

$$
A_{2,3} = \int_\Omega \basphi_2\basphi_{3}\dx =
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right) \frac{x - x_{2}}{h}
 \dx = \frac{h}{6}\tp
$$


<p>
The diagonal entry in the coefficient matrix becomes

$$ A_{2,2} =
\int_{\xno{1}}^{\xno{2}}
\left(\frac{x - \xno{1}}{h}\right)^2\dx +
\int_{\xno{2}}^{\xno{3}}
\left(1 - \frac{x - \xno{2}}{h}\right)^2\dx
= \frac{2h}{3}\tp
$$

The entry \( A_{2,1} \) has an
the integral that is geometrically similar to the situation in
Figure <a href="#fem:approx:fe:fig:phi:2:3">22</a>, so we get
\( A_{2,1}=h/6 \).

<h3 id="___sec38">Calculating a general row in the matrix <a name="___sec38"></a></h3>

We can now generalize the calculation of matrix entries to
a general row number \( i \). The entry
\( A_{i,i-1}=\int_\Omega\basphi_i\basphi_{i-1}\dx \) involves
hat functions as depicted in
Figure <a href="#fem:approx:fe:fig:phi:i:im1">23</a>. Since the integral
is geometrically identical to the situation with specific nodes
2 and 3, we realize that \( A_{i,i-1}=A_{i,i+1}=h/6 \) and
\( A_{i,i}=2h/3 \). However, we can compute the integral directly
too:

$$
\begin{align*}
A_{i,i-1} &= \int_\Omega \basphi_i\basphi_{i-1}\dx\\ 
&=
\underbrace{\int_{\xno{i-2}}^{\xno{i-1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_i=0} +
\int_{\xno{i-1}}^{\xno{i}} \basphi_i\basphi_{i-1}\dx +
\underbrace{\int_{\xno{i}}^{\xno{i+1}} \basphi_i\basphi_{i-1}\dx}_{\basphi_{i-1}=0}\\ 
&= \int_{\xno{i-1}}^{\xno{i}}
\underbrace{\left(\frac{x - x_{i}}{h}\right)}_{\basphi_i(x)}
\underbrace{\left(1 - \frac{x - \xno{i-1}}{h}\right)}_{\basphi_{i-1}(x)} \dx =
\frac{h}{6}
\tp
\end{align*}
$$

The particular formulas for \( \basphi_{i-1}(x) \) and \( \basphi_i(x) \) on
\( [\xno{i-1},\xno{i}] \) are found from <a href="#mjx-eqn-25">(25)</a>:
\( \basphi_i \) is the linear function with positive slope, corresponding
to the interval \( [\xno{i-1},\xno{i}] \) in
<a href="#mjx-eqn-25">(25)</a>, while \( \phi_{i-1} \) has a
negative slope so the definition in interval
\( [\xno{i},\xno{i+1}] \) in <a href="#mjx-eqn-25">(25)</a> must be
used. (The appearance of \( i \) in <a href="#mjx-eqn-25">(25)</a>
and the integral might be confusing, as we speak about two different
\( i \) indices.)

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 23:  Illustration of two neighboring linear (hat) functions with general node numbers.  <a name="fem:approx:fe:fig:phi:i:im1"></a> </p></center>
<p><img src="fig-fem/fe_mesh1D_phi_i_im1.png" align="bottom" width=500></p>
</center>

<p>
The first and last row of the coefficient matrix lead to slightly
different integrals:

$$ A_{0,0} = \int_\Omega \basphi_0^2\dx = \int_{\xno{0}}^{\xno{1}}
\left(1 - \frac{x-x_0}{h}\right)^2\dx = \frac{h}{3}\tp
$$

Similarly, \( A_{N,N} \) involves an integral over only one element
and equals hence \( h/3 \).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 24:  Right-hand side integral with the product of a basis function and the given function to approximate.  <a name="fem:approx:fe:fig:phi:i:f"></a> </p></center>
<p><img src="fig-fem/fe_mesh1D_phi_i_f.png" align="bottom" width=500></p>
</center>

<p>
The general formula for \( b_i \),
see Figure <a href="#fem:approx:fe:fig:phi:i:f">24</a>, is now easy to set up

$$
\begin{equation}
b_i = \int_\Omega\basphi_i(x)f(x)\dx
= \int_{\xno{i-1}}^{\xno{i}} \frac{x - \xno{i-1}}{h} f(x)\dx
+ \int_{x_{i}}^{\xno{i+1}} \left(1 - \frac{x - x_{i}}{h}\right) f(x)
\dx\tp
\tag{26}
\end{equation}
$$

We need a specific \( f(x) \) function to compute these integrals.
With two equal-sized elements in \( \Omega=[0,1] \) and \( f(x)=x(1-x) \), one gets

$$
\begin{equation*}
A = \frac{h}{6}\left(\begin{array}{ccc}
2 & 1 & 0\\ 
1 & 4 & 1\\ 
0 & 1 & 2
\end{array}\right),\quad
b = \frac{h^2}{12}\left(\begin{array}{c}
2 - 3h\\ 
12 - 14h\\ 
10 -17h
\end{array}\right)\tp
\end{equation*}
$$

The solution becomes

$$
\begin{equation*} c_0 = \frac{h^2}{6},\quad c_1 = h - \frac{5}{6}h^2,\quad
c_2 = 2h - \frac{23}{6}h^2\tp  \end{equation*}
$$

The resulting function

$$
\begin{equation*} u(x)=c_0\basphi_0(x) + c_1\basphi_1(x) + c_2\basphi_2(x)\end{equation*}
$$

is displayed in Figure <a href="#fem:approx:fe:fig:ls:P1:2:4">25</a> (left).
Doubling the number of elements to four leads to the improved
approximation in the right part of Figure <a href="#fem:approx:fe:fig:ls:P1:2:4">25</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 25:  Least squares approximation of a parabola using 2 (left) and 4 (right) P1 elements. <a name="fem:approx:fe:fig:ls:P1:2:4"></a> </p></center>
<p><img src="fig-fem/fe_p1_x2_2e_4e.png" align="bottom" width=800,></p>
</center>

<h2 id="fem:approx:fe:elementwise">Assembly of elementwise computations<a name="fem:approx:fe:elementwise"></a></h2>

The integrals above are naturally split into integrals over individual elements
since the formulas change with the elements. This idea of splitting the
integral is fundamental in all practical implementations of the finite
element method.

<p>
Let us split the integral over \( \Omega \) into a sum of contributions from
each element:

$$
\begin{equation}
A_{i,j} = \int_\Omega\basphi_i\basphi_j \dx = \sum_{e} A^{(e)}_{i,j},\quad
A^{(e)}_{i,j}=\int_{\Omega^{(e)}} \basphi_i\basphi_j \dx
\tp
\tag{27}
\end{equation}
$$

Now, \( A^{(e)}_{i,j}\neq 0 \) if and only if \( i \) and \( j \) are nodes in element
\( e \) (look at Figure <a href="#fem:approx:fe:fig:phi:i:im1">23</a> to realize this
property).
Introduce \( i=q(e,r) \) as the mapping of local node number \( r \) in element
\( e \) to the global node number \( i \). This is just a short mathematical notation
for the expression <code>i=elements[e][r]</code> in a program.
Let \( r \) and \( s \) be the local node numbers corresponding to the global
node numbers \( i=q(e,r) \) and
\( j=q(e,s) \). With \( d \) nodes per element, all the nonzero elements
in \( A^{(e)}_{i,j} \) arise from the integrals involving basis functions with
indices corresponding to the global node numbers in element number \( e \):

$$
\begin{equation*}
\int_{\Omega^{(e)}}\basphi_{q(e,r)}\basphi_{q(e,s)} \dx,
\quad r,s=0,\ldots, d\tp
\end{equation*}
$$

These contributions can be collected in a \( (d+1)\times (d+1) \) matrix known as
the <em>element matrix</em>. Let \( \Ifd=\{0,\ldots,d\} \) be the valid indices
of \( r \) and \( s \).
We introduce the notation

$$
\begin{equation*}
\tilde A^{(e)} = \{ \tilde A^{(e)}_{r,s}\},\quad
r,s\in\Ifd,
\end{equation*}
$$

for the element matrix. For the case \( d=2 \) we have
$$
\begin{equation*}
\tilde A^{(e)} = \left\lbrack\begin{array}{lllll}
\tilde A^{(e)}_{0,0} & \tilde A^{(e)}_{0,1} & \tilde A^{(e)}_{0,2}\\ 
\tilde A^{(e)}_{1,0} & \tilde A^{(e)}_{1,1} & \tilde A^{(e)}_{1,2}\\ 
\tilde A^{(e)}_{2,0} & \tilde A^{(e)}_{2,1} & \tilde A^{(e)}_{2,2}
\end{array}\right\rbrack
\tp
\end{equation*}
$$

Given the numbers \( \tilde A^{(e)}_{r,s} \),
we should according to <a href="#mjx-eqn-27">(27)</a>
add the contributions to the global coefficient matrix by

$$
\begin{equation}
 A_{q(e,r),q(e,s)} := A_{q(e,r),q(e,s)} + \tilde A^{(e)}_{r,s},\quad
r,s\in\Ifd\tp
\end{equation}
$$

This process of adding in elementwise contributions to the global matrix
is called <em>finite element assembly</em> or simply <em>assembly</em>.
Figure <a href="#fem:approx:fe:fig:assembly:2x2">26</a> illustrates how element matrices
for elements with two nodes are added into the global matrix.
More specifically, the figure shows how the element matrix associated with
elements 1 and 2 assembled, assuming that global nodes are numbered
from left to right in the domain. With regularly numbered P3 elements, where
the element matrices have size \( 4\times 4 \), the assembly of elements 1 and 2
are sketched in Figure <a href="#fem:approx:fe:fig:assembly:4x4">27</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 26:  Illustration of matrix assembly: regularly numbered P1 elements.  <a name="fem:approx:fe:fig:assembly:2x2"></a> </p></center>
<p><img src="mov-fem/fe_assembly_regular_2x2/fe_assembly_regular_2x2.png" align="bottom" width=700></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 27:  Illustration of matrix assembly: regularly numbered P3 elements.  <a name="fem:approx:fe:fig:assembly:4x4"></a> </p></center>
<p><img src="mov-fem/fe_assembly_regular_4x4/fe_assembly_regular_4x4.png" align="bottom" width=700></p>
</center>

<p>
After assembly of element matrices corresponding to regularly numbered elements
and nodes are understood, it is wise to study the assembly process for
irregularly numbered elements and nodes. Figure <a href="#fem:approx:fe:def:elements:nodes:fig:P1:irregular">17</a> shows a mesh where the <code>elements</code> array, or \( q(e,r) \)
mapping in mathematical notation, is given as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">elements <span style="color: #666666">=</span> [[<span style="color: #666666">2</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">4</span>, <span style="color: #666666">5</span>], [<span style="color: #666666">0</span>, <span style="color: #666666">4</span>], [<span style="color: #666666">3</span>, <span style="color: #666666">0</span>], [<span style="color: #666666">5</span>, <span style="color: #666666">2</span>]]
</pre></div>
<p>
The associated assembly of element matrices 1 and 2 is sketched in
Figure <a href="#fem:approx:fe:fig:assembly:irr2x2">28</a>.

<p>
These three assembly processes can also be <a href="http://tinyurl.com/k3sdbuv/pub/mov-fem/fe_assembly.html" target="_self">animated</a>.

<p>
<!-- <a href="http://tinyurl.com/k3sdbuv/pub/mov-fem/fe_assembly_regular_2x2/index.html" target="_self">P1 assembly movie</a>. -->
<!-- <a href="http://tinyurl.com/k3sdbuv/pub/mov-fem/fe_assembly_regular_4x4/index.html" target="_self">P3 assembly movie</a>. -->
<!-- <a href="http://tinyurl.com/k3sdbuv/pub/mov-fem/fe_assembly_irregular/index.html" target="_self">P1 irregular numbering</a>. -->

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 28:  Illustration of matrix assembly: irregularly numbered P1 elements.  <a name="fem:approx:fe:fig:assembly:irr2x2"></a> </p></center>
<p><img src="mov-fem/fe_assembly_irregular/fe_assembly_irregular.png" align="bottom" width=700></p>
</center>

<p>
<!-- old: -->
<!-- FIGURE: [fig-fem/matrix-assembly, width=600]  Illustration of matrix assembly.  <a name="fem:approx:fe:fig:assembly"></a> -->

<p>
The right-hand side of the linear system is also computed elementwise:

$$
\begin{equation}
b_i = \int_\Omega f(x)\basphi_i(x) \dx = \sum_{e} b^{(e)}_{i},\quad
b^{(e)}_{i}=\int_{\Omega^{(e)}} f(x)\basphi_i(x)\dx
\tp  \end{equation}
$$

We observe that
\( b_i^{(e)}\neq 0 \) if and only if global node \( i \) is a node in element \( e \)
(look at Figure <a href="#fem:approx:fe:fig:phi:i:f">24</a> to realize this property).
With \( d \) nodes per element we can collect the \( d+1 \) nonzero contributions
\( b_i^{(e)} \), for \( i=q(e,r) \), \( r\in\Ifd \), in an <em>element vector</em>

$$
\begin{equation*}
\tilde b_r^{(e)}=\{ \tilde b_r^{(e)}\},\quad r\in\Ifd\tp
\end{equation*}
$$

These contributions are added to the
global right-hand side by an assembly process similar to that for the
element matrices:

$$
\begin{equation}
b_{q(e,r)} := b_{q(e,r)} + \tilde b^{(e)}_{r},\quad
r\in\Ifd\tp  \end{equation}
$$

<h2 id="fem:approx:fe:mapping">Mapping to a reference element<a name="fem:approx:fe:mapping"></a></h2>

Instead of computing the integrals

$$
\begin{equation*} \tilde A^{(e)}_{r,s} = \int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)\dx\end{equation*}
$$

over some element
\( \Omega^{(e)} = [x_L, x_R] \),
it is convenient to map the element domain \( [x_L, x_R] \)
to a standardized reference element domain \( [-1,1] \).
(We have now introduced
\( x_L \) and \( x_R \) as the left and right boundary points of an arbitrary element.
With a natural, regular numbering of nodes and elements from left to right
through the domain, we have \( x_L=\xno{e} \) and \( x_R=\xno{e+1} \) for P1 elements.)

<p>
Let \( X\in [-1,1] \) be the coordinate
in the reference element. A linear or <em>affine mapping</em> from \( X \) to \( x \) reads

$$
\begin{equation}
x = \half (x_L + x_R) + \half (x_R - x_L)X\tp
\tag{28}
\end{equation}
$$

This relation can alternatively be expressed by
$$
\begin{equation}
x = x_m + {\half}hX,
\tag{29}
\end{equation}
$$

where we have introduced the element midpoint \( x_m=(x_L+x_R)/2 \) and
the element length \( h=x_R-x_L \).

<p>
Integrating on
the reference element is a matter of just changing the integration
variable from \( x \) to \( X \). Let

$$
\begin{equation}
\refphi_r(X) = \basphi_{q(e,r)}(x(X))
\end{equation}
$$

be the basis function associated with local node number \( r \) in the
reference element. The integral transformation reads

$$
\begin{equation}
\tilde A^{(e)}_{r,s} =
\int_{\Omega^{(e)}}\basphi_{q(e,r)}(x)\basphi_{q(e,s)}(x)\dx
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\frac{dx}{dX}\dX
\tp  \end{equation}
$$

The stretch factor \( dx/dX \) between the \( x \) and \( X \) coordinates
becomes the determinant of the Jacobian matrix of the mapping
between the coordinate systems in 2D and 3D. To obtain a uniform
notation for 1D, 2D, and 3D problems we therefore replace
\( dx/dX \) by \( \det J \) already now. In 1D, \( \det J = dx/dX = h/2 \).
The integration over the reference element is then written as

$$
\begin{equation}
\tilde A^{(e)}_{r,s}
= \int_{-1}^1 \refphi_r(X)\refphi_s(X)\det J\,dX
\tag{30}
\tp
\end{equation}
$$

The corresponding formula for the element vector entries becomes

$$
\begin{equation}
\tilde b^{(e)}_{r} = \int_{\Omega^{(e)}}f(x)\basphi_{q(e,r)}(x)dx
= \int_{-1}^1 f(x(X))\refphi_r(X)\det J\,dX
\tag{31}
\tp
\end{equation}
$$


<p>
Since we from now on will work in the reference
element, we need explicit mathematical formulas for the basis
functions \( \basphi_i(x) \) in the reference element only, i.e., we only need
to specify formulas for \( \refphi_r(X) \).
This is a very convenient simplification compared to specifying
piecewise polynomials in the physical domain.

<p>
The \( \refphi_r(x) \) functions are simply the Lagrange
polynomials defined through the local nodes in the reference element.
For \( d=1 \) and two nodes per element, we have the linear Lagrange
polynomials

$$
\begin{align}
\refphi_0(X) &= \half (1 - X)
\tag{32}\\ 
\refphi_1(X) &= \half (1 + X)
\tag{33}
\end{align}
$$

Quadratic polynomials, \( d=2 \), have the formulas

$$
\begin{align}
\refphi_0(X) &= \half (X-1)X\\ 
\refphi_1(X) &= 1 - X^2\\ 
\refphi_2(X) &= \half (X+1)X
\end{align}
$$

In general,

$$
\begin{equation}
\refphi_r(X) = \prod_{s=0,s\neq r}^d \frac{X-\Xno{s}}{\Xno{r}-\Xno{s}},
\end{equation}
$$

where \( \Xno{0},\ldots,\Xno{d} \) are the coordinates of the local nodes in
the reference element.
These are normally uniformly spaced: \( \Xno{r} = -1 + 2r/d \),
\( r\in\Ifd \).

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Why reference elements?</b>
The great advantage of using reference elements is that
the formulas for the basis functions, \( \refphi_r(X) \), are the
same for all elements and independent of the element geometry
(length and location in the mesh). The geometric information
is &quot;factored out&quot; in the simple mapping formula and the associated
\( \det J \) quantity, but this information is (here taken as) the same for
element types. Also, the integration domain is the same for
all elements.
</div>


<h2 id="fem:approx:fe:intg:ref">Example: Integration over a reference element<a name="fem:approx:fe:intg:ref"></a></h2>

To illustrate the concepts from the previous section in a specific
example, we now
consider calculation of the element matrix and vector for a specific choice of
\( d \) and \( f(x) \). A simple choice is \( d=1 \) (P1 elements) and \( f(x)=x(1-x) \)
on \( \Omega =[0,1] \). We have the general expressions
<a href="#mjx-eqn-30">(30)</a> and <a href="#mjx-eqn-31">(31)</a>
for \( \tilde A^{(e)}_{r,s} \) and \( \tilde b^{(e)}_{r} \).
Writing these out for the choices <a href="#mjx-eqn-32">(32)</a>
and <a href="#mjx-eqn-33">(33)</a>, and using that \( \det J = h/2 \),
we can do the following calculations of the element matrix entries:

$$
\begin{align}
\tilde A^{(e)}_{0,0}
&= \int_{-1}^1 \refphi_0(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1-X)\half(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X)^2 dX = \frac{h}{3},
\tag{34}\\ 
\tilde A^{(e)}_{1,0}
&= \int_{-1}^1 \refphi_1(X)\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1+X)\half(1-X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1-X^2) dX = \frac{h}{6},\\ 
\tilde A^{(e)}_{0,1} &= \tilde A^{(e)}_{1,0},
\tag{35}\\ 
\tilde A^{(e)}_{1,1}
&= \int_{-1}^1 \refphi_1(X)\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&=\int_{-1}^1 \half(1+X)\half(1+X) \frac{h}{2} dX =
\frac{h}{8}\int_{-1}^1 (1+X)^2 dX = \frac{h}{3}
\tag{36}
\tp
\end{align}
$$


<p>
The corresponding entries in the element vector becomes

$$
\begin{align}
\tilde b^{(e)}_{0}
&= \int_{-1}^1 f(x(X))\refphi_0(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\half(1-X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} + \frac{1}{6} h^{2} x_{m} - \frac{1}{12} h^{2} - \half h x_{m}^{2} + \half h x_{m}
\tag{37}\\ 
\tilde b^{(e)}_{1}
&= \int_{-1}^1 f(x(X))\refphi_1(X)\frac{h}{2} dX\nonumber\\ 
&= \int_{-1}^1 (x_m + \half hX)(1-(x_m + \half hX))
\half(1+X)\frac{h}{2} dX \nonumber\\ 
&= - \frac{1}{24} h^{3} - \frac{1}{6} h^{2} x_{m} + \frac{1}{12} h^{2} -
\half h x_{m}^{2} + \half h x_{m}
\tp
\end{align}
$$

In the last two expressions we have used the element midpoint \( x_m \).

<p>
Integration of lower-degree polynomials above is tedious,
and higher-degree polynomials involve very much more algebra, but <code>sympy</code>
may help. For example, we can easily calculate
<a href="#mjx-eqn-34">(34)</a>,
<a href="#mjx-eqn-34">(34)</a>, and
<a href="#mjx-eqn-37">(37)</a> by

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sp</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x, x_m, h, X <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x x_m h X&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> sp<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/8*</span>(<span style="color: #666666">1-</span>X)<span style="color: #666666">**2</span>, (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
h<span style="color: #666666">/3</span>
<span style="color: #666666">&gt;&gt;&gt;</span> sp<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/8*</span>(<span style="color: #666666">1+</span>X)<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>X), (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
h<span style="color: #666666">/6</span>
<span style="color: #666666">&gt;&gt;&gt;</span> x <span style="color: #666666">=</span> x_m <span style="color: #666666">+</span> h<span style="color: #666666">/2*</span>X
<span style="color: #666666">&gt;&gt;&gt;</span> b_0 <span style="color: #666666">=</span> sp<span style="color: #666666">.</span>integrate(h<span style="color: #666666">/4*</span>x<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>x)<span style="color: #666666">*</span>(<span style="color: #666666">1-</span>X), (X, <span style="color: #666666">-1</span>, <span style="color: #666666">1</span>))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> b_0
<span style="color: #666666">-</span>h<span style="color: #666666">**3/24</span> <span style="color: #666666">+</span> h<span style="color: #666666">**2*</span>x_m<span style="color: #666666">/6</span> <span style="color: #666666">-</span> h<span style="color: #666666">**2/12</span> <span style="color: #666666">-</span> h<span style="color: #666666">*</span>x_m<span style="color: #666666">**2/2</span> <span style="color: #666666">+</span> h<span style="color: #666666">*</span>x_m<span style="color: #666666">/2</span>
</pre></div>
<p>
For inclusion of formulas in documents (like the present one), <code>sympy</code> can print
expressions in LaTeX format:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> sp<span style="color: #666666">.</span>latex(b_0, mode<span style="color: #666666">=</span><span style="color: #BA2121">&#39;plain&#39;</span>)
<span style="color: #666666">-</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">24</span>} h<span style="color: #666666">^</span>{<span style="color: #666666">3</span>} <span style="color: #666666">+</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">6</span>} h<span style="color: #666666">^</span>{<span style="color: #666666">2</span>} x_{m}
<span style="color: #666666">-</span> \frac{<span style="color: #666666">1</span>}{<span style="color: #666666">12</span>} h<span style="color: #666666">^</span>{<span style="color: #666666">2</span>} <span style="color: #666666">-</span> \half h x_{m}<span style="color: #666666">^</span>{<span style="color: #666666">2</span>}
<span style="color: #666666">+</span> \half h x_{m}
</pre></div>
<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._main_fem003.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._main_fem005.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

