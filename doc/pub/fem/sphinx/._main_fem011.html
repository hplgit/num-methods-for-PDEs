

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Exercises (1)</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Introduction to finite element methods" href="index.html" />
    <link rel="next" title="Basic principles for approximating differential equations" href="._main_fem012.html" />
    <link rel="prev" title="Finite elements in 2D and 3D" href="._main_fem010.html" />
 
  
   <style type="text/css">
     div.admonition {
       background-color: whiteSmoke;
       border: 1px solid #bababa;
     }
   </style>
  </head>

  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_fem012.html" title="Basic principles for approximating differential equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_fem010.html" title="Finite elements in 2D and 3D"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Introduction to finite element methods</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="exercises-1">
<h1>Exercises  (1)<a class="headerlink" href="#exercises-1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-1-linear-algebra-refresher-i">
<span id="fem-approx-exer-linalg1"></span><h2>Exercise 1: Linear algebra refresher I<a class="headerlink" href="#exercise-1-linear-algebra-refresher-i" title="Permalink to this headline">¶</a></h2>
<p>Look up the topic of <em>vector space</em> in your favorite linear algebra
book or search for the term at Wikipedia.
Prove that vectors in the plane <span class="math">\((a,b)\)</span> form a vector space
by showing that all the axioms of a vector space
are satisfied. Similarly,
prove that all linear functions of the form <span class="math">\(ax+b\)</span> constitute a vector space,
<span class="math">\(a,b\in\mathbb{R}\)</span>.</p>
<p>On the contrary,
show that all quadratic functions of the form <span class="math">\(1 + ax^2 + bx\)</span> <em>do not</em>
constitute a vector space.
Filename: <tt class="docutils literal"><span class="pre">linalg1.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-2-linear-algebra-refresher-ii">
<span id="fem-approx-exer-linalg2"></span><h2>Exercise 2: Linear algebra refresher II<a class="headerlink" href="#exercise-2-linear-algebra-refresher-ii" title="Permalink to this headline">¶</a></h2>
<p>As an extension of <a class="reference internal" href="#fem-approx-exer-linalg1"><em>Exercise 1: Linear algebra refresher I</em></a>, check out
the topic of <em>inner product spaces</em>. Suggest a possible inner product
for the space of all linear functions of the form <span class="math">\(ax+b\)</span>, <span class="math">\(a,b\in\mathbb{R}\)</span>.
Show that this inner product satisfies the
general requirements of an inner product in a vector space.
Filename: <tt class="docutils literal"><span class="pre">linalg2.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-3-approximate-a-three-dimensional-vector-in-a-plane">
<span id="fem-approx-exer-vec-3dby2d"></span><h2>Exercise 3: Approximate a three-dimensional vector in a plane<a class="headerlink" href="#exercise-3-approximate-a-three-dimensional-vector-in-a-plane" title="Permalink to this headline">¶</a></h2>
<p>Given <span class="math">\(\boldsymbol{f} = (1,1,1)\)</span> in <span class="math">\(\mathbb{R}^3\)</span>, find the best approximation vector
<span class="math">\(\boldsymbol{u}\)</span> in the plane spanned by the unit vectors <span class="math">\((1,0)\)</span> and <span class="math">\((0,1)\)</span>.
Repeat the calculations using the vectors <span class="math">\((2,1)\)</span> and <span class="math">\((1,2)\)</span>.
Filename: <tt class="docutils literal"><span class="pre">vec111_approx.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-4-approximate-the-exponential-function-by-power-functions">
<span id="fem-approx-exer-exp-powers"></span><h2>Exercise 4: Approximate the exponential function by power functions<a class="headerlink" href="#exercise-4-approximate-the-exponential-function-by-power-functions" title="Permalink to this headline">¶</a></h2>
<p>Let <span class="math">\(V\)</span> be a function space with basis functions <span class="math">\(x^i\)</span>,
<span class="math">\(i=0,1,\ldots,N\)</span>.  Find the best approximation to <span class="math">\(f(x)=\exp(-x)\)</span> on
<span class="math">\(\Omega =[0,8]\)</span> among all functions in <span class="math">\(V\)</span> for <span class="math">\(N=2,4,6\)</span>. Illustrate
the three approximations in three separate plots.</p>
<p><strong>Hint.</strong>
The exercise is easy to solve if you apply the <tt class="docutils literal"><span class="pre">lest_squares</span></tt> and
<tt class="docutils literal"><span class="pre">comparison_plot</span></tt> functions in the <tt class="docutils literal"><span class="pre">approx1D.py</span></tt> module.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">exp_powers.py</span></tt>.</p>
</div>
<div class="section" id="exercise-5-approximate-the-sine-function-by-power-functions">
<span id="fem-approx-exer-sin-powers"></span><h2>Exercise 5: Approximate the sine function by power functions<a class="headerlink" href="#exercise-5-approximate-the-sine-function-by-power-functions" title="Permalink to this headline">¶</a></h2>
<p>In this exercise we want to approximate the sine function by polynomials
of order <span class="math">\(N+1\)</span>. Consider two bases:</p>
<div class="math">
\[\begin{split}V_1 &amp;= \{x, x^3, x^5, \ldots, x^{N-2}, x^N \}, \\
V_2 &amp;= \{1,x,x^2,x^3,\ldots, x^N\}{\thinspace .}\end{split}\]</div>
<p>The basis <span class="math">\(V_1\)</span> is motivated by the fact that the Taylor polynomial
approximation to the sine function has only odd powers, while <span class="math">\(V_2\)</span>
is motivated by the assumption that also the even powers could
improve the approximation in a least-squares setting.</p>
<p>Compute the best approximation to <span class="math">\(f(x)=\sin(x)\)</span> among all functions in <span class="math">\(V_1\)</span>
and <span class="math">\(V_2\)</span> on two domains of increasing sizes:
<span class="math">\(\Omega_{1,k} = [0, k\pi]\)</span>, <span class="math">\(k=2,3\ldots,6\)</span> and
<span class="math">\(\Omega_{2,k} = [-k\pi /2, k\pi/2]\)</span>, <span class="math">\(k=2,3\ldots,6\)</span>.
Make plots for all combinations of <span class="math">\(V_1\)</span>, <span class="math">\(V_2\)</span>, <span class="math">\(\Omega_1\)</span>, <span class="math">\(\Omega_2\)</span>,
<span class="math">\(k=2,3,\ldots,6\)</span>.</p>
<p>Add a plot of the <span class="math">\(N\)</span>-th degree Taylor polynomial approximation of
<span class="math">\(\sin(x)\)</span> around <span class="math">\(x=0\)</span>.</p>
<p><strong>Hint.</strong>
You can make a loop over <span class="math">\(V_1\)</span> and <span class="math">\(V_2\)</span>, a loop over
<span class="math">\(\Omega_1\)</span> and <span class="math">\(\Omega_2\)</span>, and a loop over <span class="math">\(k\)</span>. Inside the loops,
call the functions <tt class="docutils literal"><span class="pre">least_squares</span></tt> and
<tt class="docutils literal"><span class="pre">comparison_plot</span></tt> from the <tt class="docutils literal"><span class="pre">approx1D</span></tt> module.
<span class="math">\(N=9\)</span> is a suggested value.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">sin_powers.py</span></tt>.</p>
</div>
<div class="section" id="exercise-6-approximate-a-steep-function-by-sines">
<span id="fem-approx-exer-tanh-sine1"></span><h2>Exercise 6: Approximate a steep function by sines<a class="headerlink" href="#exercise-6-approximate-a-steep-function-by-sines" title="Permalink to this headline">¶</a></h2>
<p>Find the best approximation of <span class="math">\(f(x) = \tanh (s(x-\pi))\)</span> on
<span class="math">\([0, 2\pi]\)</span> in the space <span class="math">\(V\)</span> with basis
<span class="math">\({\psi}_i(x) = \sin((2i+1)x)\)</span>, <span class="math">\(i\in{\mathcal{I}_s} = \{0,\ldots,N\}\)</span>.
Make a movie showing how <span class="math">\(u=\sum_{j\in{\mathcal{I}_s}}c_j{\psi}_j(x)\)</span>
approximates <span class="math">\(f(x)\)</span> as <span class="math">\(N\)</span> grows. Choose <span class="math">\(s\)</span> such that <span class="math">\(f\)</span> is
steep (<span class="math">\(s=20\)</span> may be appropriate).</p>
<p><strong>Hint.</strong>
One may naively call the <tt class="docutils literal"><span class="pre">least_squares_orth</span></tt> and <tt class="docutils literal"><span class="pre">comparison_plot</span></tt>
from the <tt class="docutils literal"><span class="pre">approx1D</span></tt> module in a loop and extend the basis with
one new element in each pass. This approach
implies a lot of recomputations.
A more efficient strategy is to let <tt class="docutils literal"><span class="pre">least_squares_orth</span></tt>
compute with only one basis function at a time and accumulate
the corresponding <tt class="docutils literal"><span class="pre">u</span></tt> in the total solution.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">tanh_sines_approx.py</span></tt>.</p>
<div class="section" id="remarks">
<h3>Remarks<a class="headerlink" href="#remarks" title="Permalink to this headline">¶</a></h3>
<p>Approximation of a discontinuous (or steep) <span class="math">\(f(x)\)</span> by sines,
results in slow convergence and oscillatory behavior of the
approximation close to the abrupt changes in <span class="math">\(f\)</span>.
This is known as the <a class="reference external" href="http://en.wikipedia.org/wiki/Gibbs_phenomenon">Gibb&#8217;s phenomenon</a>.</p>
</div>
</div>
<div class="section" id="exercise-7-animate-the-approximation-of-a-steep-function-by-sines">
<span id="fem-approx-exer-tanh-sine2"></span><h2>Exercise 7: Animate the approximation of a steep function by sines<a class="headerlink" href="#exercise-7-animate-the-approximation-of-a-steep-function-by-sines" title="Permalink to this headline">¶</a></h2>
<p>Make a movie that shows how the approximation
in <a class="reference internal" href="#fem-approx-exer-tanh-sine1"><em>Exercise 6: Approximate a steep function by sines</em></a> is improved as <span class="math">\(N\)</span> grows.
Illustrate a smooth case where <span class="math">\(s=0.5\)</span> and a steep case where <span class="math">\(s=20\)</span>
in the <span class="math">\(\tanh (s(x-\pi))\)</span> function.
Filename: <tt class="docutils literal"><span class="pre">tanh_sines_approx_movie.py</span></tt>.</p>
</div>
<div class="section" id="exercise-8-fourier-series-as-a-least-squares-approximation">
<span id="fem-approx-exer-fourier"></span><h2>Exercise 8: Fourier series as a least squares approximation<a class="headerlink" href="#exercise-8-fourier-series-as-a-least-squares-approximation" title="Permalink to this headline">¶</a></h2>
<p>Given a function <span class="math">\(f(x)\)</span> on an interval <span class="math">\([0,L]\)</span>, look up the formula
for the coefficients <span class="math">\(a_j\)</span> and <span class="math">\(b_j\)</span> in the Fourier series of <span class="math">\(f\)</span>:</p>
<div class="math">
\[f(x) = a_0 + \sum_{j=1}^\infty a_j\cos \left(j\frac{\pi x}{L}\right)
+ \sum_{j=1}^\infty b_j\sin \left(j\frac{\pi x}{L}\right){\thinspace .}\]</div>
<p>Let an infinite-dimensional vector space <span class="math">\(V\)</span> have the basis functions
<span class="math">\(\cos j\frac{\pi x}{L}\)</span> for <span class="math">\(j=0,1,\dots,\infty\)</span> and
<span class="math">\(\sin j\frac{\pi x}{L}\)</span> for <span class="math">\(j=1,\dots,\infty\)</span>.  Show that the least squares
approximation method from the section <a class="reference internal" href="._main_fem003.html#fem-approx-global"><em>Approximation of functions</em></a> leads to a
linear system whose solution coincides with the standard formulas for
the coefficients in a Fourier series of <span class="math">\(f(x)\)</span> (see also
the section <a class="reference internal" href="._main_fem003.html#fem-approx-global-fourier"><em>Fourier series</em></a>). You may choose</p>
<div class="math">
\[{\psi}_{2i} = \cos\left( i\frac{\pi}{L}x\right),\quad
{\psi}_{2i+1} = \sin\left( i\frac{\pi}{L}x\right),\]</div>
<p>for <span class="math">\(i=0,1,\ldots,N\rightarrow\infty\)</span>.</p>
<p>Choose <span class="math">\(f(x) = \tanh(s(x-\frac{1}{2}))\)</span> on <span class="math">\(\Omega=[0,1]\)</span>, which is
a smooth function, but with considerable steepness around <span class="math">\(x=1/2\)</span>
as <span class="math">\(s\)</span> grows in size.
Calculate the coefficients in the Fourier expansion by
solving the linear system, arising from the least squares or Galerkin
methods, by hand. Plot
some truncated versions of the series together with <span class="math">\(f(x)\)</span> to show how
the series expansion converges for <span class="math">\(s=10\)</span> and <span class="math">\(s=100\)</span>.
Filename: <tt class="docutils literal"><span class="pre">Fourier_approx.py</span></tt>.</p>
</div>
<div class="section" id="exercise-9-approximate-a-steep-function-by-lagrange-polynomials">
<span id="fem-approx-exer-tanh"></span><h2>Exercise 9: Approximate a steep function by Lagrange polynomials<a class="headerlink" href="#exercise-9-approximate-a-steep-function-by-lagrange-polynomials" title="Permalink to this headline">¶</a></h2>
<p>Use interpolation/collocation with uniformly distributed
points and Chebychev nodes to approximate</p>
<div class="math">
\[f(x) = -\tanh(s(x-\frac{1}{2})),\quad x\in [0,1],\]</div>
<p>by Lagrange polynomials for <span class="math">\(s=10\)</span> and <span class="math">\(s=100\)</span>, and <span class="math">\(N=3,6,9,11\)</span>.
Make separate plots of the approximation for each combination of
<span class="math">\(s\)</span>, point type (Chebyshev or uniform), and <span class="math">\(N\)</span>.
Filename: <tt class="docutils literal"><span class="pre">tanh_Lagrange.py</span></tt>.</p>
</div>
<div class="section" id="exercise-10-define-nodes-and-elements">
<span id="fem-approx-fe-exer-mesh1"></span><h2>Exercise 10: Define nodes and elements<a class="headerlink" href="#exercise-10-define-nodes-and-elements" title="Permalink to this headline">¶</a></h2>
<p>Consider a domain <span class="math">\(\Omega =[0,2]\)</span> divided into the three P2 elements
<span class="math">\([0,1]\)</span>, <span class="math">\([1,1.2]\)</span>, and <span class="math">\([1.2,2]\)</span>.</p>
<p>For P1 and P2 elements, set up the list of coordinates and nodes
(<tt class="docutils literal"><span class="pre">nodes</span></tt>) and the numbers of the nodes that belong to each element
(<tt class="docutils literal"><span class="pre">elements</span></tt>) in two cases: 1) nodes and elements numbered from left to
right, and 2) nodes and elements numbered from right to left.
Filename: <tt class="docutils literal"><span class="pre">fe_numberings1.py.</span></tt>.</p>
</div>
<div class="section" id="exercise-11-define-vertices-cells-and-dof-maps">
<span id="fem-approx-fe-exer-mesh2"></span><h2>Exercise 11: Define vertices, cells, and dof maps<a class="headerlink" href="#exercise-11-define-vertices-cells-and-dof-maps" title="Permalink to this headline">¶</a></h2>
<p>Repeat <a class="reference internal" href="#fem-approx-fe-exer-mesh1"><em>Exercise 10: Define nodes and elements</em></a>, but define the
data structures <tt class="docutils literal"><span class="pre">vertices</span></tt>, <tt class="docutils literal"><span class="pre">cells</span></tt>, and <tt class="docutils literal"><span class="pre">dof_map</span></tt> instead of
<tt class="docutils literal"><span class="pre">nodes</span></tt> and <tt class="docutils literal"><span class="pre">elements</span></tt>.
Filename: <tt class="docutils literal"><span class="pre">fe_numberings2.py</span></tt>.</p>
</div>
<div class="section" id="exercise-12-construct-matrix-sparsity-patterns">
<span id="fem-approx-fe-exer-defmesh-sparsity"></span><h2>Exercise 12: Construct matrix sparsity patterns<a class="headerlink" href="#exercise-12-construct-matrix-sparsity-patterns" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#fem-approx-fe-exer-mesh1"><em>Exercise 10: Define nodes and elements</em></a> describes a element mesh
with a total of five elements, but with two different element and
node orderings. For each of the two orderings,
make a <span class="math">\(5\times 5\)</span> matrix and fill in the entries that will be nonzero.</p>
<p><strong>Hint.</strong>
A matrix entry <span class="math">\((i,j)\)</span> is nonzero if <span class="math">\(i\)</span> and <span class="math">\(j\)</span> are nodes in the
same element.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">fe_sparsity_pattern.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-13-perform-symbolic-finite-element-computations">
<span id="fem-approx-fe-exer-asinwt-symbolic"></span><h2>Exercise 13: Perform symbolic finite element computations<a class="headerlink" href="#exercise-13-perform-symbolic-finite-element-computations" title="Permalink to this headline">¶</a></h2>
<p>Perform symbolic calculations to find formulas for the coefficient matrix
and right-hand side
when approximating <span class="math">\(f(x) = \sin (x)\)</span> on
<span class="math">\(\Omega=[0, \pi]\)</span> by two P1 elements of size <span class="math">\(\pi/2\)</span>.
Solve the system and compare <span class="math">\(u(\pi/2)\)</span> with
the exact value 1.
Filename: <tt class="docutils literal"><span class="pre">sin_approx_P1.py</span></tt>.</p>
</div>
<div class="section" id="exercise-14-approximate-a-steep-function-by-p1-and-p2-elements">
<span id="id1"></span><h2>Exercise 14: Approximate a steep function by P1 and P2 elements<a class="headerlink" href="#exercise-14-approximate-a-steep-function-by-p1-and-p2-elements" title="Permalink to this headline">¶</a></h2>
<p>Given</p>
<div class="math">
\[f(x) = \tanh(s(x-\frac{1}{2}))\]</div>
<p>use the Galerkin or least squares method with finite elements to find
an approximate function <span class="math">\(u(x)\)</span>. Choose <span class="math">\(s=40\)</span> and try
<span class="math">\(N_e=4,8,16\)</span> P1 elements and
<span class="math">\(N_e=2,4,8\)</span> P2 elements.
Integrate <span class="math">\(f{\varphi}_i\)</span> numerically.
Filename: <tt class="docutils literal"><span class="pre">tanh_fe_P1P2_approx.py</span></tt>.</p>
</div>
<div class="section" id="exercise-15-approximate-a-steep-function-by-p3-and-p4-elements">
<span id="fem-approx-exer-tanh2"></span><h2>Exercise 15: Approximate a steep function by P3 and P4 elements<a class="headerlink" href="#exercise-15-approximate-a-steep-function-by-p3-and-p4-elements" title="Permalink to this headline">¶</a></h2>
<p>Solve <em class="xref std std-ref">fem:approx:exer:tanh</em> using <span class="math">\(N_e=1,2,4\)</span> P3 and P4
elements. How will a collocation/interpolation method work in
this case with the same number of nodes?
Filename: <tt class="docutils literal"><span class="pre">tanh_fe_P3P4_approx.py</span></tt>.</p>
</div>
<div class="section" id="exercise-16-investigate-the-approximation-error-in-finite-elements">
<span id="fem-approx-fe-exer-asinwt-interpol-error"></span><h2>Exercise 16: Investigate the approximation error in finite elements<a class="headerlink" href="#exercise-16-investigate-the-approximation-error-in-finite-elements" title="Permalink to this headline">¶</a></h2>
<p>The theory <a class="reference internal" href="._main_fem007.html#eq-fem-approx-fe-error-theorem"><em>(8.1)</em></a> from
the section <em class="xref std std-ref">fem:approx:fe:error</em> predicts that the
error in the Pd approximation of a function
should behave as <span class="math">\(h^{d+1}\)</span>. Use experiments to verify this
asymptotic behavior (i.e., for small enough <span class="math">\(h\)</span>).
Choose two examples: <span class="math">\(f(x)=Ae^{-\omega x}\)</span> on <span class="math">\([0,3/\omega]\)</span>
and <span class="math">\(f(x) = A\sin (\omega x)\)</span> on <span class="math">\(\Omega=[0, 2\pi/\omega]\)</span> for
constants <span class="math">\(A\)</span> and <span class="math">\(\omega\)</span>. What happens if you try
<span class="math">\(f(x)=\sqrt{x}\)</span> on <span class="math">\([0,1]\)</span>?</p>
<p><strong>Hint.</strong>
Run a series of experiments: <span class="math">\((h_i,E_)\)</span>, <span class="math">\(i=0,\ldots,m\)</span>, where <span class="math">\(E_i\)</span>
is the <span class="math">\(L^2\)</span> norm of the error corresponding to element length <span class="math">\(h_i\)</span>.
Assume an error model <span class="math">\(E=Ch^r\)</span> and compute <span class="math">\(r\)</span> from two successive
experiments:</p>
<div class="math">
\[r_i = \ln (E_{i+1}/E_i)/\ln (h_{i+1}/h_i),\quad i=0,\ldots,m-1{\thinspace .}\]</div>
<p>Hopefully, the sequence <span class="math">\(r_0,\ldots,r_{m-1}\)</span> converges to the true
<span class="math">\(r\)</span>, and <span class="math">\(r_{m-1}\)</span> can be taken as an approximation to <span class="math">\(r\)</span>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">Asinwt_interpolation_error.py</span></tt>.</p>
</div>
<div class="section" id="exercise-17-approximate-a-step-function-by-finite-elements">
<span id="fem-approx-fe-exer-heaviside"></span><h2>Exercise 17: Approximate a step function by finite elements<a class="headerlink" href="#exercise-17-approximate-a-step-function-by-finite-elements" title="Permalink to this headline">¶</a></h2>
<p>Approximate the step function</p>
<div class="math">
\[\begin{split}f(x) = \left\lbrace\begin{array}{ll}
1 &amp; x &lt; {1/2},\\
2 &amp; x \geq {1/2}
\end{array}\right.\end{split}\]</div>
<p>by 2, 4, and 8 P1 and P2 elements. Compare
approximations visually.</p>
<p><strong>Hint.</strong>
This <span class="math">\(f\)</span> can also be expressed in terms of the Heaviside function <span class="math">\(H(x)\)</span>:
<span class="math">\(f(x) = H(x-{1/2})\)</span>.
Therefore, <span class="math">\(f\)</span> can be defined by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">f</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">Heaviside</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span>  <span class="n">sp</span><span class="o">.</span><span class="n">Rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>making the <tt class="docutils literal"><span class="pre">approximate</span></tt> function in the
<tt class="docutils literal"><span class="pre">fe_approx1D.py</span></tt> module an obvious candidate to solve the
problem. However, <tt class="docutils literal"><span class="pre">sympy</span></tt> does not handle symbolic integration
with this particular integrand, and the <tt class="docutils literal"><span class="pre">approximate</span></tt> function faces a problem
when converting <tt class="docutils literal"><span class="pre">f</span></tt> to a Python function (for plotting) since
<tt class="docutils literal"><span class="pre">Heaviside</span></tt> is not an available function in <tt class="docutils literal"><span class="pre">numpy</span></tt>. It is better to make
special-purpose code for this case or perform all
calculations by hand.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">Heaviside_approx_P1P2.py.</span></tt>.</p>
</div>
<div class="section" id="exercise-18-2d-approximation-with-orthogonal-functions">
<span id="fem-approx-fe-exer-2dsines-symbolic"></span><h2>Exercise 18: 2D approximation with orthogonal functions<a class="headerlink" href="#exercise-18-2d-approximation-with-orthogonal-functions" title="Permalink to this headline">¶</a></h2>
<p>Assume we have basis functions <span class="math">\({\varphi}_i(x,y)\)</span> in 2D that are
orthogonal
such that <span class="math">\(({\varphi}_i,{\varphi}_j)=0\)</span> when <span class="math">\(i\neq j\)</span>.
The function <tt class="docutils literal"><span class="pre">least_squares</span></tt> in the
file <a class="reference external" href="http://tinyurl.com/nm5587k/fem/fe_approx2D.py">approx2D.py</a> will then spend much time on computing off-diagonal terms
in the coefficient matrix that we know are zero.
To speed up the computations, make a
version <tt class="docutils literal"><span class="pre">least_squares_orth</span></tt> that utilizes the orthogonality among the
basis functions. Apply the function to approximate</p>
<div class="math">
\[f(x,y) = x(1-x)y(1-y)e^{-x-y}\]</div>
<p>on <span class="math">\(\Omega = [0,1]\times [0,1]\)</span> via basis functions</p>
<div class="math">
\[{\varphi}_i(x,y) = \sin (p\pi x)\sin(q\pi y),\quad i=q N_x + p
{\thinspace .}\]</div>
<p><strong>Hint.</strong>
Get ideas from the function <tt class="docutils literal"><span class="pre">least_squares_orth</span></tt> in
the section <a class="reference internal" href="._main_fem003.html#fem-approx-global-orth"><em>Orthogonal basis functions</em></a> and
file <a class="reference external" href="http://tinyurl.com/nm5587k/fem/fe_approx1D.py">approx1D.py</a>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">approx2D_lsorth_sin.py</span></tt>.</p>
</div>
<div class="section" id="exercise-19-use-the-trapezoidal-rule-and-p1-elements">
<span id="fem-approx-fe-exer-1d-trapez"></span><h2>Exercise 19: Use the Trapezoidal rule and P1 elements<a class="headerlink" href="#exercise-19-use-the-trapezoidal-rule-and-p1-elements" title="Permalink to this headline">¶</a></h2>
<p>Consider approximation of some <span class="math">\(f(x)\)</span> on an interval <span class="math">\(\Omega\)</span> using
the least squares or Galerkin methods with P1 elements. Derive
the element matrix and vector using the
Trapezoidal rule <a class="reference internal" href="._main_fem008.html#eq-fem-approx-fe-numint1-trapez"><em>(9.1)</em></a> for calculating
integrals on the reference element. Assemble the contributions, assuming
a uniform cell partitioning, and show that the resulting linear system
has the form <span class="math">\(c_i=f(x_{i})\)</span> for <span class="math">\(i\in{\mathcal{I}_s}\)</span>.
Filename: <tt class="docutils literal"><span class="pre">fe_P1_trapez.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-20-compare-p1-elements-and-interpolation">
<span id="fem-approx-fe-exer-1d-p1-vs-interp"></span><h2>Problem 20: Compare P1 elements and interpolation<a class="headerlink" href="#problem-20-compare-p1-elements-and-interpolation" title="Permalink to this headline">¶</a></h2>
<p>We shall approximate the function</p>
<div class="math">
\[f(x) = 1 + \epsilon\sin (2\pi nx),\quad x\in \Omega = [0,1],\]</div>
<p>where <span class="math">\(n\in\mathbb{Z}\)</span> and <span class="math">\(\epsilon \geq 0\)</span>.</p>
<p><strong>a)</strong>
Sketch <span class="math">\(f(x)\)</span> and find the wave length of the function.</p>
<p><strong>b)</strong>
We want to use <span class="math">\(N_P\)</span> elements per wave length. Show that the number
of elements is then <span class="math">\(nN_P\)</span>.</p>
<p><strong>c)</strong>
The critical quantity for accuracy is the number of elements per
wave length, not the element size in itself. It therefore suffices
to study an <span class="math">\(f\)</span> with just one wave length in <span class="math">\(\Omega = [0,1]\)</span>.
Set <span class="math">\(\epsilon = 0.5\)</span>.</p>
<p>Run the least squares or projection/Galerkin method for
<span class="math">\(N_P=2,4,8,16,32\)</span>. Compute the error <span class="math">\(E=||u-f||_{L^2}\)</span>.</p>
<p><strong>Hint.</strong>
Use the <tt class="docutils literal"><span class="pre">fe_approx1D_numint</span></tt> module to compute <span class="math">\(u\)</span> and use
the technique from the section <a class="reference internal" href="._main_fem007.html#fem-approx-fe-element-impl-error"><em>Computing the error of the approximation</em></a> to
compute the norm of the error.</p>
<p><strong>d)</strong>
Repeat the set of experiments in the above point, but
use interpolation/collocation based on the node points to
compute <span class="math">\(u(x)\)</span> (recall that <span class="math">\(c_i\)</span> is now simply <span class="math">\(f(x_{i})\)</span>).
Compute the error <span class="math">\(E=||u-f||_{L^2}\)</span>.
Which method seems to be most accurate?</p>
<p>Filename: <tt class="docutils literal"><span class="pre">P1_vs_interp.py</span></tt>.</p>
</div>
<div class="section" id="exercise-21-implement-3d-computations-with-global-basis-functions">
<span id="fem-approx-fe-exer-3d-approx3d"></span><h2>Exercise 21: Implement 3D computations with global basis functions<a class="headerlink" href="#exercise-21-implement-3d-computations-with-global-basis-functions" title="Permalink to this headline">¶</a></h2>
<p>Extend the <a class="reference external" href="http://tinyurl.com/nm5587k/fem/approx2D.py">approx2D.py</a> code to 3D
applying ideas from the section <a class="reference internal" href="._main_fem009.html#fem-approx-3d-global"><em>Extension to 3D</em></a>.
Use a 3D generalization of the test problem in the section <a class="reference internal" href="._main_fem009.html#fem-approx-2d-global-code"><em>Implementation  (3)</em></a> to test the implementation.
Filename: <tt class="docutils literal"><span class="pre">approx3D.py</span></tt>.</p>
</div>
<div class="section" id="exercise-22-use-simpson-s-rule-and-p2-elements">
<span id="fem-approx-fe-exer-1d-simpson"></span><h2>Exercise 22: Use Simpson&#8217;s rule and P2 elements<a class="headerlink" href="#exercise-22-use-simpson-s-rule-and-p2-elements" title="Permalink to this headline">¶</a></h2>
<p>Redo <a class="reference internal" href="#fem-approx-fe-exer-1d-trapez"><em>Exercise 19: Use the Trapezoidal rule and P1 elements</em></a>, but use P2
elements and Simpson&#8217;s rule based on sampling the integrands at
the nodes in the reference cell.
Filename: <tt class="docutils literal"><span class="pre">fe_P2_simpson.pdf</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Exercises  (1)</a><ul>
<li><a class="reference internal" href="#exercise-1-linear-algebra-refresher-i">Exercise 1: Linear algebra refresher I</a></li>
<li><a class="reference internal" href="#exercise-2-linear-algebra-refresher-ii">Exercise 2: Linear algebra refresher II</a></li>
<li><a class="reference internal" href="#exercise-3-approximate-a-three-dimensional-vector-in-a-plane">Exercise 3: Approximate a three-dimensional vector in a plane</a></li>
<li><a class="reference internal" href="#exercise-4-approximate-the-exponential-function-by-power-functions">Exercise 4: Approximate the exponential function by power functions</a></li>
<li><a class="reference internal" href="#exercise-5-approximate-the-sine-function-by-power-functions">Exercise 5: Approximate the sine function by power functions</a></li>
<li><a class="reference internal" href="#exercise-6-approximate-a-steep-function-by-sines">Exercise 6: Approximate a steep function by sines</a><ul>
<li><a class="reference internal" href="#remarks">Remarks</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-7-animate-the-approximation-of-a-steep-function-by-sines">Exercise 7: Animate the approximation of a steep function by sines</a></li>
<li><a class="reference internal" href="#exercise-8-fourier-series-as-a-least-squares-approximation">Exercise 8: Fourier series as a least squares approximation</a></li>
<li><a class="reference internal" href="#exercise-9-approximate-a-steep-function-by-lagrange-polynomials">Exercise 9: Approximate a steep function by Lagrange polynomials</a></li>
<li><a class="reference internal" href="#exercise-10-define-nodes-and-elements">Exercise 10: Define nodes and elements</a></li>
<li><a class="reference internal" href="#exercise-11-define-vertices-cells-and-dof-maps">Exercise 11: Define vertices, cells, and dof maps</a></li>
<li><a class="reference internal" href="#exercise-12-construct-matrix-sparsity-patterns">Exercise 12: Construct matrix sparsity patterns</a></li>
<li><a class="reference internal" href="#exercise-13-perform-symbolic-finite-element-computations">Exercise 13: Perform symbolic finite element computations</a></li>
<li><a class="reference internal" href="#exercise-14-approximate-a-steep-function-by-p1-and-p2-elements">Exercise 14: Approximate a steep function by P1 and P2 elements</a></li>
<li><a class="reference internal" href="#exercise-15-approximate-a-steep-function-by-p3-and-p4-elements">Exercise 15: Approximate a steep function by P3 and P4 elements</a></li>
<li><a class="reference internal" href="#exercise-16-investigate-the-approximation-error-in-finite-elements">Exercise 16: Investigate the approximation error in finite elements</a></li>
<li><a class="reference internal" href="#exercise-17-approximate-a-step-function-by-finite-elements">Exercise 17: Approximate a step function by finite elements</a></li>
<li><a class="reference internal" href="#exercise-18-2d-approximation-with-orthogonal-functions">Exercise 18: 2D approximation with orthogonal functions</a></li>
<li><a class="reference internal" href="#exercise-19-use-the-trapezoidal-rule-and-p1-elements">Exercise 19: Use the Trapezoidal rule and P1 elements</a></li>
<li><a class="reference internal" href="#problem-20-compare-p1-elements-and-interpolation">Problem 20: Compare P1 elements and interpolation</a></li>
<li><a class="reference internal" href="#exercise-21-implement-3d-computations-with-global-basis-functions">Exercise 21: Implement 3D computations with global basis functions</a></li>
<li><a class="reference internal" href="#exercise-22-use-simpson-s-rule-and-p2-elements">Exercise 22: Use Simpson&#8217;s rule and P2 elements</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_fem010.html"
                        title="previous chapter">Finite elements in 2D and 3D</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_fem012.html"
                        title="next chapter">Basic principles for approximating differential equations</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._main_fem011.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_fem012.html" title="Basic principles for approximating differential equations"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_fem010.html" title="Finite elements in 2D and 3D"
             >previous</a> |</li>
        <li><a href="index.html">Introduction to finite element methods</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>