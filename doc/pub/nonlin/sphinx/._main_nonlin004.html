
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Discretization of 1D stationary nonlinear differential equations</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Solving nonlinear ODE and PDE problems" href="index.html" />
    <link rel="next" title="Multi-dimensional PDE problems" href="._main_nonlin005.html" />
    <link rel="prev" title="Linearization at the differential equation level" href="._main_nonlin003.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_nonlin005.html" title="Multi-dimensional PDE problems"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_nonlin003.html" title="Linearization at the differential equation level"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Solving nonlinear ODE and PDE problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="discretization-of-1d-stationary-nonlinear-differential-equations">
<span id="nonlin-alglevel-1d"></span><h1>Discretization of 1D stationary nonlinear differential equations<a class="headerlink" href="#discretization-of-1d-stationary-nonlinear-differential-equations" title="Permalink to this headline">¶</a></h1>
<p>The section <a class="reference internal" href="._main_nonlin003.html#nonlin-pdelevel"><span class="std std-ref">Linearization at the differential equation level</span></a> presented methods for linearizing
time-discrete PDEs directly prior to discretization in space.  We can
alternatively carry out the discretization in space of the
time-discrete nonlinear PDE problem and get a system of nonlinear
algebraic equations, which can be solved by Picard iteration or
Newton&#8217;s method as presented in the section <a class="reference internal" href="._main_nonlin002.html#nonlin-systems-alg"><span class="std std-ref">Systems of nonlinear algebraic equations</span></a>.
This latter approach will now be described in detail.</p>
<p>We shall work with the 1D problem</p>
<div class="math" id="eq-nonlin-alglevel-1d-pde">
\[\tag{50}
-({\alpha}(u)u^{\prime})^{\prime} + au = f(u),\quad x\in (0,L),
    \quad {\alpha}(u(0))u^{\prime}(0) = C,\ u(L)=D
    {\thinspace .}\]</div>
<p>The problem <a class="reference internal" href="#eq-nonlin-alglevel-1d-pde"><span class="std std-ref">(50)</span></a> arises from the stationary
limit of a diffusion equation,</p>
<div class="math" id="eq-nonlin-alglevel-1d-pde-tver">
\[\tag{51}
\frac{\partial u}{\partial t} = \frac{\partial}{\partial x}\left(
    \alpha(u)\frac{\partial u}{\partial x}\right) - au + f(u),\]</div>
<p>as <span class="math">\(t\rightarrow\infty\)</span> and <span class="math">\(\partial u/\partial t\rightarrow 0\)</span>.
Alternatively, the problem <a class="reference internal" href="#eq-nonlin-alglevel-1d-pde"><span class="std std-ref">(50)</span></a> arises
at each time level from implicit time discretization of
<a class="reference internal" href="#eq-nonlin-alglevel-1d-pde-tver"><span class="std std-ref">(51)</span></a>. For example, a Backward Euler
scheme for <a class="reference internal" href="#eq-nonlin-alglevel-1d-pde-tver"><span class="std std-ref">(51)</span></a> leads to</p>
<div class="math" id="eq-nonlin-alglevel-1d-pde-tver-be">
\[\tag{52}
\frac{u^{n}-u^{n-1}}{\Delta t} =
    \frac{d}{dx}\left(
    \alpha(u^n)\frac{du^n}{dx}\right) - au^n + f(u^n){\thinspace .}\]</div>
<p>Introducing <span class="math">\(u(x)\)</span> for <span class="math">\(u^n(x)\)</span>, <span class="math">\(u^{(1)}\)</span> for <span class="math">\(u^{n-1}\)</span>, and defining <span class="math">\(f(u)\)</span>
in <a class="reference internal" href="#eq-nonlin-alglevel-1d-pde"><span class="std std-ref">(50)</span></a> to be <span class="math">\(f(u)\)</span> in
<a class="reference internal" href="#eq-nonlin-alglevel-1d-pde-tver-be"><span class="std std-ref">(52)</span></a> plus <span class="math">\(u^{n-1}/\Delta t\)</span>, gives
<a class="reference internal" href="#eq-nonlin-alglevel-1d-pde"><span class="std std-ref">(50)</span></a> with <span class="math">\(a=1/\Delta t\)</span>.</p>
<div class="section" id="finite-difference-discretization-1">
<span id="nonlin-alglevel-1d-fd"></span><h2>Finite difference discretization<a class="headerlink" href="#finite-difference-discretization-1" title="Permalink to this headline">¶</a></h2>
<p>Since the technical steps in finite difference discretization in space
are so much simpler than the steps in the finite element method, we
start with finite difference to illustrate the concept of handling this
nonlinear problem and minimize the spatial discretization details.</p>
<p>The nonlinearity in the differential equation
<a class="reference internal" href="#eq-nonlin-alglevel-1d-pde"><span class="std std-ref">(50)</span></a> poses no more difficulty than a variable
coefficient, as in the term <span class="math">\(({\alpha}(x)u^{\prime})^{\prime}\)</span>.  We can
therefore use a standard finite difference approach to discretizing
the Laplace term with a variable coefficient:</p>
<div class="math">
\[[-D_x{\alpha} D_x u +au = f]_i{\thinspace .}\]</div>
<p>Writing this out for a uniform mesh with points <span class="math">\(x_i=i\Delta x\)</span>,
<span class="math">\(i=0,\ldots,N_x\)</span>, leads to</p>
<div class="math" id="eq-nonlin-alglevel-1d-fd-deq0">
\[\tag{53}
-\frac{1}{\Delta x^2}
    \left({\alpha}_{i+\frac{1}{2}}(u_{i+1}-u_i) -
    {\alpha}_{i-\frac{1}{2}}(u_{i}-u_{i-1})\right)
    + au_i = f(u_i){\thinspace .}\]</div>
<p>This equation is valid at all the mesh points <span class="math">\(i=0,1,\ldots,N_x-1\)</span>.
At <span class="math">\(i=N_x\)</span> we have the Dirichlet condition <span class="math">\(u_i=0\)</span>.
The only difference from the case with <span class="math">\(({\alpha}(x)u^{\prime})^{\prime}\)</span> and <span class="math">\(f(x)\)</span> is that
now <span class="math">\({\alpha}\)</span> and <span class="math">\(f\)</span> are functions of <span class="math">\(u\)</span> and not only on <span class="math">\(x\)</span>:
<span class="math">\(({\alpha}(u(x))u^{\prime})^{\prime}\)</span> and <span class="math">\(f(u(x))\)</span>.</p>
<p>The quantity <span class="math">\({\alpha}_{i+\frac{1}{2}}\)</span>, evaluated between two mesh points,
needs a comment. Since <span class="math">\({\alpha}\)</span> depends on <span class="math">\(u\)</span> and <span class="math">\(u\)</span> is only known
at the mesh points, we need to express <span class="math">\({\alpha}_{i+\frac{1}{2}}\)</span> in
terms of <span class="math">\(u_i\)</span> and <span class="math">\(u_{i+1}\)</span>. For this purpose we use an arithmetic
mean, although a harmonic mean is also common in this context if
<span class="math">\({\alpha}\)</span> features large jumps.
There are two choices of arithmetic means:</p>
<div class="math" id="eq-nonlin-alglevel-1d-fd-dfc-mean-u">
\[\tag{54}
{\alpha}_{i+\frac{1}{2}} \approx
    {\alpha}(\frac{1}{2}(u_i + u_{i+1}) =
    [{\alpha}(\overline{u}^x)]^{i+\frac{1}{2}},\]</div>
<div class="math" id="eq-nonlin-alglevel-1d-fd-dfc-mean-dfc">
\[\tag{55}
{\alpha}_{i+\frac{1}{2}} \approx
    \frac{1}{2}({\alpha}(u_i) + {\alpha}(u_{i+1})) = [\overline{{\alpha}(u)}^x]^{i+\frac{1}{2}}\]</div>
<p>Equation <a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-deq0"><span class="std std-ref">(53)</span></a> with
the latter approximation then looks like</p>
<div class="math">
\[-\frac{1}{2\Delta x^2}
\left(({\alpha}(u_i)+{\alpha}(u_{i+1}))(u_{i+1}-u_i) -
({\alpha}(u_{i-1})+{\alpha}(u_{i}))(u_{i}-u_{i-1})\right)\nonumber\]</div>
<div class="math" id="eq-nonlin-alglevel-1d-fd-deq">
\[\tag{56}
\qquad\qquad + au_i = f(u_i),\]</div>
<p>or written more compactly,</p>
<div class="math">
\[[-D_x\overline{{\alpha}}^x D_x u +au = f]_i{\thinspace .}\]</div>
<p>At mesh point <span class="math">\(i=0\)</span> we have the boundary condition <span class="math">\({\alpha}(u)u^{\prime}=C\)</span>,
which is discretized by</p>
<div class="math">
\[[{\alpha}(u)D_{2x}u = C]_0,\]</div>
<p>meaning</p>
<div class="math" id="eq-nonlin-alglevel-1d-fd-neumann-x0">
\[\tag{57}
{\alpha}(u_0)\frac{u_{1} - u_{-1}}{2\Delta x} = C{\thinspace .}\]</div>
<p>The fictitious value <span class="math">\(u_{-1}\)</span> can be eliminated with the aid
of <a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-deq"><span class="std std-ref">(56)</span></a> for <span class="math">\(i=0\)</span>.
Formally, <a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-deq"><span class="std std-ref">(56)</span></a> should be solved with
respect to <span class="math">\(u_{i-1}\)</span> and that value (for <span class="math">\(i=0\)</span>) should be inserted in
<a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-neumann-x0"><span class="std std-ref">(57)</span></a>, but it is algebraically
much easier to do it the other way around. Alternatively, one can
use a ghost cell <span class="math">\([-\Delta x,0]\)</span> and update the <span class="math">\(u_{-1}\)</span> value
in the ghost cell according to <a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-neumann-x0"><span class="std std-ref">(57)</span></a>
after every Picard or Newton iteration. Such an approach means that
we use a known <span class="math">\(u_{-1}\)</span> value in <a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-deq"><span class="std std-ref">(56)</span></a>
from the previous iteration.</p>
</div>
<div class="section" id="solution-of-algebraic-equations">
<h2>Solution of algebraic equations<a class="headerlink" href="#solution-of-algebraic-equations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-structure-of-the-equation-system">
<h3>The structure of the equation system<a class="headerlink" href="#the-structure-of-the-equation-system" title="Permalink to this headline">¶</a></h3>
<p>The nonlinear algebraic equations <a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-deq"><span class="std std-ref">(56)</span></a> are
of the form <span class="math">\(A(u)u = b(u)\)</span> with</p>
<div class="math">
\[\begin{split}A_{i,i} &amp;= \frac{1}{2\Delta x^2}({\alpha}(u_{i-1}) + 2{\alpha}(u_{i})
{\alpha}(u_{i+1})) + a,\\
A_{i,i-1} &amp;= -\frac{1}{2\Delta x^2}({\alpha}(u_{i-1}) + {\alpha}(u_{i})),\\
A_{i,i+1} &amp;= -\frac{1}{2\Delta x^2}({\alpha}(u_{i}) + {\alpha}(u_{i+1})),\\
b_i &amp;= f(u_i){\thinspace .}\end{split}\]</div>
<p>The matrix <span class="math">\(A(u)\)</span> is tridiagonal: <span class="math">\(A_{i,j}=0\)</span> for <span class="math">\(j &gt; i+1\)</span> and <span class="math">\(j &lt; i-1\)</span>.</p>
<p>The above expressions are valid for internal mesh points <span class="math">\(1\leq i\leq N_x-1\)</span>.
For <span class="math">\(i=0\)</span> we need to express <span class="math">\(u_{i-1}=u_{-1}\)</span> in terms of <span class="math">\(u_1\)</span> using
<a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-neumann-x0"><span class="std std-ref">(57)</span></a>:</p>
<div class="math" id="eq-nonlin-alglevel-1d-fd-neumann-x0-um1">
\[\tag{58}
u_{-1} = u_1 -\frac{2\Delta x}{{\alpha}(u_0)}C{\thinspace .}\]</div>
<p>This value must be inserted in <span class="math">\(A_{0,0}\)</span>. The expression for <span class="math">\(A_{i,i+1}\)</span>
applies for <span class="math">\(i=0\)</span>, and <span class="math">\(A_{i,i-1}\)</span> does not enter the system when <span class="math">\(i=0\)</span>.</p>
<p>Regarding the last equation, its form depends on whether we include
the Dirichlet condition <span class="math">\(u(L)=D\)</span>, meaning <span class="math">\(u_{N_x}=D\)</span>, in the
nonlinear algebraic equation system or not. Suppose we choose
<span class="math">\((u_0,u_1,\ldots,u_{N_x-1})\)</span> as unknowns, later referred to as
<em>systems without Dirichlet conditions</em>. The last equation
corresponds to <span class="math">\(i=N_x-1\)</span>. It involves the boundary value <span class="math">\(u_{N_x}\)</span>,
which is substituted by <span class="math">\(D\)</span>. If the unknown vector includes the
boundary value, <span class="math">\((u_0,u_1,\ldots,u_{N_x})\)</span>, later referred to as
<em>system including Dirichlet conditions</em>, the equation for <span class="math">\(i=N_x-1\)</span>
just involves the unknown <span class="math">\(u_{N_x}\)</span>, and the final equation becomes
<span class="math">\(u_{N_x}=D\)</span>, corresponding to <span class="math">\(A_{i,i}=1\)</span> and <span class="math">\(b_i=D\)</span> for <span class="math">\(i=N_x\)</span>.</p>
</div>
<div class="section" id="picard-iteration-3">
<h3>Picard iteration<a class="headerlink" href="#picard-iteration-3" title="Permalink to this headline">¶</a></h3>
<p>The obvious Picard iteration scheme is to use previously computed
values of <span class="math">\(u_i\)</span> in <span class="math">\(A(u)\)</span> and <span class="math">\(b(u)\)</span>, as described more in detail in
the section <a class="reference internal" href="._main_nonlin002.html#nonlin-systems-alg"><span class="std std-ref">Systems of nonlinear algebraic equations</span></a>. With the notation <span class="math">\(u^{-}\)</span> for the
most recently computed value of <span class="math">\(u\)</span>, we have the system <span class="math">\(F(u)\approx
\hat F(u) = A(u^{-})u - b(u^{-})\)</span>, with <span class="math">\(F=(F_0,F_1,\ldots,F_m)\)</span>,
<span class="math">\(u=(u_0,u_1,\ldots,u_m)\)</span>.  The index <span class="math">\(m\)</span> is <span class="math">\(N_x\)</span> if the system
includes the Dirichlet condition as a separate equation and <span class="math">\(N_x-1\)</span>
otherwise.  The matrix <span class="math">\(A(u^{-})\)</span> is tridiagonal, so the solution
procedure is to fill a tridiagonal matrix data structure and the
right-hand side vector with the right numbers and call a Gaussian
elimination routine for tridiagonal linear systems.</p>
<p>To write out all the mathematical details in a specific
case, let us look at the case <span class="math">\(N_x=2\)</span>. We use <span class="math">\(u^{-}_i\)</span>
for the <span class="math">\(i\)</span>-th component in <span class="math">\(u^{-}\)</span>. In case we omit the Dirichlet
condition from the system we get the following <span class="math">\(2\times 2\)</span> system,</p>
<div class="math">
\[\begin{split}\left(\begin{array}{cc}
A_{0,0}&amp; A_{0,1}\\
A_{1,0} &amp; A_{1,1}
\end{array}\right)
\left(\begin{array}{c}
u_0\\
u_1
\end{array}\right)
=
\left(\begin{array}{c}
b_0\\
b_1
\end{array}\right)\end{split}\]</div>
<p>The matrix and right-hand side entries are given by</p>
<div class="math" id="eq-auto23">
\[\tag{59}
A_{0,0} = \frac{1}{2\Delta x^2}({\alpha}(u_{-1}^{-}) + 2{\alpha}(u_{0}^{-})
    + {\alpha}(u_{1}^{-})) + a\]</div>
<div class="math" id="eq-auto24">
\[\tag{60}
A_{0,1} =
    -\frac{1}{2\Delta x^2}({\alpha}(u_{0}^{-}) + {\alpha}(u_{1}^{-})),\]</div>
<div class="math" id="eq-auto25">
\[\tag{61}
A_{1,0} =
    -\frac{1}{2\Delta x^2}({\alpha}(u_{0}^{-}) + {\alpha}(u_{1}^{-})),\]</div>
<div class="math" id="eq-auto26">
\[\tag{62}
A_{1,1} =
    \frac{1}{2\Delta x^2}({\alpha}(u_{0}^{-}) + 2{\alpha}(u_{1}^{-})
    +{\alpha}(u_{2})) + a,\]</div>
<div class="math" id="eq-auto27">
\[\tag{63}
b_0 =
    f(u_0^{-}),\]</div>
<div class="math" id="eq-auto28">
\[\tag{64}
b_1 =
    f(u_1^{-}),\]</div>
<p>where <span class="math">\(u_{-1}\)</span> must be substituted by
<a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-neumann-x0-um1"><span class="std std-ref">(58)</span></a>, and <span class="math">\(u_2\)</span> by <span class="math">\(D\)</span>.</p>
<p>The system with the Dirichlet condition becomes</p>
<div class="math">
\[\begin{split}\left(\begin{array}{ccc}
A_{0,0}&amp; A_{0,1} &amp; A_{0,2}\\
A_{1,0} &amp; A_{1,1} &amp; A_{1,2}\\
A_{2,0} &amp; A_{2,1} &amp; A_{2,2}
\end{array}\right)
\left(\begin{array}{c}
u_0\\
u_1\\
u_2
\end{array}\right)
=
\left(\begin{array}{c}
b_0\\
b_1\\
b_2
\end{array}\right),\end{split}\]</div>
<p>with entries for <span class="math">\(A_{i,j}\)</span> and <span class="math">\(b_i\)</span> as above for <span class="math">\(i,j=1,2\)</span>, keeping
<span class="math">\(u_2\)</span> as unknown in <span class="math">\(A_{1,1}\)</span>, and</p>
<div class="math" id="eq-auto29">
\[\tag{65}
A_{0,2}=A_{2,0}=A_{2,1}=0,\ A_{1,2}=
    -\frac{1}{2\Delta x^2}({\alpha}(u_{1}) + {\alpha}(u_{2})),\ A_{2,2}=1,\ b_2=D{\thinspace .}\]</div>
</div>
<div class="section" id="newton-s-method-4">
<h3>Newton&#8217;s method<a class="headerlink" href="#newton-s-method-4" title="Permalink to this headline">¶</a></h3>
<p>The Jacobian must be derived in order to use Newton&#8217;s method. Here it means
that we need to differentiate <span class="math">\(F(u)=A(u)u - b(u)\)</span> with respect to
the unknown parameters
<span class="math">\(u_0,u_1,\ldots,u_m\)</span> (<span class="math">\(m=N_x\)</span> or <span class="math">\(m=N_x-1\)</span>, depending on whether the
Dirichlet condition is included in the nonlinear system <span class="math">\(F(u)=0\)</span> or not).
Nonlinear equation number <span class="math">\(i\)</span> has the structure</p>
<div class="math">
\[F_i = A_{i,i-1}(u_{i-1},u_i)u_{i-1} +
A_{i,i}(u_{i-1},u_i,u_{i+1})u_i +
A_{i,i+1}(u_i, u_{i+1})u_{i+1} - b_i(u_i){\thinspace .}\]</div>
<p>Computing the Jacobian requires careful differentiation. For example,</p>
<div class="math">
\[\begin{split}\frac{\partial}{\partial u_i}(A_{i,i}(u_{i-1},u_i,u_{i+1})u_i) &amp;=
\frac{\partial A_{i,i}}{\partial u_i}u_i + A_{i,i}
\frac{\partial u_i}{\partial u_i}\\
&amp;=
\frac{\partial}{\partial u_i}(
\frac{1}{2\Delta x^2}({\alpha}(u_{i-1}) + 2{\alpha}(u_{i})
+{\alpha}(u_{i+1})) + a)u_i +\\
&amp;\quad\frac{1}{2\Delta x^2}({\alpha}(u_{i-1}) + 2{\alpha}(u_{i})
+{\alpha}(u_{i+1})) + a\\
&amp;= \frac{1}{2\Delta x^2}(2{\alpha}^\prime (u_i)u_i
+{\alpha}(u_{i-1}) + 2{\alpha}(u_{i})
+{\alpha}(u_{i+1})) + a{\thinspace .}\end{split}\]</div>
<p>The complete Jacobian becomes</p>
<div class="math">
\[\begin{split}J_{i,i} &amp;= \frac{\partial F_i}{\partial u_i}
= \frac{\partial A_{i,i-1}}{\partial u_i}u_{i-1}
+ \frac{\partial A_{i,i}}{\partial u_i}u_i
+ A_{i,i}
+ \frac{\partial A_{i,i+1}}{\partial u_i}u_{i+1}
- \frac{\partial b_i}{\partial u_{i}}\\
&amp;=
\frac{1}{2\Delta x^2}(
-{\alpha}^{\prime}(u_i)u_{i-1}
+2{\alpha}^{\prime}(u_i)u_{i}
+{\alpha}(u_{i-1}) + 2{\alpha}(u_i) + {\alpha}(u_{i+1})) +\\
&amp;\quad a
-\frac{1}{2\Delta x^2}{\alpha}^{\prime}(u_{i})u_{i+1}
- b^{\prime}(u_i),\\
J_{i,i-1} &amp;= \frac{\partial F_i}{\partial u_{i-1}}
= \frac{\partial A_{i,i-1}}{\partial u_{i-1}}u_{i-1}
+ A_{i-1,i}
+ \frac{\partial A_{i,i}}{\partial u_{i-1}}u_i
- \frac{\partial b_i}{\partial u_{i-1}}\\
&amp;=
\frac{1}{2\Delta x^2}(
-{\alpha}^{\prime}(u_{i-1})u_{i-1} - ({\alpha}(u_{i-1}) + {\alpha}(u_i))
+ {\alpha}^{\prime}(u_{i-1})u_i),\\
J_{i,i+1} &amp;= \frac{\partial A_{i,i+1}}{\partial u_{i-1}}u_{i+1}
+ A_{i+1,i} +
\frac{\partial A_{i,i}}{\partial u_{i+1}}u_i
- \frac{\partial b_i}{\partial u_{i+1}}\\
&amp;=\frac{1}{2\Delta x^2}(
-{\alpha}^{\prime}(u_{i+1})u_{i+1} - ({\alpha}(u_{i}) + {\alpha}(u_{i+1}))
+ {\alpha}^{\prime}(u_{i+1})u_i)
{\thinspace .}\end{split}\]</div>
<p>The explicit expression for nonlinear equation number <span class="math">\(i\)</span>,
<span class="math">\(F_i(u_0,u_1,\ldots)\)</span>, arises from moving the <span class="math">\(f(u_i)\)</span> term in
<a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-deq"><span class="std std-ref">(56)</span></a> to the left-hand side:</p>
<div class="math">
\[F_i = -\frac{1}{2\Delta x^2}
\left(({\alpha}(u_i)+{\alpha}(u_{i+1}))(u_{i+1}-u_i) -
({\alpha}(u_{i-1})+{\alpha}(u_{i}))(u_{i}-u_{i-1})\right)\nonumber\]</div>
<div class="math" id="eq-nonlin-alglevel-1d-fd-deq2">
\[\tag{66}
\qquad\qquad + au_i - f(u_i) = 0{\thinspace .}\]</div>
<p>At the boundary point <span class="math">\(i=0\)</span>, <span class="math">\(u_{-1}\)</span> must be replaced using
the formula <a class="reference internal" href="#eq-nonlin-alglevel-1d-fd-neumann-x0-um1"><span class="std std-ref">(58)</span></a>.
When the Dirichlet condition at <span class="math">\(i=N_x\)</span> is not a part of the
equation system, the last equation <span class="math">\(F_m=0\)</span> for <span class="math">\(m=N_x-1\)</span>
involves the quantity <span class="math">\(u_{N_x-1}\)</span> which must be replaced by <span class="math">\(D\)</span>.
If <span class="math">\(u_{N_x}\)</span> is treated as an unknown in the system, the
last equation <span class="math">\(F_m=0\)</span> has <span class="math">\(m=N_x\)</span> and reads</p>
<div class="math">
\[F_{N_x}(u_0,\ldots,u_{N_x}) = u_{N_x} - D = 0{\thinspace .}\]</div>
<p>Similar replacement of <span class="math">\(u_{-1}\)</span> and <span class="math">\(u_{N_x}\)</span> must be done in
the Jacobian for the first and last row. When <span class="math">\(u_{N_x}\)</span>
is included as an unknown, the last row in the Jacobian
must help implement the condition <span class="math">\(\delta u_{N_x}=0\)</span>, since
we assume that <span class="math">\(u\)</span> contains the right Dirichlet value
at the beginning of the iteration (<span class="math">\(u_{N_x}=D\)</span>), and then
the Newton update should be zero for <span class="math">\(i=0\)</span>, i.e., <span class="math">\(\delta u_{N_x}=0\)</span>.
This also forces the right-hand side to be <span class="math">\(b_i=0\)</span>, <span class="math">\(i=N_x\)</span>.</p>
<p>We have seen, and can see from the present example, that the
linear system in Newton&#8217;s method contains all the terms present
in the system that arises in the Picard iteration method.
The extra terms in Newton&#8217;s method can be multiplied by a factor
such that it is easy to program one linear system and set this
factor to 0 or 1 to generate the Picard or Newton system.</p>
</div>
</div>
<div class="section" id="galerkin-type-discretization">
<span id="nonlin-alglevel-1d-fe"></span><h2>Galerkin-type discretization<a class="headerlink" href="#galerkin-type-discretization" title="Permalink to this headline">¶</a></h2>
<p>For a Galerkin-type discretization, which may be developed into
a finite element method, we first need to derive the
variational problem. Let <span class="math">\(V\)</span> be an appropriate function space
with basis functions <span class="math">\(\left\{ {{\psi}}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>. Because of the
Dirichlet condition at <span class="math">\(x=L\)</span> we require <span class="math">\({\psi}_i(L)=0\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>.
The approximate solution is written as <span class="math">\(u = D + \sum_{j\in{\mathcal{I}_s}}c_j{\psi}_j\)</span>,
where the term <span class="math">\(D\)</span> can be viewed as a boundary function needed to
implement the Dirichlet condition <span class="math">\(u(L)=D\)</span>.</p>
<p>Using Galerkin&#8217;s method,
we multiply the differential equation by any <span class="math">\(v\in V\)</span> and integrate
terms with second-order derivatives by parts:</p>
<div class="math">
\[\int_0^L {\alpha}(u)u^{\prime}v^{\prime}{\, \mathrm{d}x} + \int_0^L auv{\, \mathrm{d}x} =
\int_0^L f(u)v{\, \mathrm{d}x} + [{\alpha}(u)u^{\prime}v]_0^L,\quad \forall v\in V{\thinspace .}\]</div>
<p>The Neumann condition at the boundary <span class="math">\(x=0\)</span> is inserted in the
boundary term:</p>
<div class="math">
\[[{\alpha}(u)u^{\prime}v]_0^L = {\alpha}(u(L))u^{\prime}(L)v(L) - {\alpha}(u(0))u^{\prime}(0)v(0)
= 0 - Cv(0)=-Cv(0){\thinspace .}\]</div>
<p>(Recall that since <span class="math">\({\psi}_i(L)=0\)</span>, any linear combination <span class="math">\(v\)</span>
of the basis functions also vanishes at <span class="math">\(x=L\)</span>: <span class="math">\(v(L)=0\)</span>.)
The variational problem is then:
find <span class="math">\(u\in V\)</span> such that</p>
<div class="math" id="eq-nonlin-alglevel-1d-pde-varform">
\[\tag{67}
\int_0^L {\alpha}(u)u^{\prime}v^{\prime}{\, \mathrm{d}x} + \int_0^L auv{\, \mathrm{d}x} =
    \int_0^L f(u)v{\, \mathrm{d}x} - Cv(0),\quad \forall v\in V{\thinspace .}\]</div>
<p>To derive the algebraic equations, we note that <span class="math">\(\forall v\in V\)</span> is
equivalent with <span class="math">\(v={\psi}_i\)</span> for <span class="math">\(i\in{\mathcal{I}_s}\)</span>. Setting <span class="math">\(u=D+\sum_jc_j{\psi}_j\)</span>
and sorting terms results in the linear system</p>
<div class="math">
\[\sum_{j\in{\mathcal{I}_s}}\left(
\int_0^L \left({\alpha}(D+\sum_{k\in{\mathcal{I}_s}}c_k{\psi}_k)
{\psi}_j^{\prime}{\psi}_i^{\prime} + a{\psi}_i{\psi}_j\right){\, \mathrm{d}x}\right)c_j
\nonumber\]</div>
<div class="math" id="eq-auto30">
\[\tag{68}
\qquad = \int_0^L f(D+\sum_{k\in{\mathcal{I}_s}}c_k{\psi}_k){\psi}_i{\, \mathrm{d}x} -
    C{\psi}_i(0),\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<div class="section" id="fundamental-integration-problem">
<h3>Fundamental integration problem<a class="headerlink" href="#fundamental-integration-problem" title="Permalink to this headline">¶</a></h3>
<p>Methods that use the Galerkin or weighted residual method face a
fundamental difficulty in nonlinear problems: how can we integrate a
terms like <span class="math">\(\int_0^L
{\alpha}(\sum_{k}c_k{\psi}_k){\psi}_i^{\prime}{\psi}_j^{\prime}{\, \mathrm{d}x}\)</span> and
<span class="math">\(\int_0^L f(\sum_{k}c_k{\psi}_k){\psi}_i{\, \mathrm{d}x}\)</span> when we do not know the
<span class="math">\(c_k\)</span> coefficients in the argument of the <span class="math">\({\alpha}\)</span> function?  We can
resort to numerical integration, provided an approximate
<span class="math">\(\sum_kc_k{\psi}_k\)</span> can be used for the argument <span class="math">\(u\)</span> in <span class="math">\(f\)</span> and
<span class="math">\({\alpha}\)</span>.  This is the approach used in computer programs.</p>
<p>However, if we want to look more mathematically into the structure of
the algebraic equations generated by the finite element method in
nonlinear problems, and compare such equations with those arising in
the finite difference method, we need techniques that enable
integration of expressions like <span class="math">\(\int_0^L
f(\sum_{k}c_k{\psi}_k){\psi}_i{\, \mathrm{d}x}\)</span> <em>by hand</em>. Two such techniques
will be shown: the group finite element and numerical integration
based on the nodes only. Both techniques are approximate, but they
allow us to see the difference equations in the finite element method.
The details are worked out in Appendix <a class="reference internal" href="._main_nonlin007.html#nonlin-app-fem-vs-fdm"><span class="std std-ref">Appendix: Symbolic nonlinear finite element equations</span></a>.
Some readers will prefer to dive into these symbolic calculations
to gain more understanding of nonlinear finite element equations,
while others will prefer to continue with computational algorithms
(in the next two sections) rather than analysis.</p>
</div>
</div>
<div class="section" id="picard-iteration-defined-from-the-variational-form">
<span id="nonlin-alglevel-1d-fe-picard"></span><h2>Picard iteration defined from the variational form<a class="headerlink" href="#picard-iteration-defined-from-the-variational-form" title="Permalink to this headline">¶</a></h2>
<p>Consider the problem <a class="reference internal" href="#eq-nonlin-alglevel-1d-pde"><span class="std std-ref">(50)</span></a> with the
corresponding variational form <a class="reference internal" href="#eq-nonlin-alglevel-1d-pde-varform"><span class="std std-ref">(67)</span></a>.
Our aim is to define a Picard iteration based on this variational form
without any attempt to compute integrals symbolically as in the
previous three sections.  The idea in Picard iteration is to use a
previously computed <span class="math">\(u\)</span> value in the nonlinear functions <span class="math">\({\alpha}(u)\)</span> and
<span class="math">\(f(u)\)</span>. Let <span class="math">\(u^{-}\)</span> be the available approximation to <span class="math">\(u\)</span> from the
previous iteration.  The linearized variational form for Picard
iteration is then</p>
<div class="math" id="eq-nonlin-alglevel-1d-pde-varform-picard">
\[\tag{69}
\int_0^L ({\alpha}(u^{-})u^{\prime}v^{\prime} + auv){\, \mathrm{d}x} = \int_0^L f(u^{-})v{\, \mathrm{d}x} -
    Cv(0),\quad \forall v\in V{\thinspace .}\]</div>
<p>This is a linear problem <span class="math">\(a(u,v)=L(v)\)</span> with bilinear and linear forms</p>
<div class="math">
\[a(u,v) = \int_0^L ({\alpha}(u^{-})u^{\prime}v^{\prime} + auv){\, \mathrm{d}x},\quad
L(v) = \int_0^L f(u^{-})v{\, \mathrm{d}x} - Cv(0){\thinspace .}\]</div>
<p>Make sure to distinguish the coefficient <span class="math">\(a\)</span> in <span class="math">\(auv\)</span> from the
differential equation from the <span class="math">\(a\)</span> in
the abstract bilinear form notation <span class="math">\(a(\cdot,\cdot)\)</span>.</p>
<p>The linear system associated with
<a class="reference internal" href="#eq-nonlin-alglevel-1d-pde-varform-picard"><span class="std std-ref">(69)</span></a> is computed the standard way.
Technically, we are back to solving <span class="math">\(-({\alpha}(x)u^{\prime})^{\prime} + au=f(x)\)</span>.
The unknown <span class="math">\(u\)</span> is sought on the form
<span class="math">\(u = B(x) + \sum_{j\in{\mathcal{I}_s}}c_j{\psi}_j\)</span>, with <span class="math">\(B(x)=D\)</span>
and <span class="math">\({\psi}_i = {\varphi}_{\nu(i)}\)</span>, <span class="math">\(\nu(i)=i+1\)</span>, and
<span class="math">\({\mathcal{I}_s} = \{0,1,\ldots,N=N_n-2\}\)</span>.</p>
</div>
<div class="section" id="newton-s-method-defined-from-the-variational-form">
<span id="nonlin-alglevel-1d-fe-newton"></span><h2>Newton&#8217;s method defined from the variational form<a class="headerlink" href="#newton-s-method-defined-from-the-variational-form" title="Permalink to this headline">¶</a></h2>
<p>Application of Newton&#8217;s method to the nonlinear variational
form <a class="reference internal" href="#eq-nonlin-alglevel-1d-pde-varform"><span class="std std-ref">(67)</span></a> arising from
the problem <a class="reference internal" href="#eq-nonlin-alglevel-1d-pde"><span class="std std-ref">(50)</span></a> requires identification
of the nonlinear algebraic equations <span class="math">\(F_i=0\)</span>.
Although we originally denoted the unknowns in nonlinear
algebraic equations by <span class="math">\(u_0,\ldots,u_N\)</span>, it is in the present
context most natural to have the unknowns as <span class="math">\(c_0,\ldots,c_N\)</span>
and write</p>
<div class="math">
\[F_i(c_0,\ldots,c_N)=0, \quad i\in{\mathcal{I}_s},\]</div>
<p>and define the Jacobian as <span class="math">\(J_{i,j}=\partial F_i/\partial c_j\)</span> for
<span class="math">\(i,j\in{\mathcal{I}_s}\)</span>.</p>
<p>The specific form of the equations <span class="math">\(F_i=0\)</span> follows from the variational form</p>
<div class="math">
\[\int_0^L ({\alpha}(u)u^{\prime}v^{\prime} + auv){\, \mathrm{d}x} =
\int_0^L f(u)v{\, \mathrm{d}x} - Cv(0),\quad \forall v\in V,\]</div>
<p>by choosing <span class="math">\(v={\psi}_i\)</span>, <span class="math">\(i\in{\mathcal{I}_s}\)</span>, and setting
<span class="math">\(u=\sum_{j\in{\mathcal{I}_s}}c_j{\psi}_j\)</span>, maybe with a boundary function
to incorporate Dirichlet conditions.</p>
<p>With <span class="math">\(v={\psi}_i\)</span> we get</p>
<div class="math" id="eq-nonlin-alglevel-1d-fe-newton-fi">
\[\tag{70}
F_i =
    \int_0^L ({\alpha}(u)u^{\prime}{\psi}_i^{\prime} + au{\psi}_i -
    f(u){\psi}_i){\, \mathrm{d}x} + C{\psi}_i(0)=0,\quad i\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>In the differentiations leading to the Jacobian we will frequently use
the results</p>
<div class="math">
\[\frac{\partial u}{\partial c_j} = \frac{\partial}{\partial c_j}
\sum_kc_k{\psi}_k = {\psi}_j,\quad
\frac{\partial u^{\prime}}{\partial c_j} = \frac{\partial}{\partial c_j}
\sum_kc_k{\psi}_k^{\prime} = {\psi}_j^{\prime}{\thinspace .}\]</div>
<p>The derivation of the Jacobian of <a class="reference internal" href="#eq-nonlin-alglevel-1d-fe-newton-fi"><span class="std std-ref">(70)</span></a> goes as</p>
<div class="math">
\[J_{i,j} = \frac{\partial F_i}{\partial c_j}
 = \int_0^L \frac{\partial}{\partial c_j}
({\alpha}(u)u^{\prime}{\psi}_i^{\prime} + au{\psi}_i -
f(u){\psi}_i){\, \mathrm{d}x}\nonumber\]</div>
<div class="math">
\[=
\int_0^L
(({\alpha}^{\prime}(u)\frac{\partial u}{\partial c_j}u^{\prime} +
{\alpha}(u)\frac{\partial u^{\prime}}{\partial c_j}){\psi}_i^{\prime}
+ a\frac{\partial u}{\partial c_j}{\psi}_i -
f^{\prime}(u)\frac{\partial u}{\partial c_j}{\psi}_i){\, \mathrm{d}x}\nonumber\]</div>
<div class="math">
\[=
\int_0^L
(({\alpha}^{\prime}(u){\psi}_ju^{\prime} +
{\alpha}(u){\psi}_j^{\prime}){\psi}_i^{\prime}
+ a{\psi}_j{\psi}_i -
f^{\prime}(u){\psi}_j{\psi}_i){\, \mathrm{d}x}\nonumber\]</div>
<div class="math" id="eq-nonlin-alglevel-1d-fe-newton-jij">
\[\tag{71}
=
    \int_0^L
    ({\alpha}^{\prime}(u)u^{\prime}{\psi}_i^{\prime}{\psi}_j +
    {\alpha}(u){\psi}_i^{\prime}{\psi}_j^{\prime}
    + (a - f(u)){\psi}_i{\psi}_j){\, \mathrm{d}x}\]</div>
<div class="admonition-one-must-be-careful-about-the-prime-symbol-as-differentiation admonition">
<p class="first admonition-title">One must be careful about the prime symbol as differentiation</p>
<p>In <span class="math">\({\alpha}^{\prime}\)</span> the derivative is with respect to the independent
variable in the <span class="math">\({\alpha}\)</span> function, and that is <span class="math">\(u\)</span>, so</p>
<div class="math">
\[\alpha^{\prime} = \frac{=d\alpha}{du},\]</div>
<p>while in <span class="math">\(u^{\prime}\)</span> the differentiation is with
respect to <span class="math">\(x\)</span>, so</p>
<div class="math">
\[u^{\prime}=\frac{du}{dx}{\thinspace .}\]</div>
<p class="last">Similarly, <span class="math">\(f\)</span> is a function
of <span class="math">\(u\)</span>, so <span class="math">\(f^{\prime}\)</span> means <span class="math">\(df/du\)</span>.</p>
</div>
<p>When calculating the right-hand side vector <span class="math">\(F_i\)</span> and the coefficient
matrix <span class="math">\(J_{i,j}\)</span> in the linear system to be solved in each Newton
iteration, one must use
a previously computed <span class="math">\(u\)</span>, denoted by <span class="math">\(u^{-}\)</span>, for
the symbol <span class="math">\(u\)</span> in <a class="reference internal" href="#eq-nonlin-alglevel-1d-fe-newton-fi"><span class="std std-ref">(70)</span></a> and
<a class="reference internal" href="#eq-nonlin-alglevel-1d-fe-newton-jij"><span class="std std-ref">(71)</span></a>.
With this notation we have</p>
<div class="math" id="eq-nonlin-alglevel-1d-fe-newton-fi2">
\[\tag{72}
F_i =
    \int_0^L\left(
    {\alpha}(u^{-})u^{-\prime}{\psi}_i^{\prime} +
    (a-f(u^{-})){\psi}_i\right){\, \mathrm{d}x} -
    C{\psi}_i(0),\quad i\in{\mathcal{I}_s},\]</div>
<div class="math" id="eq-nonlin-alglevel-1d-fe-newton-jij2">
\[\tag{73}
J_{i,j} =
    \int_0^L
    ({\alpha}^{\prime}(u^{-})u^{-\prime}{\psi}_i^{\prime}{\psi}_j +
    {\alpha}(u^{-}){\psi}_i^{\prime}{\psi}_j^{\prime}
    + (a - f(u^{-})){\psi}_i{\psi}_j){\, \mathrm{d}x},
    \quad i,j\in{\mathcal{I}_s}{\thinspace .}\]</div>
<p>These expressions can be used for any basis <span class="math">\(\left\{ {{\psi}}_i \right\}_{i\in{\mathcal{I}_s}}\)</span>.
Choosing finite element functions for <span class="math">\({\psi}_i\)</span>, one will
normally want to compute the integral contribution cell by cell,
working in a reference cell. To this end, we restrict the
integration to one cell and transform the cell to <span class="math">\([-1,1]\)</span>.
The most recently computed approximation <span class="math">\(u^{-}\)</span> to <span class="math">\(u\)</span> becomes
<span class="math">\(\tilde u^{-}=\sum_t\tilde u^{-1}_t{\tilde{\varphi}}_t(X)\)</span> over the reference
element, where <span class="math">\(\tilde u^{-1}_t\)</span> is the value of <span class="math">\(u^{-}\)</span>
at global node (or degree of freedom)
<span class="math">\(q(e,t)\)</span> corresponding to the local node <span class="math">\(t\)</span> (or degree of freedom).
The formulas <a class="reference internal" href="#eq-nonlin-alglevel-1d-fe-newton-fi2"><span class="std std-ref">(72)</span></a> and
<a class="reference internal" href="#eq-nonlin-alglevel-1d-fe-newton-jij2"><span class="std std-ref">(73)</span></a> then change to</p>
<div class="math" id="eq-nonlin-alglevel-1d-fe-newton-fi2-e">
\[\tag{74}
\tilde F_r^{(e)} =
    \int_{-1}^1\left(
    {\alpha}(\tilde u^{-})\tilde u^{-\prime}{\tilde{\varphi}}_r^{\prime} +
    (a-f(\tilde u^{-})){\tilde{\varphi}}_r\right)\det J{\, \mathrm{d}X} -
    C{\tilde{\varphi}}_r(0),\]</div>
<div class="math" id="eq-nonlin-alglevel-1d-fe-newton-jij2-e">
\[\tag{75}
\tilde J_{r,s}^{(e)} =
    \int_{-1}^1
    ({\alpha}^{\prime}(\tilde u^{-})\tilde u^{-\prime}{\tilde{\varphi}}_r^{\prime}{\tilde{\varphi}}_s +
    {\alpha}(\tilde u^{-}){\tilde{\varphi}}_r^{\prime}{\tilde{\varphi}}_s^{\prime}
    + (a - f(\tilde u^{-})){\tilde{\varphi}}_r{\tilde{\varphi}}_s)\det J{\, \mathrm{d}X},\]</div>
<p>with <span class="math">\(r,s\in{I_d}\)</span> runs over the local degrees of freedom.</p>
<p>Many finite element programs require the user to provide <span class="math">\(F_i\)</span> and
<span class="math">\(J_{i,j}\)</span>. Some programs, like <a class="reference external" href="http://fenicsproject.org">FEniCS</a>,
are capable of automatically deriving <span class="math">\(J_{i,j}\)</span> if <span class="math">\(F_i\)</span>
is specified.</p>
<div class="section" id="dirichlet-conditions">
<h3>Dirichlet conditions<a class="headerlink" href="#dirichlet-conditions" title="Permalink to this headline">¶</a></h3>
<p>Incorporation of the Dirichlet values by assembling contributions from
all degrees of freedom and then modifying the linear system can
obviously be applied to Picard iteration as that method involves
a standard linear system. In the Newton system, however, the unknown
is a correction <span class="math">\(\delta u\)</span> to the solution. Dirichlet conditions
are implemented by inserting them in the initial guess <span class="math">\(u^{-}\)</span>
for the Newton iteration and implementing <span class="math">\(\delta u_i =0\)</span> for
all known degrees of freedom. The manipulation of the linear system
follows exactly the algorithm in the linear problems, the only
difference being that the known values are zero.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Discretization of 1D stationary nonlinear differential equations</a><ul>
<li><a class="reference internal" href="#finite-difference-discretization-1">Finite difference discretization</a></li>
<li><a class="reference internal" href="#solution-of-algebraic-equations">Solution of algebraic equations</a><ul>
<li><a class="reference internal" href="#the-structure-of-the-equation-system">The structure of the equation system</a></li>
<li><a class="reference internal" href="#picard-iteration-3">Picard iteration</a></li>
<li><a class="reference internal" href="#newton-s-method-4">Newton&#8217;s method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#galerkin-type-discretization">Galerkin-type discretization</a><ul>
<li><a class="reference internal" href="#fundamental-integration-problem">Fundamental integration problem</a></li>
</ul>
</li>
<li><a class="reference internal" href="#picard-iteration-defined-from-the-variational-form">Picard iteration defined from the variational form</a></li>
<li><a class="reference internal" href="#newton-s-method-defined-from-the-variational-form">Newton&#8217;s method defined from the variational form</a><ul>
<li><a class="reference internal" href="#dirichlet-conditions">Dirichlet conditions</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_nonlin003.html"
                        title="previous chapter">Linearization at the differential equation level</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_nonlin005.html"
                        title="next chapter">Multi-dimensional PDE problems</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._main_nonlin004.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_nonlin005.html" title="Multi-dimensional PDE problems"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_nonlin003.html" title="Linearization at the differential equation level"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Solving nonlinear ODE and PDE problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Hans Petter Langtangen.
  </div>
</div>

  </body>
</html>