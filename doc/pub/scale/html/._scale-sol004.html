<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Scaling of differential equations">
<meta name="keywords" content="scaling,non-dimensionalization,dimensionless variable,units,base unit,length,mass,time,dimension of physical quantities,units US,units British,units conversion,units software,multiple software runs,web interface (Parampool),graphical web interface,exponential decay,dimensionless variable,characteristic time,e-folding time,memoize function,dimensionless number,dimensionless number,dimensionless number,logistic equation,dimensionless number,frequency,frequency, angular,period (of oscillations),radians,angular frequency,quality factor $Q$,phase shift,dimensionless number,Peclet number,dimensionless number,Reynolds number,Navier-Stokes equations,dimensionless number,Reynolds number,Reynolds number,low Reynolds number flow,Stokes problem,Stokes' flow,Froude number,creeping flow,Strouhal number,vortex shedding,Euler number,Weber number,forced convection,Peclet number,Reynolds number,free convection,Grashof number,Reynolds number,Peclet number,Eckert number,Nusselt number">

<title>Scaling of differential equations</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('Dimensions and units', 1, 'scale:dimunit', 'scale:dimunit'),
              ('Base units and dimensions', 2, None, '___sec1'),
              ('Prefixes', 3, None, '___sec2'),
              ('SI vs US/British systems', 3, None, '___sec3'),
              ('PhysicalQuantity: object for computing with units',
               2,
               'scale:PQ',
               'scale:PQ'),
              ('Parampool: user interfaces with automatic unit conversion',
               2,
               'scale:parampool',
               'scale:parampool'),
              ('Example application', 3, None, '___sec6'),
              ('Pool', 3, None, '___sec7'),
              ('Fetching pool data and computing $s$', 3, None, '___sec8'),
              ('Reading command-line options', 3, None, '___sec9'),
              ('Setting default values in a file', 3, None, '___sec10'),
              ('Specifying multiple values of input parameters',
               3,
               None,
               '___sec11'),
              ('Generating a graphical user interface', 3, None, '___sec12'),
              ('Exponential decay', 1, 'sec:scale:decay', 'sec:scale:decay'),
              ('Example: Population dynamics', 3, None, '___sec14'),
              ('Example: Decay of pressure with altitude',
               3,
               None,
               '___sec15'),
              ('The technical steps of the scaling procedure',
               2,
               'sec:scale:decay:steps',
               'sec:scale:decay:steps'),
              ('Step 1: Identify independent and dependent variables',
               3,
               None,
               '___sec17'),
              ('Step 2: Make independent and dependent variables dimensionless',
               3,
               None,
               '___sec18'),
              ('Step 3: Derive the model involving only dimensionless variables',
               3,
               None,
               '___sec19'),
              ('Step 4: Make each term dimensionless', 3, None, '___sec20'),
              ('Step 5: Estimate the scales', 3, None, '___sec21'),
              ('Making software utilizing the dimensionless model',
               2,
               'sec:scale:decay:prog',
               'sec:scale:decay:prog'),
              ('Software for the original problem with dimensions',
               3,
               None,
               '___sec23'),
              ('A plain solution', 3, None, '___sec24'),
              ('Simplifying the implementation with joblib',
               3,
               None,
               '___sec25'),
              ('Scaling a generalized problem',
               2,
               'sec:scale:decay:body',
               'sec:scale:decay:body'),
              ('Exact solution', 3, None, '___sec27'),
              ('Theory', 3, None, '___sec28'),
              ('Software', 3, None, '___sec29'),
              ('Variable coefficients',
               2,
               'sec:scale:decay:jump',
               'sec:scale:decay:jump'),
              ('Scaling a cooling problem with constant surroundings',
               2,
               'scale:decay:cooling:const',
               'scale:decay:cooling:const'),
              ('Scaling a cooling problem with time-dependent surroundings',
               2,
               'scale:decay:cooling:osc',
               'scale:decay:cooling:osc'),
              ('Exact solution', 3, None, '___sec33'),
              ('Scaling', 3, None, '___sec34'),
              ('Software', 3, None, '___sec35'),
              ('Discussion of the time scale', 3, None, '___sec36'),
              ('Scaling a nonlinear ODE',
               2,
               'sec:scale:decay:nonlinear',
               'sec:scale:decay:nonlinear'),
              ('ODE systems for spreading of diseases', 2, None, '___sec38'),
              ('SIR model', 3, None, '___sec39'),
              ('SIRV model with finite immunity', 3, None, '___sec40'),
              ('Michaelis-Menten kinetics for biochemical reactions',
               2,
               'scale:MMK',
               'scale:MMK'),
              ('Classical analysis', 3, None, '___sec42'),
              ('Dimensionless ODE system', 3, None, '___sec43'),
              ('Determining scales', 3, None, '___sec44'),
              ('Analysis of the scaled system', 3, None, '___sec45'),
              ('Vibration problems', 1, 'sec:scale:vib', 'sec:scale:vib'),
              ('Undamped vibrations without forcing',
               2,
               'sec:scale:vib:undamped',
               'sec:scale:vib:undamped'),
              ('The first technical steps of scaling', 3, None, '___sec48'),
              ('The exact solution', 3, None, '___sec49'),
              ('Discussion of the displacement scale', 3, None, '___sec50'),
              ('Discussion of the time scale', 3, None, '___sec51'),
              ('Alternative displacement scale', 3, None, '___sec52'),
              ('About frequency and dimensions', 3, None, '___sec53'),
              ('Undamped vibrations with constant forcing',
               2,
               'sec:scale:vib:undamped:mg',
               'sec:scale:vib:undamped:mg'),
              ('Undamped vibrations with time-dependent forcing',
               2,
               'sec:scale:vib:undamped:F',
               'sec:scale:vib:undamped:F'),
              ('Investigating scales via analytical solutions',
               3,
               None,
               '___sec56'),
              ('The displacement and time scales', 3, None, '___sec57'),
              ('Finding the displacement scale from the differential equation',
               3,
               None,
               '___sec58'),
              ('Scaling with free vibrations as time scale',
               3,
               None,
               '___sec59'),
              ('Software', 3, None, '___sec60'),
              ('Choice of $u_c$ close to resonance', 3, None, '___sec61'),
              ('Unit size of all terms in the ODE', 3, None, '___sec62'),
              ('Choice of $u_c$ when $\\psi\\gg\\omega$',
               3,
               None,
               '___sec63'),
              ('Displacement scale based on $I$', 3, None, '___sec64'),
              ('Damped vibrations with forcing',
               2,
               'sec:scale:vib:damped:F',
               'sec:scale:vib:damped:F'),
              ('The exact solution', 3, None, '___sec66'),
              ('Choosing scales', 3, None, '___sec67'),
              ('Choice of $u_c$ at resonance', 3, None, '___sec68'),
              ('Choice of $u_c$ when $\\omega\\gg\\psi$',
               3,
               None,
               '___sec69'),
              ('Choice of $u_c$ when $\\omega\\ll\\psi$',
               3,
               None,
               '___sec70'),
              ('Oscillating electric circuits', 2, None, '___sec71'),
              ('The wave equation', 1, 'sec:scale:wave', 'sec:scale:wave'),
              ('Simple homogeneous Dirichlet conditions',
               2,
               None,
               '___sec73'),
              ('Implementation of the scaled wave equation',
               2,
               None,
               '___sec74'),
              ('Waves on a string', 3, None, '___sec75'),
              ('Detecting an already computed case', 3, None, '___sec76'),
              ('Time-dependent Dirichlet condition',
               2,
               'scale:wave:pde2',
               'scale:wave:pde2'),
              ('Velocity initial condition',
               2,
               'scale:wave:pde2:Vcond',
               'scale:wave:pde2:Vcond'),
              ('Variable wave velocity and forcing',
               2,
               'scale:wave:pde2:cvar',
               'scale:wave:pde2:cvar'),
              ('Damped wave equation',
               2,
               'scale:wave:pde2:damped',
               'scale:wave:pde2:damped'),
              ('A three-dimensional wave equation problem',
               2,
               None,
               '___sec81'),
              ('The diffusion equation',
               1,
               'sec:scale:diffu',
               'sec:scale:diffu'),
              ('Homogeneous diffusion equation',
               2,
               'sec:scale:diffu:homo1D',
               'sec:scale:diffu:homo1D'),
              ('Simplified 1D PDE', 3, None, '___sec84'),
              ('Generalized PDE', 3, None, '___sec85'),
              ('Jump boundary condition', 2, None, '___sec86'),
              ('Oscillating Dirichlet condition', 2, None, '___sec87'),
              ('Diffusion equation with source term',
               2,
               'sec:scale:diffu:source',
               'sec:scale:diffu:source'),
              ("Fisher's equation",
               2,
               'sec:scale:diffu:Fisher',
               'sec:scale:diffu:Fisher'),
              ('The convection-diffusion equation',
               1,
               'scale:convdiff',
               'scale:convdiff'),
              ('Convection-diffusion without a force term',
               2,
               None,
               '___sec91'),
              ('Stationary PDE', 2, None, '___sec92'),
              ('Convection-diffusion with a force term',
               2,
               'scale:convdiff',
               'scale:convdiff'),
              ('The equations of linear elasticity', 1, None, '___sec94'),
              ('The Navier-Stokes equations',
               1,
               'sec:scale:ns',
               'sec:scale:ns'),
              ('The momentum equation without body forces',
               2,
               None,
               '___sec96'),
              ('The most common dimensionless form of the Navier-Stokes equations',
               2,
               None,
               '___sec97'),
              ('Scaling of time for low Reynolds numbers',
               2,
               None,
               '___sec98'),
              ('Shear stress as pressure scale', 2, None, '___sec99'),
              ('Including the gravity force', 2, None, '___sec100'),
              ('Oscillating boundary conditions', 2, None, '___sec101'),
              ('The Euler number', 2, None, '___sec102'),
              ('Free surface conditions', 2, None, '___sec103'),
              ('Thermal convection', 1, None, '___sec104'),
              ('Forced convection', 2, None, '___sec105'),
              ('Free convection',
               2,
               'scale:fluid:forced_convection',
               'scale:fluid:forced_convection'),
              ('Governing equations', 3, None, '___sec107'),
              ('Heating by viscous effects', 3, None, '___sec108'),
              ('Relation between density and temperature',
               3,
               None,
               '___sec109'),
              ('Comment on the form of the equation of continuity',
               3,
               None,
               '___sec110'),
              ('The Boussinesq approximation', 3, None, '___sec111'),
              ('Scaling', 3, None, '___sec112'),
              ('The Grashof, Prandtl, and Eckert numbers',
               2,
               None,
               '___sec113'),
              ('Heat transfer at boundaries', 2, None, '___sec114'),
              ('The bidomain model in electrophysiology',
               1,
               'scale:bidomain',
               'scale:bidomain'),
              ('Two-phase porous media flow', 1, None, '___sec116'),
              ('The Euler equations of gas dynamics', 1, None, '___sec117'),
              ('Exercises', 1, None, '___sec118'),
              ('Exercise 1: Perform unit conversion',
               2,
               'sec:scale:exer:US2SI1',
               'sec:scale:exer:US2SI1'),
              ('Problem 2: Scale a simple formula',
               2,
               'sec:scale:exer:ball_y',
               'sec:scale:exer:ball_y'),
              ('Problem 3: Scale a nonlinear ODE',
               2,
               'sec:scale:exer:ball_y_wdrag',
               'sec:scale:exer:ball_y_wdrag'),
              ('Exercise 4: Implement a scaled model with jump',
               2,
               'sec:scale:exer:decay:jump',
               'sec:scale:exer:decay:jump'),
              ('Exercise 5: Implement a scaled model for cooling',
               2,
               'sec:scale:exer:decay:cooling',
               'sec:scale:exer:decay:cooling'),
              ('Problem 6: Scale variable coefficients',
               2,
               'scale:decay:exer:decay:step',
               'scale:decay:exer:decay:step'),
              ('Exercise 7: Alternative scalings of a cooling model',
               2,
               'scale:decay:exer:cooling:Ts',
               'scale:decay:exer:cooling:Ts'),
              ('Exercise 8: Alternative scalings of a cooling model',
               2,
               'scale:decay:exer:nonlin:logistic2',
               'scale:decay:exer:nonlin:logistic2'),
              ('Exercise 9: Scale projectile motion',
               2,
               'scale:vib:exer:projectile',
               'scale:vib:exer:projectile'),
              ('Problem 10: Scale a predator-pray model',
               2,
               'scale:decay:exer:predpray',
               'scale:decay:exer:predpray'),
              ('Problem 11: Find the period of sinusoidal signals',
               2,
               'scale:decay:exer:sine',
               'scale:decay:exer:sine'),
              ('Remarks', 3, None, '___sec130'),
              ('Problem 12: Scale the pendulum equation',
               2,
               'sec:scale:exer:pendulum',
               'sec:scale:exer:pendulum'),
              ("Problem 13: Scale Duffing's equation",
               2,
               'scale:vib:exer:Duffing',
               'scale:vib:exer:Duffing'),
              ('Problem 14: Scale a stationary Couette flow',
               2,
               'scale:vib:exer:stationary_Couette',
               'scale:vib:exer:stationary_Couette'),
              ('Remarks', 3, None, '___sec134'),
              ('Problem 15: Scale a starting Couette flow',
               2,
               'scale:vib:exer:starting_Couette',
               'scale:vib:exer:starting_Couette'),
              ('Exercise 16: Scale Couette flow with pressure gradient',
               2,
               'scale:vib:exer:Couette_wpressure',
               'scale:vib:exer:Couette_wpressure'),
              ('Exercise 17: Suggestions...',
               2,
               'scale::exer:suggest',
               'scale::exer:suggest'),
              ('Bibliography', 1, None, '___sec138')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\u}{\boldsymbol{u}}
\renewcommand{\v}{\boldsymbol{v}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\dfc}{\alpha}  % diffusion coefficient
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="scale-sol.html">Scaling of differential equations</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._scale-sol003.html#scale:dimunit" style="font-size: 80%;">Dimensions and units</a></li>
     <!-- navigation toc: --> <li><a href="#sec:scale:decay" style="font-size: 80%;">Exponential decay</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol005.html#sec:scale:vib" style="font-size: 80%;">Vibration problems</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol006.html#sec:scale:wave" style="font-size: 80%;">The wave equation</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol007.html#sec:scale:diffu" style="font-size: 80%;">The diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol008.html#scale:convdiff" style="font-size: 80%;">The convection-diffusion equation</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol009.html#___sec94" style="font-size: 80%;">The equations of linear elasticity</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol009.html#sec:scale:ns" style="font-size: 80%;">The Navier-Stokes equations</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol009.html#___sec104" style="font-size: 80%;">Thermal convection</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol009.html#scale:bidomain" style="font-size: 80%;">The bidomain model in electrophysiology</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol009.html#___sec116" style="font-size: 80%;">Two-phase porous media flow</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol009.html#___sec117" style="font-size: 80%;">The Euler equations of gas dynamics</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol009.html#___sec118" style="font-size: 80%;">Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._scale-sol010.html#___sec138" style="font-size: 80%;">Bibliography</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0004"></a>
<!-- !split -->

<h1 id="sec:scale:decay">Exponential decay</h1>

<p>
Processes undergoing exponential reduction can be modeled by the ODE
problem
$$
\begin{equation}
u'(t) = -au(t),\quad u(0)=I,
\tag{2}
\end{equation}
$$

where \( a,I>0 \) are prescribed constants and \( u(t) \) is the unknown function.
For this particular model, we can easily derive the solution, \( u(t)=Ie^{-at} \),
which is helpful to have in mind during the scaling process.

<h3 id="___sec14">Example: Population dynamics </h3>

<p>
The evolution of a population of humans, animals, cells, etc.,
under unlimited access to resources, can be
modeled by <a href="#mjx-eqn-2">(2)</a>. Then \( u \) is the number of
individuals in the population, strictly speaking an integer, but well
modeled by a real number in large populations.
The parameter \( a \) is the increase in the number of individuals per
time and per individual.

<h3 id="___sec15">Example: Decay of pressure with altitude </h3>

<p>
The simple model <a href="#mjx-eqn-2">(2)</a> also governs the pressure
in the atmosphere (under many assumptions). In this case \( u \) is the
pressure, measured in \( \hbox{Nm}^{-2} \); \( t \) is the hight in meters;
and \( a=M/(R^*T) \), where
\( M \) is the molar mass of the Earth's air (0.029 kg/mol),
\( R^* \) is the universal
gas constant (\( 8.314\,\frac{\hbox{Nm}}{\hbox{mol\, K}} \)),
and \( T \) is the temperature in Kelvin (K).
The temperature depends on the hight so we have \( a=a(t) \).

<h2 id="sec:scale:decay:steps">The technical steps of the scaling procedure</h2>

<h3 id="___sec17">Step 1: Identify independent and dependent variables </h3>

<p>
There is one independent variable, time \( t \), and one dependent variable,
\( u \).

<h3 id="___sec18">Step 2: Make independent and dependent variables dimensionless </h3>

<p>
We introduce a new dimensionless \( t \), called \( \bar t \), defined by
$$
\begin{equation}
\bar t = \frac{t}{t_c},
\end{equation}
$$

where \( t_c \) is a <em>characteristic value</em> of \( t \). Similarly,
we introduce a dimensionless \( u \), named \( \bar u \), according to
$$
\begin{equation}
\bar u = \frac{u}{u_c},
\end{equation}
$$

where \( u_c \) is a constant <em>characteristic size</em> of \( u \). When \( u \) has a specific
interpretation, say when <a href="#mjx-eqn-2">(2)</a> models pressure
in an atmospheric layer, \( u_c \) would be referred to as characteristic pressure.
For a decaying population, \( u \) may be a characteristic number of
members in the population.

<h3 id="___sec19">Step 3: Derive the model involving only dimensionless variables </h3>

<p>
The next task is to insert the new dimensionless variables in the
governing mathematical model. That is, we replace \( t \) by \( t_c\bar t \)
and \( u \) by \( u_c\bar u \) in <a href="#mjx-eqn-2">(2)</a>. The derivative
with respect to \( \bar t \) is derived as
$$ \frac{du}{dt} = \frac{d (u_c\bar u)}{d\bar t}{d\bar t}{dt}
= u_c\frac{d\bar u}{d\bar t}\frac{1}{t_c} =
\frac{u_c}{t_c}\frac{d\bar u}{d\bar t}\tp
$$

The model <a href="#mjx-eqn-2">(2)</a> now becomes

$$
\begin{equation}
\frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = -au_c\bar u,\quad u_c\bar u(0)=I\tp
\tag{3}
\end{equation}
$$

<h3 id="___sec20">Step 4: Make each term dimensionless </h3>

<p>
Equation <a href="#mjx-eqn-3">(3)</a> still has terms with
dimensions. To make each term dimensionless, we usually divide by
the coefficient in front of the term with the highest time derivative
(but dividing by any coefficient will do). The result is

$$
\begin{equation}
\frac{d\bar u}{d\bar t} = -at_c\bar u,\quad \bar u(0)=u_c^{-1}I
\tp
\tag{4}
\end{equation}
$$

<h3 id="___sec21">Step 5: Estimate the scales </h3>

<p>
A characteristic quantity like \( t_c \) reflects the time scale in the
problem. Estimating such a time scale is certainly
the most challenging part of the scaling procedure. There are different
ways to reason. The first is to aim at a size of \( \bar u \) and its derivatives
that is of order unity. If \( u_c \) is chosen such that \( |\bar u| \) is
of size unity, we see from <a href="#mjx-eqn-4">(4)</a> that
\( d\bar u/d\bar t \) is of the size of \( \bar u \) (i.e., unity)
if we choose \( t_c = 1/a \).

<p>
Alternatively, we may look at a special case of the model where we have
analytical insight. In the present problem we are lucky to know the
exact solution for any value of the input data. For exponential
decay, \( u(t)\sim e^{-at} \), it is common to define a characteristic time
scale \( t_c \) as the time it takes to reduce \( u \) by a factor of \( 1/e \) (also
called the <em>e-folding time</em>):

$$ e^{-at_c} = \frac{1}{e}e^{-a\cdot 0}\quad\Rightarrow\quad e^{-at_c}=e^{-1},
$$

from which it follows that \( t_c = 1/a \).

<p>
In this example, two different, yet common ways of reasoning, lead to the
same value of \( t_c \). However, instead of using the e-folding time we
could use the half-time of the exponential decay as characteristic
time, which is also a very common measure of the time scale in such
processes. The half time is defined as the time it takes to halve \( u \):

$$ e^{-at_c} = \frac{1}{2}e^{-a\cdot 0}
\quad\Rightarrow\quad t_c = a^{-1}\ln 2\tp$$

There is a factor \( \ln 2 =0.69 \) difference from the other \( t_c \) value.
As long as the factor is not an order of magnitude or more different,
we do not pay attention to such small differences.
Although \( t_c = a^{-1}\ln 2 \) is a fine time scale to be used in this
problem, it leads to a scaled differential equation \( u'=-(\ln 2) u \),
which is fine, but an unusual form. People tend to prefer \( u'=-u \),
which arises from \( t_c=1/a \). We shall therefore use the latter as
time scale.

<p>
Regarding \( u_c \), we may look at the initial condition
and realize that the choice \( u_c=I \) makes \( \bar u(0)=1 \). For \( \bar t>0 \)
we know that \( \bar u \) is decreasing, so \( u_c=I \)
gives us \( \bar u\leq 1 \), which is always a goal.
Alternatively, we may look to analytical insight, \( u(t)=Ie^{-at} \), to
see that \( u\leq I \), such that \( u_c=I \) gives \( \bar u\leq 1 \).

<p>
With \( t_c=1/a \) and \( u_c=I \), we have the final dimensionless model

$$
\begin{equation}
\frac{d\bar u}{d\bar t} = -\bar u,\quad \bar u(0)=1
\tp
\tag{5}
\end{equation}
$$

This is a remarkable result in the sense that <em>all physical parameters</em>
(\( a \) and \( I \))
are removed from the model! Or more precisely, there are no physical input
parameters to assign
before using the model. In particular, numerical investigations of the original
model <a href="#mjx-eqn-2">(2)</a> would need experiments with different
\( a \) and \( I \) values, while numerical investigations of
<a href="#mjx-eqn-5">(5)</a> can be limited to <em>a single run</em>! As soon
as we have computed the curve \( \bar u(\bar t) \), we can find the
solution \( u(t) \) of <a href="#mjx-eqn-2">(2)</a> by

$$
\begin{equation}
u(t) = u_c\bar u(t/t_c) = I\bar u(at)
\tp
\tag{6}
\end{equation}
$$

This particular transformation actually means stretching the \( \bar t \) and
\( \bar u \) axes in a plot of \( \bar u(\bar t) \) by the factors \( a \) and \( I \),
respectively.

<p>
It is very common to drop the bars when the scaled problem has been
derived and work further with <a href="#mjx-eqn-5">(5)</a> simply
written as

$$
\frac{du}{dt} = -u,\quad u(0)=1
\tp
$$

<h2 id="sec:scale:decay:prog">Making software utilizing the dimensionless model</h2>

<p>
Software for solving <a href="#mjx-eqn-2">(2)</a> could take advantage
of the fact that only one simulation of <a href="#mjx-eqn-5">(5)</a>
is necessary. As soon as we have \( \bar u(\bar t) \) accessible,
a simple scaling <a href="#mjx-eqn-6">(6)</a> computes the real \( u(t) \)
for any given input data \( a \) and \( I \). Although the numerical computation of
\( u(t) \) from <a href="#mjx-eqn-2">(2)</a> is very fast in this simple model
problem, using <a href="#mjx-eqn-6">(6)</a> is very much faster than
computing a full numerical solution in more complicated
differential equation problems.

<p>
We can compute with the dimensionless model <a href="#mjx-eqn-5">(5)</a>
in two ways, either make a solver for <a href="#mjx-eqn-5">(5)</a>
or reuse a solver for <a href="#mjx-eqn-2">(2)</a> with the parameters
appropriately set (\( I=1 \), \( a=1 \)).
The latter approach has the advantage of giving us
software that works both with a dimensionless model and a model
with dimensions and all the original physical parameters.

<h3 id="___sec23">Software for the original problem with dimensions </h3>

<p>
We base our solver for
<a href="#mjx-eqn-5">(5)</a> on a solver for <a href="#mjx-eqn-2">(2)</a>.
Assume that we have some module <code>decay.py</code> that offers the following
functions:

<ul>
  <li> <code>solver(I, a, T, dt, theta=0.5)</code> for returning the solution arrays
    <code>u</code> and <code>t</code> for <a href="#mjx-eqn-2">(2)</a> solved by the \( \theta \) rule.</li>
  <li> <code>read_command_line_argparse()</code> for reading parameters in the problem
    from the command line and returning them: <code>I</code>, <code>a</code>, <code>T</code>, <code>theta</code> (\( \theta \)),
    and a list of \( \Delta t \) values for time steps. (We shall only make
    use of the first \( \Delta t \) value.)</li>
</ul>

The basic statements for solving <a href="#mjx-eqn-2">(2)</a> are
then

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decay</span> <span style="color: #008000; font-weight: bold">import</span> solver, read_command_line_argparse
I, a, T, theta, dt_values <span style="color: #666666">=</span> read_command_line_argparse()
u, t <span style="color: #666666">=</span> solver(I, a, T, dt_values[<span style="color: #666666">0</span>], theta)

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">import</span> plot, show
plot(t, u)
show()
</pre></div>
<p>
The module <a href="http://tinyurl.com/nm5587k/softeng1/decay.py" target="_self"><tt>decay.py</tt></a> is developed
and explained in

<p>
the document <a href="http://tinyurl.com/k3sdbuv/pub/softeng1" target="_self">Scientific software engineering; ODE model</a> <a href="._scale-sol010.html#Langtangen_deqbook_softeng1">[5]</a>.

<p>
To solve the dimensionless problem, just fix \( I=1 \) and \( a=1 \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">I, a, T, theta, dt_values <span style="color: #666666">=</span> read_command_line_argparse()
u, t <span style="color: #666666">=</span> solver(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=1</span>, T<span style="color: #666666">=</span>T, dt<span style="color: #666666">=</span>dt_values[<span style="color: #666666">0</span>], theta<span style="color: #666666">=</span>theta)
</pre></div>

<h3 id="___sec24">A plain solution </h3>

<p>
A key observation, as mentioned, is that we need to solve the problem
<a href="#mjx-eqn-5">(5)</a> only once. All solutions
corresponding to different \( I \) and \( a \) values in the original physical
problem can be recovered by scaling this single solution with formula
<a href="#mjx-eqn-6">(6)</a>.  We therefore want to make software that
takes advantage of this fact. When requesting a solution, we see if it
has already been computed and stored in a file, and if so, the data
can be retrieved from file, otherwise we have to compute a new
solution and store it in a file.

<p>
The computational recipe goes as follows.

<ol>
<li> A computed solution \( \bar u(\bar t) \) is stored in a file with name <code>u_scaled.dat</code>.</li>
<li> The first line in the file contains \( T \), \( \Delta t \), and \( \theta \)
   used to compute the stored \( \bar u(\bar t) \).</li>
<li> The \( T \), \( \Delta t \), and \( \theta \) parameters are read from the
   first line in the file and compared with those required by the user.</li>
<li> If one of the three parameters changes, the solution in the file
   must be recomputed.</li>
</ol>

The actual code may look as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decay</span> <span style="color: #008000; font-weight: bold">import</span> solver <span style="color: #008000; font-weight: bold">as</span> solver_unscaled
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_scaled</span>(T, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;=-u, u(0)=1 for (0,T] with step dt and theta method.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Is the scaled problem already solved and dimensionless</span>
    <span style="color: #408080; font-style: italic"># curve available from file?</span>
    <span style="color: #408080; font-style: italic"># See if u_scaled.dat has the right parameters.</span>
    already_computed <span style="color: #666666">=</span> <span style="color: #008000">False</span>
    datafile <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;u_scaled.dat&#39;</span>
    <span style="color: #008000; font-weight: bold">if</span> os<span style="color: #666666">.</span>path<span style="color: #666666">.</span>isfile(datafile):      <span style="color: #408080; font-style: italic"># does u_scaled.dat exist?</span>
        infile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(datafile, <span style="color: #BA2121">&#39;r&#39;</span>)
        infoline <span style="color: #666666">=</span> infile<span style="color: #666666">.</span>readline()  <span style="color: #408080; font-style: italic"># read the first line</span>
        words <span style="color: #666666">=</span> infoline<span style="color: #666666">.</span>split()      <span style="color: #408080; font-style: italic"># split line into words</span>
        T_, dt_, theta_ <span style="color: #666666">=</span> [<span style="color: #008000">float</span>(w) <span style="color: #008000; font-weight: bold">for</span> w <span style="color: #AA22FF; font-weight: bold">in</span> words]
        <span style="color: #008000; font-weight: bold">if</span> T_ <span style="color: #666666">==</span> T <span style="color: #AA22FF; font-weight: bold">and</span> dt_ <span style="color: #666666">==</span> dt <span style="color: #AA22FF; font-weight: bold">and</span> theta_ <span style="color: #666666">==</span> theta:
            <span style="color: #408080; font-style: italic"># The file was computed with the desired data, load</span>
            <span style="color: #408080; font-style: italic"># the solution into arrays</span>
            data <span style="color: #666666">=</span> np<span style="color: #666666">.</span>loadtxt(infile)
            u_scaled <span style="color: #666666">=</span> data[<span style="color: #666666">1</span>,:]
            t_scaled <span style="color: #666666">=</span> data[<span style="color: #666666">0</span>,:]
            <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Read scaled solution from file&#39;</span>
            already_computed <span style="color: #666666">=</span> <span style="color: #008000">True</span>
        infile<span style="color: #666666">.</span>close()
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> already_computed:
        <span style="color: #408080; font-style: italic"># T, dt or theta is different from u_scaled.dat</span>
        u_scaled, t_scaled <span style="color: #666666">=</span> \ 
           solver_unscaled(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=1</span>, T<span style="color: #666666">=</span>T, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
        outfile <span style="color: #666666">=</span> <span style="color: #008000">open</span>(datafile, <span style="color: #BA2121">&#39;w&#39;</span>)
        outfile<span style="color: #666666">.</span>write(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%f</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%f</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%.1f</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (T, dt, theta))
        np<span style="color: #666666">.</span>savetxt(outfile, np<span style="color: #666666">.</span>array([t_scaled, u_scaled]))
        outfile<span style="color: #666666">.</span>close()
        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Computed scaled solution&#39;</span>
    <span style="color: #008000; font-weight: bold">return</span> u_scaled, t_scaled

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">unscale</span>(u_scaled, t_scaled, I, a):
    <span style="color: #008000; font-weight: bold">return</span> I<span style="color: #666666">*</span>u_scaled, a<span style="color: #666666">*</span>t_scaled
</pre></div>
<p>
The <code>np.savetxt</code> function saves a two-dimensional arrays (&quot;table&quot;) to
a text file, and the <code>np.loadtxt</code> function can load the data back
into the program.

<h3 id="___sec25">Simplifying the implementation with joblib </h3>

<p>
The Python package <code>joblib</code> has functionality that is very convenient
for implementing the <code>solver_scaled</code> function. The first time a
function is called with a set of arguments, the statements in the
function are executed and the return value is saved to file. If the
function is called again with the same set of arguments, the
statements in the function are not executed, but the return value is
read from file. In computer science, one would say that <code>joblib</code> in
this way provides <em>memorization</em> functionality for Python functions.
This functionality is particularly aimed at large-scale computations
with arrays that one would like to avoid being recomputed.

<p>
Utilizing <code>joblib</code>, our <code>solver_scaled</code> function can be dramatically
simplified:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_scaled</span>(T, dt, theta):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;=-u, u(0)=1 for (0,T] with step dt and theta method.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Computing the numerical solution&#39;</span>
    <span style="color: #008000; font-weight: bold">return</span> solver_unscaled(I<span style="color: #666666">=1</span>, a<span style="color: #666666">=1</span>, T<span style="color: #666666">=</span>T, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)
</pre></div>
<p>
Then we create some &quot;computer memory on disk&quot;, i.e., some disk space to
store the result of a call to the <code>solver_scaled</code> function. Thereafter,
we redefine the name <code>solver_scaled</code> to a new function, created
by <code>joblib</code>, which calls our original <code>solver_scaled</code> function
if necessary and otherwise loads data from file:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">joblib</span>
disk_memory <span style="color: #666666">=</span> joblib<span style="color: #666666">.</span>Memory(cachedir<span style="color: #666666">=</span><span style="color: #BA2121">&#39;temp&#39;</span>)
solver_scaled <span style="color: #666666">=</span> disk_memory<span style="color: #666666">.</span>cache(solver_scaled)
</pre></div>
<p>
The solutions are actually stored in files in the directory <code>temp</code>.

<p>
A typical use case is to read values from the command line,
solve the unscaled problem (if necessary), scale the solution, and visualize
the solution with dimension:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>():
    <span style="color: #408080; font-style: italic"># Read parameters, solve and plot</span>
    I, a, T, theta, dt_values <span style="color: #666666">=</span> read_command_line_argparse()
    dt <span style="color: #666666">=</span> dt_values[<span style="color: #666666">0</span>]  <span style="color: #408080; font-style: italic"># use only the first dt value</span>
    u_scaled, t_scaled <span style="color: #666666">=</span> solver_scaled(T, dt, theta)
    u, t <span style="color: #666666">=</span> unscale(u_scaled, t_scaled, I, a)

    plt<span style="color: #666666">.</span>figure()
    plt<span style="color: #666666">.</span>plot(t_scaled, u_scaled)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;scaled time&#39;</span>); plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;scaled velocity&#39;</span>)
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;Universial solution of scaled problem&#39;</span>)
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp1.png&#39;</span>);  plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp1.pdf&#39;</span>)

    plt<span style="color: #666666">.</span>figure()
    plt<span style="color: #666666">.</span>plot(t, u)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>); plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;u&#39;</span>)
    plt<span style="color: #666666">.</span>title(<span style="color: #BA2121">&#39;I=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, a=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">, theta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (I, a, theta))
    plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.png&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp2.pdf&#39;</span>)
    plt<span style="color: #666666">.</span>show()
</pre></div>
<p>
The complete code resides in the file
<a href="http://tinyurl.com/nm5587k/scale/decay_scaled.py" target="_self"><tt>decay_scaled.py</tt></a>.

<p>
Note that we write a message <code>Computing the numerical solution</code> inside
the <code>solver_scaled</code> function. We can then easily detect when
the solution is actually computed and when it is simply read from file.
Here is a demo:

<p>

<!-- code=text (!bc sys) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">Terminal&gt; # Very first run
Terminal&gt; python decay_scaled.py --T 7 --a 1 --I 0.5 --dt 0.2
[Memory] Calling __main__--home-hpl...
solver_scaled-alias(7.0, 0.2, 0.5)
Computing the numerical solution

Terminal&gt; # No change of T, dt, theta - can reuse solution in file
Terminal&gt; python decay_scaled.py --T 7 --a 4 --I 2.5 --dt 0.2

Terminal&gt; # Change of dt, must recompute
Terminal&gt; python decay_scaled.py --T 7 --a 4 --I 2.0 --dt 0.5
[Memory] Calling __main__--home-hpl...
solver_scaled-alias(7.0, 0.5, 0.5)
Computing the numerical solution

Terminal&gt; # Change of dt again, but dt=0.2 is already in a file
Terminal&gt; python decay_scaled.py --T 7 --a 0.5 --I 1 --dt 0.2
</pre></div>
<p>
We realize that <code>joblib</code> has access to all previous runs and does not
recompute unless it is strictly required. Our previous implementation
without <code>joblib</code>
used only one file (for one numerical case)
and will therefore perform many more calls to
<code>solver_unscaled</code>.

<p>
A plot of the scaled and unscaled solution appears in Figure
<a href="#sec:decay:fig:simplest">2</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 2:  Scaled (left) and unscaled (right) exponential decay. <div id="sec:decay:fig:simplest"></div> </p></center>
<p><img src="fig-scale/decay.png" align="bottom" width=800></p>
</center>

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>On the implementation of a simple memoize function.</b>
A memoized function recalls
previous results when the same set
of arguments is encountered. That is, the function caches its results.
A simple implementation stores the arguments in a function call and
the returned results in a
dictionary, and if the arguments are seen again, one looks up
in the dictionary and return previously computed results:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">class</span> <span style="color: #0000FF; font-weight: bold">Memoize</span>:
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__init__</span>(<span style="color: #008000">self</span>, f):
        <span style="color: #008000">self</span><span style="color: #666666">.</span>f <span style="color: #666666">=</span> f
        <span style="color: #008000">self</span><span style="color: #666666">.</span>memo <span style="color: #666666">=</span> {}  <span style="color: #408080; font-style: italic"># map arguments to results</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">__call__</span>(<span style="color: #008000">self</span>, <span style="color: #666666">*</span>args):
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> args <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>memo:
            <span style="color: #008000">self</span><span style="color: #666666">.</span>memo[args] <span style="color: #666666">=</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>f(<span style="color: #666666">*</span>args)
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #008000">self</span><span style="color: #666666">.</span>memo[args]

<span style="color: #408080; font-style: italic"># Wrap my_compute_function(arg1, arg2, ...)</span>
my_compute_function <span style="color: #666666">=</span> Memoize(my_compute_function)
</pre></div>
<p>
The memoize functionality in <code>joblib.Memory</code> is more sophisticated and
can work very efficiently with large array data structures as arguments.
Note that the simple version above can only be used when all arguments to
the function <code>f</code> are immutable (since the key in a dictionary has to be
immutable).
</div>


<h2 id="sec:scale:decay:body">Scaling a generalized problem</h2>

<p>
Now we consider an extension of the exponential decay ODE to the
form

$$
\begin{equation}
u'(t) = -au(t) + b,\quad u(0)=I
\tag{7}
\tp
\end{equation}
$$

One particular model, with constant \( a \) and \( b \),
is a spherical micro-organism falling in air,

$$
\begin{equation}
u' = - \frac{3\pi d\mu}{\varrho_b V} u + g\left(\frac{\varrho}{\varrho_b} -1\right),
\tag{8}
\end{equation}
$$

where \( d \), \( \mu \), \( \varrho_b \), \( \varrho \), \( V \), and \( g \) are physical
parameters. The function \( u(t) \) represents the vertical velocity,
being positive upwards.
We shall use this model in the following.

<h3 id="___sec27">Exact solution </h3>

<p>
It can be handy to have the exact solution for reference, in case
of constant \( a \) and \( b \):

$$ \uex(t) = \frac{e^{-at}}{a}\left( b(e^{at}-1) + aI\right)
\tp
$$

<p>
It can be very handy to use a symbolic computation tool such as SymPy
to aid us in solving differential equations.
Let us therefore demonstrate how SymPy can be used to find this solution.
First we define the parameters in the problem as symbols
and \( u(t) \) as a function:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> t, a, b, I <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;t a b I&#39;</span>, real<span style="color: #666666">=</span><span style="color: #008000">True</span>, positive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;u&#39;</span>, cls<span style="color: #666666">=</span>Function)
</pre></div>
<p>
The next task is to define the differential equation, either as
a symbolic expression that is to equal zero, or as
an equation <code>Eq(lhs, rhs)</code> with <code>lhs</code> and <code>rhs</code> as expressions for
the left- and right-hand side):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># Define differential equation</span>
<span style="color: #666666">&gt;&gt;&gt;</span> eq <span style="color: #666666">=</span> diff(u(t), t) <span style="color: #666666">+</span> a<span style="color: #666666">*</span>u(t) <span style="color: #666666">-</span> b
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #408080; font-style: italic"># or</span>
<span style="color: #666666">&gt;&gt;&gt;</span> eq <span style="color: #666666">=</span> Eq(diff(u(t), t), <span style="color: #666666">-</span>a<span style="color: #666666">*</span>u(t) <span style="color: #666666">+</span> b)
</pre></div>
<p>
The differential equation can be solved by the <code>dsolve</code> function, yielding
an equation of the form <code>u(t) == expression</code>. We want to grab the
expression on the right-hand side as our solution:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> sol <span style="color: #666666">=</span> dsolve(eq, u(t))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> sol
u(t) <span style="color: #666666">==</span> (b <span style="color: #666666">+</span> exp(a<span style="color: #666666">*</span>(C1 <span style="color: #666666">-</span> t)))<span style="color: #666666">/</span>a
<span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> sol<span style="color: #666666">.</span>rhs                    <span style="color: #408080; font-style: italic"># grab solution</span>
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> u
(b <span style="color: #666666">+</span> exp(a<span style="color: #666666">*</span>(C1 <span style="color: #666666">-</span> t)))<span style="color: #666666">/</span>a
</pre></div>
<p>
The solution contains the unknown integration constant <code>C1</code>, which must
be determined by the initial condition. We form the equation arising
from the initial condition \( u(0)=I \):

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> C1 <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;C1&#39;</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> eq <span style="color: #666666">=</span> Eq(u<span style="color: #666666">.</span>subs(t, <span style="color: #666666">0</span>), I)   <span style="color: #408080; font-style: italic"># substitute t by 0 in u</span>
<span style="color: #666666">&gt;&gt;&gt;</span> sol <span style="color: #666666">=</span> solve(eq, C1)
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> sol
[log(I<span style="color: #666666">*</span>a <span style="color: #666666">-</span> b)<span style="color: #666666">/</span>a]
</pre></div>
<p>
The one solution that was found must then be substituted back in the
expression <code>u</code> to yield the final solution:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> u<span style="color: #666666">.</span>subs(C1, sol[<span style="color: #666666">0</span>])
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> u
(b <span style="color: #666666">+</span> exp(a<span style="color: #666666">*</span>(<span style="color: #666666">-</span>t <span style="color: #666666">+</span> log(I<span style="color: #666666">*</span>a <span style="color: #666666">-</span> b)<span style="color: #666666">/</span>a)))<span style="color: #666666">/</span>a
</pre></div>
<p>
As in mathematics with pen and paper, we strive to simplify
expressions also in symbolic computing software.
This frequently requires some trial and error
process with SymPy's simplification functions. A very standard
first try is to expand everything and run simplification algorithms:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> u <span style="color: #666666">=</span> simplify(expand(u))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> u
(I<span style="color: #666666">*</span>a <span style="color: #666666">+</span> b<span style="color: #666666">*</span>exp(a<span style="color: #666666">*</span>t) <span style="color: #666666">-</span> b)<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>a<span style="color: #666666">*</span>t)<span style="color: #666666">/</span>a
</pre></div>
<p>
Note that doing <code>latex(u)</code> automatically converts the expression to LaTeX syntax
for inclusion in reports.

<h3 id="___sec28">Theory </h3>

<p>
The challenges in our scaling is to find the right \( u_c \) and \( t_c \)
scales. From <a href="#mjx-eqn-7">(7)</a> we see that if \( u'\rightarrow 0 \)
as \( t\rightarrow\infty \), \( u \) approaches the constant value \( b/a \). It can be
convenient to let the scaled \( \bar u\rightarrow 1 \) as
we approach the \( d\bar u/d\bar t = 0 \) state. This idea points to choosing

$$
\begin{equation}
u_c = \frac{b}{a} = g\left(\frac{\varrho}{\varrho_b} -1\right)\left(\frac{3\pi d\mu}{\varrho_b V}\right)^{-1}
\tp
\end{equation}
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>On the sign of the scaled velocity.</b>
A little note on the sign of \( u_c \) is necessary here.
With \( \varrho_b < \varrho \), the buoyancy force upwards wins over the
gravity force downwards, and the body will move upwards. In this case,
the terminal velocity \( u_c > 0 \). When \( \varrho_b > \varrho \), we get
a motion downwards, and \( u_c < 0 \). The corresponding \( u \) is then also
negative, but the scaled velocity \( u/u_c \), becomes positive.
</div>


<p>
Inserting \( u = u_c\bar u = b\bar u/a \) and \( t=t_c\bar t \) in
<a href="#mjx-eqn-7">(7)</a> leads to

$$
\frac{d\bar u}{d\bar t} = -t_c a\bar u + \frac{t_c}{u_c}b,
\quad \bar u(0) = I\frac{a}{b}
\tp
$$

We want the scales such that \( d\bar u/d\bar t \) and \( \bar u \) are
about unity.
To balance the size of \( \bar u \) and \( d\bar u/d\bar t \) we must
therefore choose
\( t_c = 1/a \), resulting in the scaled ODE problem

$$
\begin{equation}
\frac{d\bar u}{d\bar t} = -\bar u + 1,\quad u(0)=\beta,
\tag{9}
\end{equation}
$$

where \( \beta \) is a dimensionless number,
$$
\begin{equation}
\beta = \frac{I}{u_c} = I\frac{a}{b},
\end{equation}
$$

reflecting the ratio of the initial velocity and the
terminal (\( t\rightarrow \infty \)) velocity \( b/a \).
Scaling normally ends up with one or more dimensionless parameters,
such as \( \beta \) here, containing ratios of physical effects in
the model. Many more examples on dimensionless parameters will appear
in later sections.

<p>
The analytical solution of the scaled model
<a href="#mjx-eqn-9">(9)</a> reads

$$
\begin{equation}
\bar\uex(t) =
e^{-t}\left( e^{t}-1 + \beta\right) = 1 + (\beta -1)e^{-t}\tp
\tag{10}
\end{equation}
$$

<p>
The result <a href="#mjx-eqn-9">(9)</a> with the
solution <a href="#mjx-eqn-10">(10)</a> is actually
astonishing if \( a \) and \( b \) are as in <a href="#mjx-eqn-8">(8)</a>:
the six parameters \( d \), \( \mu \), \( \varrho_b \), \( \varrho \), \( V \), and \( g \)
are conjured to one:
$$ \beta = I\frac{3\pi d\mu}{\varrho_b V}
\frac{1}{g}\left(\frac{\varrho}{\varrho_b} -1\right)^{-1},
$$

which is an enormous simplification of the problem if our aim is to
investigate how \( u \) varies with the physical input parameters in
the model.
In particular, if the motion starts from rest, \( \beta=0 \), and
there are no physical parameters in the scaled model!
We can then perform a single simulation and recover all physical
cases by the unscaling procedure. More precisely,
having computed \( \bar u(\bar t) \) from <a href="#mjx-eqn-9">(9)</a>,
we can use

$$
\begin{equation}
u(t) = \frac{b}{a}\bar u(at),
\end{equation}
$$

to scale us back to the original
problem again.
We observe that <a href="#mjx-eqn-9">(9)</a> can utilize a solver
for <a href="#mjx-eqn-7">(7)</a> by setting \( a=1 \), \( b=1 \), and \( I=\beta \).
Given some implementation of a solver for <a href="#mjx-eqn-7">(7)</a>,
say <code>solver(I, a, b, T, dt, theta)</code>,
the scaled model is run by <code>solver(beta, 1, 1, T, dt, theta)</code>.

<h3 id="___sec29">Software </h3>

<p>
We may develop a solver for the scaled problem that uses <code>joblib</code>
to cache solutions with the same \( \beta \), \( \Delta t \), and \( T \).
For now we fix \( \theta=0.5 \).
The module <a href="http://tinyurl.com/nm5587k/decay/decay_vc.py" target="_self"><tt>decay_vc.py</tt></a> has a function
<code>solver(I, a, b, T, dt, theta)</code> for solving \( u'(t)=-a(t)u(t)+b(t) \) for
\( t\in (0,T] \), \( u(0)=I \), with time step <code>dt</code>.
We reuse this function and call it with \( a=b=1 \) and \( I=\beta \) to solve
the scaled problem:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">decay_vc</span> <span style="color: #008000; font-weight: bold">import</span> solver <span style="color: #008000; font-weight: bold">as</span> solver_unscaled

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">solver_scaled</span>(beta, T, dt, theta<span style="color: #666666">=0.5</span>):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;=-u+1, u(0)=beta for (0,T]</span>
<span style="color: #BA2121; font-style: italic">    with step dt and theta method.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Computing the numerical solution&#39;</span>
    <span style="color: #008000; font-weight: bold">return</span> solver_unscaled(
        I<span style="color: #666666">=</span>beta, a<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">1</span>, b<span style="color: #666666">=</span><span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">1</span>,
        T<span style="color: #666666">=</span>T, dt<span style="color: #666666">=</span>dt, theta<span style="color: #666666">=</span>theta)

<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">joblib</span>
disk_memory <span style="color: #666666">=</span> joblib<span style="color: #666666">.</span>Memory(cachedir<span style="color: #666666">=</span><span style="color: #BA2121">&#39;temp&#39;</span>)
solver_scaled <span style="color: #666666">=</span> disk_memory<span style="color: #666666">.</span>cache(solver_scaled)
</pre></div>
<p>
If we want to plot the physical solution, we need an <code>unscale</code> function,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">unscale</span>(u_scaled, t_scaled, d, mu, rho, rho_b, V):
    a, b <span style="color: #666666">=</span> ab(d, mu, rho, rho_b, V)
    <span style="color: #008000; font-weight: bold">return</span> (b<span style="color: #666666">/</span>a)<span style="color: #666666">*</span>u_scaled, a<span style="color: #666666">*</span>t_scaled

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">ab</span>(d, mu, rho, rho_b, V):
    g <span style="color: #666666">=</span> <span style="color: #666666">9.81</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">3*</span>pi<span style="color: #666666">*</span>d<span style="color: #666666">*</span>mu<span style="color: #666666">/</span>(rho_b<span style="color: #666666">*</span>V)
    b <span style="color: #666666">=</span> g<span style="color: #666666">*</span>(rho<span style="color: #666666">/</span>rho_b <span style="color: #666666">-</span> <span style="color: #666666">1</span>)
    <span style="color: #008000; font-weight: bold">return</span> a, b
</pre></div>
<p>
Looking at droplets of water in air, we can fix some of the parameters
and let the size parameter \( d \) be the one for experimentation.
The following function sets physical parameters, computes \( \beta \),
runs the solver for the scaled problem (<code>joblib</code> detects
if it is necessary), and finally plots the scaled curve
\( \bar u(\bar t) \) and the unscaled curve \( u(t) \).

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">main</span>(dt<span style="color: #666666">=0.075</span>, <span style="color: #408080; font-style: italic"># Time step, scaled problem</span>
         T<span style="color: #666666">=7.5</span>,    <span style="color: #408080; font-style: italic"># Final time, scaled problem</span>
         d<span style="color: #666666">=0.001</span>,  <span style="color: #408080; font-style: italic"># Diameter (unscaled problem)</span>
         I<span style="color: #666666">=0</span>,      <span style="color: #408080; font-style: italic"># Initial velocity (unscaled problem)</span>
         ):
    <span style="color: #408080; font-style: italic"># Set parameters, solve and plot</span>
    rho <span style="color: #666666">=</span> <span style="color: #666666">0.00129E+3</span>  <span style="color: #408080; font-style: italic"># air</span>
    rho_b <span style="color: #666666">=</span> <span style="color: #666666">1E+3</span>      <span style="color: #408080; font-style: italic"># density of water</span>
    mu <span style="color: #666666">=</span> <span style="color: #666666">0.001</span>        <span style="color: #408080; font-style: italic"># viscosity of water</span>
    <span style="color: #408080; font-style: italic"># Asumme we have list or similar for d</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000">isinstance</span>(d, (<span style="color: #008000">list</span>,<span style="color: #008000">tuple</span>,np<span style="color: #666666">.</span>ndarray)):
        d <span style="color: #666666">=</span> [d]

    legends1 <span style="color: #666666">=</span> []
    legends2 <span style="color: #666666">=</span> []
    plt<span style="color: #666666">.</span>figure(<span style="color: #666666">1</span>)
    plt<span style="color: #666666">.</span>figure(<span style="color: #666666">2</span>)
    betas <span style="color: #666666">=</span> []     <span style="color: #408080; font-style: italic"># beta values already computed (for plot)</span>

    <span style="color: #008000; font-weight: bold">for</span> d_ <span style="color: #AA22FF; font-weight: bold">in</span> d:
        V <span style="color: #666666">=</span> <span style="color: #666666">4*</span>pi<span style="color: #666666">/3*</span>(d_<span style="color: #666666">/2.</span>)<span style="color: #666666">**3</span>  <span style="color: #408080; font-style: italic"># volume</span>
        a, b <span style="color: #666666">=</span> ab(d_, mu, rho, rho_b, V)
        beta <span style="color: #666666">=</span> I<span style="color: #666666">*</span>a<span style="color: #666666">/</span>b
        <span style="color: #408080; font-style: italic"># Restrict to 3 digits in beta</span>
        beta <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(<span style="color: #008000">round</span>(beta, <span style="color: #666666">3</span>))

        <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;beta=</span><span style="color: #BB6688; font-weight: bold">%.3f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> beta
        u_scaled, t_scaled <span style="color: #666666">=</span> solver_scaled(beta, T, dt)

        <span style="color: #408080; font-style: italic"># Avoid plotting curves with the same beta value</span>
        <span style="color: #008000; font-weight: bold">if</span> <span style="color: #AA22FF; font-weight: bold">not</span> beta <span style="color: #AA22FF; font-weight: bold">in</span> betas:
            plt<span style="color: #666666">.</span>figure(<span style="color: #666666">1</span>)
            plt<span style="color: #666666">.</span>plot(t_scaled, u_scaled)
            plt<span style="color: #666666">.</span>hold(<span style="color: #BA2121">&#39;on&#39;</span>)
            legends1<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;beta=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> beta)
        betas<span style="color: #666666">.</span>append(beta)

        plt<span style="color: #666666">.</span>figure(<span style="color: #666666">2</span>)
        u, t <span style="color: #666666">=</span> unscale(u_scaled, t_scaled, d_, mu, rho, rho_b, V)
        plt<span style="color: #666666">.</span>plot(t, u)
        plt<span style="color: #666666">.</span>hold(<span style="color: #BA2121">&#39;on&#39;</span>)
        legends2<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;d=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> [mm]&#39;</span> <span style="color: #666666">%</span> (d_<span style="color: #666666">*1000</span>))
    plt<span style="color: #666666">.</span>figure(<span style="color: #666666">1</span>)
    plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;scaled time&#39;</span>); plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;scaled velocity&#39;</span>)
    plt<span style="color: #666666">.</span>legend(legends1, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;lower right&#39;</span>)
</pre></div>
<p>
The most complicated part of the code is related to plotting, but
this part can be skipped when trying to understand how we work with
a scaled model to perform the computations.
The complete program is found in the file
<a href="http://tinyurl.com/nm5587k/scale/falling_body.py" target="_self"><tt>falling_body.py</tt></a>.

<p>
Since \( I=0 \) implies \( \beta=0 \), we can run different \( d \) values without
any need to recompute \( \bar u(\bar t) \) as long as we assume the particle
starts from rest.

<p>
From the scaling, we see that \( u_c = b/a\sim d^{-2} \) and
also that \( t_c=1/a \sim d^{-2} \), so plotting of \( u(t) \) with dimensions
for various \( d \) values will involve significant variations in the time
and velocity scales. Figure <a href="#sec:scale:decay:body:fig">3</a>
has an example with \( d=1,2,3 \) mm, where we clearly see the different
time and velocity scales in the figure with unscaled variables.
Note that the scaled velocity is positive because of the sign of \( u_c \)
(see the box above).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Velocity of falling body: scaled (left) and with dimensions (right). <div id="sec:scale:decay:body:fig"></div> </p></center>
<p><img src="fig-scale/falling_body.png" align="bottom" width=800></p>
</center>

<h2 id="sec:scale:decay:jump">Variable coefficients</h2>

<p>
When a prescribed coefficient like \( a(t) \) in \( u'(t) = -a(t)u(t) \)
varies with time one usually also
performs a scaling of this \( a \),

$$ \bar a(\bar t) = \frac{a(t) - a_0}{a_c}, $$

where the goal is to have the scaled \( |\bar a| \)
of size unity: \( |\bar a|\leq 1 \).
This property is obtained by choosing \( a_c \) as the maximum value
of \( |a(t)-a_0| \) for \( t\in [0,T] \), which is usually a quantity that
can be estimated since \( a(t) \) is known as a function of \( t \). The \( a_0 \)
parameter can be chosen as 0 here. (It could be tempting to
choose \( a_0=\min_t a(t) \) so that \( 0\leq \bar a\leq 1 \), but then there
is at least one point where \( \bar a = 0 \) and
the differential equation collapses to \( u'=0 \).)

<p>
As an example, imagine a decaying cell culture where we at time \( t_1 \)
change the environment such that the death rate increases: \( a(t) = d \) for
\( t < t_1 \) and \( a(t)=5d \) for \( t\geq t_1 \). The model reads \( u'=-a(t)u \), \( u(0)=I \).

<p>
The \( a(t) \) function is scaled by letting the characteristic size be
\( a_c=d \) (and \( a_0=0 \)):

$$ \bar a (\bar t) = \left\lbrace\begin{array}{ll}
1, & \bar t < t_1/t_c\\ 
5, & \bar t \geq t_1/t_c
\end{array}\right.
$$

<p>
The scaled equation becomes

$$ \frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = a_c\bar a(\bar t) u_c\bar u,\quad
u_c\bar u(0) = I\tp$$

The characteristic time, previously taken as \( t_c=1/a \), can now be
taken as \( t_c=t_1 \) or \( t_c=1/d \). The natural choice of \( u_c \) is \( I \).
With \( t_c=1/d \) we get

$$
\begin{equation}
\bar u'(\bar t)=-\bar a\bar u,\quad \bar u(0)=1,\quad
\bar a = \left\lbrace\begin{array}{ll}
1, & \bar t < \gamma\\ 
5, & \bar t \geq \gamma
\end{array}\right.
\tag{11}
\end{equation}
$$

where

$$ \gamma = t_1 d$$

is a dimensionless number in the problem. With \( t_c=t_1 \), we get

$$ \bar u'(\bar t)=-\gamma\bar a\bar u,\quad \bar u(0)=1,\quad
\bar a = \left\lbrace\begin{array}{ll}
1, & \bar t < 1\\ 
5, & \bar t \geq 1
\end{array}\right.$$

The dimensionless parameter \( \gamma \) is now in the equation rather than in
the definition of \( \bar a \). Both problems involve \( \gamma \), which
is the ratio between the time when the environmental change happens
and the typical time for the decay (\( 1/d \)).

<p>
A computation with the scaled model <a href="#mjx-eqn-11">(11)</a>
and the original model with dimensions appears in
Figure <a href="#sec:scale:decay:jump:fig">4</a>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 4:  Exponential decay with jump. <div id="sec:scale:decay:jump:fig"></div> </p></center>
<p><img src="fig-scale/decay_jump.png" align="bottom" width=800></p>
</center>

<h2 id="scale:decay:cooling:const">Scaling a cooling problem with constant surroundings</h2>

<p>
The heat exchange between a body at temperature \( T(t) \) and the
surroundings at \( T_s(t) \) can be modeled by Newton's law of cooling:

$$
\begin{equation}
T'(t) = -k(T-T_s(t)),\quad T(0)=T_0,
\tag{12}
\end{equation}
$$

where \( k \) is a prescribed heat transfer coefficient.
An analytical solution is always handy to have as a control of the
choice of scales. Here we have
the result \( T(t) = T_s + (T_0 - T_s)e^{-kt} \) when \( T_s \) is constant,
which is also the assumption for now.

<p>
Physically, we expect the temperature to start at \( T_0 \) and then
to move toward the surroundings (\( T_s \)). We therefore expect
that \( T \) lies between \( T_0 \) and \( T_s \). This is mathematically
demonstrated by the analytical solution as well. A proper scaling
is therefore to scale and translate \( T \) according to
$$
\begin{equation}
\bar T = \frac{T-T_0}{T_s-T_0}
\tag{13}
\tp
\end{equation}
$$

Now, \( 0\leq \bar T\leq 1 \).

<p>
Scaling time by \( \bar t = t/t_c \) and inserting
\( T= T_0 + (T_s-T_0)\bar T \) and \( t=t_c\bar t \) in the
problem <a href="#mjx-eqn-12">(12)</a> gives

$$ \frac{d\bar T}{d\bar t} = - t_ck(\bar T - 1),\quad \bar T(0) = 0
\tp
$$

A natural choice, as argued in other exponential decay problems,
is to choose \( t_ck=1 \), which leaves us with the scaled problem
$$
\begin{equation}
\frac{d\bar T}{d\bar t} = - (\bar T - 1),\quad \bar T(0)=0
\tag{14}
\tp
\end{equation}
$$

No physical parameter enters this problem!
Our scaling implies that \( \bar T \) starts at
0 and approaches 1 as \( \bar t\rightarrow\infty \), also in the case
\( T_s < T_0 \). The physical temperature is always recovered as
$$
\begin{equation}
T(t) = T_0 + (T_s-T_0)\bar T (k\bar t)
\tag{15}
\tp
\end{equation}
$$

An implementation for <a href="#mjx-eqn-12">(12)</a> works for
<a href="#mjx-eqn-14">(14)</a> by setting \( k=1 \), \( T_s=1 \), and \( T_0=0 \).

<p>
An alternative scaling is to choose
$$
\begin{equation}
\bar T = \frac{T-T_s}{T_0-T_s}
\tag{16}
\tp
\end{equation}
$$

Now \( \bar T=1 \) initially and approaches zero as \( t\rightarrow\infty \).
The resulting scaled ODE problem then becomes

$$
\begin{equation}
\frac{d\bar T}{d\bar t} = - \bar T,\quad \bar T(0)=1
\tag{17}
\tp
\end{equation}
$$

<h2 id="scale:decay:cooling:osc">Scaling a cooling problem with time-dependent surroundings</h2>

<p>
Let us apply the model <a href="#mjx-eqn-12">(12)</a> in
case the surrounding temperature varies in time. Say we have
an oscillating temperature environment according to
$$
\begin{equation}
T_s(t) = T_m + a\sin(\omega t)
\tag{18}
\tp
\end{equation}
$$

<h3 id="___sec33">Exact solution </h3>

<p>
It is possible to solve the differential equation problem analytically,
and such a solution is a good help to see what scales are.
In general, using the method of integrating factors for the
original differential equation, we have

$$ T(t) = T_0e^{-kt} + e^{-kt}k\int_0^t e^{k\tau}T_s(\tau)d\tau\tp$$

With \( T_s(t)=T_m + a\sin (wt) \) we can use SymPy to help us with
integrations:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">sympy</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>
<span style="color: #666666">&gt;&gt;&gt;</span> t, k, T_m, a, w <span style="color: #666666">=</span> symbols(<span style="color: #BA2121">&#39;t k T_m a w&#39;</span>, real<span style="color: #666666">=</span><span style="color: #008000">True</span>, positive<span style="color: #666666">=</span><span style="color: #008000">True</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> T_s <span style="color: #666666">=</span> T_m <span style="color: #666666">+</span> a<span style="color: #666666">*</span>sin(w<span style="color: #666666">*</span>t)
<span style="color: #666666">&gt;&gt;&gt;</span> I <span style="color: #666666">=</span> exp(k<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>T_s
<span style="color: #666666">&gt;&gt;&gt;</span> I <span style="color: #666666">=</span> integrate(I, (t, <span style="color: #666666">0</span>, t))
<span style="color: #666666">&gt;&gt;&gt;</span> Q <span style="color: #666666">=</span> k<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>k<span style="color: #666666">*</span>t)<span style="color: #666666">*</span>I
<span style="color: #666666">&gt;&gt;&gt;</span> Q <span style="color: #666666">=</span> simplify(expand(Q))
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> Q
(<span style="color: #666666">-</span>T_m<span style="color: #666666">*</span>k<span style="color: #666666">**2</span> <span style="color: #666666">-</span> T_m<span style="color: #666666">*</span>w<span style="color: #666666">**2</span> <span style="color: #666666">+</span> a<span style="color: #666666">*</span>k<span style="color: #666666">*</span>w <span style="color: #666666">+</span>
(T_m<span style="color: #666666">*</span>k<span style="color: #666666">**2</span> <span style="color: #666666">+</span> T_m<span style="color: #666666">*</span>w<span style="color: #666666">**2</span> <span style="color: #666666">+</span> a<span style="color: #666666">*</span>k<span style="color: #666666">**2*</span>sin(t<span style="color: #666666">*</span>w) <span style="color: #666666">-</span>
a<span style="color: #666666">*</span>k<span style="color: #666666">*</span>w<span style="color: #666666">*</span>cos(t<span style="color: #666666">*</span>w))<span style="color: #666666">*</span>exp(k<span style="color: #666666">*</span>t))<span style="color: #666666">*</span>exp(<span style="color: #666666">-</span>k<span style="color: #666666">*</span>t)<span style="color: #666666">/</span>((k<span style="color: #666666">**2</span> <span style="color: #666666">+</span> w<span style="color: #666666">**2</span>))
</pre></div>
<p>
Reordering the result, we get

$$ T(t) = T_0e^{-kt} + T_m(1- e^{-kt}) +  (k^2 + w^2)^{-1}(akw e^{-kt}
+ ak\sin (wt) - akw\cos(wt))\tp$$

<h3 id="___sec34">Scaling </h3>

<p>
The scaling <a href="#mjx-eqn-13">(13)</a> brings in a time-dependent
characteristic temperature scale \( T_s-T_0 \). Let us start with a
fixed scale, where we take the characteristic temperature variation to
be \( T_m - T_0 \):

$$ \bar T = \frac{T-T_0}{T_m-T_0}\tp$$

We see from the analytical solution, and realize also by physical
reasoning, that \( T \) sets out at \( T_0 \), but with time, it will oscillate
around \( T_m \). The typical average temperature span is therefore
\( |T_m-T_0| \).

<p>
We get from the differential equation, with \( t_c=1/k \) as in the former
case,

$$ k(T_m-T_0)\frac{d\bar T}{d\bar t} = -k((T_m-T_0)\bar T + T_0 - T_m - a
\sin(wt),$$

resulting in

$$
\begin{equation}
\frac{d\bar T}{d\bar t} = -\bar T + 1 + \alpha\sin (\beta \bar t),\quad
\bar T(0)=0,
\tag{19}
\end{equation}
$$

where we have two dimensionless numbers:

$$ \alpha = \frac{a}{T_m-T_0},\quad \beta = \frac{w}{k}\tp$$

The \( \alpha \) quantity
measures the ratio of temperatures: amplitude of oscillations versus
characteristic total temperature variation.
The \( \beta \) number is the ratio of the two time scales:
the frequency of the oscillations in \( T_s \) and the inverse
e-folding time of the heat transfer. For clear interpretation of \( \beta \)
we may introduce the period
\( P=2\pi/w \) of the oscillations in \( T_s \) and the e-folding time \( e=1/k \). Then
\( \beta = 2\pi e/P \) and measures the period versus the e-folding time.

<p>
The original problem features five physical parameters: \( k \), \( T_0 \),
\( T_m \), \( a \), and \( w \), but only two dimensionless numbers appear in the
scaled model.

<h3 id="___sec35">Software </h3>

<p>
Implementing the unscaled problem <a href="#mjx-eqn-12">(12)</a>
can be reused for the scaled model by setting \( k=1 \), \( T_0=0 \), and
\( T_s(t) = 1 + \alpha\sin (\beta \bar t) \) (\( T_m=1 \), \( a=\alpha \), \( w=\beta \)).

<h3 id="___sec36">Discussion of the time scale </h3>

<p>
Looking at the analytical insight we have, \( T(t) \) has two characteristic
terms in time: \( e^{-kt} \) and \( \sin(wt) \). The former points to a time
scale \( t_c=1/k \), while the latter to \( t_c=1/w \).
Which one should be chosen? Bringing the temperature from \( T_0 \) to
the level of the surroundings, \( T_m \), goes like \( e^{-kt} \), so
in this process \( t_c=1/k \) is the characteristic time. Thereafter,
the body's temperature just responds to the oscillations and the
\( \sin (wt) \) (and \( \cos(wt) \)) term dominates. For these large times,
\( t_c=1/w \) is the appropriate time scale. Choosing \( t_c=1/w \)
results in

$$
\begin{equation}
\frac{d\bar T}{d\bar t} = -\beta^{-1}(\bar T - (1 + \alpha\sin (\bar t))),\quad
\bar T(0)=0\tp
\tag{20}
\end{equation}
$$

<p>
Let us illustrate another, less effective, scaling.
The temperature scale in
<a href="#mjx-eqn-13">(13)</a> looks natural, so we apply this
choice of scale. The characteristic temperature \( T_0-T_s \)
now involves
a time-dependent term \( T_s(t) \). The mathematical steps become a bit
more technically involved:

$$ T(t) = T_0 + (T_s(t)-T_0)\bar T,$$


$$ \frac{dT}{dt} = \frac{dT_s}{dt}\bar T +
(T_s-T_0)\frac{d\bar T}{d\bar t}\frac{d\bar t}{dt}
\tp
$$

With \( \bar t = t/t_c = kt \) we get from the differential equation

$$
\frac{dT_s}{dt}\bar T +
(T_s-T_0)\frac{d\bar T}{d\bar t}k
= -k(\bar T - 1)(T_s - T_0),
$$

which after dividing by \( k(T_s-T_0) \) results in

$$
\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\frac{dT_s}{dt}\frac{\bar T}{k(T_s-T_0},
$$

or

$$
\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\frac{a\omega\cos(\omega \bar t/k)}{k(T_m + a\sin(\omega \bar t/k) -T_0)}\bar T
\tp
$$

The last term is complicated and becomes more tractable if we factor
out dimensionless numbers. To this end, we scale \( T_s \) by (e.g.) \( T_m \),
which means to factor out \( T_m \) in the denominator. We are then
left with
$$
\begin{equation}
\frac{d\bar T}{d\bar t} = -(\bar T - 1) -
\alpha\beta \frac{\cos(\beta \bar t)}{1 + \alpha\sin(\beta\bar t) - \gamma}
\bar T,
\tag{21}
\end{equation}
$$

where \( \alpha \), \( \beta \), and \( \gamma \) are dimensionless numbers
characterizing the relative importance of parameters in the problem:
$$
\begin{equation}
\alpha=a/T_m,\quad \beta = \omega/k,\quad \gamma = T_0/T_m
\tp
\end{equation}
$$

We notice that <a href="#mjx-eqn-21">(21)</a>
is not a special case of the original problem
<a href="#mjx-eqn-12">(12)</a>. Furthermore, the original five
parameters \( k \), \( T_m \), \( a \), \( \omega \), and
\( T_0 \) are reduced to three dimensionless parameters.
We conclude that this scaling is inferior, because
using the temperature scale \( T_0-T_m \) enables reuse of the software
for the unscaled problem and only two dimensionless parameters appear
in the scaled model.

<h2 id="sec:scale:decay:nonlinear">Scaling a nonlinear ODE</h2>

<p>
Exponential growth models, \( u'=au \), are not realistic in environments
with limited resources. The idea is then to assume that
the growth rate \( a \) decreases with \( u \) and vanishes when we reach the maximum
value \( M \) of \( u \) the environment can sustain. The initial growth rate
is set to \( r \): \( a(0)=\varrho \).
In general, this reasoning gives rise to models

$$
\begin{equation}
u' = a(u)u,\quad u(0)=I,
\tag{22}
\end{equation}
$$

with the logistic model, corresponding to \( a(u)=\varrho(1-u/M) \),
as the simplest:

$$
\begin{equation}
u' = \varrho u(1-u/M),\quad u(0)=I\tp
\tag{23}
\end{equation}
$$

A general choice of \( a \) might be \( a(u)=\varrho(1-u/M)^p \) for some exponent \( p \).

<p>
Let us scale <a href="#mjx-eqn-22">(22)</a> with
\( a(u)=\varrho (1-u/M)^p \).
The natural scale for \( u \) is \( M \) (\( u_c=M \)), since we know that
\( 0 < u\leq M \), and this makes the dimensionless \( \bar u = u/M \in (0,1] \).
The function \( a(u) \) is
typically varying between 0 and \( \varrho \), so it can be scaled as

$$ \bar a(\bar u) = \frac{a(u)}{\varrho} = (1 - \frac{u}{M})^p =
(1 - \bar u)^p\tp$$

Time is scaled as \( \bar t = t/t_c \) for some suitable characteristic time \( t_c \).
Inserted in <a href="#mjx-eqn-22">(22)</a>, we get

$$ \frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = \varrho\bar a u_c\bar u,\quad u_c\bar u(0)=I,$$

resulting in

$$ \frac{d\bar u}{d\bar t} = t_c \varrho (1 - \bar u)^p \bar u,\quad
\bar u(0) =\frac{I}{M}\tp$$

A natural choice is \( t_c =1/\varrho \) as in other exponential growth models
since it leads to the term on the right-hand side to be about unity,
as the left-hand side, if the scaling is physically correct.
Introducing the dimensionless parameter

$$ \alpha = \frac{I}{M},$$

measuring the fraction of the initial population compared to the maximum
one, we get the dimensionless model

$$
\begin{equation}
\frac{d\bar u}{d\bar t} = (1 - \bar u)^p \bar u,\quad
\bar u(0) =\alpha\tp
\tag{24}
\end{equation}
$$

Here, we have two dimensionless parameters: \( \alpha \) and \( p \). A classical
logistic model with \( p=1 \) has only one dimensionless variable.

<p>
We could try another scaling of \( u \) where we also translate \( \bar u \):

$$ \bar u = \frac{u-I}{M}\tp $$

This choice of \( \bar u \) results in

$$
\begin{equation}
\frac{d\bar u}{d\bar t} = (1 - \alpha - \bar u)^p \bar u,\quad
\bar u(0) =0\tp
\tag{25}
\end{equation}
$$

The essential difference between <a href="#mjx-eqn-24">(24)</a>
and <a href="#mjx-eqn-25">(25)</a> is that
\( \bar u\in [\alpha, 1] \) in the former and \( \bar u \in [0, 1-\alpha] \) in
the latter. Both models involve the dimensionless numbers \( \alpha \) and \( p \).
An advantage of <a href="#mjx-eqn-24">(24)</a>
is that software for the unscaled model can easily be used for the
scaled model by choosing \( I=\alpha \), \( M=1 \), and \( \varrho=1 \).

<h2 id="___sec38">ODE systems for spreading of diseases </h2>

<p>
The field of epidemiology frequently applies ODE systems to describe the spreading of diseases, such as smallpox, measles, plague, ordinary flu, swine flu,
and HIV. Different models include different effects, which are reflected
in dimensionless numbers. Most of the effects are modeled as exponential
decay or growth of the dependent variables.

<h3 id="___sec39">SIR model </h3>

<p>
The model has three categories of people: susceptibles (S) who can get
the disease, infected (I) who are infected and may infect susceptibles,
and recovered (R) who have recovered from the disease and gained
immunity. We introduce \( S(t) \), \( I(t) \), and \( R(t) \) as the number of
people in the categories S, I, and R, respectively.
The model, naturally known as the SIR model, takes the form a system of ODEs:

$$
\begin{align}
\frac{dS}{dt} &= - \beta SI,
\tag{26}\\ 
\frac{dI}{dt} &= \beta SI - \nu I,
\tag{27}\\ 
\frac{dR}{dt} &= \nu I,
\tag{28}
\end{align}
$$

where \( \beta \) and \( nu \) are empirical constants. The average time for recovering
from the disease can be shown to be \( \nu^{-1} \), but \( \beta \) is much harder
to estimate, so working with a scaled model where \( k \) is &quot;scaled away&quot;
is advantageous. Adding <a href="#mjx-eqn-26">(26)</a>-<a href="#mjx-eqn-28">(28)</a>
shows that

$$ \frac{dS}{dt}+\frac{dI}{dt}+\frac{dR}{dt}=0\quad\Rightarrow\quad
S+I+R=\hbox{const}=N,$$

where \( N \) is the size of the population. It is natural to scale
\( S \), \( I \), and \( R \) by, e.g., \( S(0) \):

$$ \bar S = \frac{S}{S(0)},\quad \bar I = \frac{I}{S(0)},\quad
\bar R = \frac{R}{S(0)}\tp
$$

Introducing \( \bar t = t/t_c \), we arrive at the equations

$$
\begin{align*}
\frac{d\bar S}{d\bar t} &= - t_c S(0) \beta\bar S\bar I,
\\ 
\frac{d\bar I}{d\bar t} &= t_c S(0) \beta \bar S\bar I - t_c \nu \bar I,
\\ 
\frac{d\bar R}{d\bar t} &= t_c \nu I,
\end{align*}
$$

with initial conditions \( \bar S(0)=1 \), \( \bar I(0)=I_0/S(0)=\alpha \), and
\( \bar R(0)=R(0)/S(0) \). Normally, \( R(0)=0 \).

<p>
Taking \( t_c=1/\nu \), corresponding to a time unit equal to the time it takes
to recover from the disease, we end up with the scaled model

$$
\begin{align}
\frac{d\bar S}{d\bar t} &= - R_0\bar S\bar I,
\tag{29}\\ 
\frac{d\bar I}{d\bar t} &= R_0 \bar S\bar I - \bar I,
\tag{30}\\ 
\frac{d\bar R}{d\bar t} &= I,
\tag{31}
\end{align}
$$

with \( \bar S(0)=1 \), \( \bar I(0)=\alpha \), \( \bar R(0)=0 \), and \( R_0 \) as
the dimensionless number

$$
\begin{equation}
R_0 = \frac{S(0)\beta}{\nu}\tp
\end{equation}
$$

We see from <a href="#mjx-eqn-30">(30)</a> that to make the disease spreading,
\( d\bar I/d\bar t >0 \), and therefore \( R_0 S(0) - 1 > 0 \) or \( R_0 > 1 \)
since \( S(0)=1 \).
Therefore, \( R_0 \) reflects the disease's ability to spread and is
consequently an important dimensionless quantity, known as the <em>basic
reproductive number</em>.

<!-- begin inline comment -->
<font color="red">(<b>hpl 1</b>: Explain interpretation.)</font>
<!-- end inline comment -->

<p>
Looking at <a href="#mjx-eqn-27">(27)</a>, we see that to increase \( I \) initially,
we must have \( dI/dt >0 \) at \( t=0 \), which implies
\( \beta I(0)S(0) - \nu I(0) >0 \), i.e., \( R_0 > 1 \).

<p>
We can also scale \( S \), \( I \), and \( R \) by the total population \( N=S(0)+I(0)+R(0) \),

$$ \bar S = \frac{S}{N},\quad \bar I = \frac{I}{N},\quad
\bar R = \frac{R}{N)}\tp
$$

With the same time scale, one gets the system <a href="#mjx-eqn-29">(29)</a>-<a href="#mjx-eqn-31">(31)</a>, but with \( R_0 \) replaced by the dimensionless number:

$$
\begin{equation}
\tilde R_0 = \frac{N\beta}{\nu}\tp
\end{equation}
$$

The initial conditions become \( \bar S(0)=1-\alpha \), \( \bar I(0)=\alpha \),
and \( \bar R(0)=0 \).

<p>
For the disease to spread at \( t=0 \), we must have \( \tilde R_0 \bar S(0) > 1 \),
but \( \tilde R_0 \bar S(0) = N\beta/\nu \cdot S(0)/N = R_0 \), so the
criterion is still \( R_0 > 1 \). Since \( R_0 \) is a more famous number than
\( \tilde R_0 \), we can write the ODEs with \( R_0/S(0) = R_0/(1-\alpha) \)
instead of \( \tilde R_0 \).

<p>
Choosing \( t_c \) to make the \( SI \) terms balance the time derivatives,
\( t_c = (N\beta)^{-1} \), moves \( \tilde R_0 \) (or \( R_0 \) if we scale
\( S \), \( I \), and \( R \) by \( S(0) \)) to the \( I \) terms:

$$
\begin{align*}
\frac{d\bar S}{d\bar t} &= - \bar S\bar I,
\\ 
\frac{d\bar I}{d\bar t} &= \bar S\bar I - \tilde R_0^{-1} \bar I,
\\ 
\frac{d\bar R}{d\bar t} &= \tilde R_0^{-1} I\tp
\end{align*}
$$

<h3 id="___sec40">SIRV model with finite immunity </h3>

<p>
A common extension of the SIR model involves finite immunity: after
some period of time, recovered individuals lose their immunity
and become susceptibles again. This is modeled as
a leakage \( -\mu R \) from the R to the S category, where \( \mu^{-1} \)
is the average time it takes to lose immunity.
Vaccination is another extension: a fraction \( pS \) is removed from the
S category by successful vaccination and brought to a new category V (the
vaccinated). The ODE model reads

$$
\begin{align}
\frac{dS}{dt} &= - \beta SI - pS + \mu R,
\tag{32}\\ 
\frac{dI}{dt} &= \beta SI - \nu I,
\tag{33}\\ 
\frac{dR}{dt} &= \nu I -\mu R,
\tag{34}\\ 
\frac{dV}{dt} &= p S\tp
\tag{35}
\end{align}
$$

Using \( t_c=1/\nu \) and scaling the unknowns by \( S(0) \) leads to
the dimensionless model

$$
\begin{align}
\frac{d\bar S}{d\bar t} &= - R_0 \bar S \bar I - \delta S + \gamma \bar R,
\tag{36}\\ 
\frac{d\bar I}{d\bar t} &= R_0 \bar S \bar I - \bar I,
\tag{37}\\ 
\frac{d\bar R}{d\bar t} &= \bar I -\gamma \bar R,
\tag{38}\\ 
\frac{d\bar V}{d\bar t} &= \delta \bar S,
\tag{39}
\end{align}
$$

with two new dimensionless parameters:

$$ \gamma = \frac{\mu}{\nu},\quad \delta = \frac{p}{\nu}\tp $$

The quantity \( p^{-1} \) can be interpreted as the average time it takes
to vaccinate a susceptible successfully. Writing \( \gamma = \nu^{-1}/\mu^{-1} \)
and \( \delta = \nu^{-1}/p^{-1} \) gives the interpretation that \( \gamma \)
is the ratio of the average time to recover and the average time to
lose immunity, while \( \delta \) is the ratio of the average time to recover
and the average time to successfully vaccinate a susceptible.

<h2 id="scale:MMK">Michaelis-Menten kinetics for biochemical reactions</h2>

<p>
A classical reaction model in biochemistry describes how a
substrate S is turned into a product P with aid of an enzyme E.
S and E react to form a complex ES in the first stage of the reaction.
In the second stage, ES is turned into E and P.
Introducing the amount of S, E, ES, and P by \( [S] \), \( [E] \), \( [ES] \), and
\( [P] \), the mathematical model can be written as

$$
\begin{align}
\frac{d[ES]}{dt} &= k_+[E][S] - k_v[ES] - k_-[ES],
\tag{40}\\ 
\frac{d[P]}{dt} &= k_v[ES],
\tag{41}\\ 
\frac{d[S]}{dt} &= -k_+[E][S] + k_-[ES],
\tag{42}\\ 
\frac{d[E]}{dt} &= -k_+[E][S] + k_-[ES] + k_v[ES]\tp
\tag{43}
\end{align}
$$

The initial conditions are \( [ES](0)=[P](0)=0 \), and \( [S]=S_0 \), \( [E]=E_0 \).
Three rate constants are involved: \( k_+ \), \( k_- \), and \( k_v \).

<p>
The amount of substance is measured in the unit <a href="https://en.wikipedia.org/wiki/Mole_(unit)" target="_self">mole</a> (mol). From the equations we can see that
\( k_+ \) is measured in \( \hbox{s}^{-1}\hbox{mol}^{-1} \), while \( k_- \) and
\( k_v \) are measured in \( \hbox{s}^{-1} \). It is convenient to get rid of
the mole unit for the amount of a substance. When working with
dimensionless quantities, only ratios of the rate constants and not their
specific values are needed.

<h3 id="___sec42">Classical analysis </h3>

<p>
The typical analysis of the present ODE system is to first observe
two conservation equations, arising from simply adding the ODEs:

$$
\begin{align}
\frac{d[ES]}{dt} + \frac{d[E]}{dt} & =0,
\\ 
\frac{d[ES]}{dt} + \frac{d[S]}{dt} + \frac{d[P]}{dt} &= 0,
\end{align}
$$

from which it follows that

$$
\begin{align}
[ES] + [E] &= E_0,
\tag{44}\\ 
[ES] + [S] + [P] &= S_0\tp
\tag{45}
\end{align}
$$

Using <a href="#mjx-eqn-44">(44)</a>, we can eliminate \( [E] \) and obtain a
system of only two ODEs,

$$
\begin{align}
\frac{d[ES]}{dt} &= k_+([ES]-E_0)[S] - (k_v + k_-)[ES],\\ 
\frac{d[S]}{dt} &= -k_+([ES]-E_0)[S] + k_-[ES]\tp
\end{align}
$$

A common assumption is that the formation of \( [ES] \) is very fast and that
it reaches an equilibrium state, \( [ES]^{\prime}=0 \). This implies

$$ k_+([ES]-E_0)[S] - (k_v + k_-)[ES]=0\quad\Rightarrow\quad
[ES] = \frac{E_0[S]}{[S] - K},
$$

where

$$ K = \frac{k_- + k_v}{k_+},$$

is the Michaelis constant. Using the expression for \( [ES] \) in the
equation for \( [S] \) gives

$$
\begin{equation}
\frac{dS}{dt} = \frac{k_vE_0[S]}{[S] + K}\tp
\tag{46}
\end{equation}
$$

We see that the parameter \( K \) is central.

<h3 id="___sec43">Dimensionless ODE system </h3>

<p>
Let us reason how to make the original ODE system dimensionless.
Aiming at \( [S] \) and \( [E] \) of unit size, two obvious dimensionless
unknowns are

$$ \bar S = \frac{[S]}{S_0},\quad
\bar E = \frac{[E]}{E_0}\tp$$

For the other two unknowns we just introduce scales to be determined
later:

$$
\bar P = \frac{[P]}{P_c},\quad
\bar{Q} = \frac{[ES]}{Q_c}\tp
$$

With \( \bar t = t/t_c \) the equations become

$$
\begin{align*}
\frac{d\bar Q}{d\bar t} &= t_ck_+\frac{E_0S_0}{Q_c}\bar E\bar S
- t_c(k_v + k_-)\bar Q,\\ 
\frac{d\bar P}{d\bar t} &= t_ck_v\frac{Q_c}{P_c}\bar Q,\\ 
\frac{d\bar S}{d\bar t} &= -t_ck_+E_0\bar E\bar S
+ t_ck_-\frac{Q_c}{S_0}\bar Q,\\ 
\frac{d\bar E}{d\bar t} &= -t_ck_+S_0\bar E\bar S
+ t_c(k_- + k_v)\frac{Q_c}{E_0}\bar Q\tp
\end{align*}
$$

<!-- <a href="http://www.biosym.uzh.ch/modules/models/Michaelis_Menten/michaelis_menten.html" target="_self"><tt>http://www.biosym.uzh.ch/modules/models/Michaelis_Menten/michaelis_menten.html</tt></a> -->
<!-- <a href="http://deepblue.lib.umich.edu/bitstream/handle/2027.42/26960/0000527.pdf" target="_self"><tt>http://deepblue.lib.umich.edu/bitstream/handle/2027.42/26960/0000527.pdf</tt></a>?sequence=1 -->
<!-- <a href="http://www.math.ubc.ca/~keshet/EnzKin.pdf" target="_self"><tt>http://www.math.ubc.ca/~keshet/EnzKin.pdf</tt></a> -->
<!-- Good (but complicated): <a href="https://people.maths.ox.ac.uk/maini/PKM%20publications/9.pdf" target="_self"><tt>https://people.maths.ox.ac.uk/maini/PKM%20publications/9.pdf</tt></a> -->
<!-- <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2932968/" target="_self"><tt>http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2932968/</tt></a> (read this one - it is the best, this one has units for the constants too and typical values of constants) -->
<!-- Murray has S_c=S_0, Q_c=E_0 (that is common) -->
<!-- All use the long time scale with E_0 -->
<!-- Murray has much complicated analysis before selecting scales... -->
<!-- Can find Q_c from Q'=0 which gives Q_c=E_0S_0/K -->

<h3 id="___sec44">Determining scales </h3>

<p>
Choosing the scales is actually a quite complicated matter that requires
extensive analysis of the equations to determine the characteristics of
the solutions. Much literature is written about this, but here we shall
take a simplistic and pragmatic approach.
Besides the Michaelis constant, there is another important parameter,

$$ \epsilon = \frac{E_0}{S_0},$$

because most applications will involve a small \( \epsilon \).
We shall have \( K \) and \( \epsilon \) in mind while choosing scales such that
these symbols appear naturally in the scaled equations.

<p>
Looking at the equations, we see that the \( K \) parameter will appear
if \( t_c\sim 1/k_+ \). However, \( 1/k_+ \) does not have the dimension
\( \hbox{[T]}^{-1} \) as required, so we need to add a factor with dimension
mol. A natural choice is
\( t_c^{-1}=k_+S_0 \) or \( t_c^{-1}=k_+E_0 \). Since often \( S_0\gg E_0 \),
the former \( t_c \) is a short time scale and the latter is a long
time scale. If the interest is in the long time scale, we set

$$ t_c = \frac{1}{k_+E_0}\tp$$

The equations then take the form

$$
\begin{align*}
\frac{d\bar Q}{d\bar t} &= \frac{S_0}{Q_c}\bar E\bar S
- KE_0^{-1}\bar Q,\\ 
\frac{d\bar P}{d\bar t} &= \frac{k_v}{k_+ E_0}\frac{Q_c}{P_c}\bar Q,\\ 
\frac{d\bar S}{d\bar t} &= -\bar E\bar S
+ \frac{k_-}{k_+E_0}\frac{Q_c}{S_0}\bar Q,\\ 
\frac{d\bar E}{d\bar t} &= -\epsilon^{-1}\bar E\bar S
+ K\frac{Q_c}{E_0^2}\bar Q\tp
\end{align*}
$$

The \( [ES] \) variable starts and ends at zero, and its maximum value
can be roughly estimated from the equation for \( [ES]^{\prime} \)
by setting \( [ES]^{\prime}=0 \), which gives an estimate of

$$ Q_c = \frac{E_0S_0}{K},$$

if we approximate \( [E][S] \) by \( E_0S_0 \).

<p>
The equation for \( \bar P \) simplifies if we choose \( P_c=Q_c \).
With these assumptions one gets

$$
\begin{align*}
\frac{d\bar Q}{d\bar t} &= KE_0^{-1} (\bar E\bar S
- \bar Q),\\ 
\frac{d\bar P}{d\bar t} &= \frac{k_v}{k_+ E_0}\bar Q,\\ 
\frac{d\bar S}{d\bar t} &= -\bar E\bar S
+ \frac{k_-}{k_+E_0}\frac{E_0}{K}\bar Q,\\ 
\frac{d\bar E}{d\bar t} &= -\epsilon^{-1}\bar E\bar S
+ \epsilon^{-1}\bar Q\tp
\end{align*}
$$

We can now identify the dimensionless numbers

$$ \alpha = \frac{K}{E_0},\quad \beta = \frac{k_v}{k_+ E_0},
\quad \gamma = \frac{k_-}{k_+E_0},
$$

where we see that \( \alpha = \beta + \gamma \), so \( \gamma \) can be eliminated,
leading to the final set of equations:

$$
\begin{align}
\frac{d\bar Q}{d\bar t} &= \alpha (\bar E\bar S
- \bar Q),
\tag{47}\\ 
\frac{d\bar P}{d\bar t} &= \beta\bar Q,
\tag{48}\\ 
\frac{d\bar S}{d\bar t} &= -\bar E\bar S
+ (1 - \beta\alpha^{-1})\bar Q,
\tag{49}\\ 
\epsilon\frac{d\bar E}{d\bar t} &= -\bar E\bar S + \bar Q\tp
\tag{50}
\end{align}
$$

The five initial parameters (\( S_0 \), \( E_0 \), \( k_+ \), \( k_- \), and \( k_v \))
are reduced to three dimensionless constants:

<ul>
 <li> \( \alpha \) is the dimensionless Michaelis constant, reflecting the
   ratio of the production of P and E (\( k_v+k_- \)) versus the production of
   the complex (\( k_+ \)), made dimensionless by \( E_0 \),</li>
 <li> \( \epsilon \) is the initial fraction of enzyme relative to the substrate,</li>
 <li> \( \beta \) measures the relative importance of production of P (\( k_v \))
   versus production of the complex (\( k_+ \)), made dimensionless by \( E_0 \).</li>
</ul>

Observe that software developed for
solving <a href="#mjx-eqn-40">(40)</a>-<a href="#mjx-eqn-43">(43)</a> cannot be reused
for solving <a href="#mjx-eqn-47">(47)</a>-<a href="#mjx-eqn-50">(50)</a> since the latter
system has a slightly different structure.

<h3 id="___sec45">Analysis of the scaled system </h3>

<p>
In the scaled system, we may assume \( \epsilon \) small, which from
<a href="#mjx-eqn-50">(50)</a> gives rise to the simplification
\( \epsilon\bar E^{\prime}=0 \), and thereby the relation \( \bar Q = \bar E\bar S \).
The conservation equation \( [ES] + [E]= E_0 \) reads \( Q_c\bar Q + E_0\bar E =
E_0 \) such that \( \bar E = 1 - Q_c\bar Q/E_0=1- \bar Q S_0/K = 1 - \epsilon^{-1}\alpha^{-1}\bar Q \). The relation \( \bar Q=\bar E\bar S \) then becomes

$$ \bar Q = (1 - \epsilon^{-1}\alpha^{-1}\bar Q)\bar S,$$

which can be solved for \( \bar Q \):

$$ \bar Q = \frac{\bar S}{1 + \epsilon^{-1}\alpha^{-1}\bar S}\tp$$

The equation <a href="#mjx-eqn-49">(49)</a> for \( \bar S \) becomes

$$
\begin{equation}
\frac{d\bar S}{d\bar t} = -\beta\alpha^{-1}\bar Q =
-\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}\tp
\tag{51}
\end{equation}
$$

This is a more precise analysis than the one leading to
<a href="#mjx-eqn-46">(46)</a> since we now realize that the
mathematical assumption for the simplification is
\( \epsilon\rightarrow 0 \).

<p>
Is <a href="#mjx-eqn-51">(51)</a> consistent with <a href="#mjx-eqn-46">(46)</a>? It is
easy to make algebraic mistakes when deriving scaled equations,
so it is always wise to carry out such consistency checks.
Introducing dimensions in <a href="#mjx-eqn-51">(51)</a> leads to

$$
\frac{t_c}{S_0}\frac{d S}{dt} =
\frac{d\bar S}{d\bar t}  =
-\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}
= \frac{k_v}{k_+E_0}\frac{S}{KE_0^{-1} + E_0^{-1}S_0\bar S}
= \frac{k_v}{k_+}\frac{\bar S}{K + S},$$

and hence with \( t_c^{-1}=k_+E_0 \),

$$ \frac{dS}{dt} = \frac{k_vE_0 S}{K + S},$$

which is <a href="#mjx-eqn-46">(46)</a>.

<p>
Figure <a href="#scale:MMK:fig">5</a> shows the impact of \( \epsilon \): with a small
value (0.1) we see that \( \bar Q\approx 0 \), which justifies the
simplifications performed above. We also observe that all the unknowns
vary between 0 and about 1, indicating that the scaling is successful
for the chosen dimensionless numbers.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 5:  Simulation of a biochemical process. <div id="scale:MMK:fig"></div> </p></center>
<p><img src="fig-scale/biochem.png" align="bottom" width=700></p>
</center>

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._scale-sol003.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._scale-sol005.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

