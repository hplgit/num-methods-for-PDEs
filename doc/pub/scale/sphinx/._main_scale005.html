

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The wave equation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Scaling of differential equations" href="index.html" />
    <link rel="next" title="The diffusion equation" href="._main_scale006.html" />
    <link rel="prev" title="Vibration problems" href="._main_scale004.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_scale006.html" title="The diffusion equation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_scale004.html" title="Vibration problems"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Scaling of differential equations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-wave-equation">
<span id="sec-scale-wave"></span><h1>The wave equation<a class="headerlink" href="#the-wave-equation" title="Permalink to this headline">¶</a></h1>
<p>A standard, linear, one-dimensional wave equation problem
in a homogeneous medium may be written as</p>
<div class="math" id="equation-scale:wave:pde1">
<span id="eq-scale-wave-pde1"></span><span class="eqno">(1)</span>\[     \frac{\partial^2 u}{\partial t^2} =
     c^2 {\partial^2 u\over\partial x^2}, \quad  x\in (0,L),\ t\in (0,T],\]</div>
<p>where <span class="math">\(c\)</span> is the constant wave velocity of the medium.
With a briefer notation, where subscripts indicate derivatives,
the PDE <a href="#equation-scale:wave:pde1">(1)</a> can be written
<span class="math">\(u_{tt}=c^2u_{xx}\)</span>. This subscript notation will occasionally be
used later.</p>
<p>In multi dimensions in heterogeneous media we have the generalization</p>
<div class="math" id="equation-scale:wave:pde1:3D">
<span id="eq-scale-wave-pde1-3d"></span><span class="eqno">(2)</span>\[     \frac{\partial^2 u}{\partial t^2} =
     \nabla\cdot\left(c^2 \nabla u\right) + f, \quad  x,y,z\in \Omega,\ t\in (0,T]{\thinspace .}\]</div>
<p>How to scale time depends on the PDE, the spatial scale depends on
the domain, and the scale of <span class="math">\(u\)</span> usually depends on the type of
boundary and initial condition.</p>
<div class="section" id="simple-homogeneous-dirichlet-conditions">
<h2>Simple homogeneous Dirichlet conditions<a class="headerlink" href="#simple-homogeneous-dirichlet-conditions" title="Permalink to this headline">¶</a></h2>
<p>Let us first start with homogeneous Dirichlet conditions in space and
no initial velocity <span class="math">\(u_t\)</span>:</p>
<div class="math" id="equation-scale:wave:pde1:ic:u">
<span id="eq-scale-wave-pde1-ic-u"></span><span class="eqno">(3)</span>\[     u(x,0) = I(x), \quad x\in [0,L],\]</div>
<div class="math" id="equation-scale:wave:pde1:ic:ut">
<span id="eq-scale-wave-pde1-ic-ut"></span><span class="eqno">(4)</span>\[     {\partial\over\partial t}u(x,0) = 0, \quad  x\in [0,L],\]</div>
<div class="math" id="equation-scale:wave:pde1:bc:0">
<span id="eq-scale-wave-pde1-bc-0"></span><span class="eqno">(5)</span>\[     u(0,t)  = 0, \quad   t\in (0,T],\]</div>
<div class="math" id="equation-scale:wave:pde1:bc:L">
<span id="eq-scale-wave-pde1-bc-l"></span><span class="eqno">(6)</span>\[     u(L,t)  = 0, \quad   t\in (0,T].\]</div>
<p>The independent variables are <span class="math">\(x\)</span> and <span class="math">\(t\)</span>, while <span class="math">\(u\)</span> is the dependent
variable.
The rest of the parameters, <span class="math">\(c\)</span>, <span class="math">\(L\)</span>, <span class="math">\(T\)</span>, and <span class="math">\(I(x)\)</span>, are given data.</p>
<p>We start with introducing dimensionless versions of the independent and
dependent variables:</p>
<div class="math">
\[\bar x = \frac{x}{x_c},\quad \bar t=\frac{t}{t_c},\quad\bar u=\frac{u}{u_c}
{\thinspace .}\]</div>
<p>Inserting the <span class="math">\(x=x_c\bar x\)</span>, etc., in <a href="#equation-scale:wave:pde1">(1)</a> and
<a href="#equation-scale:wave:pde1:ic:u">(3)</a>-<a href="#equation-scale:wave:pde1:bc:L">(6)</a> gives</p>
<div class="math">
\[\begin{split}\frac{\partial^2 \bar u}{\partial \bar t^2} &amp;=
\frac{t_c^2c^2}{x_c^2}{\partial^2 \bar u\over\partial x^2}, \quad &amp; \bar x\in (0,L/x_c),\ \bar t\in (0,T/t_c],
\\
\bar u(\bar x,0) &amp;= \frac{I(x_c\bar x)}{u_c},
\quad &amp;\bar x\in [0,L/x_c],
\\
\frac{\partial}{\partial \bar t}\bar u(\bar x,0) &amp;= 0,
\quad &amp; \bar x\in [0,L/x_c],
\\
\bar u(0,\bar t) &amp; = 0,
\quad  &amp; \bar t\in (0,T/t_c],
\\
\bar u(L/x_c,\bar t) &amp; = 0,
\quad &amp;\bar t\in (0,T/t_c].\end{split}\]</div>
<p>The key question is how to define the scales.
A natural choice is <span class="math">\(x_c=L\)</span> since this makes <span class="math">\(\bar x\in [0,1]\)</span>.
For the problem governed by
<a href="#equation-scale:wave:pde1">(1)</a> we
have some analytical insight, namely that the solution behaves like</p>
<div class="math" id="equation-scale:wave:pde:sol:general">
<span id="eq-scale-wave-pde-sol-general"></span><span class="eqno">(7)</span>\[     u(x,t) = f_R(x-ct) + f_R(x+ct),\]</div>
<p>i.e., a right- and left-going wave with velocity <span class="math">\(c\)</span>. The initial
conditions constrain the choices of <span class="math">\(f_R\)</span> and <span class="math">\(f_L\)</span> to <span class="math">\(f_L + f_R=I\)</span>
and <span class="math">\(-cf_L' + cf_R' = 0\)</span>. The solution is <span class="math">\(f_R = f_L = \frac{1}{2}\)</span>,
and consequently</p>
<div class="math">
\[u(x,t) = \frac{1}{2}I(x-ct) + \frac{1}{2}I(x+ct),\]</div>
<p>which tells that the initial condition splits in two, half of it moves
to the left and half to the right.
This means in particular that we can choose <span class="math">\(u_c=\max_x |I(x)|\)</span>
and get <span class="math">\(|\bar u|\leq 1\)</span>, which is a goal.</p>
<p>Regarding the time scale, we may look at the two terms in the scaled
PDE and argue that if <span class="math">\(|u|\)</span> and its derivatives are to be of order unity,
then the size of the second-order derivatives should be the same, and
<span class="math">\(t_c\)</span> can be chosen to make the coefficient <span class="math">\(t_c^2 c^2 /x_c^2\)</span> unity,
i.e., <span class="math">\(t_c=L/c\)</span>.
Another reasoning may set <span class="math">\(t_c\)</span> as the time it takes the wave
to travel through the domain <span class="math">\([0,L]\)</span>. Since the wave has constant
speed <span class="math">\(c\)</span>, <span class="math">\(t_c = L/c\)</span>.</p>
<p>With the described choices of scales,
we end up with the dimensionless initial-boundary value problem</p>
<div class="math" id="equation-scale:wave:pde1:d">
<span id="eq-scale-wave-pde1-d"></span><span class="eqno">(8)</span>\[     \frac{\partial^2 \bar u}{\partial \bar t^2} =
     {\partial^2 \bar u\over\partial x^2}, \quad  \bar x\in (0,1),\ \bar t\in (0,\bar T],\]</div>
<div class="math" id="equation-scale:wave:pde1:ic:u:d">
<span id="eq-scale-wave-pde1-ic-u-d"></span><span class="eqno">(9)</span>\[     \bar u(\bar x,0) = \frac{I(\bar x L)}{\max_{x\in(0,L)} |I(x)|},
     \quad \bar x\in [0,1],\]</div>
<div class="math" id="equation-scale:wave:pde1:ic:ut:d">
<span id="eq-scale-wave-pde1-ic-ut-d"></span><span class="eqno">(10)</span>\[     {\partial\over\partial \bar t}\bar u(\bar x,0) = 0,
     \quad  \bar x\in [0,1],\]</div>
<div class="math" id="equation-scale:wave:pde1:bc:0:d">
<span id="eq-scale-wave-pde1-bc-0-d"></span><span class="eqno">(11)</span>\[     \bar u(0,\bar t)  = 0,
     \quad  \bar t\in (0,\bar T],\]</div>
<div class="math" id="equation-scale:wave:pde1:bc:L:d">
<span id="eq-scale-wave-pde1-bc-l-d"></span><span class="eqno">(12)</span>\[     \bar u(1,\bar t)  = 0,
     \quad  \bar t\in (0,\bar T].\]</div>
<p>Here, <span class="math">\(\bar T = Tc/L\)</span>.</p>
<p>The striking feature of
<a href="#equation-scale:wave:pde1:d">(8)</a>-<a href="#equation-scale:wave:pde1:bc:L:d">(12)</a>
is that there are <em>no physical parameters</em> involved! Everything we need
to specify is the shape of the initial condition and then scale it
such that it is less than or equal to 1.</p>
<p>The physical solution with dimension is recovered from <span class="math">\(\bar u(\bar x,\bar t)\)</span>
through</p>
<div class="math">
\[u(x,t) = \max_{x\in(0,L)}I(x)\,\bar u(\bar x L, \bar t L/c)\]</div>
</div>
<div class="section" id="implementation-of-the-scaled-wave-equation">
<h2>Implementation of the scaled wave equation<a class="headerlink" href="#implementation-of-the-scaled-wave-equation" title="Permalink to this headline">¶</a></h2>
<p>How do we implement <a href="#equation-scale:wave:pde1:d">(8)</a>-<a href="#equation-scale:wave:pde1:bc:L:d">(12)</a>?
As for the simpler mathematical models, I suggest to implement the model
with dimensions and observe how to set parameters to obtain the scaled
model. In the present case, one must choose <span class="math">\(L=1\)</span>, <span class="math">\(c=1\)</span>, and scale <span class="math">\(I\)</span> by its
maximum value. That&#8217;s all!</p>
<p>Several implementations of 1D wave equation models with different
degree of mathematical and software complexity appear in
the directory <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D">wave/wave1D</a>. The simplest
version is <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_u0.py">wave1D_u0.py</a>
that implements <a href="#equation-scale:wave:pde1">(1)</a> and
(<span class="xref std std-ref">scale:wave:pde1:ic:u</span>-<a href="#equation-scale:wave:pde1:bc:L">(6)</a>.
This is the code to be used in the following. It is described
in in
the document <a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/wave">Finite difference methods for wave motion</a>
<a class="reference internal" href="._main_scale009.html#ref6" id="id1">[Ref6]</a>.</p>
<div class="section" id="waves-on-a-string">
<h3>Waves on a string<a class="headerlink" href="#waves-on-a-string" title="Permalink to this headline">¶</a></h3>
<p>As example, we may let the original initial-boundary value problem
<a href="#equation-scale:wave:pde1">(1)</a>-<a href="#equation-scale:wave:pde1:bc:L">(6)</a> model
vibrations of a string on a string instrument. With <span class="math">\(u\)</span> as the
displacement of the string, the boundary conditions <span class="math">\(u=0\)</span> at the ends
are relevant, as well as the zero velocity condition <span class="math">\(\partial u/\partial t=0\)</span>
at <span class="math">\(t=0\)</span>.
The initial condition <span class="math">\(I(x)\)</span> has typically a triangular shape for a picked
guitar string.
The physical problem needs parameters for the amplitude of <span class="math">\(I(x)\)</span>,
the length <span class="math">\(L\)</span> of the string, and the value of <span class="math">\(c\)</span> for the string. Only
the latter is challenging as it involves relating <span class="math">\(c\)</span> to the
pitch (i.e., time frequency) of the string. In the scaled problem, we
can forget about all this. We simply set <span class="math">\(L=1\)</span>, <span class="math">\(c=1\)</span>, and let
<span class="math">\(I(x)\)</span> have a peak of unity at <span class="math">\(x=x_0\in(0,1)\)</span>:</p>
<div class="math">
\[\begin{split}\frac{I(x)}{\max_x I(x)} = \left\lbrace
\begin{array}{ll}
x/x_0, &amp; x &lt; x_0,\\
(1-x)/(1-x_0), &amp; \hbox{otherwise}
\end{array}\right.\end{split}\]</div>
<p>The dimensionless coordinate of the peak, <span class="math">\(x_0\)</span>, is the only
dimensionless parameter in the problem. For fixed <span class="math">\(x_0\)</span>,
one single simulation will capture all possible solutions with such
a triangular shape.</p>
</div>
<div class="section" id="detecting-an-already-computed-case">
<h3>Detecting an already computed case<a class="headerlink" href="#detecting-an-already-computed-case" title="Permalink to this headline">¶</a></h3>
<p>In the section <a class="reference internal" href="._main_scale003.html#sec-scale-decay-prog"><span class="std std-ref">Making software utilizing the dimensionless model</span></a> we demonstrated the use of <code class="docutils literal"><span class="pre">joblib</span></code>
for making a function that detects if a case has already been run and
in that case the previous solution can be returned from a database.
It turns out that <code class="docutils literal"><span class="pre">joblib</span></code> cannot handle functions with function arguments,
which we have a lot of in the <code class="docutils literal"><span class="pre">solver</span></code> functions for 1D wave equations.</p>
<p>A manual strategy taken from <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn_vc.py">wave1D_dn_vc.py</a> and explained in
the document
<a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/softeng2">Scientific software engineering; wave equation model</a> <a class="reference internal" href="._main_scale009.html#ref7" id="id2">[Ref7]</a>
is to convert
all input data to the <code class="docutils literal"><span class="pre">solver</span></code> function to a string,
which is thereafter converted to an SHA1 hash string
(via <code class="docutils literal"><span class="pre">hashlib.sha1</span></code>) and used to recognize the input.
A SHA1 string is also suitable as part of a file or directory name
where computed solutions can be stored.</p>
<p>We can, in the wave equation solver
retrieve the solution, rather than computing it, if
the hash string is the same (because then the computations have already been
done). This can save a lot of computations if a scaled solution can be
reused in a number of cases with dimensions. We will sketch the
code that implements the idea.</p>
<p>A solver for the scaled problem is first developed. We limit the
focus to the simple constant-coefficient wave equation with <span class="math">\(u_t(x,0)=0\)</span>.
The solver for the unscaled problem is taken from the previously
mentioned <code class="docutils literal"><span class="pre">wave1D_u0.py</span></code> file.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Enable loading modules in the wave eq solver and softeng2 dirs</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
    <span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">,</span> <span class="s">&#39;wave&#39;</span><span class="p">,</span> <span class="s">&#39;src-wave&#39;</span><span class="p">,</span> <span class="s">&#39;wave1D&#39;</span><span class="p">))</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
    <span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">pardir</span><span class="p">,</span> <span class="s">&#39;softeng2&#39;</span><span class="p">,</span> <span class="s">&#39;src-softeng2&#39;</span><span class="p">))</span>
<span class="kn">from</span> <span class="nn">wave1D_u0</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver_unscaled</span>
<span class="kn">from</span> <span class="nn">Storage</span> <span class="kn">import</span> <span class="n">Storage</span>

<span class="k">def</span> <span class="nf">solver_scaled</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve 1D wave equation in dimensionless form.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c"># Make a hash of the arguments</span>
    <span class="kn">import</span> <span class="nn">inspect</span><span class="o">,</span> <span class="nn">hashlib</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> \
           <span class="nb">str</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="c"># Not fool proof: if x0 changes value, I source is the same...</span>
    <span class="n">hashed_input</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

    <span class="n">cachedir</span> <span class="o">=</span> <span class="s">&#39;tmp_</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">hashed_input</span>
    <span class="n">is_computed</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">cachedir</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;cachedir:&#39;</span><span class="p">,</span> <span class="n">cachedir</span><span class="p">,</span> <span class="n">is_computed</span>
    <span class="n">storage</span> <span class="o">=</span> <span class="n">Storage</span><span class="p">(</span><span class="n">cachedir</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">action</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">storage</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">storage</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">storage</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s">&#39;u</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">is_computed</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;No need to compute the numerical solution&#39;</span>
        <span class="k">return</span> <span class="n">storage</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&#39;Computing the numerical solution&#39;</span>
        <span class="n">solver_unscaled</span><span class="p">(</span>
            <span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span>
            <span class="n">user_action</span><span class="o">=</span><span class="n">action</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">storage</span>
</pre></div>
</div>
<p>This function employs ideas described in
the document
<a class="reference external" href="http://tinyurl.com/k3sdbuv/pub/softeng2">Scientific software engineering; wave equation model</a> <a class="reference internal" href="._main_scale009.html#ref7" id="id3">[Ref7]</a> for storing
arrays on disk with use of <code class="docutils literal"><span class="pre">joblib</span></code> (class <code class="docutils literal"><span class="pre">Storage</span></code>) and recognizing
previous input through a hash string. If the input is the same, the
hash is the same and we can test on the existence of a
directory whose name contains the hash. If that directory exists, the
solution for this set of input data is already computed, and we can just
return the <code class="docutils literal"><span class="pre">storage</span></code> object from which one can retrieve the space and time
mesh as well as all the solutions <code class="docutils literal"><span class="pre">u0</span></code>, <code class="docutils literal"><span class="pre">u1</span></code>, and so on.</p>
<p>A specific application of this simple solver is the vibrations of a guitar
string. The scaled version depends only on <span class="math">\(C\)</span> (if we say <span class="math">\(T\)</span> is fixed
and <span class="math">\(N_x\)</span> is fixed through <span class="math">\(\Delta t\)</span>). The string vibrations can be
simulated by the following function:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">guitar_scaled</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Triangular wave (pulled guitar string).&quot;&quot;&quot;</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">L</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">dx</span><span class="o">/</span><span class="mi">1</span>  <span class="c"># Choose dt at the stability limit</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">/</span><span class="n">x0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x0</span> <span class="k">else</span> <span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span>

    <span class="n">storage</span> <span class="o">=</span> <span class="n">solver_scaled</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">animate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">storage</span>

    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">plot</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="s">&#39;u</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span><span class="n">n</span><span class="p">)</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
             <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">storage</span>
</pre></div>
</div>
<p>Although the partial differential equation model has no physical
parameters (assuming <span class="math">\(x_0\)</span> fixed), the corresponding numerical model
depends on the Courant number <span class="math">\(C=c\Delta t/\Delta x\)</span> and the length
<span class="math">\(T\)</span> of the simulations.</p>
<p>To solve an unscaled problem, we need some unscale functions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">unscale_u</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">I_max</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I_max</span><span class="o">*</span><span class="n">u</span>

<span class="k">def</span> <span class="nf">unscale_x</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">I_max</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">L</span>

<span class="k">def</span> <span class="nf">unscale_t</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I_max</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">t</span><span class="o">*</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<p>We can now easily solve a range of unscaled cases by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">guitar</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">I_max</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Triangular wave (pulled guitar string). Unscaled version.&quot;&quot;&quot;</span>
    <span class="n">storage</span> <span class="o">=</span> <span class="n">guitar_scaled</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">animate</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="s">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">unscale_x</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">I_max</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">unscale_t</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I_max</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">plot</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="n">retrieve</span><span class="p">(</span><span class="s">&#39;u</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span><span class="n">n</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">unscale_u</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">I_max</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%.2f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
             <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">I_max</span><span class="o">*</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">I_max</span><span class="p">])</span>
</pre></div>
</div>
<p>If <code class="docutils literal"><span class="pre">guitar_scaled</span></code> figures out that the scaled problem is already solved,
it just returns the <code class="docutils literal"><span class="pre">storage</span></code> object, otherwise it performs calculations.
Anyway, we retrieve the space and time mesh as well as all the solutions.
The <code class="docutils literal"><span class="pre">plot</span></code> function from <a class="reference external" href="https://github.com/hplgit/scitools">SciTools</a>
is used for compact code for
animation, but Matplotlib can equally well be used (with a bit more coding).</p>
<p>Suppose we run three calls to <code class="docutils literal"><span class="pre">guitar</span></code> with three different values of
<code class="docutils literal"><span class="pre">I_max</span></code>. The output will be</p>
<div class="highlight-text"><div class="highlight"><pre>Computing the numerical solution
No need to compute the numerical solution
No need to compute the numerical solution
</pre></div>
</div>
<p>This indicates that we rely on the scaled solution for the two
other cases with different <code class="docutils literal"><span class="pre">I_max</span></code> parameter. Running such a program again
will avoid all computations and show movies solely based on
precomputed file data.</p>
<p>[<strong>hpl 3</strong>: I make a big issue of retrieving data from file, but in more complicated cases, this has little practical value as the number of dimensionless numbers gets large (approaching the number of parameters anyway). In the present simple cases, the computations are so fast that there is little to gain by avoiding them. The text is therefore biased with respect to the practical benefit of reusing old solutions. Nevertheless, it probably does not hurt to document the idea? Need views on this.]</p>
</div>
</div>
<div class="section" id="time-dependent-dirichlet-condition">
<span id="scale-wave-pde2"></span><h2>Time-dependent Dirichlet condition<a class="headerlink" href="#time-dependent-dirichlet-condition" title="Permalink to this headline">¶</a></h2>
<p>A generalization of <a href="#equation-scale:wave:pde1">(1)</a>-<a href="#equation-scale:wave:pde1:bc:L">(6)</a> is to
allow for a time-dependent Dirichlet condition at one end, say
<span class="math">\(u(0,t)=U_L(t)\)</span>. At the other end we may still have <span class="math">\(u=0\)</span>.
This new condition at <span class="math">\(x=0\)</span> may model a specified wave that
enters the domain. For example, if we feed in a monochromatic wave
<span class="math">\(A\sin(k(x-ct))\)</span> from the left end, <span class="math">\(U_L(t)=A\sin (kct)\)</span>.
This forcing of the wave motion has its own amplitude and time scale that
could affect the choice of <span class="math">\(u_c\)</span> and <span class="math">\(t_c\)</span>.</p>
<p>The main difference from the previous initial-boundary value problem
is the condition at <span class="math">\(x=0\)</span>, which now reads</p>
<div class="math">
\[\bar u(0,\bar t) = \frac{U_L(\bar t t_c)}{u_c}\]</div>
<p>in scaled form.</p>
<p>Regarding the characteristic time scale, it is natural to base this scale on
the wave propagation velocity and not on the time scale of <span class="math">\(U_L(t)\)</span>, because
the time scale of <span class="math">\(U_L\)</span> basically determines whether
short or long waves are fed in at the boundary. All waves, long or short,
propagate with the same velocity <span class="math">\(c\)</span>. We therefore continue
to use <span class="math">\(t_c=L/c\)</span>.</p>
<p>The solution <span class="math">\(u\)</span> will have
one wave contribution from the initial condition <span class="math">\(I\)</span> and one from the
feeding of waves at <span class="math">\(x=0\)</span>. This gives us three choices of <span class="math">\(u_c\)</span>:
<span class="math">\(\max_x |I| + \max_t |U_L|\)</span>, <span class="math">\(\max_x |I|\)</span>, or <span class="math">\(\max_t |U_L|\)</span>. The first seems
relevant if the size of <span class="math">\(I\)</span> and <span class="math">\(U_L\)</span> are about the same, but then
we can choose either <span class="math">\(\max_x |I|\)</span> or <span class="math">\(\max_t |U_L|\)</span> as characteristic size
of <span class="math">\(u\)</span> since a factor of 2 is not important. If <span class="math">\(I\)</span> is much less than
<span class="math">\(U_L\)</span>, <span class="math">\(u_c=\max_t |u_L|\)</span> is relevant, while <span class="math">\(u_c=\max_xI\)</span> is the choice
when <span class="math">\(I\)</span> has much bigger impact than <span class="math">\(U_L\)</span> on <span class="math">\(u\)</span>.</p>
<p>With <span class="math">\(u_c=\max_t |U_L(t)|\)</span>, we get the scaled problem</p>
<div class="math" id="equation-scale:wave:pde2:d">
<span id="eq-scale-wave-pde2-d"></span><span class="eqno">(13)</span>\[     \frac{\partial^2 \bar u}{\partial \bar t^2} =
     {\partial^2 \bar u\over\partial \bar x^2},
     \quad  \bar x\in (0,1),\ \bar t\in (0,\bar T],\]</div>
<div class="math" id="equation-scale:wave:pde2:ic:u:d">
<span id="eq-scale-wave-pde2-ic-u-d"></span><span class="eqno">(14)</span>\[     \bar u(\bar x,0) = \frac{I(x_c\bar x)}{\max_t |U_L(t)|},
     \quad \bar x\in [0,1],\]</div>
<div class="math" id="equation-scale:wave:pde2:ic:ut:d">
<span id="eq-scale-wave-pde2-ic-ut-d"></span><span class="eqno">(15)</span>\[     {\partial\over\partial \bar t}\bar u(\bar x,0) = 0,
     \quad  \bar x\in [0,1],\]</div>
<div class="math" id="equation-scale:wave:pde2:bc:0:d">
<span id="eq-scale-wave-pde2-bc-0-d"></span><span class="eqno">(16)</span>\[     \bar u(0,\bar t)  = \frac{U_L(\bar tt_c)}{\max_t |U_L(t)|},
     \quad  \bar t\in (0,\bar T],\]</div>
<div class="math" id="equation-scale:wave:pde2:bc:L:d">
<span id="eq-scale-wave-pde2-bc-l-d"></span><span class="eqno">(17)</span>\[     \bar u(1,\bar t)  = 0,
     \quad \bar t\in (0,\bar T].\]</div>
<p>Also this problem is free of physical parameters like <span class="math">\(c\)</span> and <span class="math">\(L\)</span>.
The input is completely specified by the shape of <span class="math">\(I(x)\)</span> and <span class="math">\(U_L(t)\)</span>.</p>
<p>Software for the original problem with dimensions can be reused for
<a href="#equation-scale:wave:pde2:d">(13)</a>-<a href="#equation-scale:wave:pde2:bc:L:d">(17)</a> by
setting <span class="math">\(L=1\)</span>, <span class="math">\(c=1\)</span>, and scaling <span class="math">\(U_L(t)\)</span> and <span class="math">\(I(x)\)</span> by
<span class="math">\(\max_t |U_L(t)|\)</span>.</p>
<p>As an example, consider</p>
<div class="math">
\[\begin{split}U_L(t) &amp;= a\sin(\omega t)\hbox{ for } 0\leq t\leq 2\frac{\omega}{2\pi},
\hbox{ else } 0,\\
I(x)   &amp; = Ae^{-(x-L/2)^2/\sigma^2}{\thinspace .}\end{split}\]</div>
<p>That is, we start with a Gaussian peak-shaped wave in the center of the
domain and feed in a sinusoidal wave at the left end for two periods.
The solution will be the sum of three waves: two parts from the initial
condition, plus the wave fed in from the left.</p>
<p>Since <span class="math">\(\max_t |U_L|=a\)</span> we get</p>
<div class="math">
\[\begin{split}\bar u(\bar x,0) &amp;= \frac{A}{a}e^{-(L/\sigma)^2(\bar x -\frac{1}{2})^2},\\
\bar u(0,\bar t) &amp;= \sin(\bar t\omega L/c){\thinspace .}\end{split}\]</div>
<p>Here, <span class="math">\(U_L\)</span> models an incoming wave <span class="math">\(a\sin(k(x-ct)\)</span>, with <span class="math">\(k\)</span> specified
(makes waves of length <span class="math">\(\lambda = 2\pi/k\)</span>), we have <span class="math">\(\omega =kc\)</span>,
and <span class="math">\(\bar u(0,\bar t)=\sin(kL\bar t) = \sin(2\pi\bar t L/\lambda)\)</span>.
(This formula demonstrates the previous assertion that the time scale
of <span class="math">\(U_L\)</span>, i.e., <span class="math">\(1/\omega\)</span>, determines the wave length <span class="math">\(1/\omega = \lambda/(2\pi)\)</span> in space.)
We realize from the formulas for <span class="math">\(\bar u(\bar x, 0)\)</span> and
<span class="math">\(\bar u(0,\bar t)\)</span> that there are three key dimensionless parameters related
to these specific choices of initial and boundary conditions:</p>
<div class="math">
\[\alpha = \frac{A}{a},\quad\beta = \frac{L}{\sigma},\quad\gamma = kL
=2\pi\frac{L}{\lambda}{\thinspace .}\]</div>
<p>With <span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, and <span class="math">\(\gamma\)</span> we can write the dimensionless
initial and boundary conditions as</p>
<div class="math">
\[\begin{split}\bar u(\bar x,0) &amp;= \alpha e^{-\beta^2(\bar x -\frac{1}{2})^2},\\
\bar u(0,\bar t) &amp;= \sin(\gamma\bar t){\thinspace .}\end{split}\]</div>
<p>The dimensionless parameters have the following interpretations:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math">\(\alpha\)</span>: ratio of initial condition peak and amplitude of incoming wave
at <span class="math">\(x=0\)</span></li>
<li><span class="math">\(\beta\)</span>: ratio of length of domain and width of initial condition</li>
<li><span class="math">\(\gamma\)</span>: ratio of length of domain and wave length of incoming wave</li>
</ul>
</div></blockquote>
<p>Again, these dimensionless parameters tell a lot about the interplay of
the physical effects in the problem: only some ratios count.</p>
<p>We can simulate two special cases: <span class="math">\(\alpha=10\)</span> (large) where the
incoming wave is small and the solution is dominated by the two waves
arising from <span class="math">\(I(x)\)</span>, and <span class="math">\(\alpha=0.1\)</span> (small) where the incoming waves
dominate and the has the initial condition as a small perturbation of
the wave shape. We may choose a peak-shaped initial condition: <span class="math">\(\beta = 10\)</span>,
and also a relatively short incoming wave compared to the domain size:
<span class="math">\(\gamma 6\pi\)</span> (i.e., wave length of incoming wave is <span class="math">\(L/6\)</span>).
The function below applies the general unscaled
solver in <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn.py">wave1D_dn.py</a>
for solving the wave equation with constant <span class="math">\(c\)</span>
and any time-dependent function or <span class="math">\(\partial u/\partial x=0\)</span> at the
end points.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">simulate_Gaussian_and_incoming_wave</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">wave1D_dn</span> <span class="kn">import</span> <span class="n">solver</span><span class="p">,</span> <span class="n">viz</span>
    <span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mi">3</span>

    <span class="k">def</span> <span class="nf">I</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">alpha</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">beta</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">U_0</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">gamma</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="n">L</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">80</span><span class="p">;</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">L</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">Nx</span><span class="p">);</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">dx</span><span class="o">/</span><span class="mi">1</span>
    <span class="c">#solver(I=I, V=0, f=0, U_0=U_0, U_L=None, L=1, dt=dt, C=1, T=4,</span>
    <span class="c">#       user_action=myplotter)</span>
    <span class="n">viz</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">U_0</span><span class="o">=</span><span class="n">U_0</span><span class="p">,</span> <span class="n">U_L</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">T</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">umin</span><span class="o">=-</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">umax</span><span class="o">=</span><span class="p">(</span><span class="n">alpha</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span>
        <span class="n">version</span><span class="o">=</span><span class="s">&#39;vectorized&#39;</span><span class="p">,</span> <span class="n">animate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The function is found in the file <a class="reference external" href="http://tinyurl.com/nm5587k/scale/session.py">session.py</a>.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-scale/gaussian_plus_incoming/alpha10.mp4"  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src="_static/mov-scale/gaussian_plus_incoming/alpha10.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-scale/gaussian_plus_incoming/alpha10.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em> \( \alpha=10 \) </em></p><div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-scale/gaussian_plus_incoming/alpha01.mp4"  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src="_static/mov-scale/gaussian_plus_incoming/alpha01.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-scale/gaussian_plus_incoming/alpha01.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em> \( \alpha=0.1 \) </em></p></div>
<div class="section" id="velocity-initial-condition">
<span id="scale-wave-pde2-vcond"></span><h2>Velocity initial condition<a class="headerlink" href="#velocity-initial-condition" title="Permalink to this headline">¶</a></h2>
<p>Now we change the initial condition from <span class="math">\(u=I\)</span> and <span class="math">\(\partial u/\partial t = 0\)</span> to</p>
<div class="math">
\[u(x,0) = 0,\]</div>
<div class="math">
\[\frac{\partial}{\partial t} u(x,0) = V(x){\thinspace .}\]</div>
<p>Impact problems are often of this kind.
From <a href="#equation-scale:wave:pde:sol:general">(7)</a> we now get <span class="math">\(f_L + f_R =0\)</span> and
<span class="math">\(cf_L' - cf_R' = V\)</span>. Introducing <span class="math">\(W(x)\)</span> such that <span class="math">\(W'(x)=V(x)\)</span>, a solution
is <span class="math">\(-f_L=\frac{1}{2}W\)</span> and <span class="math">\(f_R=\frac{1}{2}W\)</span>. Hence,</p>
<div class="math">
\[u(x,t) = \frac{1}{2c}\int_{x-ct}^{x+ct} v(\xi) d\xi{\thinspace .}\]</div>
<p>The scaled version of <span class="math">\(u_t(x,0)=V(x)\)</span> becomes</p>
<div class="math">
\[\frac{\partial}{\partial \bar t} \bar u(\bar x,0) =
\frac{t_c}{u_c}V(\bar x x_c){\thinspace .}\]</div>
<p>Since <span class="math">\(V\)</span> is the time-derivative of <span class="math">\(u\)</span>, the characteristic size of
<span class="math">\(V\)</span> is typically <span class="math">\(u_c/t_c\)</span>, meaning that</p>
<div class="math">
\[\max_{x\in(0,L)}|V(x)| = \frac{u_c}{t_c},\]</div>
<p>which gives $ u_c = max_{xin(0,L)}|V(x)| L/c$. As usual, we base <span class="math">\(t_c\)</span>
on the wave speed: <span class="math">\(t_c = L/c\)</span>. We end up with</p>
<div class="math">
\[\frac{\partial}{\partial \bar t} \bar u(\bar x,0) =
\frac{V(\bar x x_c)}{\max_x |V(x)|},\]</div>
<p>which also looks like a natural scaling of a function <span class="math">\(V\)</span>.</p>
<p>Suppose we change the initial condition <span class="math">\(u(x,0)=0\)</span> to <span class="math">\(u(x,0)=I(x)\)</span>.
The scaled version of this condition with the present <span class="math">\(u_c\)</span> becomes</p>
<div class="math">
\[\bar u(\bar x, 0) = \frac{cI(\bar x x_c)}{L\max_x |V(x)|}{\thinspace .}\]</div>
<div class="admonition-check-that-dimensionless-numbers-are-dimensionless admonition">
<p class="first admonition-title">Check that dimensionless numbers are dimensionless</p>
<p>Is the fraction on the right-hand side dimensionless?
It is easy to make errors when scaling equations, so checking that
such fractions are dimensionless is wise.
The dimension of <span class="math">\(I\)</span> is the same as <span class="math">\(u\)</span>, here taken to be displacement:
[L].
Since <span class="math">\(V\)</span> is <span class="math">\(\partial u/\partial t\)</span>, its dimension is
<span class="math">\([\hbox{LT}^{-1}]\)</span>. The dimensions of <span class="math">\(c\)</span> and <span class="math">\(L\)</span> are
<span class="math">\([\hbox{LT}^{-1}]\)</span> and <span class="math">\([\hbox{L}]\)</span>. The dimension of the right-hand side
is then</p>
<div class="math">
\[\frac{[\hbox{LT}^{-1}][L]}{[L][L\hbox{T}^{-1}]}
= 1,\]</div>
<p class="last">demonstrating that the fraction is indeed dimensionless.</p>
</div>
<p>One may introduce a dimensionless initial
shape, <span class="math">\(\bar I (\bar x)= I(\bar xL)/\max_x |I|\)</span>. Then</p>
<div class="math">
\[\bar u(\bar x, 0) = \alpha\bar I(\bar x),\]</div>
<p>where <span class="math">\(\alpha\)</span> the dimensionless number</p>
<div class="math">
\[\alpha = \frac{c}{L}\frac{\max_x |I(x)|}{\max_x |V(x)|}{\thinspace .}\]</div>
<p id="index-0">If <span class="math">\(V\)</span> is much larger than <span class="math">\(I\)</span>, one expects that the influence of <span class="math">\(I\)</span>
is small. However, it takes time for the initial velocity <span class="math">\(V\)</span> to
influence the wave motion, so if <span class="math">\(c\)</span> is much bigger than <span class="math">\(L\)</span>, the
initial wave shape <span class="math">\(I\)</span>
travels quickly through the domain before the effect of <span class="math">\(V\)</span> becomes
visible. The impact of <span class="math">\(I\)</span> may therefore be significant for small <span class="math">\(t\)</span>.
This is reflected in an
<span class="math">\(\alpha\)</span> value that is not small since <span class="math">\(c/L\)</span> is large and <span class="math">\(\max |I|/\max |V|\)</span>
is small, resulting in a scaled initial condition <span class="math">\(\bar u(\bar x,0)\)</span>
that is not small.
With <span class="math">\(c/L\)</span> about unity, <span class="math">\(\alpha\)</span> becomes small, and <span class="math">\(\bar u(\bar x,0)
\approx 0\)</span> such that not much happens before the effect of <span class="math">\(V\)</span> becomes
visible. Recall that the dimensionless initial velocity is about unity
regardless of other parameters.
Again, the scaling and the resulting dimensionless parameter(s)
teach us much about the interaction of the various physical effects.</p>
<p>[<strong>hpl 4</strong>: Do experiments. Make exercise or insert here.]</p>
<p>[<strong>hpl 5</strong>: Could make paradox: small <span class="math">\(I\)</span>, big <span class="math">\(V\)</span>, but still significant impact of <span class="math">\(I\)</span> in a simulation. Why? Bug? The answer is above. Best as exercise.]</p>
</div>
<div class="section" id="variable-wave-velocity-and-forcing">
<span id="scale-wave-pde2-cvar"></span><h2>Variable wave velocity and forcing<a class="headerlink" href="#variable-wave-velocity-and-forcing" title="Permalink to this headline">¶</a></h2>
<p>The next problem generalization regards wave propagation in
a non-homogeneous where the wave velocity <span class="math">\(c\)</span> depends on the
spatial position: <span class="math">\(c=c(x)\)</span>. To simplify the notation we introduce
<span class="math">\(\lambda (x) = c^2(x)\)</span>. We introduce homogeneous Neumann conditions
at <span class="math">\(x=0\)</span> and <span class="math">\(x=L\)</span>. In addition, we add a force term <span class="math">\(f(x,t)\)</span>
to the PDE, modeling wave generation in the interior of
the domain. For example, a moving slide at the bottom of a fjord
will generate surface waves and is modeled by such an <span class="math">\(f(x,t)\)</span> term.
The initial-boundary value problem
can be then expressed as</p>
<div class="math" id="equation-scale:wave:pde3">
<span id="eq-scale-wave-pde3"></span><span class="eqno">(18)</span>\[     \frac{\partial^2 u}{\partial t^2} =
     \frac{\partial}{\partial x}\left(
     \lambda(x) {\partial u\over\partial x}\right) + f(x,t),
     \quad  x\in (0,L),\ t\in (0,T],\]</div>
<div class="math" id="equation-scale:wave:pde3:ic:u">
<span id="eq-scale-wave-pde3-ic-u"></span><span class="eqno">(19)</span>\[     u(x,0) = I(x),
     \quad x\in [0,L],\]</div>
<div class="math" id="equation-scale:wave:pde3:ic:ut">
<span id="eq-scale-wave-pde3-ic-ut"></span><span class="eqno">(20)</span>\[     {\partial\over\partial t}u(x,0) = 0,
     \quad  x\in [0,L],\]</div>
<div class="math" id="equation-scale:wave:pde3:bc:0">
<span id="eq-scale-wave-pde3-bc-0"></span><span class="eqno">(21)</span>\[     \frac{\partial}{\partial x}u(0,t)  = 0,
     \quad  t\in (0,T],\]</div>
<div class="math" id="equation-scale:wave:pde3:bc:L">
<span id="eq-scale-wave-pde3-bc-l"></span><span class="eqno">(22)</span>\[     \frac{\partial}{\partial x}u(L,t)  = 0,
     \quad  t\in (0,T].\]</div>
<p>We make the coefficient <span class="math">\(\lambda\)</span> non-dimensional by</p>
<div class="math">
\[\bar\lambda(\bar x) = \frac{\lambda(\bar xx_c)}{\lambda_c},\]</div>
<p>where one normally chooses the characteristic size of <span class="math">\(\lambda\)</span>, <span class="math">\(\lambda_c\)</span>,
to be the maximum value such that <span class="math">\(|\lambda|\leq 1\)</span>:</p>
<div class="math">
\[\lambda_c = \max_{x\in(0,L)}\lambda(x){\thinspace .}\]</div>
<p>Similarly, <span class="math">\(f\)</span> has a scaled version</p>
<div class="math">
\[\bar f(\bar x,\bar t) = \frac{f(\bar x x_c, \bar t t_c)}{f_c},\]</div>
<p>where normally</p>
<div class="math">
\[f_c=\max_{x,t}|f(x,t)|{\thinspace .}\]</div>
<p>Inserting dependent and independent variables expressed by their
non-dimensional counterparts yields</p>
<div class="math" id="equation-scale:wave:pde3:d">
<span id="eq-scale-wave-pde3-d"></span><span class="eqno">(23)</span>\[     \frac{\partial^2 \bar u}{\partial \bar t^2} =
     \frac{t_c^2\lambda_c}{L^2}\frac{\partial}{\partial \bar x}\left(
     \bar\lambda(\bar x) {\partial\bar u\over\partial\bar x}\right)
     + \frac{t_c^2f_c}{u_c}\bar f(\bar x,\bar t),
     \quad  \bar x\in (0,1),\ \bar t\in (0,\bar T],\]</div>
<div class="math" id="equation-scale:wave:pde3:ic:u:d">
<span id="eq-scale-wave-pde3-ic-u-d"></span><span class="eqno">(24)</span>\[     \bar u(\bar x,0) = \frac{I(x)}{u_c},
     \quad \bar x\in [0,1],\]</div>
<div class="math" id="equation-scale:wave:pde3:ic:ut:d">
<span id="eq-scale-wave-pde3-ic-ut-d"></span><span class="eqno">(25)</span>\[     {\partial\over\partial \bar t}\bar u(\bar x,0) = 0,
     \quad  \bar x\in [0,1],\]</div>
<div class="math" id="equation-scale:wave:pde3:bc:0:d">
<span id="eq-scale-wave-pde3-bc-0-d"></span><span class="eqno">(26)</span>\[     \frac{\partial}{\partial \bar \bar x}\bar u(0,\bar t)  = 0,
     \quad  \bar t\in (0,\bar T],\]</div>
<div class="math" id="equation-scale:wave:pde3:bc:L:d">
<span id="eq-scale-wave-pde3-bc-l-d"></span><span class="eqno">(27)</span>\[     \frac{\partial}{\partial \bar x}\bar u(1,\bar t)  = 0,
     \quad  \bar t\in (0,\bar T],\]</div>
<p>with <span class="math">\(\bar T = Tc/L\)</span>.</p>
<p>The time scale is, as before, chosen as <span class="math">\(t_c
=L/\sqrt{\lambda_c}\)</span>. Note that the previous (constant) wave velocity
<span class="math">\(c\)</span> now corresponds to <span class="math">\(\sqrt{\lambda (x)}\)</span>.  Therefore,
<span class="math">\(\sqrt{\lambda_c}\)</span> is a characteristic wave velocity.</p>
<p>One could wonder if the time scale of the force term, <span class="math">\(f(x,t)\)</span>,
should influence <span class="math">\(t_c\)</span>, but as we reasoned for the boundary condition
<span class="math">\(u(0,t)=U_L(t)\)</span>, we let the characteristic time be governed by the
signal speed in the medium, i.e., by <span class="math">\(\sqrt{\lambda_c}\)</span> here and not
by the time scale of the excitation <span class="math">\(f\)</span> which dictates the
length of the generated waves and not their propagation speed.</p>
<p>Furthermore, we may choose <span class="math">\(u_c\)</span> as <span class="math">\(\max_x |I(x)|\)</span>, as before,
or we may fit <span class="math">\(u_c\)</span> such that the coefficient in the source term
is unity, i.e., all terms balance each other.
This latter idea leads to</p>
<div class="math">
\[u_c = \frac{L^2 f_c}{\lambda_c}\]</div>
<p>and a PDE without parameters,</p>
<div class="math">
\[\frac{\partial^2 \bar u}{\partial \bar t^2} =
\frac{\partial}{\partial \bar x}\left(
\bar\lambda(\bar x) {\partial\bar u\over\partial\bar x}\right)
+ \bar f(\bar x,\bar t){\thinspace .}\]</div>
<p>The initial condition <span class="math">\(u(x,0)=I(x)\)</span> becomes in dimensionless form</p>
<div class="math">
\[\bar u(\bar x, 0) = u_c^{-1} \max_x |I(x)|\bar I(\bar x) =
\beta^{-1}\bar I(\bar x),\]</div>
<p>where</p>
<div class="math">
\[\beta = \frac{L^2}{\lambda_c}\frac{\max_{x,t} |f(x,t)|}{\max_x|I(x)|}{\thinspace .}\]</div>
<p>In the case <span class="math">\(u_c=\max_x|I(x)|\)</span>, <span class="math">\(\bar u(\bar x,0)=\bar I(\bar x)\)</span> and
the <span class="math">\(\beta\)</span> parameter appears in the PDE,</p>
<div class="math">
\[\frac{\partial^2 \bar u}{\partial \bar t^2} =
\frac{\partial}{\partial \bar x}\left(
\bar\lambda(\bar x) {\partial\bar u\over\partial\bar x}\right)
+ \beta \bar f(\bar x,\bar t){\thinspace .}\]</div>
<p>With <span class="math">\(V=0\)</span>, and <span class="math">\(u=0\)</span> or <span class="math">\(u_x=0\)</span> on the boundaries <span class="math">\(x=0,L\)</span>, this scaling gives
<span class="math">\(|\bar u|\leq 1\)</span>, since initially <span class="math">\(|I|\leq 1\)</span>, and no boundary condition
can increase the amplitude.</p>
<p>The initial condition <span class="math">\(u_t(x,0)=V(x)\)</span> has its dimensionless variant as</p>
<div class="math">
\[\bar V(\bar x) = \frac{t_c}{u_c}\frac{V(L\bar x)}{\max_x|V(x)|},\]</div>
<p>which becomes</p>
<div class="math">
\[\frac{\partial\bar u}{\partial\bar t}(\bar x, 0) =
\frac{L}{\sqrt{\lambda_c}}\frac{\max_{x}|V(x)|}{\max_{x}|I(x)|}\bar V(\bar x),
\hbox{ if } u_c=\max_x|I(x)|,\]</div>
<p>or</p>
<div class="math">
\[\frac{\partial\bar u}{\partial\bar t}(\bar x, 0) =
\frac{\sqrt{\lambda_c}}{L}\frac{\max_{x}|V(x)|}{\max_{x,t}|f(x,t)|}
\bar V(\bar x),
\hbox{ if } u_c=t_c^2f_c=\frac{L^2}{\lambda_c}\max_{x,t}|f(x,t)|{\thinspace .}\]</div>
<p>Introducing the dimensionless number <span class="math">\(\alpha\)</span> (cf. The section <a class="reference internal" href="#scale-wave-pde2-vcond"><span class="std std-ref">Velocity initial condition</span></a>),</p>
<div class="math">
\[\alpha^{-1} = \frac{\sqrt{\lambda_c}}{L}\frac{\max_{x}|V(x)|}{\max_{x,t}|f(x,t)|},\]</div>
<p>we can write</p>
<div class="math">
\[\begin{split}\frac{\partial\bar u}{\partial\bar t}(\bar x, 0) =
\left\lbrace \begin{array}{ll}
\alpha^{-1}\bar V(\bar x),&amp; u_c=\max_x|I|,\\
\alpha^{-1}\beta^{-1}\bar V(\bar x), &amp; u_c=t_c^2f_c
\end{array}\right.\end{split}\]</div>
</div>
<div class="section" id="damped-wave-equation">
<span id="scale-wave-pde2-damped"></span><h2>Damped wave equation<a class="headerlink" href="#damped-wave-equation" title="Permalink to this headline">¶</a></h2>
<p>A linear damping term <span class="math">\(b\,\partial u/\partial t\)</span> is often added to
the wave equation to model energy dissipation and amplitude reduction.</p>
<div class="math">
\[\frac{\partial^2 u}{\partial t^2}
+ b\frac{\partial u}{\partial t} =
\frac{\partial}{\partial x}\left(
\lambda(x) {\partial u\over\partial x}\right) + f(x,t){\thinspace .}\]</div>
<p>The scaled equation becomes</p>
<div class="math">
\[\frac{\partial^2 \bar u}{\partial \bar t^2}
+ \frac{t_c} b\frac{\partial \bar u}{\partial \bar t} =
\frac{t_c^2\lambda_c}{L^2}\frac{\partial}{\partial \bar x}\left(
\bar \lambda(\bar x) {\partial \bar u\over\partial \bar x}\right) +
\frac{t_c^2f_c}{u_c}\bar f(\bar x,\bar t){\thinspace .}\]</div>
<p>The damping term is usually much smaller than the two other terms involving
<span class="math">\(\bar u\)</span>. The time scale is therefore chosen as in the undamped case,
<span class="math">\(t_c=L/\sqrt{\lambda_c}\)</span>. As in the section <a class="reference internal" href="#scale-wave-pde2-cvar"><span class="std std-ref">Variable wave velocity and forcing</span></a>,
we have two choices of <span class="math">\(u_c\)</span>: <span class="math">\(u_c=\max_x|I|\)</span> or <span class="math">\(u_c=t_c^2f_c\)</span>.
The former choice of <span class="math">\(u_c\)</span> gives a PDE with two dimensionless numbers,</p>
<div class="math">
\[\frac{\partial^2 \bar u}{\partial \bar t^2}
+ \gamma\frac{\partial \bar u}{\partial \bar t} =
\frac{\partial}{\partial \bar x}\left(
\bar \lambda(\bar x) {\partial\bar u\over\partial\bar x}\right) +
\beta\bar f(\bar x,\bar t),\]</div>
<p>where</p>
<div class="math">
\[\gamma = \frac{bL}{\sqrt{\lambda_c}},\]</div>
<p>measures the size of the damping.
With <span class="math">\(u_c=t_c^2f_c\)</span> we get a PDE where only <span class="math">\(\gamma\)</span> enters,</p>
<div class="math">
\[\frac{\partial^2 \bar u}{\partial \bar t^2}
+ \gamma\frac{\partial \bar u}{\partial \bar t} =
\frac{\partial}{\partial \bar x}\left(
\bar \lambda(\bar x) {\partial\bar u\over\partial\bar x}\right) +
\bar f(\bar x,\bar t){\thinspace .}\]</div>
<p>The scaled initial conditions are as in
the section <a class="reference internal" href="#scale-wave-pde2-cvar"><span class="std std-ref">Variable wave velocity and forcing</span></a>.</p>
<p>To summarize, the effects of <span class="math">\(V\)</span>, <span class="math">\(f\)</span>, and damping are reflected in
the dimensionless numbers <span class="math">\(\alpha\)</span>, <span class="math">\(\beta\)</span>, and <span class="math">\(\gamma\)</span>,
respectively.</p>
</div>
<div class="section" id="a-three-dimensional-wave-equation-problem">
<h2>A three-dimensional wave equation problem<a class="headerlink" href="#a-three-dimensional-wave-equation-problem" title="Permalink to this headline">¶</a></h2>
<p>To demonstrate how the scaling extends to and looks like in
three-dimensions, we consider</p>
<div class="math">
\[\frac{\partial^2 \bar u}{\partial \bar t^2} =
\frac{\partial}{\partial x}\left(\lambda\frac{\partial u}{\partial x}\right)+
\frac{\partial}{\partial y}\left(\lambda\frac{\partial u}{\partial y}\right)+
\frac{\partial}{\partial z}\left(\lambda\frac{\partial u}{\partial z}\right){\thinspace .}\]</div>
<p>We introduce</p>
<div class="math">
\[\bar x = \frac{x}{x_c},\quad \bar y = \frac{y}{y_c},
  \quad \bar z = \frac{z}{z_c},
  \quad \bar t = \frac{t}{t_c}, \quad \bar u =\frac{u}{u_c}{\thinspace .}\]</div>
<p>With <span class="math">\(\bar\lambda = \lambda(\bar xx_c, \bar y y_c, \bar z z_c)/\lambda_c\)</span>,
we get</p>
<div class="math">
\[\frac{\partial^2 \bar u}{\partial \bar t^2} =
\frac{t_c^2\lambda_c}{x_c^2}\frac{\partial}{\partial \bar x}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar x}\right)+
\frac{t_c^2\lambda_c}{y_c^2}\frac{\partial}{\partial \bar y}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar y}\right)+
\frac{t_c^2\lambda_c}{z_c^2}\frac{\partial}{\partial \bar z}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar z}\right){\thinspace .}\]</div>
<p>Often, we will set <span class="math">\(x_c=y_c=z_c=L\)</span> where <span class="math">\(L\)</span> is some characteristic
size of the domain.
As before, <span class="math">\(t_c = L/\sqrt{\lambda_c}\)</span>, and these choices lead to a
dimensionless wave equation without physical parameters:</p>
<div class="math">
\[\frac{\partial^2 \bar u}{\partial \bar t^2} =
\frac{\partial}{\partial \bar x}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar x}\right)+
\frac{\partial}{\partial \bar y}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar y}\right)+
\frac{\partial}{\partial \bar z}\left(\bar\lambda\frac{\partial \bar u}{\partial \bar z}\right){\thinspace .}\]</div>
<p>The initial conditions remain the same as in the previous one-dimensional
examples.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The wave equation</a><ul>
<li><a class="reference internal" href="#simple-homogeneous-dirichlet-conditions">Simple homogeneous Dirichlet conditions</a></li>
<li><a class="reference internal" href="#implementation-of-the-scaled-wave-equation">Implementation of the scaled wave equation</a><ul>
<li><a class="reference internal" href="#waves-on-a-string">Waves on a string</a></li>
<li><a class="reference internal" href="#detecting-an-already-computed-case">Detecting an already computed case</a></li>
</ul>
</li>
<li><a class="reference internal" href="#time-dependent-dirichlet-condition">Time-dependent Dirichlet condition</a></li>
<li><a class="reference internal" href="#velocity-initial-condition">Velocity initial condition</a></li>
<li><a class="reference internal" href="#variable-wave-velocity-and-forcing">Variable wave velocity and forcing</a></li>
<li><a class="reference internal" href="#damped-wave-equation">Damped wave equation</a></li>
<li><a class="reference internal" href="#a-three-dimensional-wave-equation-problem">A three-dimensional wave equation problem</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_scale004.html"
                        title="previous chapter">Vibration problems</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_scale006.html"
                        title="next chapter">The diffusion equation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._main_scale005.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_scale006.html" title="The diffusion equation"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_scale004.html" title="Vibration problems"
             >previous</a> |</li>
        <li><a href="index.html">Scaling of differential equations</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>