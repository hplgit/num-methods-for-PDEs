.. !split

.. _sec:scale:decay:

Exponential decay
=================

.. index:: exponential decay

Processes undergoing exponential reduction can be modeled by the ODE
problem

.. _Eq:scale:decay:model:

.. math::
   :label: scale:decay:model
        
        u'(t) = -au(t),\quad u(0)=I,
        \
        

where :math:`a,I>0` are prescribed constants and :math:`u(t)` is the unknown function.
For this particular model, we can easily derive the solution, :math:`u(t)=Ie^{-at}`,
which is helpful to have in mind during the scaling process.

Example: Population dynamics
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The evolution of a population of humans, animals, cells, etc.,
under unlimited access to resources, can be
modeled by :eq:`scale:decay:model`. Then :math:`u` is the number of
individuals in the population, strictly speaking an integer, but well
modeled by a real number in large populations.
The parameter :math:`a` is the increase in the number of individuals per
time and per individual.

Example: Decay of pressure with altitude
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The simple model :eq:`scale:decay:model` also governs the pressure
in the atmosphere (under many assumptions). In this case :math:`u` is the
pressure, measured in :math:`\hbox{Nm}^{-2}`; :math:`t` is the hight in meters;
and :math:`a=M/(R^*T)`, where
:math:`M` is the molar mass of the Earth's air (0.029 kg/mol),
:math:`R^*` is the universal
gas constant (:math:`8.314\,\frac{\hbox{Nm}}{\hbox{mol\, K}}`),
and :math:`T` is the temperature in Kelvin (K).
The temperature depends on the hight so we have :math:`a=a(t)`.

.. _sec:scale:decay:steps:

The technical steps of the scaling procedure
--------------------------------------------

Step 1: Identify independent and dependent variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There is one independent variable, time :math:`t`, and one dependent variable,
:math:`u`.

.. index:: dimensionless variable

.. index:: characteristic time

Step 2: Make independent and dependent variables dimensionless
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We introduce a new dimensionless :math:`t`, called :math:`\bar t`, defined by

.. math::
        
        \bar t = \frac{t}{t_c},
        

where :math:`t_c` is a *characteristic value* of :math:`t`. Similarly,
we introduce a dimensionless :math:`u`, named :math:`\bar u`, according to

.. math::
        
        \bar u = \frac{u}{u_c},
        

where :math:`u_c` is a constant *characteristic size* of :math:`u`. When :math:`u` has a specific
interpretation, say when :eq:`scale:decay:model` models pressure
in an atmospheric layer, :math:`u_c` would be referred to as characteristic pressure.
For a decaying population, :math:`u` may be a characteristic number of
members in the population.

Step 3: Derive the model involving only dimensionless variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The next task is to insert the new dimensionless variables in the
governing mathematical model. That is, we replace :math:`t` by :math:`t_c\bar t`
and :math:`u` by :math:`u_c\bar u` in :eq:`scale:decay:model`. The derivative
with respect to :math:`\bar t` is derived as

.. math::
         \frac{du}{dt} = \frac{d (u_c\bar u)}{d\bar t}{d\bar t}{dt}
        = u_c\frac{d\bar u}{d\bar t}\frac{1}{t_c} =
        \frac{u_c}{t_c}\frac{d\bar u}{d\bar t}{\thinspace .}
        

The model :eq:`scale:decay:model` now becomes

.. _Eq:scale:decay:model:scaled0:

.. math::
   :label: scale:decay:model:scaled0
        
        \frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = -au_c\bar u,\quad u_c\bar u(0)=I{\thinspace .}
        
        

Step 4: Make each term dimensionless
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Equation :eq:`scale:decay:model:scaled0` still has terms with
dimensions. To make each term dimensionless, we usually divide by
the coefficient in front of the term with the highest time derivative
(but dividing by any coefficient will do). The result is

.. _Eq:scale:decay:model:dimless0:

.. math::
   :label: scale:decay:model:dimless0
        
        \frac{d\bar u}{d\bar t} = -at_c\bar u,\quad \bar u(0)=u_c^{-1}I
        {\thinspace .}
        \
        

Step 5: Estimate the scales
~~~~~~~~~~~~~~~~~~~~~~~~~~~

A characteristic quantity like :math:`t_c` reflects the time scale in the
problem. Estimating such a time scale is certainly
the most challenging part of the scaling procedure. There are different
ways to reason. The first is to aim at a size of :math:`\bar u` and its derivatives
that is of order unity. If :math:`u_c` is chosen such that :math:`|\bar u|` is
of size unity, we see from :eq:`scale:decay:model:dimless0` that
:math:`d\bar u/d\bar t` is of the size of :math:`\bar u` (i.e., unity)
if we choose :math:`t_c = 1/a`.

.. index:: e-folding time

Alternatively, we may look at a special case of the model where we have
analytical insight. In the present problem we are lucky to know the
exact solution for any value of the input data. For exponential
decay, :math:`u(t)\sim e^{-at}`, it is common to define a characteristic time
scale :math:`t_c` as the time it takes to reduce :math:`u` by a factor of :math:`1/e` (also
called the *e-folding time*):

.. math::
         e^{-at_c} = \frac{1}{e}e^{-a\cdot 0}\quad\Rightarrow\quad e^{-at_c}=e^{-1},
        

from which it follows that :math:`t_c = 1/a`.

In this example, two different, yet common ways of reasoning, lead to the
same value of :math:`t_c`. However, instead of using the e-folding time we
could use the half-time of the exponential decay as characteristic
time, which is also a very common measure of the time scale in such
processes. The half time is defined as the time it takes to halve :math:`u`:

.. math::
         e^{-at_c} = \frac{1}{2}e^{-a\cdot 0}
        \quad\Rightarrow\quad t_c = a^{-1}\ln 2{\thinspace .}

There is a factor :math:`\ln 2 =0.69` difference from the other :math:`t_c` value.
As long as the factor is not an order of magnitude or more different,
we do not pay attention to such small differences.
Although :math:`t_c = a^{-1}\ln 2` is a fine time scale to be used in this
problem, it leads to a scaled differential equation :math:`u'=-(\ln 2) u`,
which is fine, but an unusual form. People tend to prefer :math:`u'=-u`,
which arises from :math:`t_c=1/a`. We shall therefore use the latter as
time scale.

Regarding :math:`u_c`, we may look at the initial condition
and realize that the choice :math:`u_c=I` makes :math:`\bar u(0)=1`. For :math:`\bar t>0`
we know that :math:`\bar u` is decreasing, so :math:`u_c=I`
gives us :math:`\bar u\leq 1`, which is always a goal.
Alternatively, we may look to analytical insight, :math:`u(t)=Ie^{-at}`, to
see that :math:`u\leq I`, such that :math:`u_c=I` gives :math:`\bar u\leq 1`.

With :math:`t_c=1/a` and :math:`u_c=I`, we have the final dimensionless model

.. _Eq:scale:decay:model:dimless:

.. math::
   :label: scale:decay:model:dimless
        
        \frac{d\bar u}{d\bar t} = -\bar u,\quad \bar u(0)=1
        {\thinspace .}
        \
        

This is a remarkable result in the sense that *all physical parameters*
(:math:`a` and :math:`I`)
are removed from the model! Or more precisely, there are no physical input
parameters to assign
before using the model. In particular, numerical investigations of the original
model :eq:`scale:decay:model` would need experiments with different
:math:`a` and :math:`I` values, while numerical investigations of
:eq:`scale:decay:model:dimless` can be limited to *a single run*! As soon
as we have computed the curve :math:`\bar u(\bar t)`, we can find the
solution :math:`u(t)` of :eq:`scale:decay:model` by

.. _Eq:scale:decay:u:dim:

.. math::
   :label: scale:decay:u:dim
        
        u(t) = u_c\bar u(t/t_c) = I\bar u(at)
        {\thinspace .}
        
        

This particular transformation actually means stretching the :math:`\bar t` and
:math:`\bar u` axes in a plot of :math:`\bar u(\bar t)` by the factors :math:`a` and :math:`I`,
respectively.

It is very common to drop the bars when the scaled problem has been
derived and work further with :eq:`scale:decay:model:dimless` simply
written as

.. math::
        
        \frac{du}{dt} = -u,\quad u(0)=1
        {\thinspace .}
        

.. _sec:scale:decay:prog:

Making software utilizing the dimensionless model
-------------------------------------------------

Software for solving :eq:`scale:decay:model` could take advantage
of the fact that only one simulation of :eq:`scale:decay:model:dimless`
is necessary. As soon as we have :math:`\bar u(\bar t)` accessible,
a simple scaling :eq:`scale:decay:u:dim` computes the real :math:`u(t)`
for any given input data :math:`a` and :math:`I`. Although the numerical computation of
:math:`u(t)` from :eq:`scale:decay:model` is very fast in this simple model
problem, using :eq:`scale:decay:u:dim` is very much faster than
computing a full numerical solution in more complicated
differential equation problems.

We can compute with the dimensionless model :eq:`scale:decay:model:dimless`
in two ways, either make a solver for :eq:`scale:decay:model:dimless`
or reuse a solver for :eq:`scale:decay:model` with the parameters
appropriately set (:math:`I=1`, :math:`a=1`).
The latter approach has the advantage of giving us
software that works both with a dimensionless model and a model
with dimensions and all the original physical parameters.

Software for the original problem with dimensions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We base our solver for
:eq:`scale:decay:model:dimless` on a solver for :eq:`scale:decay:model`.
Assume that we have some module ``decay.py`` that offers the following
functions:

  * ``solver(I, a, T, dt, theta=0.5)`` for returning the solution arrays
    ``u`` and ``t`` for :eq:`scale:decay:model` solved by the :math:`\theta` rule.

  * ``read_command_line_argparse()`` for reading parameters in the problem
    from the command line and returning them: ``I``, ``a``, ``T``, ``theta`` (:math:`\theta`),
    and a list of :math:`\Delta t` values for time steps. (We shall only make
    use of the first :math:`\Delta t` value.)

The basic statements for solving :eq:`scale:decay:model` are
then

.. code-block:: python

        from decay import solver, read_command_line_argparse
        I, a, T, theta, dt_values = read_command_line_argparse()
        u, t = solver(I, a, T, dt_values[0], theta)
        
        from matplotlib.pyplot import plot, show
        plot(t, u)
        show()

The module `decay.py <http://tinyurl.com/nm5587k/softeng1/decay.py>`__ is developed
and explained in

the document `Scientific software engineering; ODE model <http://tinyurl.com/k3sdbuv/pub/softeng1>`__ [Ref5]_.

To solve the dimensionless problem, just fix :math:`I=1` and :math:`a=1`:

.. code-block:: python

        I, a, T, theta, dt_values = read_command_line_argparse()
        u, t = solver(I=1, a=1, T=T, dt=dt_values[0], theta=theta)

A plain solution
~~~~~~~~~~~~~~~~

A key observation, as mentioned, is that we need to solve the problem
:eq:`scale:decay:model:dimless` only once. All solutions
corresponding to different :math:`I` and :math:`a` values in the original physical
problem can be recovered by scaling this single solution with formula
:eq:`scale:decay:u:dim`.  We therefore want to make software that
takes advantage of this fact. When requesting a solution, we see if it
has already been computed and stored in a file, and if so, the data
can be retrieved from file, otherwise we have to compute a new
solution and store it in a file.

The computational recipe goes as follows.

1. A computed solution :math:`\bar u(\bar t)` is stored in a file with name ``u_scaled.dat``.

2. The first line in the file contains :math:`T`, :math:`\Delta t`, and :math:`\theta`
   used to compute the stored :math:`\bar u(\bar t)`.

3. The :math:`T`, :math:`\Delta t`, and :math:`\theta` parameters are read from the
   first line in the file and compared with those required by the user.

4. If one of the three parameters changes, the solution in the file
   must be recomputed.

The actual code may look as follows:

.. code-block:: python

        from decay import solver as solver_unscaled
        import numpy as np
        
        def solver_scaled(T, dt, theta):
            """
            Solve u'=-u, u(0)=1 for (0,T] with step dt and theta method.
            """
            # Is the scaled problem already solved and dimensionless
            # curve available from file?
            # See if u_scaled.dat has the right parameters.
            already_computed = False
            datafile = 'u_scaled.dat'
            if os.path.isfile(datafile):      # does u_scaled.dat exist?
                infile = open(datafile, 'r')
                infoline = infile.readline()  # read the first line
                words = infoline.split()      # split line into words
                T_, dt_, theta_ = [float(w) for w in words]
                if T_ == T and dt_ == dt and theta_ == theta:
                    # The file was computed with the desired data, load
                    # the solution into arrays
                    data = np.loadtxt(infile)
                    u_scaled = data[1,:]
                    t_scaled = data[0,:]
                    print 'Read scaled solution from file'
                    already_computed = True
                infile.close()
            if not already_computed:
                # T, dt or theta is different from u_scaled.dat
                u_scaled, t_scaled = \ 
                   solver_unscaled(I=1, a=1, T=T, dt=dt, theta=theta)
                outfile = open(datafile, 'w')
                outfile.write('%f %f %.1f\n' % (T, dt, theta))
                np.savetxt(outfile, np.array([t_scaled, u_scaled]))
                outfile.close()
                print 'Computed scaled solution'
            return u_scaled, t_scaled
        
        def unscale(u_scaled, t_scaled, I, a):
            return I*u_scaled, a*t_scaled

The ``np.savetxt`` function saves a two-dimensional arrays ("table") to
a text file, and the ``np.loadtxt`` function can load the data back
into the program.

.. index:: memoize function

Simplifying the implementation with joblib
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Python package ``joblib`` has functionality that is very convenient
for implementing the ``solver_scaled`` function. The first time a
function is called with a set of arguments, the statements in the
function are executed and the return value is saved to file. If the
function is called again with the same set of arguments, the
statements in the function are not executed, but the return value is
read from file. In computer science, one would say that ``joblib`` in
this way provides *memorization* functionality for Python functions.
This functionality is particularly aimed at large-scale computations
with arrays that one would like to avoid being recomputed.

Utilizing ``joblib``, our ``solver_scaled`` function can be dramatically
simplified:

.. code-block:: python

        def solver_scaled(T, dt, theta):
            """
            Solve u'=-u, u(0)=1 for (0,T] with step dt and theta method.
            """
            print 'Computing the numerical solution'
            return solver_unscaled(I=1, a=1, T=T, dt=dt, theta=theta)

Then we create some "computer memory on disk", i.e., some disk space to
store the result of a call to the ``solver_scaled`` function. Thereafter,
we redefine the name ``solver_scaled`` to a new function, created
by ``joblib``, which calls our original ``solver_scaled`` function
if necessary and otherwise loads data from file:

.. code-block:: python

        import joblib
        disk_memory = joblib.Memory(cachedir='temp')
        solver_scaled = disk_memory.cache(solver_scaled)

The solutions are actually stored in files in the directory ``temp``.

A typical use case is to read values from the command line,
solve the unscaled problem (if necessary), scale the solution, and visualize
the solution with dimension:

.. code-block:: python

        def main():
            # Read parameters, solve and plot
            I, a, T, theta, dt_values = read_command_line_argparse()
            dt = dt_values[0]  # use only the first dt value
            u_scaled, t_scaled = solver_scaled(T, dt, theta)
            u, t = unscale(u_scaled, t_scaled, I, a)
        
            plt.figure()
            plt.plot(t_scaled, u_scaled)
            plt.xlabel('scaled time'); plt.ylabel('scaled velocity')
            plt.title('Universial solution of scaled problem')
            plt.savefig('tmp1.png');  plt.savefig('tmp1.pdf')
        
            plt.figure()
            plt.plot(t, u)
            plt.xlabel('t'); plt.ylabel('u')
            plt.title('I=%g, a=%g, theta=%g' % (I, a, theta))
            plt.savefig('tmp2.png'); plt.savefig('tmp2.pdf')
            plt.show()

The complete code resides in the file
`decay_scaled.py <http://tinyurl.com/nm5587k/scale/decay_scaled.py>`__.

Note that we write a message ``Computing the numerical solution`` inside
the ``solver_scaled`` function. We can then easily detect when
the solution is actually computed and when it is simply read from file.
Here is a demo:

.. code-block:: text

        Terminal> # Very first run
        Terminal> python decay_scaled.py --T 7 --a 1 --I 0.5 --dt 0.2
        [Memory] Calling __main__--home-hpl...
        solver_scaled-alias(7.0, 0.2, 0.5)
        Computing the numerical solution
        
        Terminal> # No change of T, dt, theta - can reuse solution in file
        Terminal> python decay_scaled.py --T 7 --a 4 --I 2.5 --dt 0.2
        
        Terminal> # Change of dt, must recompute
        Terminal> python decay_scaled.py --T 7 --a 4 --I 2.0 --dt 0.5
        [Memory] Calling __main__--home-hpl...
        solver_scaled-alias(7.0, 0.5, 0.5)
        Computing the numerical solution
        
        Terminal> # Change of dt again, but dt=0.2 is already in a file
        Terminal> python decay_scaled.py --T 7 --a 0.5 --I 1 --dt 0.2

We realize that ``joblib`` has access to all previous runs and does not
recompute unless it is strictly required. Our previous implementation
without ``joblib``
used only one file (for one numerical case)
and will therefore perform many more calls to
``solver_unscaled``.

A plot of the scaled and unscaled solution appears in Figure
:ref:`sec:decay:fig:simplest`.

.. _sec:decay:fig:simplest:

.. figure:: decay.png
   :width: 800

   *Scaled (left) and unscaled (right) exponential decay*


.. admonition:: On the implementation of a simple memoize function

   A memoized function recalls
   previous results when the same set
   of arguments is encountered. That is, the function caches its results.
   A simple implementation stores the arguments in a function call and
   the returned results in a
   dictionary, and if the arguments are seen again, one looks up
   in the dictionary and return previously computed results:
   
   .. code-block:: python
   
           class Memoize:
               def __init__(self, f):
                   self.f = f
                   self.memo = {}  # map arguments to results
           
           def __call__(self, *args):
                   if not args in self.memo:
                       self.memo[args] = self.f(*args)
                   return self.memo[args]
           
           # Wrap my_compute_function(arg1, arg2, ...)
           my_compute_function = Memoize(my_compute_function)
   
   The memoize functionality in ``joblib.Memory`` is more sophisticated and
   can work very efficiently with large array data structures as arguments.
   Note that the simple version above can only be used when all arguments to
   the function ``f`` are immutable (since the key in a dictionary has to be
   immutable).




.. _sec:scale:decay:body:

Scaling a generalized problem
-----------------------------

Now we consider an extension of the exponential decay ODE to the
form

.. _Eq:scale:decay:model:g:

.. math::
   :label: scale:decay:model:g
        
        u'(t) = -au(t) + b,\quad u(0)=I
        
        {\thinspace .}
        

One particular model, with constant :math:`a` and :math:`b`,
is a spherical micro-organism falling in air,

.. _Eq:scale:decay:model:g:spec:

.. math::
   :label: scale:decay:model:g:spec
        
        u' = - \frac{3\pi d\mu}{\varrho_b V} u + g\left(\frac{\varrho}{\varrho_b} -1\right),
        
        

where :math:`d`, :math:`\mu`, :math:`\varrho_b`, :math:`\varrho`, :math:`V`, and :math:`g` are physical
parameters. The function :math:`u(t)` represents the vertical velocity,
being positive upwards.
We shall use this model in the following.

Exact solution  (1)
~~~~~~~~~~~~~~~~~~~

It can be handy to have the exact solution for reference, in case
of constant :math:`a` and :math:`b`:

.. math::
         {u_{\small\mbox{e}}}(t) = \frac{e^{-at}}{a}\left( b(e^{at}-1) + aI\right)
        {\thinspace .}
        

It can be very handy to use a symbolic computation tool such as SymPy
to aid us in solving differential equations.
Let us therefore demonstrate how SymPy can be used to find this solution.
First we define the parameters in the problem as symbols
and :math:`u(t)` as a function:

.. code-block:: python

        >>> from sympy import *
        >>> t, a, b, I = symbols('t a b I', real=True, positive=True)
        >>> u = symbols('u', cls=Function)

The next task is to define the differential equation, either as
a symbolic expression that is to equal zero, or as
an equation ``Eq(lhs, rhs)`` with ``lhs`` and ``rhs`` as expressions for
the left- and right-hand side):

.. code-block:: python

        >>> # Define differential equation
        >>> eq = diff(u(t), t) + a*u(t) - b
        >>> # or
        >>> eq = Eq(diff(u(t), t), -a*u(t) + b)

The differential equation can be solved by the ``dsolve`` function, yielding
an equation of the form ``u(t) == expression``. We want to grab the
expression on the right-hand side as our solution:

.. code-block:: python

        >>> sol = dsolve(eq, u(t))
        >>> print sol
        u(t) == (b + exp(a*(C1 - t)))/a
        >>> u = sol.rhs                    # grab solution
        >>> print u
        (b + exp(a*(C1 - t)))/a

The solution contains the unknown integration constant ``C1``, which must
be determined by the initial condition. We form the equation arising
from the initial condition :math:`u(0)=I`:

.. code-block:: python

        >>> C1 = symbols('C1')
        >>> eq = Eq(u.subs(t, 0), I)   # substitute t by 0 in u
        >>> sol = solve(eq, C1)
        >>> print sol
        [log(I*a - b)/a]

The one solution that was found must then be substituted back in the
expression ``u`` to yield the final solution:

.. code-block:: python

        >>> u = u.subs(C1, sol[0])
        >>> print u
        (b + exp(a*(-t + log(I*a - b)/a)))/a

As in mathematics with pen and paper, we strive to simplify
expressions also in symbolic computing software.
This frequently requires some trial and error
process with SymPy's simplification functions. A very standard
first try is to expand everything and run simplification algorithms:

.. code-block:: python

        >>> u = simplify(expand(u))
        >>> print u
        (I*a + b*exp(a*t) - b)*exp(-a*t)/a

Note that doing ``latex(u)`` automatically converts the expression to LaTeX syntax
for inclusion in reports.

Theory
~~~~~~

The challenges in our scaling is to find the right :math:`u_c` and :math:`t_c`
scales. From :eq:`scale:decay:model:g` we see that if :math:`u'\rightarrow 0`
as :math:`t\rightarrow\infty`, :math:`u` approaches the constant value :math:`b/a`. It can be
convenient to let the scaled :math:`\bar u\rightarrow 1` as
we approach the :math:`d\bar u/d\bar t = 0` state. This idea points to choosing

.. math::
        
        u_c = \frac{b}{a} = g\left(\frac{\varrho}{\varrho_b} -1\right)\left(\frac{3\pi d\mu}{\varrho_b V}\right)^{-1}
        {\thinspace .}
        


.. admonition:: On the sign of the scaled velocity

   A little note on the sign of :math:`u_c` is necessary here.
   With :math:`\varrho_b < \varrho`, the buoyancy force upwards wins over the
   gravity force downwards, and the body will move upwards. In this case,
   the terminal velocity :math:`u_c > 0`. When :math:`\varrho_b > \varrho`, we get
   a motion downwards, and :math:`u_c < 0`. The corresponding :math:`u` is then also
   negative, but the scaled velocity :math:`u/u_c`, becomes positive.




.. index:: dimensionless number

Inserting :math:`u = u_c\bar u = b\bar u/a` and :math:`t=t_c\bar t` in
:eq:`scale:decay:model:g` leads to

.. math::
        
        \frac{d\bar u}{d\bar t} = -t_c a\bar u + \frac{t_c}{u_c}b,
        \quad \bar u(0) = I\frac{a}{b}
        {\thinspace .}
        

We want the scales such that :math:`d\bar u/d\bar t` and :math:`\bar u` are
about unity.
To balance the size of :math:`\bar u` and :math:`d\bar u/d\bar t` we must
therefore choose
:math:`t_c = 1/a`, resulting in the scaled ODE problem

.. _Eq:scale:decay:model:g:dimless:

.. math::
   :label: scale:decay:model:g:dimless
        
        \frac{d\bar u}{d\bar t} = -\bar u + 1,\quad u(0)=\beta,
        
        

where :math:`\beta` is a dimensionless number,

.. math::
        
        \beta = \frac{I}{u_c} = I\frac{a}{b},
        

reflecting the ratio of the initial velocity and the
terminal (:math:`t\rightarrow \infty`) velocity :math:`b/a`.
Scaling normally ends up with one or more dimensionless parameters,
such as :math:`\beta` here, containing ratios of physical effects in
the model. Many more examples on dimensionless parameters will appear
in later sections.

The analytical solution of the scaled model
:eq:`scale:decay:model:g:dimless` reads

.. _Eq:scale:decay:model:g:exact_scaled:

.. math::
   :label: scale:decay:model:g:exact_scaled
        
        \bar{u_{\small\mbox{e}}}(t) =
        e^{-t}\left( e^{t}-1 + \beta\right) = 1 + (\beta -1)e^{-t}{\thinspace .}
        
        

The result :eq:`scale:decay:model:g:dimless` with the
solution :eq:`scale:decay:model:g:exact_scaled` is actually
astonishing if :math:`a` and :math:`b` are as in :eq:`scale:decay:model:g:spec`:
the six parameters :math:`d`, :math:`\mu`, :math:`\varrho_b`, :math:`\varrho`, :math:`V`, and :math:`g`
are conjured to one:

.. math::
         \beta = I\frac{3\pi d\mu}{\varrho_b V}
        \frac{1}{g}\left(\frac{\varrho}{\varrho_b} -1\right)^{-1},
        

which is an enormous simplification of the problem if our aim is to
investigate how :math:`u` varies with the physical input parameters in
the model.
In particular, if the motion starts from rest, :math:`\beta=0`, and
there are no physical parameters in the scaled model!
We can then perform a single simulation and recover all physical
cases by the unscaling procedure. More precisely,
having computed :math:`\bar u(\bar t)` from :eq:`scale:decay:model:g:dimless`,
we can use

.. math::
        
        u(t) = \frac{b}{a}\bar u(at),
        

to scale us back to the original
problem again.
We observe that :eq:`scale:decay:model:g:dimless` can utilize a solver
for :eq:`scale:decay:model:g` by setting :math:`a=1`, :math:`b=1`, and :math:`I=\beta`.
Given some implementation of a solver for :eq:`scale:decay:model:g`,
say ``solver(I, a, b, T, dt, theta)``,
the scaled model is run by ``solver(beta, 1, 1, T, dt, theta)``.

Software  (1)
~~~~~~~~~~~~~

We may develop a solver for the scaled problem that uses ``joblib``
to cache solutions with the same :math:`\beta`, :math:`\Delta t`, and :math:`T`.
For now we fix :math:`\theta=0.5`.
The module `decay_vc.py <http://tinyurl.com/nm5587k/decay/decay_vc.py>`__ has a function
``solver(I, a, b, T, dt, theta)`` for solving :math:`u'(t)=-a(t)u(t)+b(t)` for
:math:`t\in (0,T]`, :math:`u(0)=I`, with time step ``dt``.
We reuse this function and call it with :math:`a=b=1` and :math:`I=\beta` to solve
the scaled problem:

.. code-block:: python

        from decay_vc import solver as solver_unscaled
        
        def solver_scaled(beta, T, dt, theta=0.5):
            """
            Solve u'=-u+1, u(0)=beta for (0,T]
            with step dt and theta method.
            """
            print 'Computing the numerical solution'
            return solver_unscaled(
                I=beta, a=lambda t: 1, b=lambda t: 1,
                T=T, dt=dt, theta=theta)
        
        import joblib
        disk_memory = joblib.Memory(cachedir='temp')
        solver_scaled = disk_memory.cache(solver_scaled)

If we want to plot the physical solution, we need an ``unscale`` function,

.. code-block:: python

        def unscale(u_scaled, t_scaled, d, mu, rho, rho_b, V):
            a, b = ab(d, mu, rho, rho_b, V)
            return (b/a)*u_scaled, a*t_scaled
        
        def ab(d, mu, rho, rho_b, V):
            g = 9.81
            a = 3*pi*d*mu/(rho_b*V)
            b = g*(rho/rho_b - 1)
            return a, b

Looking at droplets of water in air, we can fix some of the parameters
and let the size parameter :math:`d` be the one for experimentation.
The following function sets physical parameters, computes :math:`\beta`,
runs the solver for the scaled problem (``joblib`` detects
if it is necessary), and finally plots the scaled curve
:math:`\bar u(\bar t)` and the unscaled curve :math:`u(t)`.

.. code-block:: python

        def main(dt=0.075, # Time step, scaled problem
                 T=7.5,    # Final time, scaled problem
                 d=0.001,  # Diameter (unscaled problem)
                 I=0,      # Initial velocity (unscaled problem)
                 ):
            # Set parameters, solve and plot
            rho = 0.00129E+3  # air
            rho_b = 1E+3      # density of water
            mu = 0.001        # viscosity of water
            # Asumme we have list or similar for d
            if not isinstance(d, (list,tuple,np.ndarray)):
                d = [d]
        
            legends1 = []
            legends2 = []
            plt.figure(1)
            plt.figure(2)
            betas = []     # beta values already computed (for plot)
        
            for d_ in d:
                V = 4*pi/3*(d_/2.)**3  # volume
                a, b = ab(d_, mu, rho, rho_b, V)
                beta = I*a/b
                # Restrict to 3 digits in beta
                beta = abs(round(beta, 3))
        
                print 'beta=%.3f' % beta
                u_scaled, t_scaled = solver_scaled(beta, T, dt)
        
                # Avoid plotting curves with the same beta value
                if not beta in betas:
                    plt.figure(1)
                    plt.plot(t_scaled, u_scaled)
                    plt.hold('on')
                    legends1.append('beta=%g' % beta)
                betas.append(beta)
        
                plt.figure(2)
                u, t = unscale(u_scaled, t_scaled, d_, mu, rho, rho_b, V)
                plt.plot(t, u)
                plt.hold('on')
                legends2.append('d=%g [mm]' % (d_*1000))
            plt.figure(1)
            plt.xlabel('scaled time'); plt.ylabel('scaled velocity')
            plt.legend(legends1, loc='lower right')

The most complicated part of the code is related to plotting, but
this part can be skipped when trying to understand how we work with
a scaled model to perform the computations.
The complete program is found in the file
`falling_body.py <http://tinyurl.com/nm5587k/scale/falling_body.py>`__.

Since :math:`I=0` implies :math:`\beta=0`, we can run different :math:`d` values without
any need to recompute :math:`\bar u(\bar t)` as long as we assume the particle
starts from rest.

From the scaling, we see that :math:`u_c = b/a\sim d^{-2}` and
also that :math:`t_c=1/a \sim d^{-2}`, so plotting of :math:`u(t)` with dimensions
for various :math:`d` values will involve significant variations in the time
and velocity scales. Figure :ref:`sec:scale:decay:body:fig`
has an example with :math:`d=1,2,3` mm, where we clearly see the different
time and velocity scales in the figure with unscaled variables.
Note that the scaled velocity is positive because of the sign of :math:`u_c`
(see the box above).

.. _sec:scale:decay:body:fig:

.. figure:: falling_body.png
   :width: 800

   *Velocity of falling body: scaled (left) and with dimensions (right)*

.. _sec:scale:decay:jump:

Variable coefficients
---------------------

When a prescribed coefficient like :math:`a(t)` in :math:`u'(t) = -a(t)u(t)`
varies with time one usually also
performs a scaling of this :math:`a`,

.. math::
         \bar a(\bar t) = \frac{a(t) - a_0}{a_c}, 

where the goal is to have the scaled :math:`|\bar a|`
of size unity: :math:`|\bar a|\leq 1`.
This property is obtained by choosing :math:`a_c` as the maximum value
of :math:`|a(t)-a_0|` for :math:`t\in [0,T]`, which is usually a quantity that
can be estimated since :math:`a(t)` is known as a function of :math:`t`. The :math:`a_0`
parameter can be chosen as 0 here. (It could be tempting to
choose :math:`a_0=\min_t a(t)` so that :math:`0\leq \bar a\leq 1`, but then there
is at least one point where :math:`\bar a = 0` and
the differential equation collapses to :math:`u'=0`.)

As an example, imagine a decaying cell culture where we at time :math:`t_1`
change the environment such that the death rate increases: :math:`a(t) = d` for
:math:`t < t_1` and :math:`a(t)=5d` for :math:`t\geq t_1`. The model reads :math:`u'=-a(t)u`, :math:`u(0)=I`.

The :math:`a(t)` function is scaled by letting the characteristic size be
:math:`a_c=d` (and :math:`a_0=0`):

.. math::
         \bar a (\bar t) = \left\lbrace\begin{array}{ll}
        1, & \bar t < t_1/t_c\\ 
        5, & \bar t \geq t_1/t_c
        \end{array}\right.
        

.. index:: dimensionless number

The scaled equation becomes

.. math::
         \frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = a_c\bar a(\bar t) u_c\bar u,\quad
        u_c\bar u(0) = I{\thinspace .}

The characteristic time, previously taken as :math:`t_c=1/a`, can now be
taken as :math:`t_c=t_1` or :math:`t_c=1/d`. The natural choice of :math:`u_c` is :math:`I`.
With :math:`t_c=1/d` we get

.. _Eq:sec:scale:decay:jump:eq1:

.. math::
   :label: sec:scale:decay:jump:eq1
        
        \bar u'(\bar t)=-\bar a\bar u,\quad \bar u(0)=1,\quad
        \bar a = \left\lbrace\begin{array}{ll}
        1, & \bar t < \gamma\\ 
        5, & \bar t \geq \gamma
        \end{array}\right.
        
        

where

.. math::
         \gamma = t_1 d

is a dimensionless number in the problem. With :math:`t_c=t_1`, we get

.. math::
         \bar u'(\bar t)=-\gamma\bar a\bar u,\quad \bar u(0)=1,\quad
        \bar a = \left\lbrace\begin{array}{ll}
        1, & \bar t < 1\\ 
        5, & \bar t \geq 1
        \end{array}\right.

The dimensionless parameter :math:`\gamma` is now in the equation rather than in
the definition of :math:`\bar a`. Both problems involve :math:`\gamma`, which
is the ratio between the time when the environmental change happens
and the typical time for the decay (:math:`1/d`).

A computation with the scaled model :eq:`sec:scale:decay:jump:eq1`
and the original model with dimensions appears in
Figure :ref:`sec:scale:decay:jump:fig`.

.. _sec:scale:decay:jump:fig:

.. figure:: decay_jump.png
   :width: 800

   *Exponential decay with jump*

.. _scale:decay:cooling:const:

Scaling a cooling problem with constant surroundings
----------------------------------------------------

The heat exchange between a body at temperature :math:`T(t)` and the
surroundings at :math:`T_s(t)` can be modeled by Newton's law of cooling:

.. _Eq:scale:decay:cooling:model:

.. math::
   :label: scale:decay:cooling:model
        
        T'(t) = -k(T-T_s(t)),\quad T(0)=T_0,
        
        

where :math:`k` is a prescribed heat transfer coefficient.
An analytical solution is always handy to have as a control of the
choice of scales. Here we have
the result :math:`T(t) = T_s + (T_0 - T_s)e^{-kt}` when :math:`T_s` is constant,
which is also the assumption for now.

Physically, we expect the temperature to start at :math:`T_0` and then
to move toward the surroundings (:math:`T_s`). We therefore expect
that :math:`T` lies between :math:`T_0` and :math:`T_s`. This is mathematically
demonstrated by the analytical solution as well. A proper scaling
is therefore to scale and translate :math:`T` according to

.. _Eq:scale:decay:cooling:Tbar:

.. math::
   :label: scale:decay:cooling:Tbar
        
        \bar T = \frac{T-T_0}{T_s-T_0}
        
        {\thinspace .}
        

Now, :math:`0\leq \bar T\leq 1`.

Scaling time by :math:`\bar t = t/t_c` and inserting
:math:`T= T_0 + (T_s-T_0)\bar T` and :math:`t=t_c\bar t` in the
problem :eq:`scale:decay:cooling:model` gives

.. math::
         \frac{d\bar T}{d\bar t} = - t_ck(\bar T - 1),\quad \bar T(0) = 0
        {\thinspace .}
        

A natural choice, as argued in other exponential decay problems,
is to choose :math:`t_ck=1`, which leaves us with the scaled problem

.. _Eq:scale:decay:cooling:Tbar:eq:

.. math::
   :label: scale:decay:cooling:Tbar:eq
        
        \frac{d\bar T}{d\bar t} = - (\bar T - 1),\quad \bar T(0)=0
        
        {\thinspace .}
        

No physical parameter enters this problem!
Our scaling implies that :math:`\bar T` starts at
0 and approaches 1 as :math:`\bar t\rightarrow\infty`, also in the case
:math:`T_s < T_0`. The physical temperature is always recovered as

.. _Eq:scale:decay:cooling:T:

.. math::
   :label: scale:decay:cooling:T
        
        T(t) = T_0 + (T_s-T_0)\bar T (k\bar t)
        
        {\thinspace .}
        

An implementation for :eq:`scale:decay:cooling:model` works for
:eq:`scale:decay:cooling:Tbar:eq` by setting :math:`k=1`, :math:`T_s=1`, and :math:`T_0=0`.

An alternative scaling is to choose

.. _Eq:scale:decay:cooling:Tbar2:

.. math::
   :label: scale:decay:cooling:Tbar2
        
        \bar T = \frac{T-T_s}{T_0-T_s}
        
        {\thinspace .}
        

Now :math:`\bar T=1` initially and approaches zero as :math:`t\rightarrow\infty`.
The resulting scaled ODE problem then becomes

.. _Eq:scale:decay:cooling:Tbar:eq2:

.. math::
   :label: scale:decay:cooling:Tbar:eq2
        
        \frac{d\bar T}{d\bar t} = - \bar T,\quad \bar T(0)=1
        
        {\thinspace .}
        

.. _scale:decay:cooling:osc:

Scaling a cooling problem with time-dependent surroundings
----------------------------------------------------------

Let us apply the model :eq:`scale:decay:cooling:model` in
case the surrounding temperature varies in time. Say we have
an oscillating temperature environment according to

.. _Eq:scale:decay:cooling:Tst:

.. math::
   :label: scale:decay:cooling:Tst
        
        T_s(t) = T_m + a\sin(\omega t)
        
        {\thinspace .}
        

Exact solution  (2)
~~~~~~~~~~~~~~~~~~~

It is possible to solve the differential equation problem analytically,
and such a solution is a good help to see what scales are.
In general, using the method of integrating factors for the
original differential equation, we have

.. math::
         T(t) = T_0e^{-kt} + e^{-kt}k\int_0^t e^{k\tau}T_s(\tau)d\tau{\thinspace .}

With :math:`T_s(t)=T_m + a\sin (wt)` we can use SymPy to help us with
integrations:

.. code-block:: python

        >>> from sympy import *
        >>> t, k, T_m, a, w = symbols('t k T_m a w', real=True, positive=True)
        >>> T_s = T_m + a*sin(w*t)
        >>> I = exp(k*t)*T_s
        >>> I = integrate(I, (t, 0, t))
        >>> Q = k*exp(-k*t)*I
        >>> Q = simplify(expand(Q))
        >>> print Q
        (-T_m*k**2 - T_m*w**2 + a*k*w +
        (T_m*k**2 + T_m*w**2 + a*k**2*sin(t*w) -
        a*k*w*cos(t*w))*exp(k*t))*exp(-k*t)/((k**2 + w**2))

Reordering the result, we get

.. math::
         T(t) = T_0e^{-kt} + T_m(1- e^{-kt}) +  (k^2 + w^2)^{-1}(akw e^{-kt}
        + ak\sin (wt) - akw\cos(wt)){\thinspace .}

.. index:: dimensionless number

Scaling  (1)
~~~~~~~~~~~~

The scaling :eq:`scale:decay:cooling:Tbar` brings in a time-dependent
characteristic temperature scale :math:`T_s-T_0`. Let us start with a
fixed scale, where we take the characteristic temperature variation to
be :math:`T_m - T_0`:

.. math::
         \bar T = \frac{T-T_0}{T_m-T_0}{\thinspace .}

We see from the analytical solution, and realize also by physical
reasoning, that :math:`T` sets out at :math:`T_0`, but with time, it will oscillate
around :math:`T_m`. The typical average temperature span is therefore
:math:`|T_m-T_0|`.

We get from the differential equation, with :math:`t_c=1/k` as in the former
case,

.. math::
         k(T_m-T_0)\frac{d\bar T}{d\bar t} = -k((T_m-T_0)\bar T + T_0 - T_m - a
        \sin(wt),

resulting in

.. _Eq:scale:decay:cooling:model:scaled:

.. math::
   :label: scale:decay:cooling:model:scaled
        
        \frac{d\bar T}{d\bar t} = -\bar T + 1 + \alpha\sin (\beta \bar t),\quad
        \bar T(0)=0,
        
        

where we have two dimensionless numbers:

.. math::
         \alpha = \frac{a}{T_m-T_0},\quad \beta = \frac{w}{k}{\thinspace .}

The :math:`\alpha` quantity
measures the ratio of temperatures: amplitude of oscillations versus
characteristic total temperature variation.
The :math:`\beta` number is the ratio of the two time scales:
the frequency of the oscillations in :math:`T_s` and the inverse
e-folding time of the heat transfer. For clear interpretation of :math:`\beta`
we may introduce the period
:math:`P=2\pi/w` of the oscillations in :math:`T_s` and the e-folding time :math:`e=1/k`. Then
:math:`\beta = 2\pi e/P` and measures the period versus the e-folding time.

The original problem features five physical parameters: :math:`k`, :math:`T_0`,
:math:`T_m`, :math:`a`, and :math:`w`, but only two dimensionless numbers appear in the
scaled model.

Software  (2)
~~~~~~~~~~~~~

Implementing the unscaled problem :eq:`scale:decay:cooling:model`
can be reused for the scaled model by setting :math:`k=1`, :math:`T_0=0`, and
:math:`T_s(t) = 1 + \alpha\sin (\beta \bar t)` (:math:`T_m=1`, :math:`a=\alpha`, :math:`w=\beta`).

Discussion of the time scale  (1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Looking at the analytical insight we have, :math:`T(t)` has two characteristic
terms in time: :math:`e^{-kt}` and :math:`\sin(wt)`. The former points to a time
scale :math:`t_c=1/k`, while the latter to :math:`t_c=1/w`.
Which one should be chosen? Bringing the temperature from :math:`T_0` to
the level of the surroundings, :math:`T_m`, goes like :math:`e^{-kt}`, so
in this process :math:`t_c=1/k` is the characteristic time. Thereafter,
the body's temperature just responds to the oscillations and the
:math:`\sin (wt)` (and :math:`\cos(wt)`) term dominates. For these large times,
:math:`t_c=1/w` is the appropriate time scale. Choosing :math:`t_c=1/w`
results in

.. _Eq:scale:decay:cooling:model:scaled2:

.. math::
   :label: scale:decay:cooling:model:scaled2
        
        \frac{d\bar T}{d\bar t} = -\beta^{-1}(\bar T - (1 + \alpha\sin (\bar t))),\quad
        \bar T(0)=0{\thinspace .}
        
        

Let us illustrate another, less effective, scaling.
The temperature scale in
:eq:`scale:decay:cooling:Tbar` looks natural, so we apply this
choice of scale. The characteristic temperature :math:`T_0-T_s`
now involves
a time-dependent term :math:`T_s(t)`. The mathematical steps become a bit
more technically involved:

.. math::
         T(t) = T_0 + (T_s(t)-T_0)\bar T,

.. math::
         \frac{dT}{dt} = \frac{dT_s}{dt}\bar T +
        (T_s-T_0)\frac{d\bar T}{d\bar t}\frac{d\bar t}{dt}
        {\thinspace .}
        

With :math:`\bar t = t/t_c = kt` we get from the differential equation

.. math::
        
        \frac{dT_s}{dt}\bar T +
        (T_s-T_0)\frac{d\bar T}{d\bar t}k
        = -k(\bar T - 1)(T_s - T_0),
        

which after dividing by :math:`k(T_s-T_0)` results in

.. math::
        
        \frac{d\bar T}{d\bar t} = -(\bar T - 1) -
        \frac{dT_s}{dt}\frac{\bar T}{k(T_s-T_0},
        

or

.. math::
        
        \frac{d\bar T}{d\bar t} = -(\bar T - 1) -
        \frac{a\omega\cos(\omega \bar t/k)}{k(T_m + a\sin(\omega \bar t/k) -T_0)}\bar T
        {\thinspace .}
        

The last term is complicated and becomes more tractable if we factor
out dimensionless numbers. To this end, we scale :math:`T_s` by (e.g.) :math:`T_m`,
which means to factor out :math:`T_m` in the denominator. We are then
left with

.. _Eq:scale:decay:cooling:Tbar:eq3:

.. math::
   :label: scale:decay:cooling:Tbar:eq3
        
        \frac{d\bar T}{d\bar t} = -(\bar T - 1) -
        \alpha\beta \frac{\cos(\beta \bar t)}{1 + \alpha\sin(\beta\bar t) - \gamma}
        \bar T,
        
        

where :math:`\alpha`, :math:`\beta`, and :math:`\gamma` are dimensionless numbers
characterizing the relative importance of parameters in the problem:

.. math::
        
        \alpha=a/T_m,\quad \beta = \omega/k,\quad \gamma = T_0/T_m
        {\thinspace .}
        

We notice that :eq:`scale:decay:cooling:Tbar:eq3`
is not a special case of the original problem
:eq:`scale:decay:cooling:model`. Furthermore, the original five
parameters :math:`k`, :math:`T_m`, :math:`a`, :math:`\omega`, and
:math:`T_0` are reduced to three dimensionless parameters.
We conclude that this scaling is inferior, because
using the temperature scale :math:`T_0-T_m` enables reuse of the software
for the unscaled problem and only two dimensionless parameters appear
in the scaled model.

.. _sec:scale:decay:nonlinear:

Scaling a nonlinear ODE
-----------------------

.. index:: logistic equation

Exponential growth models, :math:`u'=au`, are not realistic in environments
with limited resources. The idea is then to assume that
the growth rate :math:`a` decreases with :math:`u` and vanishes when we reach the maximum
value :math:`M` of :math:`u` the environment can sustain. The initial growth rate
is set to :math:`r`: :math:`a(0)=\varrho`.
In general, this reasoning gives rise to models

.. _Eq:sec:scale:decay:nonlinear:model1:

.. math::
   :label: sec:scale:decay:nonlinear:model1
        
        u' = a(u)u,\quad u(0)=I,
        
        

with the logistic model, corresponding to :math:`a(u)=\varrho(1-u/M)`,
as the simplest:

.. _Eq:sec:scale:decay:nonlinear:model2:

.. math::
   :label: sec:scale:decay:nonlinear:model2
        
        u' = \varrho u(1-u/M),\quad u(0)=I{\thinspace .}
        
        

A general choice of :math:`a` might be :math:`a(u)=\varrho(1-u/M)^p` for some exponent :math:`p`.

.. index:: dimensionless number

Let us scale :eq:`sec:scale:decay:nonlinear:model1` with
:math:`a(u)=\varrho (1-u/M)^p`.
The natural scale for :math:`u` is :math:`M` (:math:`u_c=M`), since we know that
:math:`0 < u\leq M`, and this makes the dimensionless :math:`\bar u = u/M \in (0,1]`.
The function :math:`a(u)` is
typically varying between 0 and :math:`\varrho`, so it can be scaled as

.. math::
         \bar a(\bar u) = \frac{a(u)}{\varrho} = (1 - \frac{u}{M})^p =
        (1 - \bar u)^p{\thinspace .}

Time is scaled as :math:`\bar t = t/t_c` for some suitable characteristic time :math:`t_c`.
Inserted in :eq:`sec:scale:decay:nonlinear:model1`, we get

.. math::
         \frac{u_c}{t_c}\frac{d\bar u}{d\bar t} = \varrho\bar a u_c\bar u,\quad u_c\bar u(0)=I,

resulting in

.. math::
         \frac{d\bar u}{d\bar t} = t_c \varrho (1 - \bar u)^p \bar u,\quad
        \bar u(0) =\frac{I}{M}{\thinspace .}

A natural choice is :math:`t_c =1/\varrho` as in other exponential growth models
since it leads to the term on the right-hand side to be about unity,
as the left-hand side, if the scaling is physically correct.
Introducing the dimensionless parameter

.. math::
         \alpha = \frac{I}{M},

measuring the fraction of the initial population compared to the maximum
one, we get the dimensionless model

.. _Eq:sec:scale:decay:nonlinear:model1:scaled:

.. math::
   :label: sec:scale:decay:nonlinear:model1:scaled
        
        \frac{d\bar u}{d\bar t} = (1 - \bar u)^p \bar u,\quad
        \bar u(0) =\alpha{\thinspace .}
        
        

Here, we have two dimensionless parameters: :math:`\alpha` and :math:`p`. A classical
logistic model with :math:`p=1` has only one dimensionless variable.

We could try another scaling of :math:`u` where we also translate :math:`\bar u`:

.. math::
         \bar u = \frac{u-I}{M}{\thinspace .} 

This choice of :math:`\bar u` results in

.. _Eq:sec:scale:decay:nonlinear:model1:scaled2:

.. math::
   :label: sec:scale:decay:nonlinear:model1:scaled2
        
        \frac{d\bar u}{d\bar t} = (1 - \alpha - \bar u)^p \bar u,\quad
        \bar u(0) =0{\thinspace .}
        
        

The essential difference between :eq:`sec:scale:decay:nonlinear:model1:scaled`
and :eq:`sec:scale:decay:nonlinear:model1:scaled2` is that
:math:`\bar u\in [\alpha, 1]` in the former and :math:`\bar u \in [0, 1-\alpha]` in
the latter. Both models involve the dimensionless numbers :math:`\alpha` and :math:`p`.
An advantage of :eq:`sec:scale:decay:nonlinear:model1:scaled`
is that software for the unscaled model can easily be used for the
scaled model by choosing :math:`I=\alpha`, :math:`M=1`, and :math:`\varrho=1`.

ODE systems for spreading of diseases
-------------------------------------

The field of epidemiology frequently applies ODE systems to describe the spreading of diseases, such as smallpox, measles, plague, ordinary flu, swine flu,
and HIV. Different models include different effects, which are reflected
in dimensionless numbers. Most of the effects are modeled as exponential
decay or growth of the dependent variables.

SIR model
~~~~~~~~~

The model has three categories of people: susceptibles (S) who can get
the disease, infected (I) who are infected and may infect susceptibles,
and recovered (R) who have recovered from the disease and gained
immunity. We introduce :math:`S(t)`, :math:`I(t)`, and :math:`R(t)` as the number of
people in the categories S, I, and R, respectively.
The model, naturally known as the SIR model, takes the form a system of ODEs:

.. _Eq:scale:SIR:S:

.. math::
   :label: scale:SIR:S
        
        \frac{dS}{dt} = - \beta SI,
        
        

.. _Eq:scale:SIR:I:

.. math::
   :label: scale:SIR:I
          
        \frac{dI}{dt} = \beta SI - \nu I,
        
        

.. _Eq:scale:SIR:R:

.. math::
   :label: scale:SIR:R
          
        \frac{dR}{dt} = \nu I,
        
        

where :math:`\beta` and :math:`nu` are empirical constants. The average time for recovering
from the disease can be shown to be :math:`\nu^{-1}`, but :math:`\beta` is much harder
to estimate, so working with a scaled model where :math:`k` is "scaled away"
is advantageous. Adding :eq:`scale:SIR:S`-:eq:`scale:SIR:R`
shows that

.. math::
         \frac{dS}{dt}+\frac{dI}{dt}+\frac{dR}{dt}=0\quad\Rightarrow\quad
        S+I+R=\hbox{const}=N,

where :math:`N` is the size of the population. It is natural to scale
:math:`S`, :math:`I`, and :math:`R` by, e.g., :math:`S(0)`:

.. math::
         \bar S = \frac{S}{S(0)},\quad \bar I = \frac{I}{S(0)},\quad
        \bar R = \frac{R}{S(0)}{\thinspace .}
        

Introducing :math:`\bar t = t/t_c`, we arrive at the equations

.. math::
        
        \frac{d\bar S}{d\bar t} &= - t_c S(0) \beta\bar S\bar I,
        \\ 
        \frac{d\bar I}{d\bar t} &= t_c S(0) \beta \bar S\bar I - t_c \nu \bar I,
        \\ 
        \frac{d\bar R}{d\bar t} &= t_c \nu I,
        

with initial conditions :math:`\bar S(0)=1`, :math:`\bar I(0)=I_0/S(0)=\alpha`, and
:math:`\bar R(0)=R(0)/S(0)`. Normally, :math:`R(0)=0`.

Taking :math:`t_c=1/\nu`, corresponding to a time unit equal to the time it takes
to recover from the disease, we end up with the scaled model

.. _Eq:scale:SIR:S2:

.. math::
   :label: scale:SIR:S2
        
        \frac{d\bar S}{d\bar t} = - R_0\bar S\bar I,
        
        

.. _Eq:scale:SIR:I2:

.. math::
   :label: scale:SIR:I2
          
        \frac{d\bar I}{d\bar t} = R_0 \bar S\bar I - \bar I,
        
        

.. _Eq:scale:SIR:R2:

.. math::
   :label: scale:SIR:R2
          
        \frac{d\bar R}{d\bar t} = I,
        
        

with :math:`\bar S(0)=1`, :math:`\bar I(0)=\alpha`, :math:`\bar R(0)=0`, and :math:`R_0` as
the dimensionless number

.. math::
        
        R_0 = \frac{S(0)\beta}{\nu}{\thinspace .}
        

We see from :eq:`scale:SIR:I2` that to make the disease spreading,
:math:`d\bar I/d\bar t >0`, and therefore :math:`R_0 S(0) - 1 > 0` or :math:`R_0 > 1`
since :math:`S(0)=1`.
Therefore, :math:`R_0` reflects the disease's ability to spread and is
consequently an important dimensionless quantity, known as the *basic
reproductive number*.
[**hpl 1**: Explain interpretation.]

Looking at :eq:`scale:SIR:I`, we see that to increase :math:`I` initially,
we must have :math:`dI/dt >0` at :math:`t=0`, which implies
:math:`\beta I(0)S(0) - \nu I(0) >0`, i.e., :math:`R_0 > 1`.

We can also scale :math:`S`, :math:`I`, and :math:`R` by the total population :math:`N=S(0)+I(0)+R(0)`,

.. math::
         \bar S = \frac{S}{N},\quad \bar I = \frac{I}{N},\quad
        \bar R = \frac{R}{N)}{\thinspace .}
        

With the same time scale, one gets the system :eq:`scale:SIR:S2`-:eq:`scale:SIR:R2`, but with :math:`R_0` replaced by the dimensionless number:

.. math::
        
        \tilde R_0 = \frac{N\beta}{\nu}{\thinspace .}
        

The initial conditions become :math:`\bar S(0)=1-\alpha`, :math:`\bar I(0)=\alpha`,
and :math:`\bar R(0)=0`.

For the disease to spread at :math:`t=0`, we must have :math:`\tilde R_0 \bar S(0) > 1`,
but :math:`\tilde R_0 \bar S(0) = N\beta/\nu \cdot S(0)/N = R_0`, so the
criterion is still :math:`R_0 > 1`. Since :math:`R_0` is a more famous number than
:math:`\tilde R_0`, we can write the ODEs with :math:`R_0/S(0) = R_0/(1-\alpha)`
instead of :math:`\tilde R_0`.

Choosing :math:`t_c` to make the :math:`SI` terms balance the time derivatives,
:math:`t_c = (N\beta)^{-1}`, moves :math:`\tilde R_0` (or :math:`R_0` if we scale
:math:`S`, :math:`I`, and :math:`R` by :math:`S(0)`) to the :math:`I` terms:

.. math::
        
        \frac{d\bar S}{d\bar t} &= - \bar S\bar I,
        \\ 
        \frac{d\bar I}{d\bar t} &= \bar S\bar I - \tilde R_0^{-1} \bar I,
        \\ 
        \frac{d\bar R}{d\bar t} &= \tilde R_0^{-1} I{\thinspace .}
        

SIRV model with finite immunity
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A common extension of the SIR model involves finite immunity: after
some period of time, recovered individuals lose their immunity
and become susceptibles again. This is modeled as
a leakage :math:`-\mu R` from the R to the S category, where :math:`\mu^{-1}`
is the average time it takes to lose immunity.
Vaccination is another extension: a fraction :math:`pS` is removed from the
S category by successful vaccination and brought to a new category V (the
vaccinated). The ODE model reads

.. _Eq:scale:SIRV:S:

.. math::
   :label: scale:SIRV:S
        
        \frac{dS}{dt} = - \beta SI - pS + \mu R,
        
        

.. _Eq:scale:SIRV:I:

.. math::
   :label: scale:SIRV:I
          
        \frac{dI}{dt} = \beta SI - \nu I,
        
        

.. _Eq:scale:SIRV:R:

.. math::
   :label: scale:SIRV:R
          
        \frac{dR}{dt} = \nu I -\mu R,
        
        

.. _Eq:scale:SIRV:V:

.. math::
   :label: scale:SIRV:V
          
        \frac{dV}{dt} = p S{\thinspace .}
        
        

Using :math:`t_c=1/\nu` and scaling the unknowns by :math:`S(0)` leads to
the dimensionless model

.. _Eq:scale:SIRV:S2:

.. math::
   :label: scale:SIRV:S2
        
        \frac{d\bar S}{d\bar t} = - R_0 \bar S \bar I - \delta S + \gamma \bar R,
        
        

.. _Eq:scale:SIRV:I2:

.. math::
   :label: scale:SIRV:I2
          
        \frac{d\bar I}{d\bar t} = R_0 \bar S \bar I - \bar I,
        
        

.. _Eq:scale:SIRV:R2:

.. math::
   :label: scale:SIRV:R2
          
        \frac{d\bar R}{d\bar t} = \bar I -\gamma \bar R,
        
        

.. _Eq:scale:SIRV:V2:

.. math::
   :label: scale:SIRV:V2
          
        \frac{d\bar V}{d\bar t} = \delta \bar S,
        
        

with two new dimensionless parameters:

.. math::
         \gamma = \frac{\mu}{\nu},\quad \delta = \frac{p}{\nu}{\thinspace .} 

The quantity :math:`p^{-1}` can be interpreted as the average time it takes
to vaccinate a susceptible successfully. Writing :math:`\gamma = \nu^{-1}/\mu^{-1}`
and :math:`\delta = \nu^{-1}/p^{-1}` gives the interpretation that :math:`\gamma`
is the ratio of the average time to recover and the average time to
lose immunity, while :math:`\delta` is the ratio of the average time to recover
and the average time to successfully vaccinate a susceptible.

.. _scale:MMK:

Michaelis-Menten kinetics for biochemical reactions
---------------------------------------------------

A classical reaction model in biochemistry describes how a
substrate S is turned into a product P with aid of an enzyme E.
S and E react to form a complex ES in the first stage of the reaction.
In the second stage, ES is turned into E and P.
Introducing the amount of S, E, ES, and P by :math:`[S]`, :math:`[E]`, :math:`[ES]`, and
:math:`[P]`, the mathematical model can be written as

.. _Eq:scale:MMK:ES1:

.. math::
   :label: scale:MMK:ES1
        
        \frac{d[ES]}{dt} = k_+[E][S] - k_v[ES] - k_-[ES],
        
        

.. _Eq:scale:MMK:P1:

.. math::
   :label: scale:MMK:P1
          
        \frac{d[P]}{dt} = k_v[ES],
        
        

.. _Eq:scale:MMK:S1:

.. math::
   :label: scale:MMK:S1
          
        \frac{d[S]}{dt} = -k_+[E][S] + k_-[ES],
        
        

.. _Eq:scale:MMK:E1:

.. math::
   :label: scale:MMK:E1
          
        \frac{d[E]}{dt} = -k_+[E][S] + k_-[ES] + k_v[ES]{\thinspace .}
        
        

The initial conditions are :math:`[ES](0)=[P](0)=0`, and :math:`[S]=S_0`, :math:`[E]=E_0`.
Three rate constants are involved: :math:`k_+`, :math:`k_-`, and :math:`k_v`.

The amount of substance is measured in the unit `mole <https://en.wikipedia.org/wiki/Mole_(unit)>`__ (mol). From the equations we can see that
:math:`k_+` is measured in :math:`\hbox{s}^{-1}\hbox{mol}^{-1}`, while :math:`k_-` and
:math:`k_v` are measured in :math:`\hbox{s}^{-1}`. It is convenient to get rid of
the mole unit for the amount of a substance. When working with
dimensionless quantities, only ratios of the rate constants and not their
specific values are needed.

Classical analysis
~~~~~~~~~~~~~~~~~~

The typical analysis of the present ODE system is to first observe
two conservation equations, arising from simply adding the ODEs:

.. math::
        
        \frac{d[ES]}{dt} + \frac{d[E]}{dt}  =0,
        
        

.. math::
          
        \frac{d[ES]}{dt} + \frac{d[S]}{dt} + \frac{d[P]}{dt} = 0,
        

from which it follows that

.. _Eq:scale:MMK:cons1:

.. math::
   :label: scale:MMK:cons1
        
        [ES] + [E] = E_0,
        
        

.. _Eq:scale:MMK:cons2:

.. math::
   :label: scale:MMK:cons2
          
        [ES] + [S] + [P] = S_0{\thinspace .}
        
        

Using :eq:`scale:MMK:cons1`, we can eliminate :math:`[E]` and obtain a
system of only two ODEs,

.. math::
        
        \frac{d[ES]}{dt} = k_+([ES]-E_0)[S] - (k_v + k_-)[ES],
        

.. math::
          
        \frac{d[S]}{dt} = -k_+([ES]-E_0)[S] + k_-[ES]{\thinspace .}
        

A common assumption is that the formation of :math:`[ES]` is very fast and that
it reaches an equilibrium state, :math:`[ES]^{\prime}=0`. This implies

.. math::
         k_+([ES]-E_0)[S] - (k_v + k_-)[ES]=0\quad\Rightarrow\quad
        [ES] = \frac{E_0[S]}{[S] - K},
        

where

.. math::
         K = \frac{k_- + k_v}{k_+},

is the Michaelis constant. Using the expression for :math:`[ES]` in the
equation for :math:`[S]` gives

.. _Eq:scale:MMK:Seq1:

.. math::
   :label: scale:MMK:Seq1
        
        \frac{dS}{dt} = \frac{k_vE_0[S]}{[S] + K}{\thinspace .}
        
        

We see that the parameter :math:`K` is central.

Dimensionless ODE system
~~~~~~~~~~~~~~~~~~~~~~~~

Let us reason how to make the original ODE system dimensionless.
Aiming at :math:`[S]` and :math:`[E]` of unit size, two obvious dimensionless
unknowns are

.. math::
         \bar S = \frac{[S]}{S_0},\quad
        \bar E = \frac{[E]}{E_0}{\thinspace .}

For the other two unknowns we just introduce scales to be determined
later:

.. math::
        
        \bar P = \frac{[P]}{P_c},\quad
        \bar{Q} = \frac{[ES]}{Q_c}{\thinspace .}
        

With :math:`\bar t = t/t_c` the equations become

.. math::
        
        \frac{d\bar Q}{d\bar t} &= t_ck_+\frac{E_0S_0}{Q_c}\bar E\bar S
        - t_c(k_v + k_-)\bar Q,\\ 
        \frac{d\bar P}{d\bar t} &= t_ck_v\frac{Q_c}{P_c}\bar Q,\\ 
        \frac{d\bar S}{d\bar t} &= -t_ck_+E_0\bar E\bar S
        + t_ck_-\frac{Q_c}{S_0}\bar Q,\\ 
        \frac{d\bar E}{d\bar t} &= -t_ck_+S_0\bar E\bar S
        + t_c(k_- + k_v)\frac{Q_c}{E_0}\bar Q{\thinspace .}
        

.. `<http://www.biosym.uzh.ch/modules/models/Michaelis_Menten/michaelis_menten.html>`_

.. `<http://deepblue.lib.umich.edu/bitstream/handle/2027.42/26960/0000527.pdf>`_?sequence=1

.. `<http://www.math.ubc.ca/~keshet/EnzKin.pdf>`_

.. Good (but complicated): `<https://people.maths.ox.ac.uk/maini/PKM%20publications/9.pdf>`_

.. `<http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2932968/>`_ (read this one - it is the best, this one has units for the constants too and typical values of constants)

.. Murray has S_c=S_0, Q_c=E_0 (that is common)

.. All use the long time scale with E_0

.. Murray has much complicated analysis before selecting scales...

.. Can find Q_c from Q'=0 which gives Q_c=E_0S_0/K

Determining scales
~~~~~~~~~~~~~~~~~~

Choosing the scales is actually a quite complicated matter that requires
extensive analysis of the equations to determine the characteristics of
the solutions. Much literature is written about this, but here we shall
take a simplistic and pragmatic approach.
Besides the Michaelis constant, there is another important parameter,

.. math::
         \epsilon = \frac{E_0}{S_0},

because most applications will involve a small :math:`\epsilon`.
We shall have :math:`K` and :math:`\epsilon` in mind while choosing scales such that
these symbols appear naturally in the scaled equations.

Looking at the equations, we see that the :math:`K` parameter will appear
if :math:`t_c\sim 1/k_+`. However, :math:`1/k_+` does not have the dimension
:math:`\hbox{[T]}^{-1}` as required, so we need to add a factor with dimension
mol. A natural choice is
:math:`t_c^{-1}=k_+S_0` or :math:`t_c^{-1}=k_+E_0`. Since often :math:`S_0\gg E_0`,
the former :math:`t_c` is a short time scale and the latter is a long
time scale. If the interest is in the long time scale, we set

.. math::
         t_c = \frac{1}{k_+E_0}{\thinspace .}

The equations then take the form

.. math::
        
        \frac{d\bar Q}{d\bar t} &= \frac{S_0}{Q_c}\bar E\bar S
        - KE_0^{-1}\bar Q,\\ 
        \frac{d\bar P}{d\bar t} &= \frac{k_v}{k_+ E_0}\frac{Q_c}{P_c}\bar Q,\\ 
        \frac{d\bar S}{d\bar t} &= -\bar E\bar S
        + \frac{k_-}{k_+E_0}\frac{Q_c}{S_0}\bar Q,\\ 
        \frac{d\bar E}{d\bar t} &= -\epsilon^{-1}\bar E\bar S
        + K\frac{Q_c}{E_0^2}\bar Q{\thinspace .}
        

The :math:`[ES]` variable starts and ends at zero, and its maximum value
can be roughly estimated from the equation for :math:`[ES]^{\prime}`
by setting :math:`[ES]^{\prime}=0`, which gives an estimate of

.. math::
         Q_c = \frac{E_0S_0}{K},

if we approximate :math:`[E][S]` by :math:`E_0S_0`.

The equation for :math:`\bar P` simplifies if we choose :math:`P_c=Q_c`.
With these assumptions one gets

.. math::
        
        \frac{d\bar Q}{d\bar t} &= KE_0^{-1} (\bar E\bar S
        - \bar Q),\\ 
        \frac{d\bar P}{d\bar t} &= \frac{k_v}{k_+ E_0}\bar Q,\\ 
        \frac{d\bar S}{d\bar t} &= -\bar E\bar S
        + \frac{k_-}{k_+E_0}\frac{E_0}{K}\bar Q,\\ 
        \frac{d\bar E}{d\bar t} &= -\epsilon^{-1}\bar E\bar S
        + \epsilon^{-1}\bar Q{\thinspace .}
        

We can now identify the dimensionless numbers

.. math::
         \alpha = \frac{K}{E_0},\quad \beta = \frac{k_v}{k_+ E_0},
        \quad \gamma = \frac{k_-}{k_+E_0},
        

where we see that :math:`\alpha = \beta + \gamma`, so :math:`\gamma` can be eliminated,
leading to the final set of equations:

.. _Eq:scale:MMK:Q2:

.. math::
   :label: scale:MMK:Q2
        
        \frac{d\bar Q}{d\bar t} = \alpha (\bar E\bar S
        - \bar Q),
        
        

.. _Eq:scale:MMK:P2:

.. math::
   :label: scale:MMK:P2
          
        \frac{d\bar P}{d\bar t} = \beta\bar Q,
        
        

.. _Eq:scale:MMK:S2:

.. math::
   :label: scale:MMK:S2
          
        \frac{d\bar S}{d\bar t} = -\bar E\bar S
        + (1 - \beta\alpha^{-1})\bar Q,
        
        

.. _Eq:scale:MMK:E2:

.. math::
   :label: scale:MMK:E2
          
        \epsilon\frac{d\bar E}{d\bar t} = -\bar E\bar S + \bar Q{\thinspace .}
        
        

The five initial parameters (:math:`S_0`, :math:`E_0`, :math:`k_+`, :math:`k_-`, and :math:`k_v`)
are reduced to three dimensionless constants:

 * :math:`\alpha` is the dimensionless Michaelis constant, reflecting the
   ratio of the production of P and E (:math:`k_v+k_-`) versus the production of
   the complex (:math:`k_+`), made dimensionless by :math:`E_0`,

 * :math:`\epsilon` is the initial fraction of enzyme relative to the substrate,

 * :math:`\beta` measures the relative importance of production of P (:math:`k_v`)
   versus production of the complex (:math:`k_+`), made dimensionless by :math:`E_0`.

Observe that software developed for
solving :eq:`scale:MMK:ES1`-:eq:`scale:MMK:E1` cannot be reused
for solving :eq:`scale:MMK:Q2`-:eq:`scale:MMK:E2` since the latter
system has a slightly different structure.

Analysis of the scaled system
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the scaled system, we may assume :math:`\epsilon` small, which from
:eq:`scale:MMK:E2` gives rise to the simplification
:math:`\epsilon\bar E^{\prime}=0`, and thereby the relation :math:`\bar Q = \bar E\bar S`.
The conservation equation :math:`[ES] + [E]= E_0` reads :math:`Q_c\bar Q + E_0\bar E =
E_0` such that :math:`\bar E = 1 - Q_c\bar Q/E_0=1- \bar Q S_0/K = 1 - \epsilon^{-1}\alpha^{-1}\bar Q`. The relation :math:`\bar Q=\bar E\bar S` then becomes

.. math::
         \bar Q = (1 - \epsilon^{-1}\alpha^{-1}\bar Q)\bar S,

which can be solved for :math:`\bar Q`:

.. math::
         \bar Q = \frac{\bar S}{1 + \epsilon^{-1}\alpha^{-1}\bar S}{\thinspace .}

The equation :eq:`scale:MMK:S2` for :math:`\bar S` becomes

.. _Eq:scale:MMK:Seq2:

.. math::
   :label: scale:MMK:Seq2
        
        \frac{d\bar S}{d\bar t} = -\beta\alpha^{-1}\bar Q =
        -\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}{\thinspace .}
        
        

This is a more precise analysis than the one leading to
:eq:`scale:MMK:Seq1` since we now realize that the
mathematical assumption for the simplification is
:math:`\epsilon\rightarrow 0`.

Is :eq:`scale:MMK:Seq2` consistent with :eq:`scale:MMK:Seq1`? It is
easy to make algebraic mistakes when deriving scaled equations,
so it is always wise to carry out such consistency checks.
Introducing dimensions in :eq:`scale:MMK:Seq2` leads to

.. math::
        
        \frac{t_c}{S_0}\frac{d S}{dt} =
        \frac{d\bar S}{d\bar t}  =
        -\frac{\beta\bar S}{\alpha + \epsilon^{-1}\bar S}
        = \frac{k_v}{k_+E_0}\frac{S}{KE_0^{-1} + E_0^{-1}S_0\bar S}
        = \frac{k_v}{k_+}\frac{\bar S}{K + S},

and hence with :math:`t_c^{-1}=k_+E_0`,

.. math::
         \frac{dS}{dt} = \frac{k_vE_0 S}{K + S},

which is :eq:`scale:MMK:Seq1`.

Figure :ref:`scale:MMK:fig` shows the impact of :math:`\epsilon`: with a small
value (0.1) we see that :math:`\bar Q\approx 0`, which justifies the
simplifications performed above. We also observe that all the unknowns
vary between 0 and about 1, indicating that the scaling is successful
for the chosen dimensionless numbers.

.. _scale:MMK:fig:

.. figure:: biochem.png
   :width: 700

   *Simulation of a biochemical process*

