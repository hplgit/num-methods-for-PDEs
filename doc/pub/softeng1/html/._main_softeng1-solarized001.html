<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Scientific software engineering with a simple ODE model as example">
<meta name="keywords" content="user interfaces to programs,command-line arguments,reading the command line,list comprehension,option-value pairs (command line),command-line options and values,reading the command line,convergence rate,dictionary,verification,modules,test block (in Python modules),importing modules,doctests,software testing doctests,unit testing,software testing nose,software testing nose w/doctests,unit testing,software testing unit testing (class-based),problem class,solver class,wrapper (code),visualizer class,problem class,solver class,visualizer class,numerical experiments,scientific experiments,script,Unix wildcard notation,wildcard notation (Unix)">

<title>Scientific software engineering with a simple ODE model as example</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Sample problem and code ', 1, None, '___sec0'),
              (' Mathematical problem ', 2, None, '___sec1'),
              (' Implementation ', 2, None, '___sec2'),
              (' User interfaces ', 1, None, '___sec3'),
              (' Creating command-line interfaces ',
               2,
               'decay:commandline',
               'decay:commandline'),
              (' Reading a sequence of command-line arguments ',
               3,
               None,
               '___sec5'),
              (' Working with an argument parser ', 3, None, '___sec6'),
              (' Creating a graphical web user interface ',
               2,
               None,
               '___sec7'),
              (' Making a compute function ', 3, None, '___sec8'),
              (' Generating the user interface ', 3, None, '___sec9'),
              (' Running the web application ', 3, None, '___sec10'),
              (' Verification ', 1, None, '___sec11'),
              (' Comparison with hand calculations ', 2, None, '___sec12'),
              (' Test function ', 2, None, '___sec13'),
              (' Comparison with an exact discrete solution ',
               2,
               None,
               '___sec14'),
              (' Computing convergence rates ',
               2,
               'decay:convergence:rate',
               'decay:convergence:rate'),
              (' Estimating $r$ ', 3, None, '___sec16'),
              (' Implementation ', 3, None, '___sec17'),
              (' Debugging via convergence rates ', 3, None, '___sec18'),
              (' Software engineering ', 1, None, '___sec19'),
              (' Making a module ',
               2,
               'decay:prog:se:module',
               'decay:prog:se:module'),
              (' Prefixing imported functions by the module name ',
               2,
               'decay:prog:se:import',
               'decay:prog:se:import'),
              (' Doctests ',
               2,
               'decay:prog:se:doctest',
               'decay:prog:se:doctest'),
              (' Unit testing with nose ',
               2,
               'decay:prog:se:nose',
               'decay:prog:se:nose'),
              (' Basic use of nose ', 3, None, '___sec24'),
              (' Alternative assert statements ', 3, None, '___sec25'),
              (' Applying nose ', 3, None, '___sec26'),
              (' Installation of nose ', 3, None, '___sec27'),
              (' Using nose to test modules with doctests ',
               3,
               None,
               '___sec28'),
              (' Classical class-based unit testing ',
               2,
               'decay:prog:se:unittest',
               'decay:prog:se:unittest'),
              (' Basic use of unittest ', 3, None, '___sec30'),
              (' Demonstration of unittest ', 3, None, '___sec31'),
              (' Implementing simple problem and solver classes ',
               2,
               'decay:prog:se:class',
               'decay:prog:se:class'),
              (' The problem class ', 3, None, '___sec33'),
              (' The solver class ', 3, None, '___sec34'),
              (' The visualizer class ', 3, None, '___sec35'),
              (' Combining the objects ', 3, None, '___sec36'),
              (' Improving the problem and solver classes ',
               2,
               'decay:prog:se:class2',
               'decay:prog:se:class2'),
              (' A generic class for parameters ', 3, None, '___sec38'),
              (' The problem class ', 3, None, '___sec39'),
              (' The solver class ', 3, None, '___sec40'),
              (' The visualizer class ', 3, None, '___sec41'),
              (' Performing scientific experiments ',
               1,
               'decay:experiments',
               'decay:experiments'),
              (' Software ', 2, None, '___sec43'),
              (' Combining plot files ', 2, None, '___sec44'),
              (' Interpreting output from other programs ',
               2,
               None,
               '___sec45'),
              (' Making a report ',
               2,
               'decay:exper:report',
               'decay:exper:report'),
              (' Plain HTML ', 3, None, '___sec47'),
              (' HTML with MathJax ', 3, None, '___sec48'),
              (' LaTeX ', 3, None, '___sec49'),
              (' Sphinx ', 3, None, '___sec50'),
              (' Markdown ', 3, None, '___sec51'),
              (' Wiki formats ', 3, None, '___sec52'),
              (' DocOnce ', 3, None, '___sec53'),
              (' Worked example ', 3, None, '___sec54'),
              (' Publishing a complete project ',
               2,
               'decay:exper:github',
               'decay:exper:github'),
              (' Exercises ', 1, None, '___sec56'),
              (' Exercise 1: Refactor a flat program in terms of a function ',
               2,
               'decay:exer:main2func',
               'decay:exer:main2func'),
              (' Remarks ', 3, None, '___sec58'),
              (' Exercise 2: Compare methods for a given time mesh ',
               2,
               'decay:exer:plot:dtconst',
               'decay:exer:plot:dtconst'),
              (' Problem 3: Write a doctest ',
               2,
               'decay:exer:doctest1',
               'decay:exer:doctest1'),
              (' Problem 4: Write a nose test ',
               2,
               'decay:exer:nosetest1',
               'decay:exer:nosetest1'),
              (' Problem 5: Make a module ',
               2,
               'decay:exer:module1',
               'decay:exer:module1'),
              (' Exercise 6: Make use of a class implementation ',
               2,
               'decay:exer:decay_class:exper',
               'decay:exer:decay_class:exper'),
              (' Exercise 7: Generalize a class implementation ',
               2,
               'decay:exer:decay_class2',
               'decay:exer:decay_class2'),
              (' Exercise 8: Generalize an advanced class implementation ',
               2,
               'decay:exer:decay_class3',
               'decay:exer:decay_class3'),
              (' Bibliography ', 1, None, '___sec66')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\tp}{\thinspace .}
$$




    
<a name="part0001"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_softeng1-solarized000.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_softeng1-solarized002.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->
<div class="alert alert-block alert-notice alert-text-normal">
<b>Goal.</b>
<p>
This document illustrates <em>best practice</em> for developing scientific software
in an efficient and reliable way. Not only will the outlined techniques
save a lost of human time, but they will also help assure reproducible science
and higher quality of computational investigations. Key questions to
be answered are

<ul>
 <li> How should I organize a program?</li>
 <li> How can I efficiently and safely provide input data and run my code?</li>
 <li> How can I verify that the implementation is correct?</li>
 <li> How should I reliably work with files and documents?</li>
 <li> How should I conduct large numerical experiments?</li>
</ul>
</div>


<h1>Sample problem and code  <a name="___sec0"></a></h1>

<p>
This first introduction to good programming habits in scientific
computing will make use of a very simple mathematical problem to keep
the mathematical details at the lowest possible level while
introducing a series of computer science concepts. The simplicity of
the mathematical problem obviously prevents us from treating several
techniques that are only meaningful for complex scientific software.

<h2>Mathematical problem  <a name="___sec1"></a></h2>

<p>
We consider the simplest possible ordinary differential equation
with constant coefficient \( a \):

$$
\begin{equation}
u'(t) = -au(t),\quad u(0)=I,\quad t\in (0,T]\tp
\tag{1}
\end{equation}
$$


<p>
This problem is numerically solved by the so-called \( \theta \)-rule,
which is a convenient way to merge different formulas for the
well-known Forward Euler, Backward Euler, and Crank-Nicolson
(midpoint/central) schemes. We introduce a uniform time mesh
\( t_n=n\Delta t \), \( n=0,1,\ldots,N_t \), and seek \( u(t) \) at the mesh
points. The numerical approximation to \( u(t_n) \) is denoted
\( u^n \). Since we will use the symbol \( u \) both for the exact analytical
solution of <a href="#mjx-eqn-1">(1)</a> and for the numerical
approximation, we sometimes introduce \( \uex(t) \) to help distinguish
the two types of solutions (i.e., subscript e for &quot;exact&quot;) [<a name="link_footnote_1"><a><a href="#def_footnote_1">1</a>].

<p><a name="def_footnote_1"></a><a href="#link_footnote_1"><b>1:</b></a> In the literature, it is more common to put a subscript
(like \( u_\Delta \) or \( u_h \))
on the numerical solution to distinguish it from the exact solution.
However, we will use the variable <code>u</code> in the code for the numerical
approximation to be computed, and therefore adjust the mathematical
notation to convenient conventions in the code such that we can have
as close correspondence as possible between the implementation and
the mathematics.

<p>
The \( \theta \)-rule leads to an explicit updating formula for \( u^{n+1} \),
given \( u^n \):

$$
u^{n+1} = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a\Delta t}u^n,
$$

<h2>Implementation  <a name="___sec2"></a></h2>

<p>
The numerical method is implemented as a function <code>solver</code>.
Another function <code>explore</code> computes the error in the solution,
by comparing with the exact solution \( \uex(t)=Ie^{-at} \),
and creates a plot for comparing the numerical and exact solution.

<p>
The program file
<a href="http://tinyurl.com/nm5587k/softeng1/decay_plot.py" target="_self"><tt>decay_plot.py</tt></a> contains the two
functions and a main program.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, a, T, dt, theta):
    <span style="color: #CD5555">&quot;&quot;&quot;Solve u&#39;=-a*u, u(0)=I, for t in (0,T] with steps of dt.&quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)            <span style="color: #228B22"># avoid integer division</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))     <span style="color: #228B22"># no of time intervals</span>
    T = Nt*dt                 <span style="color: #228B22"># adjust T to fit time step dt</span>
    u = zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># array of u[n] values</span>
    t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># time mesh</span>

    u[<span style="color: #B452CD">0</span>] = I                  <span style="color: #228B22"># assign initial condition</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt):    <span style="color: #228B22"># n=0,1,...,Nt-1</span>
        u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u, t

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(t, I, a):
    <span style="color: #8B008B; font-weight: bold">return</span> I*exp(-a*t)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">explore</span>(I, a, T, dt, theta=<span style="color: #B452CD">0.5</span>, makeplot=<span style="color: #658b00">True</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Run a case with the solver, compute error measure,</span>
<span style="color: #CD5555">    and plot the numerical and exact solutions (if makeplot=True).</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    u, t = solver(I, a, T, dt, theta)    <span style="color: #228B22"># Numerical solution</span>
    u_e = exact_solution(t, I, a)
    e = u_e - u
    E = sqrt(dt*<span style="color: #658b00">sum</span>(e**<span style="color: #B452CD">2</span>))
    <span style="color: #8B008B; font-weight: bold">if</span> makeplot:
        figure()                         <span style="color: #228B22"># create new plot</span>
        t_e = linspace(<span style="color: #B452CD">0</span>, T, <span style="color: #B452CD">1001</span>)       <span style="color: #228B22"># fine mesh for u_e</span>
        u_e = exact_solution(t_e, I, a)
        plot(t,   u,   <span style="color: #CD5555">&#39;r--o&#39;</span>)           <span style="color: #228B22"># red dashes w/circles</span>
        plot(t_e, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)             <span style="color: #228B22"># blue line for exact sol.</span>
        legend([<span style="color: #CD5555">&#39;numerical&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>])
        xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
        ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
        title(<span style="color: #CD5555">&#39;theta=%g, dt=%g&#39;</span> % (theta, dt))
        theta2name = {<span style="color: #B452CD">0</span>: <span style="color: #CD5555">&#39;FE&#39;</span>, <span style="color: #B452CD">1</span>: <span style="color: #CD5555">&#39;BE&#39;</span>, <span style="color: #B452CD">0.5</span>: <span style="color: #CD5555">&#39;CN&#39;</span>}
        savefig(<span style="color: #CD5555">&#39;%s_%g.png&#39;</span> % (theta2name[theta], dt))
        savefig(<span style="color: #CD5555">&#39;%s_%g.pdf&#39;</span> % (theta2name[theta], dt))
        show()
    <span style="color: #8B008B; font-weight: bold">return</span> E

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main</span>(I, a, T, dt_values, theta_values=(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>)):
    <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> theta_values:
        <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values:
            E = explore(I, a, T, dt, theta, makeplot=<span style="color: #658b00">True</span>)
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;%3.1f %6.2f: %12.3E&#39;</span> % (theta, dt, E)

main(I=<span style="color: #B452CD">1</span>, a=<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">5</span>, dt_values=[<span style="color: #B452CD">0.4</span>, <span style="color: #B452CD">0.04</span>])
</pre></div>

<h1>User interfaces  <a name="___sec3"></a></h1>

<p>
It is good programming practice to let programs read input from the
user rather than require the user to edit the source code when trying
out new values of input parameters. One reason is that any edit of the
code has a danger of introducing bugs. Another reason is that it is
easier and less manual work to supply data to a program instead of
editing the program code. A third reason is that a program that reads
input can easily be run by another program, and in this way we can
automate a large number of runs in scientific investigations.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Tip.</b>
<p>
We shall make it a habit to equip any implementation of a
numerical solver with an appropriate user interface before testing out
the code.
</div>


<p>
Reading input data can be done in many ways. We have to decide on
desired <em>user interface</em>, i.e., how we want to operate the program
when providing input, and then use appropriate tools to implement
the user interface. There are four basic types of user interface
of relevance to our programs, listed here with increasing complexity
of the implementation:

<ol>
<li> Questions and answers in the terminal window</li>
<li> Command-line arguments</li>
<li> Reading data from file</li>
<li> Graphical user interfaces</li>
</ol>

Although conceptually simple, alternative 1 involves more typing than
the other alternatives and is therefore abandoned. Below, we shall
address alternative 2 and 4, which are most appropriate for the
present problem.

<p>
[[[

<h2>Creating command-line interfaces <a name="decay:commandline"></a></h2>

<p>
Reading input from the command line is a simple and flexible way of interacting
with the user. Python stores all the command-line arguments in
the list <code>sys.argv</code>, and there are, in principle, two ways of programming with
command-line arguments in Python:

<ul>
 <li> Decide upon a sequence of parameters on the command line and read
   their values directly from the <code>sys.argv[1:]</code> list (<code>sys.argv[0]</code> is
   the just program name).</li>
 <li> Use option-value pairs (<code>--option value</code>) on
   the command line to override default values of input parameters,
   and utilize the <code>argparse.ArgumentParser</code> tool to interact with
   the command line.</li>
</ul>

Both strategies will be illustrated next.

<h3>Reading a sequence of command-line arguments  <a name="___sec5"></a></h3>

<p>
The <a href="http://tinyurl.com/nm5587k/softeng1/decay_plot.py" target="_self"><tt>decay_plot.py</tt></a>
program needs the following input data: \( I \), \( a \), \( T \), an option to
turn the plot on or off (<code>makeplot</code>), and a list of \( \Delta t \) values.

<p>
The simplest way of reading this input from the command line is to say
that the first four command-line arguments correspond to the first
four points in the list above, in that order, and that the rest of the
command-line arguments are the \( \Delta t \) values.  The input given for
<code>makeplot</code> can be a string among <code>'on'</code>, <code>'off'</code>, <code>'True'</code>, and
<code>'False'</code>. The code for reading this input is most conveniently put in
a function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sys</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">read_command_line</span>():
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #658b00">len</span>(sys.argv) &lt; <span style="color: #B452CD">6</span>:
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Usage: %s I a T on/off dt1 dt2 dt3 ...&#39;</span> % \ 
              sys.argv[<span style="color: #B452CD">0</span>]; sys.exit(<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># abort</span>

    I = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">1</span>])
    a = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">2</span>])
    T = <span style="color: #658b00">float</span>(sys.argv[<span style="color: #B452CD">3</span>])
    makeplot = sys.argv[<span style="color: #B452CD">4</span>] <span style="color: #8B008B">in</span> (<span style="color: #CD5555">&#39;on&#39;</span>, <span style="color: #CD5555">&#39;True&#39;</span>)
    dt_values = [<span style="color: #658b00">float</span>(arg) <span style="color: #8B008B; font-weight: bold">for</span> arg <span style="color: #8B008B">in</span> sys.argv[<span style="color: #B452CD">5</span>:]]

    <span style="color: #8B008B; font-weight: bold">return</span> I, a, T, makeplot, dt_values
</pre></div>
<p>
One should note the following about the constructions in the program above:

<ul>
  <li> Everything on the command line ends up in a <em>string</em> in
    the list <code>sys.argv</code>. Explicit conversion to, e.g., a <code>float</code> object is
    required if the string as a number we want to compute with.</li>
  <li> The value of <code>makeplot</code> is determined from a boolean expression,
    which becomes <code>True</code> if the command-line argument is either <code>'on'</code> or
    <code>'True'</code>, and <code>False</code> otherwise.</li>
  <li> It is easy to build the list of \( \Delta t \) values: we simply run through
    the rest of the list, <code>sys.argv[5:]</code>, convert each command-line argument
    to <code>float</code>, and collect these <code>float</code> objects in a list, using the
    compact and convenient <em>list comprehension</em> syntax in Python.</li>
</ul>

The loops over \( \theta \) and \( \Delta t \) values can be coded in a <code>main</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main</span>():
    I, a, T, makeplot, dt_values = read_command_line()
    <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>:
        <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values:
            E = explore(I, a, T, dt, theta, makeplot)
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;%3.1f %6.2f: %12.3E&#39;</span> % (theta, dt, E)
</pre></div>
<p>
The complete program can be found in <a href="http://tinyurl.com/nm5587k/softeng1/decay_cml.py" target="_self"><tt>decay_cml.py</tt></a>.

<h3>Working with an argument parser  <a name="___sec6"></a></h3>

<p>
Python's <code>ArgumentParser</code> tool in the <code>argparse</code> module makes it easy
to create a professional command-line interface to any program. The
documentation of <a href="http://docs.python.org/library/argparse.html" target="_self"><tt>ArgumentParser</tt></a> demonstrates its
versatile applications, so we shall here just list an example
containing basic features.  On the command line we want to specify
option-value pairs for \( I \), \( a \), and \( T \), e.g., <code>--a 3.5 --I 2 --T
2</code>. Including <code>--makeplot</code> turns the plot on and excluding this option
turns the plot off.  The \( \Delta t \) values can be given as <code>--dt 1 0.5
0.25 0.1 0.01</code>.  Each parameter must have a sensible default value so
that we specify the option on the command line only when the default
value is not suitable.

<p>
We introduce a function for defining the mentioned command-line options:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">define_command_line_options</span>():
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
    parser = argparse.ArgumentParser()
    parser.add_argument(<span style="color: #CD5555">&#39;--I&#39;</span>, <span style="color: #CD5555">&#39;--initial_condition&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
                        default=<span style="color: #B452CD">1.0</span>, help=<span style="color: #CD5555">&#39;initial condition, u(0)&#39;</span>,
                        metavar=<span style="color: #CD5555">&#39;I&#39;</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--a&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
                        default=<span style="color: #B452CD">1.0</span>, help=<span style="color: #CD5555">&#39;coefficient in ODE&#39;</span>,
                        metavar=<span style="color: #CD5555">&#39;a&#39;</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--T&#39;</span>, <span style="color: #CD5555">&#39;--stop_time&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
                        default=<span style="color: #B452CD">1.0</span>, help=<span style="color: #CD5555">&#39;end time of simulation&#39;</span>,
                        metavar=<span style="color: #CD5555">&#39;T&#39;</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--makeplot&#39;</span>, action=<span style="color: #CD5555">&#39;store_true&#39;</span>,
                        help=<span style="color: #CD5555">&#39;display plot or not&#39;</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--dt&#39;</span>, <span style="color: #CD5555">&#39;--time_step_values&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>,
                        default=[<span style="color: #B452CD">1.0</span>], help=<span style="color: #CD5555">&#39;time step values&#39;</span>,
                        metavar=<span style="color: #CD5555">&#39;dt&#39;</span>, nargs=<span style="color: #CD5555">&#39;+&#39;</span>, dest=<span style="color: #CD5555">&#39;dt_values&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> parser
</pre></div>
<p>
Each command-line option is defined through the <code>parser.add_argument</code>
method. Alternative options, like the short <code>--I</code> and the more
explaining version <code>--initial_condition</code> can be defined. Other arguments
are <code>type</code> for the Python object type, a default value, and a help
string, which gets printed if the command-line argument <code>-h</code> or <code>--help</code> is
included. The <code>metavar</code> argument specifies the value associated with
the option when the help string is printed. For example, the option for
\( I \) has this help output:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_argparse.py -h
  ...
  --I I, --initial_condition I
                        initial condition, u(0)
  ...
</pre></div>
<p>
The structure of this output is

<p>

<!-- code=text typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">  --I metavar, --initial_condition metavar
                        help-string
</pre></div>
<p>
The <code>--makeplot</code> option is a pure flag without any value, implying a
true value if the flag is present and otherwise a false value. The
<code>action='store_true'</code> makes an option for such a flag.

<p>
Finally, the <code>--dt</code> option demonstrates how to allow for more than one
value (separated by blanks) through the <code>nargs='+'</code> keyword argument.
After the command line is parsed, we get an object where the values of
the options are stored as attributes. The attribute name is specified
by the <code>dist</code> keyword argument, which for the <code>--dt</code> option is
<code>dt_values</code>. Without the <code>dest</code> argument, the value of an option <code>--opt</code>
is stored as the attribute <code>opt</code>.

<p>
The code below demonstrates how to read the command line and extract
the values for each option:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">read_command_line</span>():
    parser = define_command_line_options()
    args = parser.parse_args()
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;I={}, a={}, T={}, makeplot={}, dt_values={}&#39;</span>.format(
        args.I, args.a, args.T, args.makeplot, args.dt_values)
    <span style="color: #8B008B; font-weight: bold">return</span> args.I, args.a, args.T, args.makeplot, args.dt_values
</pre></div>
<p>
The <code>main</code> function remains the same as in the <code>decay_cml.py</code> code based
on reading from <code>sys.argv</code> directly. A complete program featuring the
demo above of <code>ArgumentParser</code> appears in the file <a href="http://tinyurl.com/nm5587k/softeng1/decay_argparse.py" target="_self"><tt>decay_argparse.py</tt></a>.

<h2>Creating a graphical web user interface  <a name="___sec7"></a></h2>

<p>
The Python package <a href="https://github.com/hplgit/parampool" target="_self">Parampool</a>
can be used to automatically generate a web-based <em>graphical user interface</em>
(GUI) for our simulation program. Although the programming technique
dramatically simplifies the efforts to create a GUI, the forthcoming
material on equipping our <code>decay_mod</code> module with a GUI is quite technical
and of significantly less importance than knowing how to make
a command-line interface (the section <a href="#decay:commandline">Creating command-line interfaces</a>).
There is no danger in jumping right to the section <a href="#decay:convergence:rate">Computing convergence rates</a>.

<h3>Making a compute function  <a name="___sec8"></a></h3>

<p>
The first step is to identify a function
that performs the computations and that takes the necessary input
variables as arguments. This is called the <em>compute function</em> in
Parampool terminology. We may start with a copy of the basic file
<a href="http://tinyurl.com/nm5587k/softeng1/decay_plot.py" target="_self"><tt>decay_plot.py</tt></a>,
which has a <code>main</code> function displayed in
the section ref{decay:plotting} for carrying out simulations and plotting
for a series of \( \Delta t \) values. Now we want to control and view the same
experiments from a web GUI.

<p>
To tell Parampool what type of input data we have,
we assign default values of the right type to all arguments in the
main function and call it <code>main_GUI</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main_GUI</span>(I=<span style="color: #B452CD">1.0</span>, a=.<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4.0</span>,
         dt_values=[<span style="color: #B452CD">1.25</span>, <span style="color: #B452CD">0.75</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">0.1</span>],
         theta_values=[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]):
</pre></div>
<p>
The compute function must return the HTML code we want for displaying
the result in a web page. Here we want to show plots of the numerical
and exact solution for different methods and \( \Delta t \) values.
The plots can be organized in a table with \( \theta \) (methods) varying
through the columns and \( \Delta t \) varying through the rows.
Assume now that a new version of the <code>explore</code> function
not only returns the error <code>E</code> but also HTML code containing the
plot. Then we can write the <code>main_GUI</code> function as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main_GUI</span>(I=<span style="color: #B452CD">1.0</span>, a=.<span style="color: #B452CD">2</span>, T=<span style="color: #B452CD">4.0</span>,
         dt_values=[<span style="color: #B452CD">1.25</span>, <span style="color: #B452CD">0.75</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">0.1</span>],
         theta_values=[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>]):
    <span style="color: #228B22"># Build HTML code for web page. Arrange plots in columns</span>
    <span style="color: #228B22"># corresponding to the theta values, with dt down the rows</span>
    theta2name = {<span style="color: #B452CD">0</span>: <span style="color: #CD5555">&#39;FE&#39;</span>, <span style="color: #B452CD">1</span>: <span style="color: #CD5555">&#39;BE&#39;</span>, <span style="color: #B452CD">0.5</span>: <span style="color: #CD5555">&#39;CN&#39;</span>}
    html_text = <span style="color: #CD5555">&#39;&lt;table&gt;\n&#39;</span>
    <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values:
        html_text += <span style="color: #CD5555">&#39;&lt;tr&gt;\n&#39;</span>
        <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> theta_values:
            E, html = explore(I, a, T, dt, theta, makeplot=<span style="color: #658b00">True</span>)
            html_text += <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">&lt;td&gt;</span>
<span style="color: #CD5555">&lt;center&gt;&lt;b&gt;%s, dt=%g, error: %s&lt;/b&gt;&lt;/center&gt;&lt;br&gt;</span>
<span style="color: #CD5555">%s</span>
<span style="color: #CD5555">&lt;/td&gt;</span>
<span style="color: #CD5555">&quot;&quot;&quot;</span> % (theta2name[theta], dt, E, html)
        html_text += <span style="color: #CD5555">&#39;&lt;/tr&gt;\n&#39;</span>
    html_text += <span style="color: #CD5555">&#39;&lt;/table&gt;\n&#39;</span>
    <span style="color: #8B008B; font-weight: bold">return</span> html_text
</pre></div>
<p>
Rather than creating plot files and showing the plot on the screen,
the new version of the <code>explore</code> function makes a string with the PNG code of
the plot and embeds that string in HTML code. This action is
conveniently performed by Parampool's <code>save_png_to_str</code> function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
...
<span style="color: #228B22"># plot</span>
plt.plot(t, u, r-<span style="color: #CD5555">&#39;)</span>
plt.xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
plt.ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
...
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">parampool.utils</span> <span style="color: #8B008B; font-weight: bold">import</span> save_png_to_str
html_text = save_png_to_str(plt, plotwidth=<span style="color: #B452CD">400</span>)
</pre></div>
<p>
Note that we now write <code>plt.plot</code>, <code>plt.xlabel</code>, etc.
The <code>html_text</code> string is long and contains all the characters that
build up the PNG file of the current plot. The new <code>explore</code>
function can make use of the above code snippet and return
<code>html_text</code> along with <code>E</code>.

<h3>Generating the user interface  <a name="___sec9"></a></h3>

<p>
The web GUI is automatically generated by
the following code, placed in a file <a href="http://tinyurl.com/nm5587k/softeng1/decay_GUI_generate.py" target="_self"><tt>decay_GUI_generate.py</tt></a>

<p>

<!-- code=python (!bc pypro) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">parampool.generator.flask</span> <span style="color: #8B008B; font-weight: bold">import</span> generate
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">decay_GUI</span> <span style="color: #8B008B; font-weight: bold">import</span> main
generate(main,
         output_controller=<span style="color: #CD5555">&#39;decay_GUI_controller.py&#39;</span>,
         output_template=<span style="color: #CD5555">&#39;decay_GUI_view.py&#39;</span>,
         output_model=<span style="color: #CD5555">&#39;decay_GUI_model.py&#39;</span>)
</pre></div>
<p>
Running the <code>decay_GUI_generate.py</code> program results in three new
files whose names are specified in the call to <code>generate</code>:

<ol>
 <li> <code>decay_GUI_model.py</code> defines HTML widgets to be used to set
    input data in the web interface,</li>
 <li> <code>templates/decay_GUI_views.py</code> defines the layout of the web page,</li>
 <li> <code>decay_GUI_controller.py</code> runs the web application.</li>
</ol>

We only need to run the last program, and there is no need to look into
these files.

<h3>Running the web application  <a name="___sec10"></a></h3>

<p>
The web GUI is started by

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_GUI_controller.py
</pre></div>
<p>
Open a web browser at the location <code>127.0.0.1:5000</code>. Input fields for
<code>I</code>, <code>a</code>, <code>T</code>, <code>dt_values</code>, and <code>theta_values</code> are presented.  Setting
the latter two to <code>[1.25, 0.5]</code> and <code>[1, 0.5]</code>, respectively, and
pressing <em>Compute</em> results in four plots, see Figure
<a href="#decay:fig:GUI">1</a>. With the techniques demonstrated here, one can
easily create a tailored web GUI for a particular type of application
and use it to interactively explore physical and numerical effects.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Automatically generated graphical web interface. <a name="decay:fig:GUI"></a> </p></center>
<p><img src="fig-softeng1/decay_GUI.png" align="bottom" width=800></p>
</center>

<h1>Verification  <a name="___sec11"></a></h1>

<h2>Comparison with hand calculations  <a name="___sec12"></a></h2>

<p>
One of the simplest and most powerful methods for verifying numerical
codes is to perform some steps of the algorithm by hand and compare the
results with those produced by the code.
In the present case, we may choose some test problem and run three
steps by hand. Picking \( a(t)=t^2 \)...

<h2>Test function  <a name="___sec13"></a></h2>

<p>
<!-- Note: the admon function needs a raw string to handle \theta (\t, \b, etc) -->

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Caution: choice of parameter values.</b>
<p>
For the choice of values of parameters in verification tests one should
stay away from integers, especially 0 and 1, as these can
simplify formulas too much for test purposes. For example, with
\( \theta =1 \) the nominator in the formula for \( u^n \) will be the same for
all \( a \) and \( \Delta t \) values. One should therefore choose more
&quot;arbitrary&quot; values, say \( \theta =0.8 \) and \( I=0.1 \).
</div>


<h2>Comparison with an exact discrete solution  <a name="___sec14"></a></h2>

<p>
Sometimes it is possible to find a closed-form
<em>exact discrete solution</em> that fulfills the discrete finite
difference equations. The implementation can then be verified against
the exact discrete solution. This is usually the best technique for
verification.

<p>
<!-- Not so limited, will later guess that linear functions and MMS can -->
<!-- be used in the discrete eqs as well! -->

<p>
Define
$$ A = \frac{1 - (1-\theta) a\Delta t}{1 + \theta a \Delta t}\tp  $$

Manual computations with the \( \theta \)-rule results in
$$
\begin{align*}
u^0 &= I,\\ 
u^1 &= Au^0 = AI,\\ 
u^2 &= Au^1 = A^2I,\\ 
&\vdots\\ 
u^n &= A^nu^{n-1} = A^nI \tp
\end{align*}
$$

We have then established the exact discrete solution as
$$
\begin{equation}
u^n = IA^n
\tag{2}
\tp
\end{equation}
$$


<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b>Caution.</b>
<p>
One should be conscious about the different meanings of the notation
on the left- and right-hand side
of <a href="#mjx-eqn-2">(2)</a>: on the left, \( n \) in \( u^n \)
is a superscript reflecting a counter
of mesh points (\( t_n \)), while on the right, \( n \)
is the power in the exponentiation \( A^n \).
</div>


<p>
Comparison of the exact discrete solution and the computed
solution is done in the following function:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">verify_exact_discrete_solution</span>():

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_discrete_solution</span>(n, I, a, theta, dt):
        A = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)
        <span style="color: #8B008B; font-weight: bold">return</span> I*A**n

    theta = <span style="color: #B452CD">0.8</span>; a = <span style="color: #B452CD">2</span>; I = <span style="color: #B452CD">0.1</span>; dt = <span style="color: #B452CD">0.8</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #B452CD">8</span>/dt)  <span style="color: #228B22"># no of steps</span>
    u, t = solver(I=I, a=a, T=Nt*dt, dt=dt, theta=theta)
    u_de = array([exact_discrete_solution(n, I, a, theta, dt)
                  <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Nt+<span style="color: #B452CD">1</span>)])
    difference = <span style="color: #658b00">abs</span>(u_de - u).max()  <span style="color: #228B22"># max deviation</span>
    tol = <span style="color: #B452CD">1E-15</span>  <span style="color: #228B22"># tolerance for comparing floats</span>
    success = difference &lt;= tol
    <span style="color: #8B008B; font-weight: bold">return</span> success
</pre></div>
<p>
The complete program is found in the file <a href="http://tinyurl.com/nm5587k/softeng1/decay_verf2.py" target="_self"><tt>decay_verf2.py</tt></a> (<code>verf2</code> is a short name for "verification,
version 2").

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Local functions.</b>
<p>
One can define a function inside another function, here called
a <em>local function</em> (also known as <em>closure</em>) inside a <em>parent function</em>.
A local function is invisible outside the parent function.
A convenient property is that any local function has access to all
variables defined in the parent function, also if we send the
local function to some other function as argument (!).
In the present example, it means that the local function
<code>exact_discrete_solution</code> does not need its five arguments as the
values can alternatively be accessed through the local variables defined
in the parent function <code>verify_exact_discrete_solution</code>. We can send
such an <code>exact_discrete_solution</code> without arguments to any other
function and <code>exact_discrete_solution</code> will still have access to
<code>n</code>, <code>I</code>, <code>a</code>, and so forth defined in its parent function.
</div>


<h2>Computing convergence rates <a name="decay:convergence:rate"></a></h2>

<p>
We expect that the error \( E \) in the numerical solution is
reduced if the mesh size \( \Delta t \) is decreased. More specifically,
many numerical methods obey a power-law relation between \( E \) and
\( \Delta t \):

$$
\begin{equation}
E = C\Delta t^r,
\tag{3}
\end{equation}
$$

where \( C \) and \( r \) are (usually unknown) constants independent of \( \Delta t \).
The formula <a href="#mjx-eqn-3">(3)</a> is viewed as an asymptotic model valid for
sufficiently small \( \Delta t \). How small is normally hard to estimate
without doing numerical estimations of \( r \).

<p>
The parameter \( r \) is known as the <em>convergence rate</em>. For example,
if the convergence rate is 2, halving \( \Delta t \) reduces the error by
a factor of 4. Diminishing \( \Delta t \) then has a greater impact on
the error compared with methods that have \( r=1 \). For a given value of \( r \),
we refer to the method as of \( r \)-th order. First- and second-order
methods are most common in scientific computing.

<h3>Estimating \( r \)  <a name="___sec16"></a></h3>

<p>
There are two alternative ways of estimating \( C \) and \( r \) based on a set of
\( m \) simulations with corresponding pairs \( (\Delta t_i, E_i) \), \( i=0,\ldots,m-1 \),
and \( \Delta t_{i} < \Delta t_{i-1} \) (i.e., decreasing cell size).

<ol>
 <li> Take the logarithm of <a href="#mjx-eqn-3">(3)</a>, \( \ln E = r\ln \Delta t + \ln C \),
    and fit a straight line to the data points \( (\Delta t_i, E_i) \),
    \( i=0,\ldots,m-1 \).</li>
 <li> Consider two consecutive experiments, \( (\Delta t_i, E_i) \) and
    \( (\Delta t_{i-1}, E_{i-1}) \). Dividing the equation
    \( E_{i-1}=C\Delta t_{i-1}^r \) by \( E_{i}=C\Delta t_{i}^r \) and solving
    for \( r \) yields</li>
</ol>

$$
\begin{equation}
r_{i-1} = \frac{\ln (E_{i-1}/E_i)}{\ln (\Delta t_{i-1}/\Delta t_i)}
\tag{4}
\end{equation}
$$

for \( i=1,\ldots,m-1 \).

<p>
The disadvantage of method 1 is that <a href="#mjx-eqn-3">(3)</a> might not be valid
for the coarsest meshes (largest \( \Delta t \) values). Fitting a line
to all the data points is then misleading.  Method 2 computes
convergence rates for pairs of experiments and allows us to see
if the sequence \( r_i \) converges to some value as \( i\rightarrow m-2 \).
The final \( r_{m-2} \) can then be taken as the convergence rate.
If the coarsest meshes have a differing rate, the corresponding
time steps are probably too large for <a href="#mjx-eqn-3">(3)</a> to be valid.
That is, those time steps lie outside the asymptotic range of
\( \Delta t \) values where the error behaves like <a href="#mjx-eqn-3">(3)</a>.

<h3>Implementation  <a name="___sec17"></a></h3>

<p>
It is straightforward to extend the <code>main</code> function in the program
<code>decay_argparse.py</code> with statements for computing \( r_0, r_1, \ldots, r_{m-2} \)
from <a href="#mjx-eqn-3">(3)</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">math</span> <span style="color: #8B008B; font-weight: bold">import</span> log

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main</span>():
    I, a, T, makeplot, dt_values = read_command_line()
    r = {}  <span style="color: #228B22"># estimated convergence rates</span>
    <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0.5</span>, <span style="color: #B452CD">1</span>:
        E_values = []
        <span style="color: #8B008B; font-weight: bold">for</span> dt <span style="color: #8B008B">in</span> dt_values:
            E = explore(I, a, T, dt, theta, makeplot=<span style="color: #658b00">False</span>)
            E_values.append(E)

        <span style="color: #228B22"># Compute convergence rates</span>
        m = <span style="color: #658b00">len</span>(dt_values)
        r[theta] = [log(E_values[i-<span style="color: #B452CD">1</span>]/E_values[i])/
                    log(dt_values[i-<span style="color: #B452CD">1</span>]/dt_values[i])
                    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, m, <span style="color: #B452CD">1</span>)]

    <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> r:
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;\nPairwise convergence rates for theta=%g:&#39;</span> % theta
        <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39; &#39;</span>.join([<span style="color: #CD5555">&#39;%.2f&#39;</span> % r_ <span style="color: #8B008B; font-weight: bold">for</span> r_ <span style="color: #8B008B">in</span> r[theta]])
    <span style="color: #8B008B; font-weight: bold">return</span> r
</pre></div>
<p>
The program containing this <code>main</code> function is called <a href="http://tinyurl.com/nm5587k/softeng1/decay_convrate.py" target="_self"><tt>decay_convrate.py</tt></a>.

<p>
The <code>r</code> object is a <em>dictionary of lists</em>. The keys in this
dictionary are the \( \theta \) values. For example,
<code>r[1]</code> holds the list of the \( r_i \) values corresponding to
\( \theta=1 \). In the loop <code>for theta in r</code>, the loop variable <code>theta</code>
takes on the values of the keys in the dictionary <code>r</code> (in an
undetermined ordering). We could simply do a <code>print r[theta]</code>
inside the loop, but this would typically yield output of
the convergence rates with 16 decimals:

<p>

<!-- code=text (!bc dat) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">[1.331919482274763, 1.1488178494691532, ...]
</pre></div>
<p>
Instead, we format each number with 2 decimals, using a list
comprehension to turn the list of numbers, <code>r[theta]</code>, into
a list of formatted strings. Then we join these strings
with a space in between to get a sequence of rates on one line
in the terminal window. More generally, <code>d.join(list)</code> joins the
strings in the list <code>list</code> to one string, with <code>d</code>
as delimiter between <code>list[0]</code>, <code>list[1]</code>, etc.

<p>
Here is an example on the outcome of the convergence rate computations:
<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_convrate.py --dt 0.5 0.25 0.1 0.05 0.025 0.01
...
Pairwise convergence rates for theta=0:
1.33 1.15 1.07 1.03 1.02

Pairwise convergence rates for theta=0.5:
2.14 2.07 2.03 2.01 2.01

Pairwise convergence rates for theta=1:
0.98 0.99 0.99 1.00 1.00
</pre></div>
<p>
The Forward and Backward Euler methods seem to have an \( r \) value which
stabilizes at 1, while the Crank-Nicolson seems to be a second-order
method with \( r=2 \).

<p>
Very often, we have some theory that predicts what \( r \) is for a numerical
method. Various theoretical error measures for the \( \theta \)-rule point to
\( r=2 \) for \( \theta =0.5 \) and \( r=1 \) otherwise. The computed estimates of \( r \) are
in very good agreement with these theoretical values.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Why convergence rates are important.</b>
<p>
The strong practical application of computing convergence rates is for
verification: wrong convergence rates point to errors in the code, and
correct convergence rates brings evidence that the implementation is
correct. Experience shows that bugs in the code easily destroy the
expected convergence rate.
</div>


<h3>Debugging via convergence rates  <a name="___sec18"></a></h3>

<p>
Let us experiment with bugs and see the implication on the convergence
rate. We may, for instance, forget to multiply by <code>a</code> in the denominator
in the updating formula for <code>u[n+1]</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">1</span> - (<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt)*u[n]
</pre></div>
<p>
Running the same <code>decay_convrate.py</code> command as above gives the expected
convergence rates (!). Why? The reason is that we just specified
the \( \Delta t \) values are relied on default values for other
parameters. The default value of \( a \) is 1. Forgetting the factor
<code>a</code> has then no effect. This example shows how important it is to
avoid parameters that are 1 or 0 when verifying implementations.
Running the code <code>decay_v0.py</code> with \( a=2.1 \) and \( I=0.1 \) yields

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python decay_convrate.py --a 2.1 --I 0.1  \ 
          --dt 0.5 0.25 0.1 0.05 0.025 0.01
...
Pairwise convergence rates for theta=0:
1.49 1.18 1.07 1.04 1.02

Pairwise convergence rates for theta=0.5:
-1.42 -0.22 -0.07 -0.03 -0.01

Pairwise convergence rates for theta=1:
0.21 0.12 0.06 0.03 0.01
</pre></div>
<p>
This time we see that the expected convergence rates for the Crank-Nicolson and
Backward Euler methods are not obtained, while \( r=1 \) for the Forward Euler
method. The reason for correct rate in the latter case is that \( \theta=0 \)
and the wrong <code>theta*dt</code> term in the denominator vanishes anyway.

<p>
The error

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[n+<span style="color: #B452CD">1</span>] = ((<span style="color: #B452CD">1</span>-theta)*a*dt)/(<span style="color: #B452CD">1</span> + theta*dt*a)*u[n]
</pre></div>
<p>
manifests itself through wrong rates \( r\approx 0 \) for all three methods.
About the same results arise from an erroneous initial condition, <code>u[0] = 1</code>,
or wrong loop limits, <code>range(1,Nt)</code>. It seems that in this simple
problem, most bugs we can think of are detected by the convergence rate
test, provided the values of the input data do not hide the bug.

<p>
A <code>verify_convergence_rate</code> function could compute the dictionary of
list via <code>main</code> and check if the final rate estimates (\( r_{m-2} \))
are sufficiently close to the expected ones. A tolerance of 0.1
seems appropriate, given the uncertainty in estimating \( r \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">verify_convergence_rate</span>():
    r = main()
    tol = <span style="color: #B452CD">0.1</span>
    expected_rates = {<span style="color: #B452CD">0</span>: <span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>: <span style="color: #B452CD">1</span>, <span style="color: #B452CD">0.5</span>: <span style="color: #B452CD">2</span>}
    <span style="color: #8B008B; font-weight: bold">for</span> theta <span style="color: #8B008B">in</span> r:
        r_final = r[theta][-<span style="color: #B452CD">1</span>]
        diff = <span style="color: #658b00">abs</span>(expected_rates[theta] - r_final)
        <span style="color: #8B008B; font-weight: bold">if</span> diff &gt; tol:
            <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">False</span>
    <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #658b00">True</span>  <span style="color: #228B22"># all tests passed</span>
</pre></div>
<p>
We remark that <code>r[theta]</code> is a list and the last element in any list
can be extracted by the index <code>-1</code>.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_softeng1-solarized000.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_softeng1-solarized002.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

