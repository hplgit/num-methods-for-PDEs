<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Finite difference methods for vibration problems">
<meta name="keywords" content="period (of oscillations),frequency (of oscillations),Hz (unit),stability criterion">

<title>Study guide: Finite difference methods for vibration problems</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}

div { text-align: justify; text-justify: inter-word; }
</style>


</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [('A simple vibration problem', 1, None, '___sec0'),
              ('A centered finite difference scheme; step 1 and 2',
               2,
               'vib:model1:fdm',
               'vib:model1:fdm'),
              ('A centered finite difference scheme; step 3',
               2,
               None,
               '___sec2'),
              ('A centered finite difference scheme; step 4',
               2,
               None,
               '___sec3'),
              ('Computing the first step', 2, None, '___sec4'),
              ('The computational algorithm', 2, None, '___sec5'),
              ('Operator notation; ODE', 2, None, '___sec6'),
              ('Operator notation; initial condition', 2, None, '___sec7'),
              ('Computing $u^{\\prime}$', 2, None, '___sec8'),
              ('Implementation', 1, None, '___sec9'),
              ('Core algorithm', 2, None, '___sec10'),
              ('Plotting', 2, None, '___sec11'),
              ('Main program', 2, None, '___sec12'),
              ('User interface: command line', 2, None, '___sec13'),
              ('Running the program', 2, None, '___sec14'),
              ('Verification', 1, None, '___sec15'),
              ('First steps for testing and debugging', 2, None, '___sec16'),
              ('Checking convergence rates', 2, None, '___sec17'),
              ('Implementational details', 2, None, '___sec18'),
              ('Nose test', 2, None, '___sec19'),
              ('Long time simulations',
               1,
               'vib:model1:longseries',
               'vib:model1:longseries'),
              ('Effect of the time step on long simulations',
               2,
               None,
               '___sec21'),
              ('Using a moving plot window', 2, None, '___sec22'),
              ('Analysis of the numerical scheme',
               1,
               'vib:model1:analysis',
               'vib:model1:analysis'),
              ('Movie of the angular frequency error', 2, None, '___sec24'),
              ('We can derive an exact solution of the discrete equations',
               2,
               None,
               '___sec25'),
              ('Calculations of an exact solution of the discrete equations',
               2,
               None,
               '___sec26'),
              ('Solving for the numerical frequency', 2, None, '___sec27'),
              ('Polynomial approximation of the frequency error',
               2,
               None,
               '___sec28'),
              ('Plot of the frequency error', 2, None, '___sec29'),
              ('Exact discrete solution', 2, None, '___sec30'),
              ('Convergence of the numerical scheme', 2, None, '___sec31'),
              ('Stability', 2, None, '___sec32'),
              ('The stability criterion', 2, None, '___sec33'),
              ('Summary of the analysis', 2, None, '___sec34'),
              ('Alternative schemes based on 1st-order equations',
               1,
               'vib:model2x2',
               'vib:model2x2'),
              ('Rewriting 2nd-order ODE as system of two 1st-order ODEs',
               2,
               None,
               '___sec36'),
              ('The Forward Euler scheme', 2, None, '___sec37'),
              ('The Backward Euler scheme', 2, None, '___sec38'),
              ('The Crank-Nicolson scheme', 2, None, '___sec39'),
              ('Comparison of schemes via Odespy', 2, None, '___sec40'),
              ('Forward and Backward Euler and Crank-Nicolson',
               2,
               None,
               '___sec41'),
              ('Phase plane plot of the numerical solutions',
               2,
               None,
               '___sec42'),
              ('Plain solution curves', 2, None, '___sec43'),
              ('Observations from the figures', 2, None, '___sec44'),
              ('Runge-Kutta methods of order 2 and 4; short time series',
               2,
               None,
               '___sec45'),
              ('Runge-Kutta methods of order 2 and 4; longer time series',
               2,
               None,
               '___sec46'),
              ('Crank-Nicolson; longer time series', 2, None, '___sec47'),
              ('Observations of RK and CN methods', 2, None, '___sec48'),
              ('Energy conservation property', 2, None, '___sec49'),
              ('Derivation of the energy conservation property',
               2,
               None,
               '___sec50'),
              ('Remark about $E(t)$', 2, None, '___sec51'),
              ('The Euler-Cromer method; idea',
               2,
               'vib:model2x2:EulerCromer',
               'vib:model2x2:EulerCromer'),
              ('The Euler-Cromer method; complete formulas',
               2,
               None,
               '___sec53'),
              ('Euler-Cromer is equivalent to the scheme for $u^{\\prime\\prime}+\\omega^2u=0$',
               2,
               None,
               '___sec54'),
              ('The schemes are not equivalent wrt the initial conditions',
               2,
               None,
               '___sec55'),
              ('Generalization: damping, nonlinear spring, and external excitation',
               1,
               'vib:model2',
               'vib:model2'),
              ('A centered scheme for linear damping',
               2,
               'vib:ode2:fdm:flin',
               'vib:ode2:fdm:flin'),
              ('Initial conditions', 2, None, '___sec58'),
              ('Linearization via a geometric mean approximation',
               2,
               'vib:ode2:fdm:fquad',
               'vib:ode2:fdm:fquad'),
              ('A centered scheme for quadratic damping',
               2,
               None,
               '___sec60'),
              ('Initial condition for quadratic damping',
               2,
               None,
               '___sec61'),
              ('Algorithm', 2, None, '___sec62'),
              ('Implementation', 2, None, '___sec63'),
              ('Verification', 2, 'vib:ode2:verify', 'vib:ode2:verify'),
              ('Demo program', 2, None, '___sec65'),
              ('Euler-Cromer formulation', 2, None, '___sec66'),
              ('Staggered grid', 2, None, '___sec67'),
              ('Linear damping', 2, None, '___sec68'),
              ('Quadratic damping', 2, None, '___sec69'),
              ('Initial conditions', 2, None, '___sec70')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
$$




    
<!-- ------------------- main content ---------------------- -->



<center><h1>Study guide: Finite difference methods for vibration problems</h1></center>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b>Hans Petter Langtangen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b>Department of Informatics, University of Oslo</b></center>
<br>
<p>
<center><h4>Aug 9, 2015</h4></center> <!-- date -->
<br>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2>Table of contents</h2>

<p>
<a href="#___sec0"> A simple vibration problem </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model1:fdm"> A centered finite difference scheme; step 1 and 2 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec2"> A centered finite difference scheme; step 3 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec3"> A centered finite difference scheme; step 4 </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec4"> Computing the first step </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec5"> The computational algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec6"> Operator notation; ODE </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec7"> Operator notation; initial condition </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec8"> Computing \( u^{\prime} \) </a><br>
<a href="#___sec9"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec10"> Core algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec11"> Plotting </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec12"> Main program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec13"> User interface: command line </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec14"> Running the program </a><br>
<a href="#___sec15"> Verification </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec16"> First steps for testing and debugging </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec17"> Checking convergence rates </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec18"> Implementational details </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec19"> Nose test </a><br>
<a href="#vib:model1:longseries"> Long time simulations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec21"> Effect of the time step on long simulations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec22"> Using a moving plot window </a><br>
<a href="#vib:model1:analysis"> Analysis of the numerical scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec24"> Movie of the angular frequency error </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec25"> We can derive an exact solution of the discrete equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec26"> Calculations of an exact solution of the discrete equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec27"> Solving for the numerical frequency </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec28"> Polynomial approximation of the frequency error </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec29"> Plot of the frequency error </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec30"> Exact discrete solution </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec31"> Convergence of the numerical scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec32"> Stability </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec33"> The stability criterion </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec34"> Summary of the analysis </a><br>
<a href="#vib:model2x2"> Alternative schemes based on 1st-order equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec36"> Rewriting 2nd-order ODE as system of two 1st-order ODEs </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec37"> The Forward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec38"> The Backward Euler scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec39"> The Crank-Nicolson scheme </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec40"> Comparison of schemes via Odespy </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec41"> Forward and Backward Euler and Crank-Nicolson </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec42"> Phase plane plot of the numerical solutions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec43"> Plain solution curves </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec44"> Observations from the figures </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec45"> Runge-Kutta methods of order 2 and 4; short time series </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec46"> Runge-Kutta methods of order 2 and 4; longer time series </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec47"> Crank-Nicolson; longer time series </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec48"> Observations of RK and CN methods </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec49"> Energy conservation property </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec50"> Derivation of the energy conservation property </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec51"> Remark about \( E(t) \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:model2x2:EulerCromer"> The Euler-Cromer method; idea </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec53"> The Euler-Cromer method; complete formulas </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec54"> Euler-Cromer is equivalent to the scheme for \( u^{\prime\prime}+\omega^2u=0 \) </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec55"> The schemes are not equivalent wrt the initial conditions </a><br>
<a href="#vib:model2"> Generalization: damping, nonlinear spring, and external excitation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:fdm:flin"> A centered scheme for linear damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec58"> Initial conditions </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:fdm:fquad"> Linearization via a geometric mean approximation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec60"> A centered scheme for quadratic damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec61"> Initial condition for quadratic damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec62"> Algorithm </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec63"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#vib:ode2:verify"> Verification </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec65"> Demo program </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec66"> Euler-Cromer formulation </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec67"> Staggered grid </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec68"> Linear damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec69"> Quadratic damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="#___sec70"> Initial conditions </a><br>
</p>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="___sec0">A simple vibration problem </h1>

$$
u^{\prime\prime}(t) + \omega^2u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\ t\in (0,T]
$$

<p>
Exact solution:

$$
u(t) = I\cos (\omega t)
$$

\( u(t) \) oscillates with constant amplitude \( I \) and
(angular) frequency \( \omega \).
Period: \( P=2\pi/\omega \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="vib:model1:fdm">A centered finite difference scheme; step 1 and 2</h2>

<ul>
 <p><li> Strategy: follow the <a href="http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#the-forward-euler-scheme" target="_self">four steps</a> of the finite difference method.</li>
 <p><li> Step 1: Introduce a time mesh, here uniform on \( [0,T] \): \( t_n=n\Delta t \)</li>
 <p><li> Step 2: Let the ODE be satisfied at each mesh point:</li>
</ul>

$$
u^{\prime\prime}(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec2">A centered finite difference scheme; step 3 </h2>

<p>
Step 3: Approximate derivative(s) by finite
difference approximation(s).
Very common (standard!) formula for \( u^{\prime\prime} \):

$$
u^{\prime\prime}(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
$$

<p>
Use this discrete initial condition together with the ODE at \( t=0 \) to
eliminate \( u^{-1} \):

$$
\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec3">A centered finite difference scheme; step 4 </h2>

<p>
Step 4: Formulate the computational algorithm.
Assume \( u^{n-1} \) and \( u^n \) are known, solve for unknown \( u^{n+1} \):

$$
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
$$

<p>
Nick names for this scheme:
Stormer's
method or <a href="http://en.wikipedia.org/wiki/Velocity_Verlet" target="_self">Verlet integration</a>.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec4">Computing the first step </h2>

<ul>
  <p><li> The formula breaks down for \( u^1 \) because \( u^{-1} \) is unknown and
    outside the mesh!</li>
  <p><li> And: we have not used the initial condition \( u^{\prime}(0)=0 \).</li>
</ul>

Discretize \( u^{\prime}(0)=0 \) by a centered difference
$$
\frac{u^1-u^{-1}}{2\Delta t} = 0\quad\Rightarrow\quad u^{-1} = u^1
$$

<p>
Inserted in the scheme for \( n=0 \) gives

$$
u^1 = u^0 - \half \Delta t^2 \omega^2 u^0
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec5">The computational algorithm </h2>

<ol>
 <p><li> \( u^0=I \)</li>
 <p><li> compute \( u^1 \)</li>
 <p><li> for \( n=1,2,\ldots,N_t-1 \):</li>

<ol>
   <p><li> compute \( u^{n+1} \)</li>
</ol>

</ol>

More precisly expressed in Python:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">t = linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># mesh points in time</span>
dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]          <span style="color: #228B22"># constant time step.</span>
u = zeros(Nt+<span style="color: #B452CD">1</span>)           <span style="color: #228B22"># solution</span>

u[<span style="color: #B452CD">0</span>] = I
u[<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>] - <span style="color: #B452CD">0.5</span>*dt**<span style="color: #B452CD">2</span>*w**<span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">0</span>]
<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
    u[n+<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">2</span>*u[n] - u[n-<span style="color: #B452CD">1</span>] - dt**<span style="color: #B452CD">2</span>*w**<span style="color: #B452CD">2</span>*u[n]
</pre></div>
</td></tr></table><p>
Note: <code>w</code> is consistently used for \( \omega \) in my code.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec6">Operator notation; ODE </h2>

<p>
With \( [D_tD_t u]^n \) as the finite difference approximation to
\( u^{\prime\prime}(t_n) \) we can write

$$
[D_tD_t u  + \omega^2 u = 0]^n
$$

<p>
\( [D_tD_t u]^n \) means applying a central difference with step \( \Delta t/2 \) twice:

$$ [D_t(D_t u)]^n = \frac{[D_t u]^{n+\half} - [D_t u]^{n-\half}}{\Delta t}$$

which is written out as
$$
\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\tp
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec7">Operator notation; initial condition </h2>

$$
[u = I]^0,\quad [D_{2t} u = 0]^0
$$

where \( [D_{2t} u]^n \) is defined as
$$
[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
\tp
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec8">Computing \( u^{\prime} \) </h2>

<p>
\( u \) is often displacement/position, \( u^{\prime} \) is velocity and can be computed by

$$
u^{\prime}(t_n) \approx \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="___sec9">Implementation </h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec10">Core algorithm </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, w, dt, T):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span style="color: #CD5555">    by a central finite difference method with time step dt.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    dt = <span style="color: #658b00">float</span>(dt)
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    u = zeros(Nt+<span style="color: #B452CD">1</span>)
    t = linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)

    u[<span style="color: #B452CD">0</span>] = I
    u[<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>] - <span style="color: #B452CD">0.5</span>*dt**<span style="color: #B452CD">2</span>*w**<span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">0</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
        u[n+<span style="color: #B452CD">1</span>] = <span style="color: #B452CD">2</span>*u[n] - u[n-<span style="color: #B452CD">1</span>] - dt**<span style="color: #B452CD">2</span>*w**<span style="color: #B452CD">2</span>*u[n]
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec11">Plotting </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(t, I, w):
    <span style="color: #8B008B; font-weight: bold">return</span> I*cos(w*t)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">visualize</span>(u, t, I, w):
    plot(t, u, <span style="color: #CD5555">&#39;r--o&#39;</span>)
    t_fine = linspace(<span style="color: #B452CD">0</span>, t[-<span style="color: #B452CD">1</span>], <span style="color: #B452CD">1001</span>)  <span style="color: #228B22"># very fine mesh for u_e</span>
    u_e = u_exact(t_fine, I, w)
    hold(<span style="color: #CD5555">&#39;on&#39;</span>)
    plot(t_fine, u_e, <span style="color: #CD5555">&#39;b-&#39;</span>)
    legend([<span style="color: #CD5555">&#39;numerical&#39;</span>, <span style="color: #CD5555">&#39;exact&#39;</span>], loc=<span style="color: #CD5555">&#39;upper left&#39;</span>)
    xlabel(<span style="color: #CD5555">&#39;t&#39;</span>)
    ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
    dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]
    title(<span style="color: #CD5555">&#39;dt=%g&#39;</span> % dt)
    umin = <span style="color: #B452CD">1.2</span>*u.min();  umax = -umin
    axis([t[<span style="color: #B452CD">0</span>], t[-<span style="color: #B452CD">1</span>], umin, umax])
    savefig(<span style="color: #CD5555">&#39;tmp1.png&#39;</span>);  savefig(<span style="color: #CD5555">&#39;tmp1.pdf&#39;</span>)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_three_steps</span>():
    I = <span style="color: #B452CD">1</span>;  w = <span style="color: #B452CD">2</span>*pi;  dt = <span style="color: #B452CD">0.1</span>;  T = <span style="color: #B452CD">1</span>
    u_by_hand = array([<span style="color: #B452CD">1.000000000000000</span>,
                       <span style="color: #B452CD">0.802607911978213</span>,
                       <span style="color: #B452CD">0.288358920740053</span>])
    u, t = solver(I, w, dt, T)
    diff = <span style="color: #658b00">abs</span>(u_by_hand - u[:<span style="color: #B452CD">3</span>]).max()
    tol = <span style="color: #B452CD">1E-14</span>
    <span style="color: #8B008B; font-weight: bold">assert</span> diff &lt; tol

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">convergence_rates</span>(m, solver_function, num_periods=<span style="color: #B452CD">8</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Return m-1 empirical estimates of the convergence rate</span>
<span style="color: #CD5555">    based on m simulations, where the time step is halved</span>
<span style="color: #CD5555">    for each simulation.</span>
<span style="color: #CD5555">    solver_function(I, w, dt, T) solves each problem, where T</span>
<span style="color: #CD5555">    is based on simulation for num_periods periods.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    w = <span style="color: #B452CD">0.35</span>; I = <span style="color: #B452CD">0.3</span>       <span style="color: #228B22"># just chosen values</span>
    P = <span style="color: #B452CD">2</span>*pi/w              <span style="color: #228B22"># period</span>
    dt = P/<span style="color: #B452CD">30</span>               <span style="color: #228B22"># 30 time step per period 2*pi/w</span>
    T = P*num_periods

    dt_values = []
    E_values = []
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(m):
        u, t = solver_function(I, w, dt, T)
        u_e = u_exact(t, I, w)
        E = sqrt(dt*<span style="color: #658b00">sum</span>((u_e-u)**<span style="color: #B452CD">2</span>))
        dt_values.append(dt)
        E_values.append(E)
        dt = dt/<span style="color: #B452CD">2</span>

    r = [log(E_values[i-<span style="color: #B452CD">1</span>]/E_values[i])/
         log(dt_values[i-<span style="color: #B452CD">1</span>]/dt_values[i])
         <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, m, <span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">return</span> r

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_convergence_rates</span>():
    r = convergence_rates(m=<span style="color: #B452CD">5</span>, solver_function=solver, num_periods=<span style="color: #B452CD">8</span>)
    <span style="color: #228B22"># Accept rate to 1 decimal place</span>
    tol = <span style="color: #B452CD">0.1</span>
    <span style="color: #8B008B; font-weight: bold">assert</span> <span style="color: #658b00">abs</span>(r[-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2.0</span>) &lt; tol

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">main</span>(solver_function=solver):
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
    parser = argparse.ArgumentParser()
    parser.add_argument(<span style="color: #CD5555">&#39;--I&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">1.0</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--w&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">2</span>*pi)
    parser.add_argument(<span style="color: #CD5555">&#39;--dt&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">0.05</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--num_periods&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">int</span>, default=<span style="color: #B452CD">5</span>)
    parser.add_argument(<span style="color: #CD5555">&#39;--savefig&#39;</span>, action=<span style="color: #CD5555">&#39;store_true&#39;</span>)
    <span style="color: #228B22"># Hack to allow --SCITOOLS options (read when importing scitools.std)</span>
    parser.add_argument(<span style="color: #CD5555">&#39;--SCITOOLS_easyviz_backend&#39;</span>, default=<span style="color: #CD5555">&#39;matplotlib&#39;</span>)
    a = parser.parse_args()
    I, w, dt, num_periods, savefig = \ 
       a.I, a.w, a.dt, a.num_periods, a.savefig
    P = <span style="color: #B452CD">2</span>*pi/w  <span style="color: #228B22"># one period</span>
    T = P*num_periods
    u, t = solver_function(I, w, dt, T)
    <span style="color: #8B008B; font-weight: bold">if</span> num_periods &lt;= <span style="color: #B452CD">10</span>:
        visualize(u, t, I, w)
    <span style="color: #8B008B; font-weight: bold">else</span>:
        visualize_front(u, t, I, w, savefig)
        <span style="color: #228B22">#visualize_front_ascii(u, t, I, w)</span>
    <span style="color: #228B22">#plot_empirical_freq_and_amplitude(u, t, I, w)</span>
    show()

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">plot_empirical_freq_and_amplitude</span>(u, t, I, w):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Find the empirical angular frequency and amplitude of</span>
<span style="color: #CD5555">    simulations in u and t. u and t can be arrays or (in</span>
<span style="color: #CD5555">    the case of multiple simulations) multiple arrays.</span>
<span style="color: #CD5555">    One plot is made for the amplitude and one for the angular</span>
<span style="color: #CD5555">    frequency (just called frequency in the legends).</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">vib_empirical_analysis</span> <span style="color: #8B008B; font-weight: bold">import</span> minmax, periods, amplitudes
    <span style="color: #8B008B; font-weight: bold">if</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">isinstance</span>(u, (<span style="color: #658b00">list</span>,<span style="color: #658b00">tuple</span>)):
        u = [u]
        t = [t]
    legends1 = []
    legends2 = []
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(u)):
        minima, maxima = minmax(t[i], u[i])
        p = periods(maxima)
        a = amplitudes(minima, maxima)
        figure(<span style="color: #B452CD">1</span>)
        plot(<span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(p)), <span style="color: #B452CD">2</span>*pi/p)
        legends1.append(<span style="color: #CD5555">&#39;frequency, case%d&#39;</span> % (i+<span style="color: #B452CD">1</span>))
        hold(<span style="color: #CD5555">&#39;on&#39;</span>)
        figure(<span style="color: #B452CD">2</span>)
        plot(<span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(a)), a)
        hold(<span style="color: #CD5555">&#39;on&#39;</span>)
        legends2.append(<span style="color: #CD5555">&#39;amplitude, case%d&#39;</span> % (i+<span style="color: #B452CD">1</span>))
    figure(<span style="color: #B452CD">1</span>)
    plot(<span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(p)), [w]*<span style="color: #658b00">len</span>(p), <span style="color: #CD5555">&#39;k--&#39;</span>)
    legends1.append(<span style="color: #CD5555">&#39;exact frequency&#39;</span>)
    legend(legends1, loc=<span style="color: #CD5555">&#39;lower left&#39;</span>)
    axis([<span style="color: #B452CD">0</span>, <span style="color: #658b00">len</span>(a)-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">0.8</span>*w, <span style="color: #B452CD">1.2</span>*w])
    savefig(<span style="color: #CD5555">&#39;tmp1.png&#39;</span>);  savefig(<span style="color: #CD5555">&#39;tmp1.pdf&#39;</span>)
    figure(<span style="color: #B452CD">2</span>)
    plot(<span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(a)), [I]*<span style="color: #658b00">len</span>(a), <span style="color: #CD5555">&#39;k--&#39;</span>)
    legends2.append(<span style="color: #CD5555">&#39;exact amplitude&#39;</span>)
    legend(legends2, loc=<span style="color: #CD5555">&#39;lower left&#39;</span>)
    axis([<span style="color: #B452CD">0</span>, <span style="color: #658b00">len</span>(a)-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">0.8</span>*I, <span style="color: #B452CD">1.2</span>*I])
    savefig(<span style="color: #CD5555">&#39;tmp2.png&#39;</span>);  savefig(<span style="color: #CD5555">&#39;tmp2.pdf&#39;</span>)
    show()


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">visualize_front</span>(u, t, I, w, savefig=<span style="color: #658b00">False</span>, skip_frames=<span style="color: #B452CD">1</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Visualize u and the exact solution vs t, using a</span>
<span style="color: #CD5555">    moving plot window and continuous drawing of the</span>
<span style="color: #CD5555">    curves as they evolve in time.</span>
<span style="color: #CD5555">    Makes it easy to plot very long time series.</span>
<span style="color: #CD5555">    Plots are saved to files if savefig is True.</span>
<span style="color: #CD5555">    Only each skip_frames-th plot is saved (e.g., if</span>
<span style="color: #CD5555">    skip_frame=10, only each 10th plot is saved to file;</span>
<span style="color: #CD5555">    this is convenient if plot files corresponding to</span>
<span style="color: #CD5555">    different time steps are to be compared).</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">st</span>
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scitools.MovingPlotWindow</span> <span style="color: #8B008B; font-weight: bold">import</span> MovingPlotWindow

    <span style="color: #228B22"># Remove all old plot files tmp_*.png</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">glob</span>, <span style="color: #008b45; text-decoration: underline">os</span>
    <span style="color: #8B008B; font-weight: bold">for</span> filename <span style="color: #8B008B">in</span> glob.glob(<span style="color: #CD5555">&#39;tmp_*.png&#39;</span>):
        os.remove(filename)

    P = <span style="color: #B452CD">2</span>*pi/w  <span style="color: #228B22"># one period</span>
    umin = <span style="color: #B452CD">1.2</span>*u.min();  umax = -umin
    dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]
    plot_manager = MovingPlotWindow(
        window_width=<span style="color: #B452CD">8</span>*P,
        dt=dt,
        yaxis=[umin, umax],
        mode=<span style="color: #CD5555">&#39;continuous drawing&#39;</span>)
    frame_counter = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>,<span style="color: #658b00">len</span>(u)):
        <span style="color: #8B008B; font-weight: bold">if</span> plot_manager.plot(n):
            s = plot_manager.first_index_in_plot
            st.plot(t[s:n+<span style="color: #B452CD">1</span>], u[s:n+<span style="color: #B452CD">1</span>], <span style="color: #CD5555">&#39;r-1&#39;</span>,
                    t[s:n+<span style="color: #B452CD">1</span>], I*cos(w*t)[s:n+<span style="color: #B452CD">1</span>], <span style="color: #CD5555">&#39;b-1&#39;</span>,
                    title=<span style="color: #CD5555">&#39;t=%6.3f&#39;</span> % t[n],
                    axis=plot_manager.axis(),
                    show=<span style="color: #8B008B">not</span> savefig) <span style="color: #228B22"># drop window if savefig</span>
            <span style="color: #8B008B; font-weight: bold">if</span> savefig <span style="color: #8B008B">and</span> n % skip_frames == <span style="color: #B452CD">0</span>:
                filename = <span style="color: #CD5555">&#39;tmp_%04d.png&#39;</span> % frame_counter
                st.savefig(filename)
                <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;making plot file&#39;</span>, filename, <span style="color: #CD5555">&#39;at t=%g&#39;</span> % t[n]
                frame_counter += <span style="color: #B452CD">1</span>
        plot_manager.update(n)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">visualize_front_ascii</span>(u, t, I, w, fps=<span style="color: #B452CD">10</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Plot u and the exact solution vs t line by line in a</span>
<span style="color: #CD5555">    terminal window (only using ascii characters).</span>
<span style="color: #CD5555">    Makes it easy to plot very long time series.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scitools.avplotter</span> <span style="color: #8B008B; font-weight: bold">import</span> Plotter
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>
    P = <span style="color: #B452CD">2</span>*pi/w
    umin = <span style="color: #B452CD">1.2</span>*u.min();  umax = -umin

    p = Plotter(ymin=umin, ymax=umax, width=<span style="color: #B452CD">60</span>, symbols=<span style="color: #CD5555">&#39;+o&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #658b00">len</span>(u)):
        <span style="color: #8B008B; font-weight: bold">print</span> p.plot(t[n], u[n], I*cos(w*t[n])), \ 
              <span style="color: #CD5555">&#39;%.1f&#39;</span> % (t[n]/P)
        time.sleep(<span style="color: #B452CD">1</span>/<span style="color: #658b00">float</span>(fps))

<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    main()
    <span style="color: #658b00">raw_input</span>()
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec12">Main program </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">I = <span style="color: #B452CD">1</span>
w = <span style="color: #B452CD">2</span>*pi
dt = <span style="color: #B452CD">0.05</span>
num_periods = <span style="color: #B452CD">5</span>
P = <span style="color: #B452CD">2</span>*pi/w    <span style="color: #228B22">#  one period</span>
T = P*num_periods
u, t = solver(I, w, dt, T)
visualize(u, t, I, w, dt)
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec13">User interface: command line </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">argparse</span>
parser = argparse.ArgumentParser()
parser.add_argument(<span style="color: #CD5555">&#39;--I&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">1.0</span>)
parser.add_argument(<span style="color: #CD5555">&#39;--w&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">2</span>*pi)
parser.add_argument(<span style="color: #CD5555">&#39;--dt&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">float</span>, default=<span style="color: #B452CD">0.05</span>)
parser.add_argument(<span style="color: #CD5555">&#39;--num_periods&#39;</span>, <span style="color: #658b00">type</span>=<span style="color: #658b00">int</span>, default=<span style="color: #B452CD">5</span>)
a = parser.parse_args()
I, w, dt, num_periods = a.I, a.w, a.dt, a.num_periods
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec14">Running the program </h2>

<p>
<a href="http://tinyurl.com/nm5587k/vib/vib_undamped.py" target="_self"><tt>vib_undamped.py</tt></a>:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
</td></tr></table><p>
Generates frames <code>tmp_vib%04d.png</code> in files. Can make movie:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; avconv -r 12 -i tmp_vib%04d.png -c:v flv movie.flv
</pre></div>
</td></tr></table><p>
Can use <code>ffmpeg</code> instead of <code>avconv</code>.

<p>
<table border="1">
<thead>
<tr><th align="center">Format</th> <th align="center">          Codec and filename         </th> </tr>
</thead>
<tbody>
<tr><td align="left">   Flash     </td> <td align="left">   <code>-c:v flv movie.flv</code>          </td> </tr>
<tr><td align="left">   MP4       </td> <td align="left">   <code>-c:v libx264 movie.mp4</code>      </td> </tr>
<tr><td align="left">   Webm      </td> <td align="left">   <code>-c:v libvpx movie.webm</code>      </td> </tr>
<tr><td align="left">   Ogg       </td> <td align="left">   <code>-c:v libtheora movie.ogg</code>    </td> </tr>
</tbody>
</table>
<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="___sec15">Verification </h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec16">First steps for testing and debugging </h2>

<ul>
 <p><li> <b>Testing very simple solutions</b>:
   \( u=\hbox{const} \) or \( u=ct + d \) do not apply here (without a force
   term in the equation: \( u^{\prime\prime} + \omega^2u = f \)).</li>
 <p><li> <b>Hand calculations</b>: calculate \( u^1 \) and \( u^2 \) and compare with program.</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec17">Checking convergence rates </h2>

<p>
The next function estimates convergence rates, i.e., it

<ul>
 <p><li> performs \( m \) simulations with halved time steps: \( 2^{-k}\Delta t \), \( k=0,\ldots,m-1 \),</li>
 <p><li> computes the \( L_2 \) norm of the error,
   \( E = \sqrt{\Delta t_i\sum_{n=0}^{N_t-1}(u^n-\uex(t_n))^2} \) in each case,</li>
 <p><li> estimates the rates \( r_i \) from two consecutive
   experiments \( (\Delta t_{i-1}, E_{i-1}) \) and \( (\Delta t_{i}, E_{i}) \),
   assuming \( E_i=C\Delta t_i^{r_i} \) and \( E_{i-1}=C\Delta t_{i-1}^{r_i} \):</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec18">Implementational details </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">convergence_rates</span>(m, solver_function, num_periods=<span style="color: #B452CD">8</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Return m-1 empirical estimates of the convergence rate</span>
<span style="color: #CD5555">    based on m simulations, where the time step is halved</span>
<span style="color: #CD5555">    for each simulation.</span>
<span style="color: #CD5555">    solver_function(I, w, dt, T) solves each problem, where T</span>
<span style="color: #CD5555">    is based on simulation for num_periods periods.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    w = <span style="color: #B452CD">0.35</span>; I = <span style="color: #B452CD">0.3</span>       <span style="color: #228B22"># just chosen values</span>
    P = <span style="color: #B452CD">2</span>*pi/w              <span style="color: #228B22"># period</span>
    dt = P/<span style="color: #B452CD">30</span>               <span style="color: #228B22"># 30 time step per period 2*pi/w</span>
    T = P*num_periods

    dt_values = []
    E_values = []
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(m):
        u, t = solver_function(I, w, dt, T)
        u_e = u_exact(t, I, w)
        E = sqrt(dt*<span style="color: #658b00">sum</span>((u_e-u)**<span style="color: #B452CD">2</span>))
        dt_values.append(dt)
        E_values.append(E)
        dt = dt/<span style="color: #B452CD">2</span>

    r = [log(E_values[i-<span style="color: #B452CD">1</span>]/E_values[i])/
         log(dt_values[i-<span style="color: #B452CD">1</span>]/dt_values[i])
         <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, m, <span style="color: #B452CD">1</span>)]
    <span style="color: #8B008B; font-weight: bold">return</span> r
</pre></div>
</td></tr></table><p>
Result: <code>r</code> contains values equal to 2.00 - as expected!

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec19">Nose test </h2>

<p>
Use final <code>r[-1]</code> in a unit test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_convergence_rates</span>():
    r = convergence_rates(m=<span style="color: #B452CD">5</span>, solver_function=solver, num_periods=<span style="color: #B452CD">8</span>)
    <span style="color: #228B22"># Accept rate to 1 decimal place</span>
    tol = <span style="color: #B452CD">0.1</span>
    <span style="color: #8B008B; font-weight: bold">assert</span> <span style="color: #658b00">abs</span>(r[-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2.0</span>) &lt; tol
</pre></div>
</td></tr></table><p>
Complete code in <a href="http://tinyurl.com/nm5587k/vib/vib_undamped.py" target="_self"><tt>vib_undamped.py</tt></a>.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="vib:model1:longseries">Long time simulations</h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec21">Effect of the time step on long simulations </h2>

<p>
<center><p><img src="fig-vib/vib_freq_err1.png" align="bottom" width=800></p></center>

<ul>
 <p><li> The numerical solution seems to have right amplitude.</li>
 <p><li> There is an angular frequency error (reduced by reducing the time step).</li>
 <p><li> The total angular frequency error seems to grow with time.</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec22">Using a moving plot window </h2>

<ul>
 <p><li> In long time simulations we need a plot window that follows
   the solution.</li>
 <p><li> Method 1: <code>scitools.MovingPlotWindow</code>.</li>
 <p><li> Method 2: <code>scitools.avplotter</code> (ASCII vertical plotter).</li>
</ul>

Example:
<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
</td></tr></table><p>
<a href="http://tinyurl.com/opdfafk/pub/mov-vib/vib_undamped_dt0.05/index.html" target="_self">Movie of the moving plot window</a>.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="vib:model1:analysis">Analysis of the numerical scheme</h1>

<p>

<!-- begin box -->
<div style="width: 95%; padding: 10px; border: 1px solid #000; border-radius: 4px;">
Can we understand the frequency error?
</div>
<!-- end box -->


<p>
<center><p><img src="fig-vib/vib_freq_err1.png" align="bottom" width=800></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec24">Movie of the angular frequency error </h2>

<p>
\( u^{\prime\prime} + \omega^2 u = 0 \), \( u(0)=1 \), \( u^{\prime}(0)=0 \),
\( \omega=2\pi \), \( \uex(t)=\cos (2\pi t) \), \( \Delta t = 0.05 \) (20 intervals
per period)
<br />

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-vib/vib_undamped_movie_dt0.05/movie.mp4'  type='video/mp4;  codecs="avc1.42E01E, mp4a.40.2"'>
    <source src='mov-vib/vib_undamped_movie_dt0.05/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-vib/vib_undamped_movie_dt0.05/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec25">We can derive an exact solution of the discrete equations </h2>

<ul>
  <p><li> We have a linear, homogeneous, difference equation for \( u^n \).</li>
  <p><li> Has solutions \( u^n \sim IA^n \), where \( A \) is unknown (number).</li>
  <p><li> Here: \( \uex(t) =I\cos(\omega t) \sim I\exp{(i\omega t)} = I(e^{i\omega\Delta t})^n \)</li>
  <p><li> Trick for simplifying the algebra: \( u^n = IA^n \), with \( A=\exp{(i\tilde\omega\Delta t)} \), then find \( \tilde\omega \)</li>
  <p><li> \( \tilde\omega \): unknown <em>numerical frequency</em> (easier to calculate than \( A \))</li>
  <p><li> \( \omega - \tilde\omega \) is the angular <em>frequency error</em></li>
  <p><li> Use the real part as the physical relevant part of a complex expression</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec26">Calculations of an exact solution of the discrete equations </h2>

$$
u^n = IA^n = I\exp{(\tilde\omega \Delta t\, n)}=I\exp{(\tilde\omega t)} =
I\cos (\tilde\omega t) + iI\sin(\tilde \omega t)
\tp
$$


$$
\begin{align*}
[D_tD_t u]^n &= \frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2}\\ 
&= I\frac{A^{n+1} - 2A^n + A^{n-1}}{\Delta t^2}\\ 
&= I\frac{\exp{(i\tilde\omega(t+\Delta t))} - 2\exp{(i\tilde\omega t)} + \exp{(i\tilde\omega(t-\Delta t))}}{\Delta t^2}\\ 
&= I\exp{(i\tilde\omega t)}\frac{1}{\Delta t^2}\left(\exp{(i\tilde\omega(\Delta t))} + \exp{(i\tilde\omega(-\Delta t))} - 2\right)\\ 
&= I\exp{(i\tilde\omega t)}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\ 
&= I\exp{(i\tilde\omega t)}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\ 
&= -I\exp{(i\tilde\omega t)}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec27">Solving for the numerical frequency </h2>

<p>
The scheme
with \( u^n=I\exp{(i\omega\tilde\Delta t\, n)} \) inserted gives

$$
-I\exp{(i\tilde\omega t)}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
+ \omega^2 I\exp{(i\tilde\omega t)} = 0
$$

which after dividing by \( I\exp{(i\tilde\omega t)} \) results in
$$
\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
$$

Solve for \( \tilde\omega \):
$$
\tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
$$


<ul>
 <p><li> Frequency error because \( \tilde\omega \neq \omega \).</li>
 <p><li> Note: dimensionless number \( p=\omega\Delta t \) is the key parameter <br />
   (i.e., no of time intervals per period is important, not \( \Delta t \) itself)</li>
 <p><li> But how good is the approximation \( \tilde\omega \) to \( \omega \)?</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec28">Polynomial approximation of the frequency error </h2>

<p>
Taylor series expansion
for small \( \Delta t \) gives a formula that is easier to understand:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">import</span> *
&gt;&gt;&gt; dt, w = symbols(<span style="color: #CD5555">&#39;dt w&#39;</span>)
&gt;&gt;&gt; w_tilde = asin(w*dt/<span style="color: #B452CD">2</span>).series(dt, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">4</span>)*<span style="color: #B452CD">2</span>/dt
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> w_tilde
(dt*w + dt**<span style="color: #B452CD">3</span>*w**<span style="color: #B452CD">3</span>/<span style="color: #B452CD">24</span> + O(dt**<span style="color: #B452CD">4</span>))/dt  <span style="color: #228B22"># note the final &quot;/dt&quot;</span>
</pre></div>
</td></tr></table>$$
\tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right) + {\cal O}(\Delta t^3)
$$

The numerical frequency is too large (to fast oscillations).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec29">Plot of the frequency error </h2>

<p>
<center><p><img src="fig-vib/discrete_freq.png" align="bottom" width=600></p></center>

<p>
Recommendation: 25-30 points per period.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec30">Exact discrete solution </h2>

$$
u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
\tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
$$

<p>
The error mesh function,

$$ e^n = \uex(t_n) - u^n =
I\cos\left(\omega n\Delta t\right)
- I\cos\left(\tilde\omega n\Delta t\right)
$$

is ideal for verification and further analysis!

$$
e^n = I\cos\left(\omega n\Delta t\right)
- I\cos\left(\tilde\omega n\Delta t\right)
= -2I\sin\left(t\half\left( \omega - \tilde\omega\right)\right)
\sin\left(t\half\left( \omega + \tilde\omega\right)\right)
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec31">Convergence of the numerical scheme </h2>

<p>
Can easily show <em>convergence</em>:

$$ e^n\rightarrow 0 \hbox{ as }\Delta t\rightarrow 0,$$

because

$$
\lim_{\Delta t\rightarrow 0}
\tilde\omega = \lim_{\Delta t\rightarrow 0}
\frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
= \omega,
$$

by L'Hopital's rule or simply asking <code>sympy</code>:
or <a href="http://www.wolframalpha.com/input/?i=%282%2Fx%29*asin%28w*x%2F2%29+as+x-%3E0" target="_self">WolframAlpha</a>:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">sympy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sym</span>
&gt;&gt;&gt; dt, w = sym.symbols(<span style="color: #CD5555">&#39;x w&#39;</span>)
&gt;&gt;&gt; sym.limit((<span style="color: #B452CD">2</span>/dt)*sym.asin(w*dt/<span style="color: #B452CD">2</span>), dt, <span style="color: #B452CD">0</span>, <span style="color: #658b00">dir</span>=<span style="color: #CD5555">&#39;+&#39;</span>)
w
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec32">Stability </h2>

<p>
Observations:

<ul>
 <p><li> Numerical solution has constant amplitude (desired!), but an angular frequency error</li>
 <p><li> Constant amplitude requires \( \sin^{-1}(\omega\Delta t/2) \) to be
   real-valued \( \Rightarrow |\omega\Delta t/2| \leq 1 \)</li>
 <p><li> \( \sin^{-1}(x) \) is complex if \( |x| > 1 \), and then \( \tilde\omega \) becomes
   complex</li>
</ul>

What is the consequence of complex \( \tilde\omega \)?

<ul>
 <p><li> Set \( \tilde\omega = \tilde\omega_r + i\tilde\omega_i \)</li>
 <p><li> Since \( \sin^{-1}(x) \) has a <a href="http://www.wolframalpha.com/input/?i=arcsin%28x%29%2C+x+in+%280%2C3%29" target="_self">*negative* imaginary part</a> for
   \( x>1 \), \( \exp{(i\omega\tilde t)}=\exp{(-\tilde\omega_i t)}\exp{(i\tilde\omega_r t)} \)
   leads to exponential growth \( e^{-\tilde\omega_it} \)
   when \( -\tilde\omega_i t > 0 \)</li>
 <p><li> This is <em>instability</em> because the qualitative behavior is wrong</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec33">The stability criterion </h2>

<p>
Cannot tolerate growth and must therefore demand a <em>stability criterion</em>
$$
\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
\Delta t \leq \frac{2}{\omega}
$$

<p>
Try \( \Delta t = \frac{2}{\omega} + 9.01\cdot 10^{-5} \) (<em>slightly</em> too big!):

<p>
<center><p><img src="fig-vib/vib_unstable.png" align="bottom" width=400></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec34">Summary of the analysis </h2>

<p>
We can draw three important conclusions:

<ol>
<p><li> The key parameter in the formulas is \( p=\omega\Delta t \) (dimensionless)</li>

<ol>
  <p><li> Period of oscillations: \( P=2\pi/\omega \)</li>
  <p><li> Number of time steps per period: \( N_P=P/\Delta t \)</li>
  <p><li> \( \Rightarrow\ p=\omega\Delta t = 2\pi/ N_P \sim 1/N_P \)</li>
  <p><li> The smallest possible \( N_P \) is 2 \( \Rightarrow \) $p\in (0,\pi]$</li>
</ol>

<p><li> For \( p\leq 2 \) the amplitude of \( u^n \) is constant (stable solution)</li>
<p><li> \( u^n \) has a relative frequency error
   \( \tilde\omega/\omega \approx 1 + \frac{1}{24}p^2 \), making numerical
   peaks occur too early</li>
</ol>

<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="vib:model2x2">Alternative schemes based on 1st-order equations</h1>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec36">Rewriting 2nd-order ODE as system of two 1st-order ODEs </h2>

<p>
The vast collection of ODE solvers (e.g., in <a href="https://github.com/hplgit/odespy" target="_self">Odespy</a>) cannot be applied to
$$ u^{\prime\prime} + \omega^2 u = 0$$

unless we write this higher-order ODE as a system of 1st-order ODEs.

<p>
Introduce an auxiliary variable \( v=u^{\prime} \):

$$
\begin{align}
u^{\prime} &= v,
\label{vib:model2x2:ueq}\\ 
v^{\prime} &= -\omega^2 u
\label{vib:model2x2:veq}
\tp
\end{align}
$$

<p>
Initial conditions: \( u(0)=I \) and \( v(0)=0 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec37">The Forward Euler scheme </h2>

<p>
We apply the Forward Euler scheme to each component equation:

$$ [D_t^+ u = v]^n,$$


$$ [D_t^+ v = -\omega^2 u]^n,$$

or written out,

$$
\begin{align}
u^{n+1} &= u^n + \Delta t v^n,\\ 
v^{n+1} &= v^n -\Delta t \omega^2 u^n
\tp
\end{align}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec38">The Backward Euler scheme </h2>

<p>
We apply the Backward Euler scheme to each component equation:

$$ [D_t^- u = v]^{n+1},$$


$$ [D_t^- v = -\omega u]^{n+1} \tp  $$

Written out:
$$
\begin{align}
u^{n+1} - \Delta t v^{n+1} = u^{n},\\ 
v^{n+1} + \Delta t \omega^2 u^{n+1} = v^{n}
\tp
\end{align}
$$

This is a <em>coupled</em> \( 2\times 2 \) system for the new values at \( t=t_{n+1} \)!

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec39">The Crank-Nicolson scheme </h2>

$$
[D_t u = \overline{v}^t]^{n+\half},$$


$$
[D_t v = -\omega \overline{u}^t]^{n+\half}$$

The result is also a coupled system:

$$
\begin{align}
u^{n+1} - \half\Delta t v^{n+1} &= u^{n} + \half\Delta t v^{n},\\ 
v^{n+1} + \half\Delta t \omega^2 u^{n+1} &= v^{n}
- \half\Delta t \omega^2 u^{n}
\tp
\end{align}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec40">Comparison of schemes via Odespy </h2>

<p>
Can use
<a href="https://github.com/hplgit/odespy" target="_self">Odespy</a> to compare many methods
for first-order schemes:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">odespy</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(u, t, w=<span style="color: #B452CD">1</span>):
    u, v = u  <span style="color: #228B22"># u is array of length 2 holding our [u, v]</span>
    <span style="color: #8B008B; font-weight: bold">return</span> [v, -w**<span style="color: #B452CD">2</span>*u]

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">run_solvers_and_plot</span>(solvers, timesteps_per_period=<span style="color: #B452CD">20</span>,
                         num_periods=<span style="color: #B452CD">1</span>, I=<span style="color: #B452CD">1</span>, w=<span style="color: #B452CD">2</span>*np.pi):
    P = <span style="color: #B452CD">2</span>*np.pi/w  <span style="color: #228B22"># duration of one period</span>
    dt = P/timesteps_per_period
    Nt = num_periods*timesteps_per_period
    T = Nt*dt
    t_mesh = np.linspace(<span style="color: #B452CD">0</span>, T, Nt+<span style="color: #B452CD">1</span>)

    legends = []
    <span style="color: #8B008B; font-weight: bold">for</span> solver <span style="color: #8B008B">in</span> solvers:
        solver.set(f_kwargs={<span style="color: #CD5555">&#39;w&#39;</span>: w})
        solver.set_initial_condition([I, <span style="color: #B452CD">0</span>])
        u, t = solver.solve(t_mesh)
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec41">Forward and Backward Euler and Crank-Nicolson </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">solvers = [
    odespy.ForwardEuler(f),
    <span style="color: #228B22"># Implicit methods must use Newton solver to converge</span>
    odespy.BackwardEuler(f, nonlinear_solver=<span style="color: #CD5555">&#39;Newton&#39;</span>),
    odespy.CrankNicolson(f, nonlinear_solver=<span style="color: #CD5555">&#39;Newton&#39;</span>),
    ]
</pre></div>
</td></tr></table><p>
Two plot types:

<ul>
  <p><li> \( u(t) \) vs \( t \)</li>
  <p><li> Parameterized curve \( (u(t), v(t)) \) in <em>phase space</em></li>
  <p><li> Exact curve is an ellipse: \( (I\cos\omega t, -\omega I\sin\omega t) \),
    closed and periodic</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec42">Phase plane plot of the numerical solutions </h2>

<p>
<center><p><img src="fig-vib/vib_theta_1_pp.png" align="bottom" width=800></p></center>

<p>
Note: CrankNicolson in Odespy leads to the name MidpointImplicit in plots.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec43">Plain solution curves </h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 1:  Comparison of classical schemes. <div id="vib:model1:1st:odespy:theta"></div> </p></center>
<p><img src="fig-vib/vib_theta_1_u.png" align="bottom" width=800></p>
</center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec44">Observations from the figures </h2>

<ul>
  <p><li> Forward Euler has growing amplitude and outward \( (u,v) \) spiral - pumps
    energy into the system.</li>
  <p><li> Backward Euler is opposite: decreasing amplitude, inward sprial,
    extracts energy.</li>
  <p><li> <b>Forward and Backward Euler are useless for vibrations.</b></li>
  <p><li> Crank-Nicolson (MidpointImplicit) looks much better.</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec45">Runge-Kutta methods of order 2 and 4; short time series </h2>

<p>
<center><p><img src="fig-vib/vib_RK_1_pp.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-vib/vib_RK_1_u.png" align="bottom" width=800></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec46">Runge-Kutta methods of order 2 and 4; longer time series </h2>

<p>
<center><p><img src="fig-vib/vib_RK_10_pp.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-vib/vib_RK_10_u.png" align="bottom" width=800></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec47">Crank-Nicolson; longer time series </h2>

<p>
<center><p><img src="fig-vib/vib_CN_10_pp.png" align="bottom" width=800></p></center>

<p>
<center><p><img src="fig-vib/vib_CN_10_u.png" align="bottom" width=800></p></center>

<p>
(MidpointImplicit means CrankNicolson in Odespy)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec48">Observations of RK and CN methods </h2>

<ul>
  <p><li> 4th-order Runge-Kutta is very accurate, also for large \( \Delta t \).</li>
  <p><li> 2th-order Runge-Kutta is almost as bad as Forward and Backward
    Euler.</li>
  <p><li> Crank-Nicolson is accurate, but the amplitude is not as accurate
    as the difference scheme for \( u^{\prime\prime}+\omega^2u=0 \).</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec49">Energy conservation property </h2>

<p>
The model

$$ u^{\prime\prime} + \omega^2 u = 0,\quad u(0)=I,\ u^{\prime}(0)=V,$$

has the nice <em>energy conservation property</em> that

$$ E(t) = \half(u^{\prime})^2 + \half\omega^2u^2 = \hbox{const}\tp$$

This can be used to check solutions.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec50">Derivation of the energy conservation property </h2>

<p>
Multiply \( u^{\prime\prime}+\omega^2u=0 \) by \( u^{\prime} \) and integrate:

$$ \int_0^T u^{\prime\prime}u^{\prime} dt + \int_0^T\omega^2 u u^{\prime} dt = 0\tp$$

Observing that

$$ u^{\prime\prime}u^{\prime} = \frac{d}{dt}\half(u^{\prime})^2,\quad uu^{\prime} = \frac{d}{dt} {\half}u^2,$$

we get

$$
\int_0^T (\frac{d}{dt}\half(u^{\prime})^2 + \frac{d}{dt} \half\omega^2u^2)dt = E(T) - E(0),
$$

where

$$
E(t) = \half(u^{\prime})^2 + \half\omega^2u^2
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec51">Remark about \( E(t) \) </h2>

<p>
\( E(t) \) does not measure energy, energy per mass unit.

<p>
Starting with an ODE coming directly from Newton's 2nd law \( F=ma \) with
a spring force \( F=-ku \) and \( ma=mu^{\prime\prime} \) (\( a \): acceleration, \( u \): displacement),
we have

$$ mu^{\prime\prime} + ku = 0$$

Integrating this equation gives a physical energy balance:

$$
E(t) = \underbrace{{\half}mv^2}_{\hbox{kinetic energy} }
+ \underbrace{{\half}ku^2}_{\hbox{potential energy}} = E(0),\quad v=u^{\prime}
$$

Note: the balance is not valid if we add other terms to the ODE.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="vib:model2x2:EulerCromer">The Euler-Cromer method; idea</h2>

<p>
2x2 system for \( u^{\prime\prime}+\omega^2u=0 \):

$$
\begin{align*}
v^{\prime} &= -\omega^2u\\ 
u^{\prime} &= v
\end{align*}
$$

<p>
Forward-backward discretization:

<ul>
  <p><li> Update \( v \) with Forward Euler</li>
  <p><li> Update \( u \) with Backward Euler, using latest \( v \)</li>
</ul>

$$
\begin{align}
[D_t^+v &= -\omega^2u]^n\\ 
[D_t^-u &= v]^{n+1}
\end{align}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec53">The Euler-Cromer method; complete formulas </h2>

<p>
Written out:

$$
\begin{align}
u^0 &= I,\\ 
v^0 &= 0,\\ 
v^{n+1} &= v^n -\Delta t \omega^2u^{n}
\label{vib:model2x2:EulerCromer:veq1}\\ 
u^{n+1} &= u^n + \Delta t v^{n+1}
\label{vib:model2x2:EulerCromer:ueq1}
\end{align}
$$

<p>
Names: Forward-backward scheme, <a href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method" target="_self">Semi-implicit Euler method</a>, symplectic
Euler, semi-explicit Euler, Newton-Stormer-Verlet, and <em>Euler-Cromer</em>.

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec54">Euler-Cromer is equivalent to the scheme for \( u^{\prime\prime}+\omega^2u=0 \) </h2>

<ul>
 <p><li> Forward Euler and Backward Euler have error \( \Oof{\Delta t} \)</li>
 <p><li> What about the overall scheme? Expect \( \Oof{\Delta t} \)...</li>
</ul>

We can eliminate \( v^n \) and \( v^{n+1} \), resulting in

$$
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n}
$$

<p>
which is the centered finite differrence scheme for \( u^{\prime\prime}+\omega^2u=0 \)!

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec55">The schemes are not equivalent wrt the initial conditions </h2>

$$ u^{\prime}=v=0\quad\Rightarrow\quad v^0=0,$$

so

$$
\begin{align*}
v^1 &= v^0 - \Delta t\omega^2 u^0 = - \Delta t\omega^2 u^0\\ 
u^1 &= u^0 + \Delta t v^1 = u^0 - \Delta t\omega^2 u^0 !=
\underbrace{u^0 - \frac{1}{2}\Delta t\omega^2 u^0}_{\mbox{from }[D_tD_t u +\omega^2 u=0]^n\mbox{ and }[D_{2t}u=0]^0}
\end{align*}
$$

<p>
The exact discrete solution derived earlier does not fit the Euler-Cromer
scheme because of mismatch for \( u^1 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h1 id="vib:model2">Generalization: damping, nonlinear spring, and external excitation</h1>

$$
mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T]
$$

Input data: \( m \), \( f(u') \), \( s(u) \), \( F(t) \), \( I \), \( V \), and \( T \).

<p>
Typical choices of \( f \) and \( s \):

<ul>
 <p><li> linear damping \( f(u')=bu \), or</li>
 <p><li> quadratic damping \( f(u')=bu'|u'| \)</li>
 <p><li> linear spring \( s(u)=cu \)</li>
 <p><li> nonlinear spring \( s(u)\sim \sin(u) \) (pendulum)</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="vib:ode2:fdm:flin">A centered scheme for linear damping</h2>

$$
[mD_tD_t u + f(D_{2t}u) + s(u) = F]^n
$$

Written out

$$
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
+ f(\frac{u^{n+1}-u^{n-1}}{2\Delta t}) + s(u^n) = F^n
$$

Assume \( f(u') \) is linear in \( u'=v \):

$$
u^{n+1} = \left(2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
\Delta t^2(F^n - s(u^n))
\right)(m + \frac{b}{2}\Delta t)^{-1}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec58">Initial conditions </h2>

<p>
\( u(0)=I \), \( u'(0)=V \):

$$
\begin{align*}
\lbrack u &=I\rbrack^0\quad\Rightarrow\quad u^0=I\\ 
\lbrack D_{2t}u &=V\rbrack^0\quad\Rightarrow\quad u^{-1} = u^{1} - 2\Delta t V
\end{align*}
$$

End result:

$$
u^1 = u^0 + \Delta t\, V
+ \frac{\Delta t^2}{2m}(-bV - s(u^0) + F^0)
$$

Same formula for \( u^1 \) as when using a centered scheme for \( u''+\omega u=0 \).

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="vib:ode2:fdm:fquad">Linearization via a geometric mean approximation</h2>

<ul>
 <p><li> \( f(u')=bu'|u'| \) leads to a quadratic equation for \( u^{n+1} \)</li>
 <p><li> Instead of solving the quadratic equation, we use a geometric mean
   approximation</li>
</ul>

In general, the geometric mean approximation reads
$$ (w^2)^n \approx w^{n-\half}w^{n+\half}\tp$$

For \( |u'|u' \) at \( t_n \):

$$ [u'|u'|]^n \approx u'(t_n+{\half})|u'(t_n-{\half})|\tp$$

For \( u' \) at \( t_{n\pm 1/2} \) we use centered difference:

$$
u'(t_{n+1/2})\approx [D_t u]^{n+\half},\quad u'(t_{n-1/2})\approx [D_t u]^{n-\half}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec60">A centered scheme for quadratic damping </h2>

<p>
After some algebra:

$$
\begin{align*}
u^{n+1} &=  \left( m + b|u^n-u^{n-1}|\right)^{-1}\times \\ 
& \qquad \left(2m u^n - mu^{n-1} + bu^n|u^n-u^{n-1}| + \Delta t^2 (F^n - s(u^n))
\right)
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec61">Initial condition for quadratic damping </h2>

<p>
Simply use that \( u'=V \) in the scheme when \( t=0 \) (\( n=0 \)):

$$
[mD_tD_t u + bV|V| + s(u) = F]^0
$$

<p>
which gives

$$
u^1 = u^0 + \Delta t V + \frac{\Delta t^2}{2m}\left(-bV|V| - s(u^0) + F^0\right)
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec62">Algorithm </h2>

<ol>
 <p><li> \( u^0=I \)</li>
 <p><li> compute \( u^1 \) (formula depends on linear/quadratic damping)</li>
 <p><li> for \( n=1,2,\ldots,N_t-1 \):</li>

<ol>
   <p><li> compute \( u^{n+1} \) from formula (depends on linear/quadratic damping)</li>
</ol>

</ol>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec63">Implementation </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, V, m, b, s, F, dt, T, damping=<span style="color: #CD5555">&#39;linear&#39;</span>):
    dt = <span style="color: #658b00">float</span>(dt); b = <span style="color: #658b00">float</span>(b); m = <span style="color: #658b00">float</span>(m) <span style="color: #228B22"># avoid integer div.</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    u = zeros(Nt+<span style="color: #B452CD">1</span>)
    t = linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)

    u[<span style="color: #B452CD">0</span>] = I
    <span style="color: #8B008B; font-weight: bold">if</span> damping == <span style="color: #CD5555">&#39;linear&#39;</span>:
        u[<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>] + dt*V + dt**<span style="color: #B452CD">2</span>/(<span style="color: #B452CD">2</span>*m)*(-b*V - s(u[<span style="color: #B452CD">0</span>]) + F(t[<span style="color: #B452CD">0</span>]))
    <span style="color: #8B008B; font-weight: bold">elif</span> damping == <span style="color: #CD5555">&#39;quadratic&#39;</span>:
        u[<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>] + dt*V + \ 
               dt**<span style="color: #B452CD">2</span>/(<span style="color: #B452CD">2</span>*m)*(-b*V*<span style="color: #658b00">abs</span>(V) - s(u[<span style="color: #B452CD">0</span>]) + F(t[<span style="color: #B452CD">0</span>]))

    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
        <span style="color: #8B008B; font-weight: bold">if</span> damping == <span style="color: #CD5555">&#39;linear&#39;</span>:
            u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">2</span>*m*u[n] + (b*dt/<span style="color: #B452CD">2</span> - m)*u[n-<span style="color: #B452CD">1</span>] +
                      dt**<span style="color: #B452CD">2</span>*(F(t[n]) - s(u[n])))/(m + b*dt/<span style="color: #B452CD">2</span>)
        <span style="color: #8B008B; font-weight: bold">elif</span> damping == <span style="color: #CD5555">&#39;quadratic&#39;</span>:
            u[n+<span style="color: #B452CD">1</span>] = (<span style="color: #B452CD">2</span>*m*u[n] - m*u[n-<span style="color: #B452CD">1</span>] + b*u[n]*<span style="color: #658b00">abs</span>(u[n] - u[n-<span style="color: #B452CD">1</span>])
                      + dt**<span style="color: #B452CD">2</span>*(F(t[n]) - s(u[n])))/\ 
                      (m + b*<span style="color: #658b00">abs</span>(u[n] - u[n-<span style="color: #B452CD">1</span>]))
    <span style="color: #8B008B; font-weight: bold">return</span> u, t
</pre></div>
</td></tr></table><p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="vib:ode2:verify">Verification</h2>

<ul>
 <p><li> Constant solution \( \uex = I \) (\( V=0 \)) fulfills the ODE problem
   and the discrete equations. Ideal for debugging!</li>
 <p><li> Linear solution \( \uex = Vt+I \) fulfills the ODE problem and
   the discrete equations.</li>
 <p><li> Quadratic solution \( \uex = bt^2 + Vt + I \) fulfills the ODE
   problem and the discrete equations with linear damping, but not
   for quadratic damping.
   A special discrete source term can allow \( \uex \) to also fulfill
   the discrete equations with quadratic damping.</li>
</ul>

<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec65">Demo program </h2>

<p>
<a href="http://tinyurl.com/nm5587k/vib/vib.py" target="_self"><tt>vib.py</tt></a> supports input via the command line:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<table class="highlighttable"><tr><td><div class="linenodiv" style="background-color: #f0f0f0; padding-right: 10px"><pre style="line-height: 125%">1</pre></div></td><td class="code"><div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; python vib.py --s &#39;sin(u)&#39; --F &#39;3*cos(4*t)&#39; --c 0.03
</pre></div>
</td></tr></table><p>
This results in a <a href="http://tinyurl.com/opdfafk/pub/mov-vib/vib_generalized_dt0.05/index.html" target="_self">moving window following the function</a> on the screen.

<p>
<center><p><img src="fig-vib/vib_gen_demo.png" align="bottom" width=600></p></center>

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec66">Euler-Cromer formulation </h2>

<p>
We rewrite

$$
mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T]
$$

as a first-order ODE system

$$
\begin{align*}
u' &= v
\\ 
v' &= m^{-1}\left(F(t) - f(v) - s(u)\right)
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec67">Staggered grid </h2>

<ul>
 <p><li> \( u \) is unknown at \( t_n \): \( u^n \)</li>
 <p><li> \( v \) is unknown at \( t_{n+1/2} \): \( v^{n+\half} \)</li>
 <p><li> All derivatives are approximated by centered differences</li>
</ul>

$$
\begin{align*}
\lbrack D_t u &= v\rbrack^{n-\half}
\\ 
\lbrack D_tv &= m^{-1}\left(F(t) - f(v) - s(u)\right)\rbrack^n
\end{align*}
$$

<p>
Written out,

$$
\begin{align*}
\frac{u^n - u^{n-1}}{\Delta t} &= v^{n-\half}\\ 
\frac{v^{n+\half} - v^{n-\half}}{\Delta t}
&= m^{-1}\left(F^n - f(v^n) - s(u^n)\right)
\end{align*}
$$

<p>
Problem: \( f(v^n) \)

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec68">Linear damping </h2>

<p>
With \( f(v)=bv \), we can use an arithmetic mean for \( bv^n \) a la
Crank-Nicolson schemes.

$$
\begin{align*}
u^n & = u^{n-1} + {\Delta t}v^{n-\half},\\ 
v^{n+\half} &= \left(1 + \frac{b}{2m}\Delta t\right)^{-1}\left(
v^{n-\half} + {\Delta t}
m^{-1}\left(F^n - {\half}f(v^{n-\half}) - s(u^n)\right)\right)\tp
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec69">Quadratic damping </h2>

<p>
With \( f(v)=b|v|v \), we can use a geometric mean

$$
b|v^n|v^n\approx b|v^{n-\half}|v^{n+\half},
$$

resulting in

$$
\begin{align*}
u^n & = u^{n-1} + {\Delta t}v^{n-\half},\\ 
v^{n+\half} &= (1 + \frac{b}{m}|v^{n-\half}|\Delta t)^{-1}\left(
v^{n-\half} + {\Delta t}
m^{-1}\left(F^n - s(u^n)\right)\right)\tp
\end{align*}
$$

<p>
<!-- !split --><br><br><br><br><br><br><br><br>

<h2 id="___sec70">Initial conditions </h2>

$$
\begin{align*}
u^0 &= I\\ 
v^{\half} &= V - \half\Delta t\omega^2I
\end{align*}
$$


<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

