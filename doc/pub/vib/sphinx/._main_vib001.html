

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Finite difference discretization</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite difference methods for vibration problems" href="index.html" />
    <link rel="next" title="Generalization: damping, nonlinear spring, and external excitation" href="._main_vib002.html" />
    <link rel="prev" title="Finite difference methods for vibration problems" href="._main_vib000.html" />
 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_vib002.html" title="Generalization: damping, nonlinear spring, and external excitation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_vib000.html" title="Finite difference methods for vibration problems"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Finite difference methods for vibration problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <p>Vibration problems lead to differential equations with solutions that
oscillate in time, typically in a damped or undamped sinusoidal
fashion.  Such solutions put certain demands on the numerical methods
compared to other phenomena whose solutions are monotone or very smooth.
Both the frequency and amplitude of the oscillations need to be
accurately handled by the numerical schemes. Most of the reasoning and
specific building blocks introduced in the forthcoming text can be
reused to construct sound methods for partial differential equations
of wave nature in multiple spatial dimensions.</p>
<p>[<strong>hpl 1</strong>: Need to discuss errors also for the damped and nonlinear models. At least the frequency errors must be illustrated here as well and investigated numerically, either in text or exercises.]</p>
<div class="section" id="finite-difference-discretization">
<span id="vib-model1"></span><h1>Finite difference discretization<a class="headerlink" href="#finite-difference-discretization" title="Permalink to this headline">¶</a></h1>
<p>Many of the numerical challenges faced when computing oscillatory
solutions to ODEs and PDEs can be captured by the very simple ODE
<span class="math">\(u^{\prime\prime} + u =0\)</span>. This ODE is thus chosen as our starting
point for method development, implementation, and analysis.</p>
<div class="section" id="a-basic-model-for-vibrations">
<h2>A basic model for vibrations<a class="headerlink" href="#a-basic-model-for-vibrations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><p id="index-2">A system that vibrates without damping and external forcing
can be described by the ODE problem</p>
<div class="math" id="equation-vib:ode1">
<span id="eq-vib-ode1"></span><span class="eqno">(1)</span>\[     u^{\prime\prime} + \omega^2u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\ t\in (0,T]
     {\thinspace .}\]</div>
<p>Here, <span class="math">\(\omega\)</span> and <span class="math">\(I\)</span> are given constants.
The exact solution of <a href="#equation-vib:ode1">(1)</a> is</p>
<span class="target" id="index-3"></span><span class="target" id="index-4"></span><div class="math" id="equation-vib:ode1:uex">
<span id="eq-vib-ode1-uex"></span><span id="index-5"></span><span class="eqno">(2)</span>\[     u(t) = I\cos (\omega t)
     {\thinspace .}\]</div>
<p>That is, <span class="math">\(u\)</span> oscillates with constant amplitude <span class="math">\(I\)</span> and
angular frequency <span class="math">\(\omega\)</span>.
The corresponding period of oscillations (i.e., the time between two
neighboring peaks in the cosine function) is <span class="math">\(P=2\pi/\omega\)</span>.
The number of periods per second
is <span class="math">\(f=\omega/(2\pi)\)</span> and measured in the unit Hz.
Both <span class="math">\(f\)</span> and <span class="math">\(\omega\)</span> are referred to as frequency, but <span class="math">\(\omega\)</span>
is more precisely named <em>angular frequency</em>, measured in rad/s.</p>
<p>In vibrating mechanical systems modeled by <a href="#equation-vib:ode1">(1)</a>, <span class="math">\(u(t)\)</span>
very often represents a position or a displacement of a particular
point in the system. The derivative <span class="math">\(u^{\prime}(t)\)</span> then has the
interpretation of velocity, and <span class="math">\(u^{\prime\prime}(t)\)</span> is the associated
acceleration.  The model <a href="#equation-vib:ode1">(1)</a> is not only
applicable to vibrating mechanical systems, but also to oscillations
in electrical circuits.</p>
</div>
<div class="section" id="a-centered-finite-difference-scheme">
<span id="vib-ode1-fdm"></span><h2>A centered finite difference scheme<a class="headerlink" href="#a-centered-finite-difference-scheme" title="Permalink to this headline">¶</a></h2>
<p>To formulate a finite difference method for the model
problem  <a href="#equation-vib:ode1">(1)</a> we follow the <a class="reference external" href="http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#the-forward-euler-scheme">four steps</a> explained in <a class="reference internal" href="._main_vib002.html#ref1" id="id1">[Ref1]</a>.</p>
<span class="target" id="index-6"></span><div class="section" id="step-1-discretizing-the-domain">
<span id="index-7"></span><h3>Step 1: Discretizing the domain<a class="headerlink" href="#step-1-discretizing-the-domain" title="Permalink to this headline">¶</a></h3>
<p>The domain is discretized by
introducing a uniformly partitioned time mesh.
The points in the mesh are <span class="math">\(t_n=n\Delta t\)</span>, <span class="math">\(n=0,1,\ldots,N_t\)</span>,
where <span class="math">\(\Delta t = T/N_t\)</span> is the constant length of the time steps.
We introduce a mesh function <span class="math">\(u^n\)</span> for <span class="math">\(n=0,1,\ldots,N_t\)</span>, which
approximates the exact solution at the mesh points. The mesh
function will be computed from algebraic equations derived from
the differential equation problem.</p>
</div>
<div class="section" id="step-2-fulfilling-the-equation-at-discrete-time-points">
<h3>Step 2: Fulfilling the equation at discrete time points<a class="headerlink" href="#step-2-fulfilling-the-equation-at-discrete-time-points" title="Permalink to this headline">¶</a></h3>
<p>The ODE is to be satisfied at each mesh point:</p>
<div class="math" id="equation-vib:ode1:step2">
<span id="eq-vib-ode1-step2"></span><span class="eqno">(3)</span>\[     u^{\prime\prime}(t_n) + \omega^2u(t_n) = 0,\quad n=1,\ldots,N_t
     {\thinspace .}\]</div>
<span class="target" id="index-8"></span></div>
<div class="section" id="step-3-replacing-derivatives-by-finite-differences">
<span id="index-9"></span><h3>Step 3: Replacing derivatives by finite differences<a class="headerlink" href="#step-3-replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h3>
<p>The derivative <span class="math">\(u^{\prime\prime}(t_n)\)</span> is to be replaced by a finite
difference approximation. A common second-order accurate approximation
to the second-order derivative is</p>
<div class="math" id="equation-vib:ode1:step3">
<span id="eq-vib-ode1-step3"></span><span class="eqno">(4)</span>\[     u^{\prime\prime}(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
     {\thinspace .}\]</div>
<p>Inserting <a href="#equation-vib:ode1:step3">(4)</a> in <a href="#equation-vib:ode1:step2">(3)</a>
yields</p>
<div class="math" id="equation-vib:ode1:step3b">
<span id="eq-vib-ode1-step3b"></span><span class="eqno">(5)</span>\[     \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
     {\thinspace .}\]</div>
<p>We also need to replace the derivative in the initial condition by
a finite difference. Here we choose a centered difference, whose
accuracy is similar to the centered difference we used for <span class="math">\(u^{\prime\prime}\)</span>:</p>
<div class="math" id="equation-vib:ode1:step3c">
<span id="eq-vib-ode1-step3c"></span><span class="eqno">(6)</span>\[     \frac{u^1-u^{-1}}{2\Delta t} = 0\]\[     {\thinspace .}\]</div>
</div>
<div class="section" id="step-4-formulating-a-recursive-algorithm">
<h3>Step 4: Formulating a recursive algorithm<a class="headerlink" href="#step-4-formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h3>
<p>To formulate the computational algorithm, we assume that we
have already computed <span class="math">\(u^{n-1}\)</span> and <span class="math">\(u^n\)</span> such that <span class="math">\(u^{n+1}\)</span> is the
unknown value, which we can readily solve for:</p>
<div class="math" id="equation-vib:ode1:step4">
<span id="eq-vib-ode1-step4"></span><span class="eqno">(7)</span>\[     u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
     {\thinspace .}\]</div>
<p>The computational algorithm is simply to apply <a href="#equation-vib:ode1:step4">(7)</a>
successively for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>. This numerical scheme sometimes
goes under the name
Stormer&#8217;s
method or <a class="reference external" href="http://en.wikipedia.org/wiki/Verlet_integration">Verlet integration</a>.</p>
</div>
<div class="section" id="computing-the-first-step">
<h3>Computing the first step<a class="headerlink" href="#computing-the-first-step" title="Permalink to this headline">¶</a></h3>
<p>We observe that <a href="#equation-vib:ode1:step4">(7)</a> cannot be used for <span class="math">\(n=0\)</span> since
the computation of <span class="math">\(u^1\)</span> then involves the undefined value <span class="math">\(u^{-1}\)</span>
at <span class="math">\(t=-\Delta t\)</span>. The discretization of the initial condition
then comes to our rescue: <a href="#equation-vib:ode1:step3c">(6)</a> implies <span class="math">\(u^{-1} = u^1\)</span>
and this relation can be combined with <a href="#equation-vib:ode1:step4">(7)</a>
for <span class="math">\(n=1\)</span> to yield a value for <span class="math">\(u^1\)</span>:</p>
<div class="math">
\[u^1 = 2u^0 - u^{1} - \Delta t^2 \omega^2 u^0,\]</div>
<p>which reduces to</p>
<div class="math" id="equation-vib:ode1:step4b">
<span id="eq-vib-ode1-step4b"></span><span class="eqno">(8)</span>\[     u^1 = u^0 - \frac{1}{2} \Delta t^2 \omega^2 u^0
     {\thinspace .}\]</div>
<p><a class="reference internal" href="._main_vib002.html#vib-exer-step4b-alt"><span class="std std-ref">Exercise 5: Use a Taylor polynomial to compute </span></a> asks you to perform an alternative derivation
and also to generalize the initial condition to <span class="math">\(u^{\prime}(0)=V\neq 0\)</span>.</p>
</div>
<div class="section" id="the-computational-algorithm">
<h3>The computational algorithm<a class="headerlink" href="#the-computational-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The steps for solving <a href="#equation-vib:ode1">(1)</a> becomes</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u^0=I\)</span></li>
<li>compute <span class="math">\(u^1\)</span> from <a href="#equation-vib:ode1:step4b">(8)</a></li>
<li>for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>:</li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>compute <span class="math">\(u^{n+1}\)</span> from <a href="#equation-vib:ode1:step4">(7)</a></li>
</ol>
</div></blockquote>
</div></blockquote>
<p>The algorithm is more precisely expressed directly in Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  <span class="c"># mesh points in time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>          <span class="c"># constant time step</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>           <span class="c"># solution</span>

<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
<span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition-remark-on-using-w-for-math-omega admonition">
<p class="first admonition-title">Remark on using <code class="docutils literal"><span class="pre">w</span></code> for <span class="math">\(\omega\)</span></p>
<p class="last">In the code, we use <code class="docutils literal"><span class="pre">w</span></code> as the symbol for <span class="math">\(\omega\)</span>.
The reason is that this author prefers <code class="docutils literal"><span class="pre">w</span></code> for readability
and comparison with the mathematical <span class="math">\(\omega\)</span> instead of
the full word <code class="docutils literal"><span class="pre">omega</span></code> as variable name.</p>
</div>
</div>
<div class="section" id="operator-notation">
<h3>Operator notation<a class="headerlink" href="#operator-notation" title="Permalink to this headline">¶</a></h3>
<p>We may write the scheme using a compact difference notation
(see also
<a class="reference external" href="http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#compact-operator-notation-for-finite-differences">examples</a> in <a class="reference internal" href="._main_vib002.html#ref1" id="id2">[Ref1]</a>).
The difference <a href="#equation-vib:ode1:step3">(4)</a> has the operator
notation <span class="math">\([D_tD_t u]^n\)</span> such that we can write:</p>
<div class="math" id="equation-vib:ode1:step4:op">
<span id="eq-vib-ode1-step4-op"></span><span class="eqno">(9)</span>\[     [D_tD_t u  + \omega^2 u = 0]^n
     {\thinspace .}\]</div>
<p>Note that <span class="math">\([D_tD_t u]^n\)</span> means applying a central difference with step <span class="math">\(\Delta t/2\)</span> twice:</p>
<div class="math">
\[[D_t(D_t u)]^n = \frac{[D_t u]^{n+\frac{1}{2}} - [D_t u]^{n-\frac{1}{2}}}{\Delta t}\]</div>
<p>which is written out as</p>
<div class="math">
\[\frac{1}{\Delta t}\left(\frac{u^{n+1}-u^n}{\Delta t} - \frac{u^{n}-u^{n-1}}{\Delta t}\right) = \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
{\thinspace .}\]</div>
<p>The discretization of initial conditions can in the operator notation
be expressed as</p>
<div class="math">
\[[u = I]^0,\quad [D_{2t} u = 0]^0,\]</div>
<p>where the operator <span class="math">\([D_{2t} u]^n\)</span> is defined as</p>
<div class="math">
\[[D_{2t} u]^n = \frac{u^{n+1} - u^{n-1}}{2\Delta t}
{\thinspace .}\]</div>
</div>
</div>
</div>
<div class="section" id="implementation-1">
<span id="vib-impl1"></span><h1>Implementation  (1)<a class="headerlink" href="#implementation-1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="making-a-solver-function">
<span id="vib-impl1-solver"></span><h2>Making a solver function<a class="headerlink" href="#making-a-solver-function" title="Permalink to this headline">¶</a></h2>
<p>The algorithm from the previous section is readily translated to
a complete Python function for computing and returning
<span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> and <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span>, given the
input <span class="math">\(I\)</span>, <span class="math">\(\omega\)</span>, <span class="math">\(\Delta t\)</span>, and <span class="math">\(T\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;&#39; + w**2*u = 0 for t in (0,T], u(0)=I and u&#39;(0)=0,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>We do a simple <code class="docutils literal"><span class="pre">from</span> <span class="pre">module</span> <span class="pre">import</span> <span class="pre">*</span></code> to make the code as close as
possible to MATLAB, although good programming habits would prefix
the <code class="docutils literal"><span class="pre">numpy</span></code> and <code class="docutils literal"><span class="pre">matplotlib</span></code> calls by (abbreviations of) the module
name.</p>
<p>[<strong>hpl 2</strong>: Refer to right section in decay book for prefix discussion.]</p>
<p>A function for plotting the numerical and the exact solution is also
convenient to have:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;r--o&#39;</span><span class="p">)</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1001</span><span class="p">)</span>  <span class="c"># very fine mesh for u_e</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
    <span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">u_e</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">)</span>
    <span class="n">legend</span><span class="p">([</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;upper left&#39;</span><span class="p">)</span>
    <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">title</span><span class="p">(</span><span class="s">&#39;dt=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">axis</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">])</span>
    <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.png&#39;</span><span class="p">);</span>  <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp1.pdf&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A corresponding main program calling these functions for a simulation
of a given number of periods (<code class="docutils literal"><span class="pre">num_periods</span></code>) may take the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">I</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">num_periods</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>    <span class="c">#  one period</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Adjusting some of the input parameters via the command line can be
handy. Here is a code segment using the <code class="docutils literal"><span class="pre">ArgumentParser</span></code> tool in
the <code class="docutils literal"><span class="pre">argparse</span></code> module to define option value (<code class="docutils literal"><span class="pre">--option</span> <span class="pre">value</span></code>)
pairs on the command line:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">argparse</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--w&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--num_periods&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
<span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num_periods</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">num_periods</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Such parsing of the command line is explained in more detailed in</dt>
<dd>the</dd>
</dl>
<p>&#8220;section on user interfaces&#8221;: &#8221;...&#8221; in <a class="reference internal" href="._main_vib002.html#ref1" id="id3">[Ref1]</a>.</p>
<p>[<strong>hpl 3</strong>: Fix reference to web document.]</p>
<p>A typical execution goes like</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python vib_undamped.py --num_periods 20 --dt 0.1
</pre></div>
</div>
<div class="section" id="computing">
<h3>Computing <span class="math">\(u^{\prime}\)</span><a class="headerlink" href="#computing" title="Permalink to this headline">¶</a></h3>
<p>In mechanical vibration applications one is often interested in
computing the velocity <span class="math">\(v(t)=u^{\prime}(t)\)</span> after <span class="math">\(u(t)\)</span> has been computed.
This can be done by a central difference,</p>
<div class="math">
\[v(t_n)=u^{\prime}(t_n) \approx v^n = \frac{u^{n+1}-u^{n-1}}{2\Delta t} = [D_{2t}u]^n
{\thinspace .}\]</div>
<p>This formula applies for all inner mesh points, <span class="math">\(n=1,\ldots,N_t-1\)</span>.
For <span class="math">\(n=0\)</span>, <span class="math">\(v(0)\)</span> is given by the initial condition on <span class="math">\(u^{\prime}(0)\)</span>,
and for <span class="math">\(n=N_t\)</span> we can use a one-sided, backward difference:</p>
<div class="math">
\[v^n=[D_t^-u]^n = \frac{u^{n} - u^{n-1}}{\Delta t}{\thinspace .}\]</div>
<p>Typical (scalar) code is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>  <span class="c"># or v = np.zeros(len(u))</span>
<span class="c"># Use central difference for internal points</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
<span class="c"># Use initial condition for u&#39;(0) when i=0</span>
<span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c"># Use backward difference at the final mesh point</span>
<span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">dt</span>
</pre></div>
</div>
<p>We can get rid of the loop, which is slow for large <span class="math">\(N_t\)</span>, by
vectorizing the central difference. The above code segment
goes as follows in its vectorized version:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># central difference</span>
<span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>                           <span class="c"># boundary condition u&#39;(0)</span>
<span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">dt</span>         <span class="c"># backward difference</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-1">
<span id="vib-ode1-verify"></span><h2>Verification  (1)<a class="headerlink" href="#verification-1" title="Permalink to this headline">¶</a></h2>
<div class="section" id="manual-calculation">
<h3>Manual calculation<a class="headerlink" href="#manual-calculation" title="Permalink to this headline">¶</a></h3>
<p>The simplest type of verification, which is also instructive for understanding
the algorithm, is to compute <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span>
with the aid of a calculator
and make a function for comparing these results with those from the <code class="docutils literal"><span class="pre">solver</span></code>
function. The <code class="docutils literal"><span class="pre">test_three_steps</span></code> function in
the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_undamped.py">vib_undamped.py</a>
shows the details how we use the hand calculations to test the code:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_three_steps</span><span class="p">():</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">;</span>  <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>  <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">u_by_hand</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mf">1.000000000000000</span><span class="p">,</span>
                       <span class="mf">0.802607911978213</span><span class="p">,</span>
                       <span class="mf">0.288358920740053</span><span class="p">])</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u_by_hand</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
</div>
<div class="section" id="testing-very-simple-solutions">
<h3>Testing very simple solutions<a class="headerlink" href="#testing-very-simple-solutions" title="Permalink to this headline">¶</a></h3>
<p>Constructing test problems where the exact solution is constant or
linear helps initial debugging and verification as one expects any
reasonable numerical method to reproduce such solutions to machine
precision.  Second-order accurate methods will often also reproduce a
quadratic solution.  Here <span class="math">\([D_tD_tt^2]^n=2\)</span>, which is the exact
result. A solution <span class="math">\(u=t^2\)</span> leads to <span class="math">\(u^{\prime\prime}+\omega^2 u=2 + (\omega
t)^2\neq 0\)</span>.  We must therefore add a source in the equation: <span class="math">\(u^{\prime\prime} +
\omega^2 u = f\)</span> to allow a solution <span class="math">\(u=t^2\)</span> for <span class="math">\(f=(\omega t)^2\)</span>.  By
simple insertion we can show that the mesh function <span class="math">\(u^n = t_n^2\)</span> is
also a solution of the discrete equations.  <a class="reference internal" href="._main_vib002.html#vib-exer-undamped-verify-linquad"><span class="std std-ref">Problem 1: Use linear/quadratic functions for verification</span></a> asks you to carry out all
details to show that linear and quadratic solutions are solutions
of the discrete equations. Such results are very useful for debugging
and verification. You are strongly encouraged to do this problem now!</p>
</div>
<div class="section" id="checking-convergence-rates">
<h3>Checking convergence rates<a class="headerlink" href="#checking-convergence-rates" title="Permalink to this headline">¶</a></h3>
<p>Empirical computation of convergence rates
yields a good method for verification. The method and its computational
are explained in detail for a simple ODE model in the section on <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book006.html#computing-convergence-rates">computing convergence rates</a>
in <a class="reference internal" href="._main_vib002.html#ref1" id="id4">[Ref1]</a>. Readers not familiar with the concept should
look up this reference before proceeding.</p>
<p>In the present problem, computing convergence rates means that we must</p>
<blockquote>
<div><ul class="simple">
<li>perform <span class="math">\(m\)</span> simulations with halved time steps: <span class="math">\(\Delta t_i=2^{-i}\Delta t_0\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>,</li>
<li>compute the <span class="math">\(L^2\)</span> norm of the error,
<span class="math">\(E_i=\sqrt{\Delta t_i\sum_{n=0}^{N_t-1}(u^n-{u_{\small\mbox{e}}}(t_n))^2}\)</span> in each case,</li>
<li>estimate the convergence rates <span class="math">\(r_i\)</span> based on two consecutive
experiments <span class="math">\((\Delta t_{i-1}, E_{i-1})\)</span> and <span class="math">\((\Delta t_{i}, E_{i})\)</span>,
assuming <span class="math">\(E_i=C(\Delta t_i)^{r}\)</span> and <span class="math">\(E_{i-1}=C(\Delta t_{i-1})^{r}\)</span>.
From these equations it follows that
<span class="math">\(r = \ln (E_{i-1}/E_i)/\ln (\Delta t_{i-1}/\Delta t_i)\)</span>. Since this <span class="math">\(r\)</span>
will vary with <span class="math">\(i\)</span>, we equip it with an index and call it <span class="math">\(r_{i-1}\)</span>,
where <span class="math">\(i\)</span> runs from <span class="math">\(1\)</span> to <span class="math">\(m-1\)</span>.</li>
</ul>
</div></blockquote>
<p>The computed rates <span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span> hopefully converges to a
number, which hopefully is 2, the right one, in the present
problem. The convergence of the rates demands that the time steps
<span class="math">\(\Delta t_i\)</span> are sufficiently small for the error model <span class="math">\(E_i=(\Delta t_i)^r\)</span>
to be valid.</p>
<p>All the implementational details of computing the sequence
<span class="math">\(r_0,r_1,\ldots,r_{m-2}\)</span> appear below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">solver_function</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return m-1 empirical estimates of the convergence rate</span>
<span class="sd">    based on m simulations, where the time step is halved</span>
<span class="sd">    for each simulation.</span>
<span class="sd">    solver_function(I, w, dt, T) solves each problem, where T</span>
<span class="sd">    is based on simulation for num_periods periods.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">0.35</span><span class="p">;</span> <span class="n">I</span> <span class="o">=</span> <span class="mf">0.3</span>       <span class="c"># just chosen values</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>              <span class="c"># period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="mi">30</span>               <span class="c"># 30 time step per period 2*pi/w</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">P</span><span class="o">*</span><span class="n">num_periods</span>

    <span class="n">dt_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">E_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_function</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
        <span class="n">u_e</span> <span class="o">=</span> <span class="n">u_exact</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="nb">sum</span><span class="p">((</span><span class="n">u_e</span><span class="o">-</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">dt_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">E_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="mi">2</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">log</span><span class="p">(</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">E_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span>
         <span class="n">log</span><span class="p">(</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">dt_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
<p>The expected convergence rate is 2, because we have used
a second-order finite
difference approximations <span class="math">\([D_tD_tu]^n\)</span> to the ODE and a
second-order finite difference formula for the initial condition for
<span class="math">\(u^{\prime}\)</span>. Other theoretical error measures also points to
<span class="math">\(r=2\)</span>.</p>
<p>In the present problem, when <span class="math">\(\Delta t_0\)</span> corresponds to 30 time steps
per period, the returned <code class="docutils literal"><span class="pre">r</span></code> list has all its values equal to 2.00
(if rounded to two decimals). This amazing result means that all
<span class="math">\(\Delta t_i\)</span> values are well into the asymptotic regime where the
error model <span class="math">\(E_i = C(\Delta t_i)^r\)</span> is valid.</p>
<p>We can now construct a test function that computes convergence rates
and checks that the final (and usually the best) estimate is sufficiently
close to 2. Here, a rough tolerance of 0.1 is enough. This unit test
goes like</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_convergence_rates</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">convergence_rates</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">num_periods</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    <span class="c"># Accept rate to 1 decimal place</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>The complete code appears in the file <code class="docutils literal"><span class="pre">vib_undamped.py</span></code>.</p>
</div>
</div>
<div class="section" id="scaled-model">
<h2>Scaled model<a class="headerlink" href="#scaled-model" title="Permalink to this headline">¶</a></h2>
<p>[<strong>hpl 4</strong>: Need reference to scaling book and maybe also decay book.]</p>
<p>It is advantageous to use dimensionless variables in simulations, because
fewer parameters need to be set. The present problem is made dimensionless
by introducing dimensionless variables <span class="math">\(\bar t = t/t_c\)</span> and <span class="math">\(\bar u = u/u_c\)</span>,
where <span class="math">\(t_c\)</span> and <span class="math">\(u_c\)</span> are characteristic scales for <span class="math">\(t\)</span> and <span class="math">\(u\)</span>,
respectively. The scaled ODE problem reads</p>
<div class="math">
\[\frac{u_c}{t_c^2}\frac{d^2\bar u}{d\bar t^2} + u_c\bar u = 0,\quad
u_c\bar u(0) = I,\ \frac{u_c}{t_c}\frac{d\bar u}{d\bar t}(0)=0{\thinspace .}\]</div>
<p>A common choice is to take <span class="math">\(t_c\)</span> as one period of
the oscillations, <span class="math">\(t_c = 2\pi/w\)</span>, and <span class="math">\(u_c=I\)</span>.
This gives the dimensionless model</p>
<div class="math" id="equation-vib:ode1:model:scaled">
<span id="eq-vib-ode1-model-scaled"></span><span class="eqno">(10)</span>\[     \frac{d^2\bar u}{\bar t^2} + 4\pi^2 \bar u = 0,\quad \bar u(0)=1,\
     \bar u^{\prime}(0)=0{\thinspace .}\]</div>
<p>Observe that there are no physical parameters in <a href="#equation-vib:ode1:model:scaled">(10)</a>!
We can therefore perform
a single numerical simulation <span class="math">\(\bar u(\bar t)\)</span> and afterwards
recover any <span class="math">\(u(t; \omega, I)\)</span> by</p>
<div class="math">
\[u(t;\omega, I) = u_c\bar u(t/t_c) = I\bar u(omega t/(2\pi)){\thinspace .}\]</div>
<p>We can easily check this assertion: the solution of the scaled problem
is <span class="math">\(\bar u(\bar t) = \cos(2\pi\bar t)\)</span>. The formula for <span class="math">\(u\)</span> in terms
of <span class="math">\(\bar u\)</span> gives <span class="math">\(u = I\cos(\omega t)\)</span>, which is nothing but the solution
of the original problem with dimensions.</p>
<p>The scaled model can by run by calling <code class="docutils literal"><span class="pre">solver(I=1,</span> <span class="pre">w=2*pi,</span> <span class="pre">dt,</span> <span class="pre">T)</span></code>.
Each period is now 1 and <code class="docutils literal"><span class="pre">T</span></code> simply counts the number of periods.
Choosing <code class="docutils literal"><span class="pre">dt</span></code> as <code class="docutils literal"><span class="pre">1./M</span></code> gives <code class="docutils literal"><span class="pre">M</span></code> time steps per period.</p>
</div>
</div>
<div class="section" id="long-time-simulations">
<span id="vib-ode1-longseries"></span><h1>Long time simulations<a class="headerlink" href="#long-time-simulations" title="Permalink to this headline">¶</a></h1>
<p>Figure <a class="reference internal" href="#vib-ode1-2dt"><span class="std std-ref">Effect of halving the time step</span></a> shows a comparison of the exact and numerical
solution for the scaled model <a href="#equation-vib:ode1:model:scaled">(10)</a> with
<span class="math">\(\Delta t=0.1, 0.05\)</span>.
From the plot we make the following observations:</p>
<blockquote>
<div><ul class="simple">
<li>The numerical solution seems to have correct amplitude.</li>
<li>There is a angular frequency error which is reduced by reducing the time step.</li>
<li>The total angular frequency error grows with time.</li>
</ul>
</div></blockquote>
<p>By angular frequency error we mean that the numerical angular frequency differs
from the exact <span class="math">\(\omega\)</span>. This is evident by looking
at the peaks of the numerical solution: these have incorrect
positions compared with the peaks of the exact cosine solution. The
effect can be mathematical expressed by writing the numerical solution
as <span class="math">\(I\cos\tilde\omega t\)</span>, where <span class="math">\(\tilde\omega\)</span> is not exactly
equal to <span class="math">\(\omega\)</span>. Later, we shall mathematically
quantify this numerical angular frequency <span class="math">\(\tilde\omega\)</span>.</p>
<div class="figure" id="id8">
<span id="vib-ode1-2dt"></span><a class="reference internal image-reference" href="_images/vib_freq_err1.png"><img alt="_images/vib_freq_err1.png" src="_images/vib_freq_err1.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Effect of halving the time step</em></span></p>
</div>
<div class="section" id="using-a-moving-plot-window">
<h2>Using a moving plot window<a class="headerlink" href="#using-a-moving-plot-window" title="Permalink to this headline">¶</a></h2>
<p>In vibration problems it is often of interest to investigate the system&#8217;s
behavior over long time intervals. Errors in the angular frequency accumulate
and become more visible as time grows. We can investigate long
time series by introducing a moving plot window that can move along with
the <span class="math">\(p\)</span> most recently computed periods of the solution. The
<a class="reference external" href="https://github.com/hplgit/scitools">SciTools</a> package contains
a convenient tool for this: <code class="docutils literal"><span class="pre">MovingPlotWindow</span></code>. Typing
<code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">scitools.MovingPlotWindow</span></code> shows a demo and a description of its use.
The function below utilizes the moving plot window and is in fact
called by the <code class="docutils literal"><span class="pre">main</span></code> function the <code class="docutils literal"><span class="pre">vib_undamped</span></code> module
if the number of periods in the simulation exceeds 10.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">savefig</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">skip_frames</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Visualize u and the exact solution vs t, using a</span>
<span class="sd">    moving plot window and continuous drawing of the</span>
<span class="sd">    curves as they evolve in time.</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    Plots are saved to files if savefig is True.</span>
<span class="sd">    Only each skip_frames-th plot is saved (e.g., if</span>
<span class="sd">    skip_frame=10, only each 10th plot is saved to file;</span>
<span class="sd">    this is convenient if plot files corresponding to</span>
<span class="sd">    different time steps are to be compared).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">scitools.std</span> <span class="kn">as</span> <span class="nn">st</span>
    <span class="kn">from</span> <span class="nn">scitools.MovingPlotWindow</span> <span class="kn">import</span> <span class="n">MovingPlotWindow</span>

    <span class="c"># Remove all old plot files tmp_*.png</span>
    <span class="kn">import</span> <span class="nn">glob</span><span class="o">,</span> <span class="nn">os</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">&#39;tmp_*.png&#39;</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># one period</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">plot_manager</span> <span class="o">=</span> <span class="n">MovingPlotWindow</span><span class="p">(</span>
        <span class="n">window_width</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="n">P</span><span class="p">,</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
        <span class="n">yaxis</span><span class="o">=</span><span class="p">[</span><span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">],</span>
        <span class="n">mode</span><span class="o">=</span><span class="s">&#39;continuous drawing&#39;</span><span class="p">)</span>
    <span class="n">frame_counter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">plot_manager</span><span class="o">.</span><span class="n">first_index_in_plot</span>
            <span class="n">st</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;r-1&#39;</span><span class="p">,</span>
                    <span class="n">t</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)[</span><span class="n">s</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s">&#39;b-1&#39;</span><span class="p">,</span>
                    <span class="n">title</span><span class="o">=</span><span class="s">&#39;t=</span><span class="si">%6.3f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                    <span class="n">axis</span><span class="o">=</span><span class="n">plot_manager</span><span class="o">.</span><span class="n">axis</span><span class="p">(),</span>
                    <span class="n">show</span><span class="o">=</span><span class="ow">not</span> <span class="n">savefig</span><span class="p">)</span> <span class="c"># drop window if savefig</span>
            <span class="k">if</span> <span class="n">savefig</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">%</span> <span class="n">skip_frames</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;tmp_</span><span class="si">%04d</span><span class="s">.png&#39;</span> <span class="o">%</span> <span class="n">frame_counter</span>
                <span class="n">st</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="k">print</span> <span class="s">&#39;making plot file&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">&#39;at t=</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="n">frame_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">plot_manager</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>We run the scaled problem (the default values for the command-line arguments
<code class="docutils literal"><span class="pre">--I</span></code> and <code class="docutils literal"><span class="pre">--w</span></code> correspond to the scaled problem) for 40 periods with 20
time steps per period:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python vib_undamped.py --dt 0.05 --num_periods 40
</pre></div>
</div>
<p>The moving plot window is invoked, and we can follow the numerical and exact
solutions as time progresses. From this demo we see that
the angular frequency error is small in the beginning, but it becomes more
prominent with time. A new run with <span class="math">\(\Delta t=0.1\)</span> (i.e., only 10 time steps per period)
clearly shows that the phase errors become significant even earlier
in the time series, deteriorating the solution further.</p>
</div>
<div class="section" id="making-animations">
<span id="vib-ode1-anim"></span><h2>Making animations<a class="headerlink" href="#making-animations" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-10"></span><span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><span class="target" id="index-14"></span><span class="target" id="index-15"></span><div class="section" id="producing-standard-video-formats">
<span id="index-16"></span><h3>Producing standard video formats<a class="headerlink" href="#producing-standard-video-formats" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">visualize_front</span></code> function stores all the plots in
files whose names are numbered:
<code class="docutils literal"><span class="pre">tmp_0000.png</span></code>, <code class="docutils literal"><span class="pre">tmp_0001.png</span></code>, <code class="docutils literal"><span class="pre">tmp_0002.png</span></code>,
and so on. From these files we may make a movie. The Flash
format is popular,</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; ffmpeg -r 12 -i tmp_%04d.png -c:v flv movie.flv
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">ffmpeg</span></code> program can be replaced by the <code class="docutils literal"><span class="pre">avconv</span></code> program in
the above command if desired (but at the time of this writing it seems
to be more momentum in the <code class="docutils literal"><span class="pre">ffmpeg</span></code> project).
The <code class="docutils literal"><span class="pre">-r</span></code> option should come first and
describes the number of frames per second in the movie. The
<code class="docutils literal"><span class="pre">-i</span></code> option describes the name of the plot files.
Other formats can be generated by changing the video codec
and equipping the video file with the right extension:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Codec and filename</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Flash</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">flv</span> <span class="pre">movie.flv</span></code></td>
</tr>
<tr class="row-odd"><td>MP4</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libx264</span> <span class="pre">movie.mp4</span></code></td>
</tr>
<tr class="row-even"><td>WebM</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libvpx</span> <span class="pre">movie.webm</span></code></td>
</tr>
<tr class="row-odd"><td>Ogg</td>
<td><code class="docutils literal"><span class="pre">-c:v</span> <span class="pre">libtheora</span> <span class="pre">movie.ogg</span></code></td>
</tr>
</tbody>
</table>
<p id="index-17">The video file can be played by some video player like <code class="docutils literal"><span class="pre">vlc</span></code>, <code class="docutils literal"><span class="pre">mplayer</span></code>,
<code class="docutils literal"><span class="pre">gxine</span></code>, or <code class="docutils literal"><span class="pre">totem</span></code>, e.g.,</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; vlc movie.webm
</pre></div>
</div>
<p>A web page can also be used to play the movie. Today&#8217;s standard is
to use the HTML5 <code class="docutils literal"><span class="pre">video</span></code> tag:</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;video</span> <span class="na">autoplay</span> <span class="na">loop</span> <span class="na">controls</span>
       <span class="na">width=</span><span class="s">&#39;640&#39;</span> <span class="na">height=</span><span class="s">&#39;365&#39;</span> <span class="na">preload=</span><span class="s">&#39;none&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">&#39;movie.webm&#39;</span>  <span class="na">type=</span><span class="s">&#39;video/webm; codecs=&quot;vp8, vorbis&quot;&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/video&gt;</span>
</pre></div>
</div>
<p>Modern browsers do not support all of the video formats.
MP4 is needed to successfully play the videos on Apple devices
that use the Safari browser.
WebM is the preferred format for Chrome, Opera, Firefox, and Internet
Explorer v9+. Flash was a popular format, but older browsers that
required Flash can play MP4. All browsers that work with Ogg can also
work with WebM. This means that to have a video work in all browsers,
the video should be available in the MP4 and WebM formats.
The proper HTML code reads</p>
<div class="highlight-html"><div class="highlight"><pre><span class="nt">&lt;video</span> <span class="na">autoplay</span> <span class="na">loop</span> <span class="na">controls</span>
       <span class="na">width=</span><span class="s">&#39;640&#39;</span> <span class="na">height=</span><span class="s">&#39;365&#39;</span> <span class="na">preload=</span><span class="s">&#39;none&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">&#39;movie.mp4&#39;</span>   <span class="na">type=</span><span class="s">&#39;video/mp4;</span>
<span class="s"> codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">&#39;movie.webm&#39;</span>  <span class="na">type=</span><span class="s">&#39;video/webm;</span>
<span class="s"> codecs=&quot;vp8, vorbis&quot;&#39;</span><span class="nt">&gt;</span>
<span class="nt">&lt;/video&gt;</span>
</pre></div>
</div>
<p>The MP4 format should appear first to ensure that Apple devices will
load the video correctly.</p>
<div class="admonition-caution-number-the-plot-files-correctly admonition">
<p class="first admonition-title">Caution: number the plot files correctly</p>
<p class="last">To ensure that the individual plot frames are shown in correct order,
it is important to number the files with zero-padded numbers
(0000, 0001, 0002, etc.). The printf format <code class="docutils literal"><span class="pre">%04d</span></code> specifies an
integer in a field of width 4, padded with zeros from the left.
A simple Unix wildcard file specification like <code class="docutils literal"><span class="pre">tmp_*.png</span></code>
will then list the frames in the right order. If the numbers in the
filenames were not zero-padded, the frame <code class="docutils literal"><span class="pre">tmp_11.png</span></code> would appear
before <code class="docutils literal"><span class="pre">tmp_2.png</span></code> in the movie.</p>
</div>
</div>
<div class="section" id="paying-png-files-in-a-web-browser">
<h3>Paying PNG files in a web browser<a class="headerlink" href="#paying-png-files-in-a-web-browser" title="Permalink to this headline">¶</a></h3>
<p id="index-18">The <code class="docutils literal"><span class="pre">scitools</span> <span class="pre">movie</span></code> command can create a movie player for a set
of PNG files such that a web browser can be used to watch the movie.
This interface has the advantage that the speed of the movie can
easily be controlled, a feature that scientists often appreciate.
The command for creating an HTML with a player for a set of
PNG files <code class="docutils literal"><span class="pre">tmp_*.png</span></code> goes like</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; scitools movie output_file=vib.html fps=4 tmp_*.png
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">fps</span></code> argument controls the speed of the movie (&#8220;frames per second&#8221;).</p>
<p>To watch the movie, load the video file <code class="docutils literal"><span class="pre">vib.html</span></code> into some browser, e.g.,</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; google-chrome vib.html  # invoke web page
</pre></div>
</div>
<p>Clicking on <code class="docutils literal"><span class="pre">Start</span> <span class="pre">movie</span></code> to see the result. Moving this movie to
some other place requires moving <code class="docutils literal"><span class="pre">vib.html</span></code> <em>and all the PNG files</em>
<code class="docutils literal"><span class="pre">tmp_*.png</span></code>:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; mkdir vib_dt0.1
Terminal&gt; mv tmp_*.png vib_dt0.1
Terminal&gt; mv vib.html vib_dt0.1/index.html
</pre></div>
</div>
</div>
<div class="section" id="making-animated-gif-files">
<h3>Making animated GIF files<a class="headerlink" href="#making-animated-gif-files" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">convert</span></code> program from the ImageMagick software suite can be
used to produce animated GIF files from a set of PNG files:</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; convert -delay 25 tmp_vib*.png tmp_vib.gif
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">-delay</span></code> option needs an argument of the delay between each frame,
measured in 1/100 s, so 4 frames/s here gives 25/100 s delay.
Note, however, that in this particular example
with <span class="math">\(\Delta t=0.05\)</span> and 40 periods,
making an animated GIF file out of
the large number of PNG files is a very heavy process and not
considered feasible.</p>
<p>[<strong>hpl 5</strong>: Combine two simulations side by side!]</p>
</div>
</div>
<div class="section" id="using-a-line-by-line-ascii-plotter">
<h2>Using a line-by-line ascii plotter<a class="headerlink" href="#using-a-line-by-line-ascii-plotter" title="Permalink to this headline">¶</a></h2>
<p>Plotting functions vertically, line by line, in the terminal window
using ascii characters only is a simple, fast, and convenient
visualization technique for long time series. Note that the time
axis then is positive downwards on the screen.
The tool
<code class="docutils literal"><span class="pre">scitools.avplotter.Plotter</span></code> makes it easy to create such plots:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">visualize_front_ascii</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plot u and the exact solution vs t line by line in a</span>
<span class="sd">    terminal window (only using ascii characters).</span>
<span class="sd">    Makes it easy to plot very long time series.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scitools.avplotter</span> <span class="kn">import</span> <span class="n">Plotter</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>
    <span class="n">umin</span> <span class="o">=</span> <span class="mf">1.2</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">min</span><span class="p">();</span>  <span class="n">umax</span> <span class="o">=</span> <span class="o">-</span><span class="n">umin</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">Plotter</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="n">umin</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="n">umax</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="s">&#39;+o&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)):</span>
        <span class="k">print</span> <span class="n">p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">I</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])),</span> \
              <span class="s">&#39;</span><span class="si">%.1f</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">/</span><span class="n">P</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">fps</span><span class="p">))</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
    <span class="nb">raw_input</span><span class="p">()</span>
</pre></div>
</div>
<p>The call <code class="docutils literal"><span class="pre">p.plot</span></code> returns a line of text, with the <span class="math">\(t\)</span> axis marked and
a symbol <code class="docutils literal"><span class="pre">+</span></code> for the first function (<code class="docutils literal"><span class="pre">u</span></code>) and <code class="docutils literal"><span class="pre">o</span></code> for the second
function (the exact solution). Here we append to this text
a time counter reflecting how many periods the current time point
corresponds to. A typical output (<span class="math">\(\omega =2\pi\)</span>, <span class="math">\(\Delta t=0.05\)</span>)
looks like this:</p>
<div class="highlight-text"><div class="highlight"><pre>                         |                       o+      14.0
                         |                      + o      14.0
                         |                  +    o       14.1
                         |             +     o           14.1
                         |     +        o                14.2
                        +|       o                       14.2
                +        |                               14.2
         +       o       |                               14.3
    +     o              |                               14.4
 +   o                   |                               14.4
+o                       |                               14.5
o +                      |                               14.5
 o    +                  |                               14.6
     o      +            |                               14.6
          o        +     |                               14.7
                 o       | +                             14.7
                         |        +                      14.8
                         |       o       +               14.8
                         |              o     +          14.9
                         |                   o   +       14.9
                         |                       o+      15.0
</pre></div>
</div>
</div>
<div class="section" id="empirical-analysis-of-the-solution">
<span id="vib-ode1-empirical"></span><h2>Empirical analysis of the solution<a class="headerlink" href="#empirical-analysis-of-the-solution" title="Permalink to this headline">¶</a></h2>
<p>For oscillating functions like those in Figure <a class="reference internal" href="#vib-ode1-2dt"><span class="std std-ref">Effect of halving the time step</span></a> we may
compute the amplitude and frequency (or period) empirically.
That is, we run through the discrete solution points <span class="math">\((t_n, u_n)\)</span> and
find all maxima and minima points. The distance between two consecutive
maxima (or minima) points can be used as estimate of the local period,
while half the difference between the <span class="math">\(u\)</span> value at a maximum and a nearby
minimum gives an estimate of the local amplitude.</p>
<p>The local maxima are the points where</p>
<div class="math">
\[\begin{split}u^{n-1} &lt; u^n &gt; u^{n+1},\quad n=1,\ldots,N_t-1,\end{split}\]</div>
<p>and the local minima are recognized by</p>
<div class="math">
\[\begin{split}u^{n-1} &gt; u^n &lt; u^{n+1},\quad n=1,\ldots,N_t-1
{\thinspace .}\end{split}\]</div>
<p>In computer code this becomes</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">minmax</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">minima</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">maxima</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">minima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">maxima</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span>
</pre></div>
</div>
<p>Note that the two returned objects are lists of tuples.</p>
<p>Let <span class="math">\((t_i, e_i)\)</span>, <span class="math">\(i=0,\ldots,M-1\)</span>, be the sequence of all
the <span class="math">\(M\)</span> maxima points, where <span class="math">\(t_i\)</span>
is the time value and <span class="math">\(e_i\)</span> the corresponding <span class="math">\(u\)</span> value.
The local period can be defined as <span class="math">\(p_i=t_{i+1}-t_i\)</span>.
With Python syntax this reads</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">periods</span><span class="p">(</span><span class="n">maxima</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">extrema</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
</pre></div>
</div>
<p>The list <code class="docutils literal"><span class="pre">p</span></code> created by a list comprehension is converted to an array
since we probably want to compute with it, e.g., find the corresponding
frequencies <code class="docutils literal"><span class="pre">2*pi/p</span></code>.</p>
<p>Having the minima and the maxima, the local amplitude can be
calculated as the difference between two neighboring minimum and
maximum points:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">amplitudes</span><span class="p">(</span><span class="n">minima</span><span class="p">,</span> <span class="n">maxima</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">abs</span><span class="p">(</span><span class="n">maxima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">minima</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="mf">2.0</span>
         <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minima</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">maxima</span><span class="p">)))]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>The code segments are found in the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_empirical_analysis.py">vib_empirical_analysis.py</a>.</p>
<p>Since <code class="docutils literal"><span class="pre">a[i]</span></code> and <code class="docutils literal"><span class="pre">p[i]</span></code> correspond to
the <span class="math">\(i\)</span>-th amplitude estimate and the <span class="math">\(i\)</span>-th period estimate, respectively,
it is most convenient to visualize the <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">p</span></code> values with the
index <code class="docutils literal"><span class="pre">i</span></code> on the horizontal axis.
(There is no unique time point associated with either of these estimate
since values at two different time points were used in the
computations.)</p>
<p>In the analysis of very long time series, it is advantageous to
compute and plot <code class="docutils literal"><span class="pre">p</span></code> and <code class="docutils literal"><span class="pre">a</span></code> instead of <span class="math">\(u\)</span> to get an impression of
the development of the oscillations. Let us do this for the scaled
problem and <span class="math">\(\Delta t=0.1, 0.05, 0.01\)</span>.
A ready-made function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
<p>computes the empirical amplitudes and periods, and creates a plot
where the amplitudes and angular frequencies
are visualized together with the exact amplitude <code class="docutils literal"><span class="pre">I</span></code>
and the exact angular frequency <code class="docutils literal"><span class="pre">w</span></code>. We can make a little program
for creating the plot:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span><span class="p">,</span> <span class="n">plot_empirical_freq_and_amplitude</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="n">dt_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">]</span>
<span class="n">u_cases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">t_cases</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dt_values</span><span class="p">:</span>
    <span class="c"># Simulate scaled problem for 40 periods</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
    <span class="n">u_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">t_cases</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">plot_empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u_cases</span><span class="p">,</span> <span class="n">t_cases</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#vib-ode1-fig-freq-ampl"><span class="std std-ref">Empirical amplitude and angular frequency for three cases of time steps</span></a> shows the result: we clearly see that
lowering <span class="math">\(\Delta t\)</span> improves the angular frequency significantly, while the
amplitude seems to be more accurate.
The lines with
<span class="math">\(\Delta t=0.01\)</span>, corresponding to 100 steps per period, can hardly be
distinguished from the exact values. The next section shows how we
can get mathematical insight into why amplitudes are good and frequencies
are more inaccurate.</p>
<div class="figure" id="id9">
<span id="vib-ode1-fig-freq-ampl"></span><a class="reference internal image-reference" href="_images/empirical_ampl_freq.png"><img alt="_images/empirical_ampl_freq.png" src="_images/empirical_ampl_freq.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Empirical amplitude and angular frequency for three cases of time steps</em></span></p>
</div>
</div>
</div>
<div class="section" id="analysis-of-the-numerical-scheme">
<span id="vib-ode1-analysis"></span><h1>Analysis of the numerical scheme<a class="headerlink" href="#analysis-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h1>
<div class="section" id="deriving-a-solution-of-the-numerical-scheme">
<h2>Deriving a solution of the numerical scheme<a class="headerlink" href="#deriving-a-solution-of-the-numerical-scheme" title="Permalink to this headline">¶</a></h2>
<p>After having seen the phase error grow with time in the previous
section, we shall now quantify this error through mathematical
analysis.  The key tool in the analysis will be to establish an exact
solution of the discrete equations.  The difference equation
<a href="#equation-vib:ode1:step4">(7)</a> has constant coefficients and is
homogeneous. Such equations are known to have solutions on the form
<span class="math">\(u^n=CA^n\)</span>, where <span class="math">\(A\)</span> is some number
to be determined from the difference equation and <span class="math">\(C\)</span> is found as the
initial condition (<span class="math">\(C=I\)</span>).  Recall that <span class="math">\(n\)</span> in <span class="math">\(u^n\)</span> is a
superscript labeling the time level, while <span class="math">\(n\)</span> in <span class="math">\(A^n\)</span> is an
exponent.</p>
<p>With oscillating functions as solutions, the algebra will
be considerably simplified if we seek an <span class="math">\(A\)</span> on the form</p>
<div class="math">
\[A=e^{i\tilde\omega \Delta t},\]</div>
<p>and solve for the numerical frequency <span class="math">\(\tilde\omega\)</span> rather than
<span class="math">\(A\)</span>. Note that <span class="math">\(i=\sqrt{-1}\)</span> is the imaginary unit. (Using a
complex exponential function gives simpler arithmetics than working
with a sine or cosine function.)
We have</p>
<div class="math">
\[A^n = e^{i\tilde\omega \Delta t\, n}=e^{i\tilde\omega t} =
\cos (\tilde\omega t) + i\sin(\tilde \omega t)
{\thinspace .}\]</div>
<p>The physically relevant numerical solution can
be taken as the real part of this complex expression.</p>
<p>The calculations go as</p>
<div class="math">
\[\begin{split}[D_tD_t u]^n &amp;= \frac{u^{n+1} - 2u^n + u^{n-1}}{\Delta t^2}\\
&amp;= I\frac{A^{n+1} - 2A^n + A^{n-1}}{\Delta t^2}\\
&amp;= \frac{I}{\Delta t^{2}}(e^{i\tilde\omega(t+\Delta t)} - 2e^{i\tilde\omega t} + e^{i\tilde\omega(t-\Delta t)})\\
&amp;= Ie^{i\tilde\omega t}\frac{1}{\Delta t^2}\left(e^{i\tilde\omega\Delta t} + e^{i\tilde\omega(-\Delta t)} - 2\right)\\
&amp;= Ie^{i\tilde\omega t}\frac{2}{\Delta t^2}\left(\cosh(i\tilde\omega\Delta t) -1 \right)\\
&amp;= Ie^{i\tilde\omega t}\frac{2}{\Delta t^2}\left(\cos(\tilde\omega\Delta t) -1 \right)\\
&amp;= -Ie^{i\tilde\omega t}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})\end{split}\]</div>
<p>The last line follows from the relation
<span class="math">\(\cos x - 1 = -2\sin^2(x/2)\)</span> (try <code class="docutils literal"><span class="pre">cos(x)-1</span></code> in
<a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see the formula).</p>
<p>The scheme <a href="#equation-vib:ode1:step4">(7)</a>
with <span class="math">\(u^n=Ie^{i\omega\tilde\Delta t\, n}\)</span> inserted now gives</p>
<div class="math">
\[-Ie^{i\tilde\omega t}\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2})
+ \omega^2 Ie^{i\tilde\omega t} = 0,\]</div>
<p>which after dividing by <span class="math">\(Ie^{i\tilde\omega t}\)</span> results in</p>
<div class="math">
\[\frac{4}{\Delta t^2}\sin^2(\frac{\tilde\omega\Delta t}{2}) = \omega^2
{\thinspace .}\]</div>
<p>The first step in solving for the unknown <span class="math">\(\tilde\omega\)</span> is</p>
<div class="math">
\[\sin^2(\frac{\tilde\omega\Delta t}{2}) = \left(\frac{\omega\Delta t}{2}\right)^2
{\thinspace .}\]</div>
<p>Then, taking the square root, applying the inverse sine function, and
multiplying by <span class="math">\(2/\Delta t\)</span>, results in</p>
<div class="math" id="equation-vib:ode1:tildeomega">
<span id="eq-vib-ode1-tildeomega"></span><span class="eqno">(11)</span>\[     \tilde\omega = \pm \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
     {\thinspace .}\]</div>
<p>The first observation of <a href="#equation-vib:ode1:tildeomega">(11)</a> tells that
there is a phase error since the numerical frequency <span class="math">\(\tilde\omega\)</span>
never equals the exact frequency <span class="math">\(\omega\)</span>. But how good is
the approximation <a href="#equation-vib:ode1:tildeomega">(11)</a>? That is, what
is the error <span class="math">\(\omega - \tilde\omega\)</span> or <span class="math">\(\tilde\omega/\omega\)</span>?
Taylor series expansion
for small <span class="math">\(\Delta t\)</span> may give an expression that is easier to understand
than the complicated function in <a href="#equation-vib:ode1:tildeomega">(11)</a>:</p>
<div class="highlight-ipy"><div class="highlight"><pre><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;dt w&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w_tilde_e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span> <span class="n">w_tilde_series</span>
<span class="n">w</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mi">24</span> <span class="o">+</span> <span class="n">O</span><span class="p">(</span><span class="n">dt</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>This means that</p>
<div class="math" id="equation-vib:ode1:tildeomega:series">
<span id="eq-vib-ode1-tildeomega-series"></span><span class="eqno">(12)</span>\[     \tilde\omega = \omega\left( 1 + \frac{1}{24}\omega^2\Delta t^2\right)
     + {\mathcal{O}(\Delta t^4)}
     {\thinspace .}\]</div>
<p>The error in the numerical frequency is of second-order in
<span class="math">\(\Delta t\)</span>, and the error vanishes as <span class="math">\(\Delta t\rightarrow 0\)</span>.
We see that <span class="math">\(\tilde\omega &gt; \omega\)</span> since the term <span class="math">\(\omega^3\Delta t^2/24 &gt;0\)</span>
and this is by far the biggest term in the series expansion for small
<span class="math">\(\omega\Delta t\)</span>. A numerical frequency that is too large gives an oscillating
curve that oscillates too fast and therefore &#8220;lags behind&#8221; the exact
oscillations, a feature that can be seen in the left plot in Figure
<a class="reference internal" href="#vib-ode1-2dt"><span class="std std-ref">Effect of halving the time step</span></a>.</p>
<p>Figure <a class="reference internal" href="#vib-ode1-tildeomega-plot"><span class="std std-ref">Exact discrete frequency and its second-order series expansion</span></a> plots the discrete frequency
<a href="#equation-vib:ode1:tildeomega">(11)</a>
and its approximation <a href="#equation-vib:ode1:tildeomega:series">(12)</a> for <span class="math">\(\omega =1\)</span> (based
on the program <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_plot_freq.py">vib_plot_freq.py</a>).
Although <span class="math">\(\tilde\omega\)</span> is a function of <span class="math">\(\Delta t\)</span> in
<a href="#equation-vib:ode1:tildeomega:series">(12)</a>,
it is misleading to think of <span class="math">\(\Delta t\)</span> as the important
discretization parameter. It is the product <span class="math">\(\omega\Delta t\)</span> that is
the key discretization parameter. This quantity reflects the
<em>number of time steps per period</em> of the oscillations.
To see this, we set <span class="math">\(P=N_P\Delta t\)</span>, where <span class="math">\(P\)</span> is the length of
a period, and <span class="math">\(N_P\)</span> is the number of time steps during a period.
Since <span class="math">\(P\)</span> and <span class="math">\(\omega\)</span> are related by <span class="math">\(P=2\pi/\omega\)</span>,
we get that <span class="math">\(\omega\Delta t = 2\pi/N_P\)</span>, which shows that
<span class="math">\(\omega\Delta t\)</span> is directly related to <span class="math">\(N_P\)</span>.</p>
<p>The plot shows
that at least <span class="math">\(N_P\sim 25-30\)</span> points per period are necessary for reasonable
accuracy, but this depends on the length of the simulation (<span class="math">\(T\)</span>) as
the total phase error due to the frequency error grows linearly with time
(see <a class="reference internal" href="._main_vib002.html#vib-exer-phase-err-growth"><span class="std std-ref">Exercise 2: Show linear growth of the phase with time</span></a>).</p>
<div class="figure" id="id10">
<span id="vib-ode1-tildeomega-plot"></span><a class="reference internal image-reference" href="_images/discrete_freq.png"><img alt="_images/discrete_freq.png" src="_images/discrete_freq.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Exact discrete frequency and its second-order series expansion</em></span></p>
</div>
</div>
<div class="section" id="exact-discrete-solution">
<span id="vib-ode1-analysis-sol"></span><h2>Exact discrete solution<a class="headerlink" href="#exact-discrete-solution" title="Permalink to this headline">¶</a></h2>
<p>Perhaps more important than the <span class="math">\(\tilde\omega = \omega + {\cal O}(\Delta t^2)\)</span>
result found above is the fact that we have an exact discrete solution of
the problem:</p>
<div class="math" id="equation-vib:ode1:un:exact">
<span id="eq-vib-ode1-un-exact"></span><span class="eqno">(13)</span>\[     u^n = I\cos\left(\tilde\omega n\Delta t\right),\quad
     \tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
     {\thinspace .}\]</div>
<p>We can then compute the error mesh function</p>
<div class="math" id="equation-vib:ode1:en">
<span id="eq-vib-ode1-en"></span><span class="eqno">(14)</span>\[     e^n = {u_{\small\mbox{e}}}(t_n) - u^n =
     I\cos\left(\omega n\Delta t\right) - I\cos\left(\tilde\omega n\Delta t\right){\thinspace .}\]</div>
<p>From the formula <span class="math">\(\cos 2x - \cos 2y = -2\sin(x-y)\sin(x+y)\)</span> we can
rewrite <span class="math">\(e^n\)</span> so the expression is easier to interpret:</p>
<div class="math" id="equation-vib:ode1:en2">
<span id="eq-vib-ode1-en2"></span><span class="eqno">(15)</span>\[     e^n = -2I\sin\left(t\frac{1}{2}\left( \omega - \tilde\omega\right)\right)
     \sin\left(t\frac{1}{2}\left( \omega + \tilde\omega\right)\right){\thinspace .}\]</div>
<p>The error mesh function is ideal for verification purposes
and you are strongly encouraged to make a test based on <a href="#equation-vib:ode1:un:exact">(13)</a>
by doing <a class="reference internal" href="._main_vib002.html#vib-exer-discrete-omega"><span class="std std-ref">Exercise 10: Use an exact discrete solution for verification</span></a>.</p>
</div>
<div class="section" id="convergence">
<span id="vib-ode1-analysis-conv"></span><h2>Convergence<a class="headerlink" href="#convergence" title="Permalink to this headline">¶</a></h2>
<p>We can use <a href="#equation-vib:ode1:tildeomega:series">(12)</a>, <a href="#equation-vib:ode1:en">(14)</a>, or
<a href="#equation-vib:ode1:en2">(15)</a> to show <em>convergence</em> of the
numerical scheme, i.e., <span class="math">\(e^n\rightarrow 0\)</span> as <span class="math">\(\Delta t\rightarrow 0\)</span>.
We have that</p>
<div class="math">
\[\lim_{\Delta t\rightarrow 0}
\tilde\omega = \lim_{\Delta t\rightarrow 0}
\frac{2}{\Delta t}\sin^{-1}\left(\frac{\omega\Delta t}{2}\right)
= \omega,\]</div>
<p>by L&#8217;Hopital&#8217;s rule or simply asking <code class="docutils literal"><span class="pre">sympy</span></code> or
<a class="reference external" href="http://www.wolframalpha.com/input/?i=%282%2Fx%29*asin%28w*x%2F2%29+as+x-%3E0">WolframAlpha</a> about the limit:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sym</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">sym</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x w&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym</span><span class="o">.</span><span class="n">limit</span><span class="p">((</span><span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="o">*</span><span class="n">sym</span><span class="o">.</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="s">&#39;+&#39;</span><span class="p">)</span>
<span class="go">w</span>
</pre></div>
</div>
<p>Also <a href="#equation-vib:ode1:tildeomega:series">(12)</a> can be used to establish
this result that
<span class="math">\(\tilde\omega\rightarrow\omega\)</span>. It then follows from the expression(s)
for <span class="math">\(e^n\)</span> that <span class="math">\(e^n\rightarrow 0\)</span>.</p>
</div>
<div class="section" id="the-global-error">
<h2>The global error<a class="headerlink" href="#the-global-error" title="Permalink to this headline">¶</a></h2>
<p id="index-19">To achieve more analytical insight into the nature of the global error,
we can Taylor expand the error mesh function <a href="#equation-vib:ode1:en">(14)</a>.
Since <span class="math">\(\tilde\omega\)</span> in <a href="#equation-vib:ode1:tildeomega">(11)</a>
contains <span class="math">\(\Delta t\)</span> in the denominator we use the series expansion
for <span class="math">\(\tilde\omega\)</span> inside the cosine function. A relevant <code class="docutils literal"><span class="pre">sympy</span></code>
session is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;dt w t&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_e</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">dt</span><span class="o">*</span><span class="n">asin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span> <span class="o">=</span> <span class="n">w_tilde_e</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span>
<span class="go">w + dt**2*w**3/24 + O(dt**4)</span>
</pre></div>
</div>
<p>Series expansions in <code class="docutils literal"><span class="pre">sympy</span></code> have the inconvenient <code class="docutils literal"><span class="pre">O()</span></code> term that
prevents further calculations with the series. We can use the
following construction to get rid of the <code class="docutils literal"><span class="pre">O()</span></code> term (order the
terms in a list, sum the list, but skip the last term, which is
the undesired <code class="docutils literal"><span class="pre">O()</span></code> term):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">w_tilde_series</span><span class="o">.</span><span class="n">as_ordered_terms</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w_tilde_series</span>
<span class="go">dt**2*w**3/24 + w</span>
</pre></div>
</div>
<p>Using this <code class="docutils literal"><span class="pre">w_tilde_series</span></code> expression
for <span class="math">\(\tilde w\)</span> in <a href="#equation-vib:ode1:en">(14)</a>,
dropping <span class="math">\(I\)</span> (which is a common factor), and performing a series
expansion of the error yields</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">error</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">w_tilde_series</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">dt**2*t*w**3*sin(t*w)/24 + dt**4*t**2*w**6*cos(t*w)/1152 + O(dt**6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">error</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">as_leading_term</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
<span class="go">dt**2*t*w**3*sin(t*w)/24</span>
</pre></div>
</div>
<p>Since we are mainly interested in the leading-order term in
such expansions (the term with lowest power in <span class="math">\(\Delta t\)</span> and
goes most slowly to zero), we use the <code class="docutils literal"><span class="pre">.as_leading_term(dt)</span></code>
construction to pick out this term.</p>
<p>The last result
means that the leading order global (true) error at a point <span class="math">\(t\)</span>
is proportional to <span class="math">\(\omega^3t\Delta t^2\)</span>. Now, <span class="math">\(t\)</span> is related
to <span class="math">\(\Delta t\)</span> through <span class="math">\(t=n\Delta t\)</span>. The factor
<span class="math">\(\sin(\omega t)\)</span> can at most be 1, so we use this value to
bound the leading-order expression to its maximum value</p>
<div class="math">
\[e^n = \frac{1}{24}n\omega^3\Delta t^3{\thinspace .}\]</div>
<p>This is the dominating term of the error <em>at a point</em>.</p>
<p>We are interested in the accumulated global error, which can
be taken as the <span class="math">\(\ell^2\)</span> norm of <span class="math">\(e^n\)</span>.
The norm is simply computed by summing contributions from all mesh
points:</p>
<div class="math">
\[||e^n||_{\ell^2}^2 = \Delta t\sum_{n=0}^{N_t} \frac{1}{24^2}n^2\omega^6\Delta t^6
=\frac{1}{24^2}\omega^6\Delta t^7 \sum_{n=0}^{N_t} n^2{\thinspace .}\]</div>
<p>The sum <span class="math">\(\sum_{n=0}^{N_t} n^2\)</span> is approximately equal to
<span class="math">\(\frac{1}{3}N_t^3\)</span>. Replacing <span class="math">\(N_t\)</span> by <span class="math">\(T/\Delta t\)</span> and taking
the square root gives the expression</p>
<div class="math">
\[||e^n||_{\ell^2} = \frac{1}{24}\sqrt{\frac{T^3}{3}}\omega^3\Delta t^2{\thinspace .}\]</div>
<p>This is our expression for the global (or integrated) error.
The main result from this expression is that also the global error
is proportional to <span class="math">\(\Delta t^2\)</span>.</p>
</div>
<div class="section" id="stability">
<h2>Stability<a class="headerlink" href="#stability" title="Permalink to this headline">¶</a></h2>
<p>Looking at <a href="#equation-vib:ode1:un:exact">(13)</a>, it appears that the numerical
solution has constant and correct amplitude, but an error in the
angular frequency. A constant amplitude is not necessarily the case,
however! To see this, note that if only <span class="math">\(\Delta t\)</span> is large
enough, the magnitude of the argument to <span class="math">\(\sin^{-1}\)</span> in
<a href="#equation-vib:ode1:tildeomega">(11)</a> may be larger than 1, i.e.,
<span class="math">\(\omega\Delta t/2 &gt; 1\)</span>. In this case, <span class="math">\(\sin^{-1}(\omega\Delta t/2)\)</span>
has a complex value and therefore <span class="math">\(\tilde\omega\)</span> becomes complex.
Type, for example, <code class="docutils literal"><span class="pre">asin(x)</span></code> in
<a class="reference external" href="http://www.wolframalpha.com">wolframalpha.com</a> to see basic properties of <span class="math">\(\sin^{-1} (x)\)</span>).</p>
<p>A complex <span class="math">\(\tilde\omega\)</span> can be written <span class="math">\(\tilde\omega = \tilde\omega_r +
i\tilde\omega_i\)</span>. Since <span class="math">\(\sin^{-1}(x)\)</span> has a <em>negative</em> imaginary part for
<span class="math">\(x&gt;1\)</span>, <span class="math">\(\tilde\omega_i &lt; 0\)</span>, which means that
<span class="math">\(e^{i\tilde\omega t}=e^{-\tilde\omega_i t}e^{i\tilde\omega_r t}\)</span>
will lead to exponential growth in time because
<span class="math">\(e^{-\tilde\omega_i t}\)</span> with <span class="math">\(\tilde\omega_i &lt;0\)</span> has a positive
exponent.</p>
<div class="admonition-stability-criterion admonition" id="index-20">
<p class="first admonition-title">Stability criterion</p>
<p>We do not tolerate growth in the amplitude since such growth is not
present in the exact solution. Therefore, we
must impose a <em>stability criterion</em>  that
the argument in the inverse sine function leads
to real and not complex values of <span class="math">\(\tilde\omega\)</span>. The stability
criterion reads</p>
<div class="last math">
\[\frac{\omega\Delta t}{2} \leq 1\quad\Rightarrow\quad
\Delta t \leq \frac{2}{\omega}
{\thinspace .}\]</div>
</div>
<p>With <span class="math">\(\omega =2\pi\)</span>, <span class="math">\(\Delta t &gt; \pi^{-1} = 0.3183098861837907\)</span> will give
growing solutions. Figure <a class="reference internal" href="#vib-ode1-dt-unstable"><span class="std std-ref">Growing, unstable solution because of a time step slightly beyond the stability limit</span></a>
displays what happens when <span class="math">\(\Delta t =0.3184\)</span>,
which is slightly above the critical value: <span class="math">\(\Delta t =\pi^{-1} + 9.01\cdot
10^{-5}\)</span>.</p>
<div class="figure" id="id11">
<span id="vib-ode1-dt-unstable"></span><a class="reference internal image-reference" href="_images/vib_unstable.png"><img alt="_images/vib_unstable.png" src="_images/vib_unstable.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Growing, unstable solution because of a time step slightly beyond the stability limit</em></span></p>
</div>
</div>
<div class="section" id="about-the-accuracy-at-the-stability-limit">
<h2>About the accuracy at the stability limit<a class="headerlink" href="#about-the-accuracy-at-the-stability-limit" title="Permalink to this headline">¶</a></h2>
<p>An interesting question is whether the stability condition
<span class="math">\(\Delta t &lt; 2/\omega\)</span> is unfortunate, or more precisely:
would it be meaningful to take larger time steps to speed up computations?
The answer is a clear no. At the stability limit, we have that
<span class="math">\(\sin^{-1}\omega\Delta t/2 = \sin^{-1} 1 = \pi/2\)</span>, and therefore
<span class="math">\(\tilde\omega = \pi/\Delta t\)</span>. (Note that the approximate formula
<a href="#equation-vib:ode1:tildeomega:series">(12)</a> is very inaccurate for this
value of <span class="math">\(\Delta t\)</span> as it predicts <span class="math">\(\tilde\omega = 2.34/pi\)</span>, which is
a 25 percent reduction.) The corresponding
period of the numerical solution
is <span class="math">\(\tilde P=2\pi/\tilde\omega = 2\Delta t\)</span>, which means that there is
just one time step <span class="math">\(\Delta t\)</span> between a peak (maximum)
and a <a class="reference external" href="https://simple.wikipedia.org/wiki/Wave_(physics)">through</a>
(minimum) in the
numerical solution. This is the shortest possible wave that can be
represented in the mesh! In other words, it is not meaningful to
use a larger time step than the stability limit.</p>
<p>Also, the error in angular frequency
when <span class="math">\(\Delta t = 2/\omega\)</span> is severe: Figure
<a class="reference internal" href="#vib-ode1-dt-stablimit"><span class="std std-ref">Numerical solution with  \( Delta t \)  exactly at the stability limit</span></a> shows a comparison of the numerical and
analytical solution with <span class="math">\(\omega = 2\pi\)</span> and
<span class="math">\(\Delta t = 2/\omega = \pi^{-1}\)</span>. Already after one period, the
numerical solution has a through while the exact solution has a peak (!).
The error in frequency when <span class="math">\(\Delta t\)</span> is at the stability limit
becomes <span class="math">\(\omega - \tilde\omega = \omega(1-\pi/2)\approx -0.57\omega\)</span>.
The corresponding error in the period is <span class="math">\(P - \tilde P \approx 0.36P\)</span>.
The error after <span class="math">\(m\)</span> periods is then <span class="math">\(0.36mP\)</span>. This error has reached
half a period when <span class="math">\(m=1/(2\cdot 0.36)\approx 1.38\)</span>, which theoretically
confirms the observations in Figure <a class="reference internal" href="#vib-ode1-dt-stablimit"><span class="std std-ref">Numerical solution with  \( Delta t \)  exactly at the stability limit</span></a>
that the numerical solution is a through ahead of a peak already after
one and a half period. Consequently, <span class="math">\(\Delta t\)</span> should be chosen much
less than the stability limit to achieve meaningful numerical computations.</p>
<div class="figure" id="id12">
<span id="vib-ode1-dt-stablimit"></span><a class="reference internal image-reference" href="_images/vib_stability_limit.png"><img alt="_images/vib_stability_limit.png" src="_images/vib_stability_limit.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><em>Numerical solution with  \( Delta t \)  exactly at the stability limit</em></span></p>
</div>
<div class="admonition-summary admonition">
<p class="first admonition-title">Summary</p>
<p>From the accuracy and stability
analysis we can draw three important conclusions:</p>
<ol class="last arabic simple">
<li>The key parameter in the formulas is <span class="math">\(p=\omega\Delta t\)</span>.
The period of oscillations is <span class="math">\(P=2\pi/\omega\)</span>, and the
number of time steps per period is <span class="math">\(N_P=P/\Delta t\)</span>.
Therefore, <span class="math">\(p=\omega\Delta t = 2\pi N_P\)</span>, showing that the
critical parameter is the number of time steps per period.
The smallest possible <span class="math">\(N_P\)</span> is 2, showing that <span class="math">\(p\in (0,\pi]\)</span>.</li>
<li>Provided <span class="math">\(p\leq 2\)</span>, the amplitude of the numerical solution is
constant.</li>
<li>The ratio of the numerical angular frequency and the exact
one is
<span class="math">\(\tilde\omega/\omega \approx 1 + \frac{1}{24}p^2\)</span>.
The error <span class="math">\(\frac{1}{24}p^2\)</span> leads to wrongly displaced peaks of the numerical
solution, and the error in peak location grows linearly with time
(see <a class="reference internal" href="._main_vib002.html#vib-exer-phase-err-growth"><span class="std std-ref">Exercise 2: Show linear growth of the phase with time</span></a>).</li>
</ol>
</div>
</div>
</div>
<div class="section" id="alternative-schemes-based-on-1st-order-equations">
<span id="vib-model2x2"></span><h1>Alternative schemes based on 1st-order equations<a class="headerlink" href="#alternative-schemes-based-on-1st-order-equations" title="Permalink to this headline">¶</a></h1>
<p>A standard technique for solving second-order ODEs is
to rewrite them as a system of first-order ODEs and then choose a
solution strategy from the
vast collection of methods for first-order ODE systems.
Given the second-order ODE problem</p>
<div class="math">
\[u^{\prime\prime} + \omega^2 u = 0,\quad u(0)=I,\ u^{\prime}(0)=0,\]</div>
<p>we introduce the auxiliary variable <span class="math">\(v=u^{\prime}\)</span> and express the ODE problem
in terms of first-order derivatives of <span class="math">\(u\)</span> and <span class="math">\(v\)</span>:</p>
<div class="math" id="equation-vib:model2x2:ueq">
<span id="eq-vib-model2x2-ueq"></span><span class="eqno">(16)</span>\[     u^{\prime} = v,\]</div>
<div class="math" id="equation-vib:model2x2:veq">
<span id="eq-vib-model2x2-veq"></span><span class="eqno">(17)</span>\[     v' = -\omega^2 u\]\[     {\thinspace .}\]</div>
<p>The initial conditions become <span class="math">\(u(0)=I\)</span> and <span class="math">\(v(0)=0\)</span>.</p>
<div class="section" id="the-forward-euler-scheme">
<h2>The Forward Euler scheme<a class="headerlink" href="#the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>A Forward Euler approximation to our <span class="math">\(2\times 2\)</span> system of ODEs
<a href="#equation-vib:model2x2:ueq">(16)</a>-<a href="#equation-vib:model2x2:veq">(17)</a>
becomes</p>
<div class="math">
\[\lbrack D_t^+ u = v\rbrack^n,
\lbrack D_t^+ v = -\omega^2 u\rbrack^n,\]</div>
<p>or written out,</p>
<div class="math" id="equation-vib:undamped:FE1">
<span id="eq-vib-undamped-fe1"></span><span class="eqno">(18)</span>\[     u^{n+1} = u^n + \Delta t v^n,\]</div>
<div class="math" id="equation-vib:undamped:FE2">
<span id="eq-vib-undamped-fe2"></span><span class="eqno">(19)</span>\[     v^{n+1} = v^n -\Delta t \omega^2 u^n\]\[     {\thinspace .}\]</div>
<p>Let us briefly compare this Forward Euler method with the
centered difference scheme for the second-order differential
equation. We have from <a href="#equation-vib:undamped:FE1">(18)</a> and
<a href="#equation-vib:undamped:FE2">(19)</a> applied at levels <span class="math">\(n\)</span> and <span class="math">\(n-1\)</span> that</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t v^n = u^n + \Delta t (v^{n-1} -\Delta t \omega^2 u^{n-1}{\thinspace .}\]</div>
<p>Since from <a href="#equation-vib:undamped:FE1">(18)</a></p>
<div class="math">
\[v^{n-1} = \frac{1}{\Delta t}(u^{n}-u^{n-1}),\]</div>
<p>it follows that</p>
<div class="math">
\[u^{n+1} = 2u^n - u^{n-1} -\Delta t^2\omega^2 u^{n-1},\]</div>
<p>which is very close to the centered difference scheme, but
the last term is evaluated at <span class="math">\(t_{n-1}\)</span> instead of <span class="math">\(t_n\)</span>.
Dividing by <span class="math">\(\Delta t^2\)</span>, the left-hand side is an approximation to
<span class="math">\(u^{\prime\prime}\)</span> at <span class="math">\(t_n\)</span>, while the right-hand side is sampled at <span class="math">\(t_{n-1}\)</span>.
All terms should be sampled at the same mesh point, so using
<span class="math">\(\omega^2 u^{n-1}\)</span> instead of <span class="math">\(\omega^2 u^n\)</span> is an inconsistency
in the scheme. This inconsistency turns out to be rather
crucial for the accuracy of
the Forward Euler method applied to vibration problems.</p>
</div>
<div class="section" id="the-backward-euler-scheme">
<h2>The Backward Euler scheme<a class="headerlink" href="#the-backward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>A Backward Euler approximation the ODE system is equally easy to
write up in the operator notation:</p>
<div class="math">
\[\lbrack D_t^- u = v\rbrack^{n+1},\]</div>
<div class="math">
\[\lbrack D_t^- v = -\omega u\rbrack^{n+1} {\thinspace .}\]</div>
<p>This becomes a coupled system for <span class="math">\(u^{n+1}\)</span> and <span class="math">\(v^{n+1}\)</span>:</p>
<div class="math" id="equation-vib:undamped:BE1">
<span id="eq-vib-undamped-be1"></span><span class="eqno">(20)</span>\[     u^{n+1} - \Delta t v^{n+1} = u^{n},\]</div>
<div class="math" id="equation-vib:undamped:BE2">
<span id="eq-vib-undamped-be2"></span><span class="eqno">(21)</span>\[     v^{n+1} + \Delta t \omega^2 u^{n+1} = v^{n}\]\[     {\thinspace .}\]</div>
<p>We can compare <a href="#equation-vib:undamped:BE1">(20)</a>-<a href="#equation-vib:undamped:BE2">(21)</a> with
the centered scheme <a href="#equation-vib:ode1:step4">(7)</a>
for the second-order differential equation.
To this end, we eliminate <span class="math">\(v^{n+1}\)</span> in <a href="#equation-vib:undamped:BE1">(20)</a>
using <a href="#equation-vib:undamped:BE2">(21)</a> solved with respect to <span class="math">\(v^{n+1}\)</span>.
Thereafter, we eliminate <span class="math">\(v^n\)</span> using <a href="#equation-vib:undamped:BE1">(20)</a>
solved with respect to <span class="math">\(v^{n+1}\)</span> and replacing <span class="math">\(n+1\)</span> by <span class="math">\(n\)</span>.
The resulting equation involving only <span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and <span class="math">\(u^{n-1}\)</span>
can be ordered as</p>
<div class="math">
\[\frac{u^{n+1}-2u^n+u^{n-1}}{\Delta t^2} = -\omega^2 u^{n+1},\]</div>
<p>which has almost the same form as the centered scheme for the
second-order differential equation, but the right-hand side is
evaluated at <span class="math">\(u^{n+1}\)</span> and not <span class="math">\(u^n\)</span>. This inconsistent sampling
of terms has a dramatic effect on the numerical solution.</p>
</div>
<div class="section" id="the-crank-nicolson-scheme">
<h2>The Crank-Nicolson scheme<a class="headerlink" href="#the-crank-nicolson-scheme" title="Permalink to this headline">¶</a></h2>
<p>The Crank-Nicolson scheme takes this form in the operator notation:</p>
<div class="math">
\[\lbrack D_t u = \overline{v}^t\rbrack^{n+\frac{1}{2}},\]</div>
<div class="math">
\[\lbrack D_t v = -\omega \overline{u}^t\rbrack^{n+\frac{1}{2}}
{\thinspace .}\]</div>
<p>Writing the equations out shows that this is also a coupled system:</p>
<div class="math">
\[u^{n+1} - \frac{1}{2}\Delta t v^{n+1} = u^{n} + \frac{1}{2}\Delta t v^{n},\]</div>
<div class="math">
\[v^{n+1} + \frac{1}{2}\Delta t \omega^2 u^{n+1} = v^{n}
- \frac{1}{2}\Delta t \omega^2 u^{n}
{\thinspace .}\]</div>
<p>To see the nature of this approximation, and that it is actually
very promising, we write the equations as follows</p>
<div class="math" id="equation-vib:undamped:CN3a">
<span id="eq-vib-undamped-cn3a"></span><span class="eqno">(22)</span>\[     u^{n+1} - u^n = \frac{1}{2}\Delta t(v^{n+1} + v^n),\]</div>
<div class="math" id="equation-vib:undamped:CN4a">
<span id="eq-vib-undamped-cn4a"></span><span class="eqno">(23)</span>\[     v^{n+1}  = v^n -\frac{1}{2}\Delta t(u^{n+1} + u^n),\]</div>
<p>and add the latter at the previous time level as well:</p>
<div class="math" id="equation-vib:undamped:CN4b">
<span id="id5"></span><span class="eqno">(24)</span>\[     v^{n}  = v^{n-1} -\frac{1}{2}\Delta t(u^{n} + u^{n-1})\]</div>
<p>We can also rewrite <a href="#equation-vib:undamped:CN3a">(22)</a> at the previous time level
as</p>
<div class="math" id="equation-vib:undamped:CN4b">
<span id="id7"></span><span class="eqno">(25)</span>\[     v^{n+1} + v^n = \frac{2}{\Delta t}(u^{n+1} - u^n){\thinspace .}\]</div>
<p>Inserting <a href="#equation-vib:undamped:CN4a">(23)</a> for <span class="math">\(v^{n+1}\)</span> in
(ref) and
<a href="#equation-vib:undamped:CN4b">(25)</a> for <span class="math">\(v^{n}\)</span> in
(ref) yields after some reordering:</p>
<div class="math">
\[u^{n+1} - n^n = \frac{1}{2}(-\frac{1}{2}\Delta t\omega^2
(u^{n+1} + 2u^n + u^{n-1}) + v^ + v^{n-1}){\thinspace .}\]</div>
<p>Now, <span class="math">\(v^n + v^{n-1}\)</span> can be eliminated by means of
<a href="#equation-vib:undamped:CN4b">(25)</a>. The result becomes</p>
<div class="math" id="equation-vib:undamped:CN5">
<span id="eq-vib-undamped-cn5"></span><span class="eqno">(26)</span>\[     u^{n+1} - 2u^n + u^{n-1} = \Delta t^2\omega^2
     \frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}){\thinspace .}\]</div>
<p>We have that</p>
<div class="math">
\[\frac{1}{4}(u^{n+1} + 2u^n + u^{n-1}) \approx u^n + {\mathcal{O}(\Delta t^2)},\]</div>
<p>meaning that <a href="#equation-vib:undamped:CN5">(26)</a> is an approximation to
the centered scheme <a href="#equation-vib:ode1:step4">(7)</a> for the second-order ODE where
the sampling error in the term <span class="math">\(\Delta t^2\omega^2 u^n\)</span> is of the same
order as the approximation errors in the finite differences, i.e.,
<span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>. The Crank-Nicolson scheme written as
<a href="#equation-vib:undamped:CN5">(26)</a> therefore has consistent sampling of all
terms at the same time point <span class="math">\(t_n\)</span>. The implication is a much better
method than the Forward and Backward Euler schemes.</p>
</div>
<div class="section" id="comparison-of-schemes">
<span id="vib-model2x2-compare"></span><h2>Comparison of schemes<a class="headerlink" href="#comparison-of-schemes" title="Permalink to this headline">¶</a></h2>
<p>We can easily compare methods like the ones above (and many more!)
with the aid of the
<a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a> package. Below is
a sketch of the code.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">u</span>  <span class="c"># u is array of length 2 holding our [u, v]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">run_solvers_and_plot</span><span class="p">(</span><span class="n">solvers</span><span class="p">,</span> <span class="n">timesteps_per_period</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
                         <span class="n">num_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">w</span>  <span class="c"># duration of one period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">timesteps_per_period</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="n">num_periods</span><span class="o">*</span><span class="n">timesteps_per_period</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span>
    <span class="n">t_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">f_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;w&#39;</span><span class="p">:</span> <span class="n">w</span><span class="p">})</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="n">I</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">t_mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>There is quite some more code dealing with plots also, and we refer
to the source file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_undamped_odespy.py">vib_undamped_odespy.py</a>
for details. Observe that keyword arguments in <code class="docutils literal"><span class="pre">f(u,t,w=1)</span></code> can
be supplied through a solver parameter <code class="docutils literal"><span class="pre">f_kwargs</span></code> (dictionary of
additional keyword arguments to <code class="docutils literal"><span class="pre">f</span></code>).</p>
<p>Specification of the Forward Euler, Backward Euler, and
Crank-Nicolson schemes is done like this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solvers</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">ForwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">),</span>
    <span class="c"># Implicit methods must use Newton solver to converge</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="n">odespy</span><span class="o">.</span><span class="n">CrankNicolson</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">nonlinear_solver</span><span class="o">=</span><span class="s">&#39;Newton&#39;</span><span class="p">),</span>
    <span class="p">]</span>
</pre></div>
</div>
<p id="index-21">The <code class="docutils literal"><span class="pre">vib_undamped_odespy.py</span></code>
program makes two plots of the computed solutions with the various
methods in the <code class="docutils literal"><span class="pre">solvers</span></code> list: one plot with <span class="math">\(u(t)\)</span> versus <span class="math">\(t\)</span>, and
one <em>phase plane plot</em> where <span class="math">\(v\)</span> is plotted against <span class="math">\(u\)</span>.
That is, the phase plane plot is the curve <span class="math">\((u(t),v(t))\)</span> parameterized
by <span class="math">\(t\)</span>. Analytically, <span class="math">\(u=I\cos(\omega t)\)</span> and <span class="math">\(v=u^{\prime}=-\omega I\sin(\omega t)\)</span>.
The exact curve <span class="math">\((u(t),v(t))\)</span> is therefore an ellipse, which often
looks like a circle in a plot if the axes are automatically scaled. The
important feature, however, is that exact curve <span class="math">\((u(t),v(t))\)</span> is
closed and repeats itself for every period. Not all numerical schemes
are capable of doing that, meaning that the amplitude instead shrinks or
grows with time.</p>
<p>Figure
<a class="reference internal" href="#vib-ode1-1st-odespy-theta-phaseplane"><span class="std std-ref">Comparison of classical schemes in the phase plane for two time step values</span></a> show the results. Note that
Odespy applies the label MidpointImplicit for what we have specified
as <code class="docutils literal"><span class="pre">CrankNicolson</span></code> in the code (<code class="docutils literal"><span class="pre">CrankNicolson</span></code> is just a synonym for
class <code class="docutils literal"><span class="pre">MidpointImplicit</span></code> in the Odespy code).
The Forward Euler scheme in Figure
<a class="reference internal" href="#vib-ode1-1st-odespy-theta-phaseplane"><span class="std std-ref">Comparison of classical schemes in the phase plane for two time step values</span></a> has a pronounced spiral
curve, pointing to the fact that the amplitude steadily grows, which
is also evident in Figure <a class="reference internal" href="#vib-ode1-1st-odespy-theta"><span class="std std-ref">Comparison of solution curves for classical schemes</span></a>.
The Backward Euler scheme has a similar feature, except that the
spriral goes inward and the amplitude is significantly damped.  The
changing amplitude and the sprial form decreases with decreasing time
step.  The Crank-Nicolson scheme looks much more
accurate.  In fact, these plots tell that the Forward and Backward
Euler schemes are not suitable for solving our ODEs with oscillating
solutions.</p>
<div class="figure" id="id13">
<span id="vib-ode1-1st-odespy-theta-phaseplane"></span><a class="reference internal image-reference" href="_images/vib_theta_1_pp.png"><img alt="_images/vib_theta_1_pp.png" src="_images/vib_theta_1_pp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of classical schemes in the phase plane for two time step values</em></span></p>
</div>
<div class="figure" id="id14">
<span id="vib-ode1-1st-odespy-theta"></span><a class="reference internal image-reference" href="_images/vib_theta_1_u.png"><img alt="_images/vib_theta_1_u.png" src="_images/vib_theta_1_u.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of solution curves for classical schemes</em></span></p>
</div>
</div>
<div class="section" id="runge-kutta-methods">
<h2>Runge-Kutta methods<a class="headerlink" href="#runge-kutta-methods" title="Permalink to this headline">¶</a></h2>
<p>We may run two popular standard methods for first-order ODEs, the 2nd-
and 4th-order Runge-Kutta methods, to see how they perform. Figures
<a class="reference internal" href="#vib-ode1-1st-odespy-rk-phaseplane"><span class="std std-ref">Comparison of Runge-Kutta schemes in the phase plane</span></a> and
<a class="reference internal" href="#vib-ode1-1st-odespy-rk"><span class="std std-ref">Comparison of Runge-Kutta schemes</span></a> show the solutions with larger <span class="math">\(\Delta
t\)</span> values than what was used in the previous two plots.</p>
<div class="figure" id="id15">
<span id="vib-ode1-1st-odespy-rk-phaseplane"></span><a class="reference internal image-reference" href="_images/vib_RK_1_pp.png"><img alt="_images/vib_RK_1_pp.png" src="_images/vib_RK_1_pp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of Runge-Kutta schemes in the phase plane</em></span></p>
</div>
<div class="figure" id="id16">
<span id="vib-ode1-1st-odespy-rk"></span><a class="reference internal image-reference" href="_images/vib_RK_1_u.png"><img alt="_images/vib_RK_1_u.png" src="_images/vib_RK_1_u.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of Runge-Kutta schemes</em></span></p>
</div>
<p>The visual impression is that the
4th-order Runge-Kutta method is very accurate, under all circumstances
in these tests, while the 2nd-order scheme suffers from amplitude errors
unless the time step is very small.</p>
<p>The corresponding results for the Crank-Nicolson scheme are shown in
Figure <a class="reference internal" href="#vib-ode1-1st-odespy-cn-long-phaseplane"><span class="std std-ref">Long-time behavior of the Crank-Nicolson scheme in the phase plane</span></a>.
It is clear that the Crank-Nicolson
scheme outperforms the 2nd-order Runge-Kutta method. Both schemes have
the same order of accuracy <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>, but their differences
in the accuracy that matters in a real physical application is very
clearly pronounced in this example.  <a class="reference internal" href="._main_vib002.html#vib-exer-undamped-odespy"><span class="std std-ref">Exercise 12: Investigate the amplitude errors of many solvers</span></a> invites you to investigate how the amplitude
is computed by a series of famous methods for first-order ODEs.</p>
<div class="figure" id="id17">
<span id="vib-ode1-1st-odespy-cn-long-phaseplane"></span><a class="reference internal image-reference" href="_images/vib_CN_10_pp.png"><img alt="_images/vib_CN_10_pp.png" src="_images/vib_CN_10_pp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Long-time behavior of the Crank-Nicolson scheme in the phase plane</em></span></p>
</div>
</div>
<div class="section" id="analysis-of-the-forward-euler-scheme">
<h2>Analysis of the Forward Euler scheme<a class="headerlink" href="#analysis-of-the-forward-euler-scheme" title="Permalink to this headline">¶</a></h2>
<p>We may try to find exact solutions of the discrete
equations <a href="#equation-vib:undamped:FE1">(18)</a>-<a href="#equation-vib:undamped:FE2">(19)</a>
in the Forward Euler method. An &#8220;ansatz&#8221;
is</p>
<div class="math">
\[\begin{split}u^n &amp;= IA^n,\\
v^n &amp;= qIA^n,\end{split}\]</div>
<p>where <span class="math">\(q\)</span> and <span class="math">\(A\)</span> are unknown numbers. We could have used a complex
exponential form <span class="math">\(e^{i\tilde\omega n\Delta t}\)</span> since we get
oscillatory form, but the oscillations grow in the Forward Euler
method, so the numerical frequency <span class="math">\(\tilde\omega\)</span> will be complex
anyway (producing an exponentially growing amplitude). Therefore, it is
easier to just work with potentially complex <span class="math">\(A\)</span> and <span class="math">\(q\)</span> as introduced
above.</p>
<p>The Forward Euler scheme leads to</p>
<div class="math">
\[\begin{split}A &amp;= 1 + \Delta t q,\\
A &amp;= 1 - \Delta t\omega^2 q^{-1}{\thinspace .}\end{split}\]</div>
<p>We can easily eliminate <span class="math">\(A\)</span>, get <span class="math">\(q^2 + \omega^2=0\)</span>, and solve for</p>
<div class="math">
\[q = \pm i\omega,\]</div>
<p>which gives</p>
<div class="math">
\[A = 1 \pm \Delta t i\omega{\thinspace .}\]</div>
<p>We shall take the real part of <span class="math">\(A^n\)</span> as the solution. The two
values of <span class="math">\(A\)</span> are complex conjugates, and the real part of
<span class="math">\(A^n\)</span> will be the same for both roots. This is easy to realize if
we rewrite the complex numbers in polar form,
which is also convenient
for further analysis and understanding.
The polar form <span class="math">\(re^{i\theta}\)</span> of a complex number <span class="math">\(x+iy\)</span> has
<span class="math">\(r=\sqrt{x^2+y^2}\)</span> and <span class="math">\(\theta = \tan^{-1}(y/x)\)</span>.
Hence, the polar form of the two values for <span class="math">\(A\)</span> become</p>
<div class="math">
\[1 \pm \Delta t i\omega = \sqrt{1+\omega^2\Delta t^2}e^{\pm i\tan^{-1}(\omega\Delta t)}{\thinspace .}\]</div>
<p>Now it is very easy to compute <span class="math">\(A^n\)</span>:</p>
<div class="math">
\[(1 \pm \Delta t i\omega)^n = (1+\omega^2\Delta t^2)^{n/2}e^{\pm ni\tan^{-1}(\omega\Delta t)}{\thinspace .}\]</div>
<p>Since <span class="math">\(\cos (\theta n) = \cos (-\theta n)\)</span>, the real part of the two
numbers become the same. We therefore continue with the solution that has
the plus sign.</p>
<p>The general solution is <span class="math">\(u^n = CA^n\)</span>, where
<span class="math">\(C\)</span> is a constant determined from the initial condition:
<span class="math">\(u^0=C=I\)</span>. We have <span class="math">\(u^n=IA^n\)</span> and
<span class="math">\(v^n=qIA^n\)</span>. The final solutions
are just the real part of the expressions in polar form:</p>
<div class="math">
\[u^n  =
I(1+\omega^2\Delta t^2)^{n/2}\cos (n\tan^{-1}(\omega\Delta t)),\]</div>
<div class="math">
\[v^n =- \omega
I(1+\omega^2\Delta t^2)^{n/2}\sin (n\tan^{-1}(\omega\Delta t)){\thinspace .}\]</div>
<p>The expression <span class="math">\((1+\omega^2\Delta t^2)^{n/2}\)</span> causes growth of
the amplitude, since a number greater than one is raised to a positive
exponent <span class="math">\(n/2\)</span>. We can develop a series expression to better understand
the formula for the amplitude. Introducing <span class="math">\(p=\omega\Delta t\)</span> as the
key variable and using <code class="docutils literal"><span class="pre">sympy</span></code> gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;p&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">amplitude</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">1 + n*p**2/2 + O(p**4)</span>
</pre></div>
</div>
<p>The amplitude goes like <span class="math">\(1 + \frac{1}{2} n\omega^2\Delta t^2\)</span>, clearly growing
linearly in time (with <span class="math">\(n\)</span>).</p>
<p>We can also investigate the error in the angular frequency by a
series expansion:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span><span class="o">*</span><span class="n">atan</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">series</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">n*(p - p**3/3 + O(p**4))</span>
</pre></div>
</div>
<p>This means that the solution for <span class="math">\(u^n\)</span> can be written as</p>
<div class="math">
\[u^n = (1 + \frac{1}{2} n\omega^2\Delta t^2 + \Oof(\Delta t^4))
\cos\left(\omega t - \frac{1}{3}\omega t\Delta t^2 + {\mathcal{O}(\Delta t^4)}\right)
{\thinspace .}\]</div>
<p>The error in the angular frequency is of the same order as in the
scheme <a href="#equation-vib:ode1:step4">(7)</a> for the second-order ODE, but error
in the amplitude is severe.</p>
</div>
</div>
<div class="section" id="energy-considerations">
<span id="vib-model1-energy"></span><h1>Energy considerations<a class="headerlink" href="#energy-considerations" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-22"></span><p id="index-23">The observations of various methods in the previous section can be
better interpreted if we compute a quantity reflecting
the total <em>energy of the system</em>. It turns out that this quantity,</p>
<div class="math">
\[E(t) = \frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2,\]</div>
<p>is <em>constant</em> for all <span class="math">\(t\)</span>. Checking that <span class="math">\(E(t)\)</span> really remains constant
brings evidence that the numerical computations are sound.
It turns out that <span class="math">\(E\)</span> is proportional to the mechanical energy
in the system. Conservation of energy is
much used to check numerical simulations.</p>
<div class="section" id="derivation-of-the-energy-expression">
<h2>Derivation of the energy expression<a class="headerlink" href="#derivation-of-the-energy-expression" title="Permalink to this headline">¶</a></h2>
<p>We start out with multiplying</p>
<div class="math">
\[u^{\prime\prime} + \omega^2 u = 0,\]</div>
<p>by <span class="math">\(u^{\prime}\)</span> and integrating from <span class="math">\(0\)</span> to <span class="math">\(T\)</span>:</p>
<div class="math">
\[\int_0^T u^{\prime\prime}u^{\prime} dt + \int_0^T\omega^2 u u^{\prime} dt = 0{\thinspace .}\]</div>
<p>Observing that</p>
<div class="math">
\[u^{\prime\prime}u^{\prime} = \frac{d}{dt}\frac{1}{2}(u^{\prime})^2,\quad uu^{\prime} = \frac{d}{dt} {\frac{1}{2}}u^2,\]</div>
<p>we get</p>
<div class="math">
\[\int_0^T (\frac{d}{dt}\frac{1}{2}(u^{\prime})^2 + \frac{d}{dt} \frac{1}{2}\omega^2u^2)dt = E(T) - E(0)=0,\]</div>
<p>where we have introduced</p>
<div class="math" id="equation-vib:model1:energy:balance1">
<span id="eq-vib-model1-energy-balance1"></span><span class="eqno">(27)</span>\[     E(t) = \frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2{\thinspace .}\]</div>
<p>The important result from this derivation is that the total energy
is constant:</p>
<div class="math">
\[E(t) = E(0){\thinspace .}\]</div>
<div class="admonition-math-e-t-is-closely-related-to-the-system-s-energy admonition">
<p class="first admonition-title"><span class="math">\(E(t)\)</span> is closely related to the system&#8217;s energy</p>
<p>The quantity <span class="math">\(E(t)\)</span> derived above is physically not the mechanical energy of a
vibrating mechanical system, but the energy per unit mass. To see this,
we start with Newton&#8217;s second law <span class="math">\(F=ma\)</span> (<span class="math">\(F\)</span> is the sum of forces, <span class="math">\(m\)</span>
is the mass of the system, and <span class="math">\(a\)</span> is the acceleration).
The displacement <span class="math">\(u\)</span> is related to <span class="math">\(a\)</span> through
<span class="math">\(a=u^{\prime\prime}\)</span>. With a spring force as the only force we have <span class="math">\(F=-ku\)</span>, where
<span class="math">\(k\)</span> is a spring constant measuring the stiffness of the spring.
Newton&#8217;s second law then implies the differential equation</p>
<div class="math">
\[-ku = mu^{\prime\prime}\quad\Rightarrow mu^{\prime\prime} + ku = 0{\thinspace .}\]</div>
<p>This equation of motion can be turned into an energy balance equation
by finding the work done by each term during a time interval <span class="math">\([0,T]\)</span>.
To this end, we multiply the equation by <span class="math">\(du=u^{\prime}dt\)</span> and integrate:</p>
<div class="math">
\[\int_0^T muu^{\prime}dt + \int_0^T kuu^{\prime}dt = 0{\thinspace .}\]</div>
<p>The result is</p>
<div class="math">
\[\tilde E(t) = E_k(t) + E_p(t) = 0,\]</div>
<p class="last">where</p>
</div>
<div class="math" id="equation-vib:model1:energy:kinetic">
<span id="eq-vib-model1-energy-kinetic"></span><span class="eqno">(28)</span>\[        E_k(t) = \frac{1}{2}mv^2,\quad v=u^{\prime},\]\[is the *kinetic energy* of the system, and\]\[.. _Eq:vib:model1:energy:potential:\]</div>
<div class="math" id="equation-vib:model1:energy:potential">
<span class="eqno">(29)</span>\[        E_p(t) = {\frac{1}{2}}ku^2\]\[is the *potential energy*. The sum  \( \tilde E(t) \)  is the total mechanical energy.
The derivation demonstrates the famous energy principle that, under
the right physical circumstances, any
change in the kinetic energy is due to a change in potential energy
and vice versa. (This principle breaks down when we introduce damping
in system, as we do in the section :ref:`vib:model2`.)\]\[The equation  \( mu^{\prime\prime}+ku=0 \)  can be divided by  \( m \)  and written as
 \( u^{\prime\prime} + \omega^2u=0 \)  for  \( \omega=\sqrt{k/m} \) . The energy expression
 \( E(t)=\frac{1}{2}(u^{\prime})^2 + \frac{1}{2}\omega^2u^2 \)  derived earlier is then
 \( \tilde E(t)/m \) , i.e., mechanical energy per unit mass.\]</div>
<div class="section" id="energy-of-the-exact-solution">
<h3>Energy of the exact solution<a class="headerlink" href="#energy-of-the-exact-solution" title="Permalink to this headline">¶</a></h3>
<p>Analytically, we have <span class="math">\(u(t)=I\cos\omega t\)</span>, if <span class="math">\(u(0)=I\)</span> and <span class="math">\(u^{\prime}(0)=0\)</span>,
so we can easily check that the energy evolution and confirm that <span class="math">\(E(t)\)</span>
is constant:</p>
<div class="math">
\[E(t) = {\frac{1}{2}}I^2 (-\omega\sin\omega t)^2
+ \frac{1}{2}\omega^2 I^2 \cos^2\omega t
= \frac{1}{2}\omega^2 (\sin^2\omega t + \cos^2\omega t) = \frac{1}{2}\omega^2
{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="an-error-measure-based-on-energy">
<h2>An error measure based on energy<a class="headerlink" href="#an-error-measure-based-on-energy" title="Permalink to this headline">¶</a></h2>
<p>The constant energy is well expressed by its initial value <span class="math">\(E(0)\)</span>, so that
the error in mechanical energy can be computed as a mesh function by</p>
<div class="math">
\[e_E^n = \frac{1}{2}\left(\frac{u^{n+1}-u^{n-1}}{2\Delta t}\right)^2
+ \frac{1}{2}\omega^2 (u^n)^2 - E(0),
\quad n=1,\ldots,N_t-1,\]</div>
<p>where</p>
<div class="math">
\[E(0) = {\frac{1}{2}}V^2 + \frac{1}{2}\omega^2I^2,\]</div>
<p>if <span class="math">\(u(0)=I\)</span> and <span class="math">\(u^{\prime}(0)=V\)</span>. Note that we have used
a centered approximation to <span class="math">\(u^{\prime}\)</span>: <span class="math">\(\boldsymbol{u}^{\prime}(t_n)\approx
[D_{2t}u]^n\)</span>.</p>
<p>A useful norm of the mesh function <span class="math">\(e_E^n\)</span>
for the discrete mechanical energy
can be the maximum absolute value of <span class="math">\(e_E^n\)</span>:</p>
<div class="math">
\[\begin{split}||e_E^n||_{\ell^\infty} = \max_{1\leq n &lt;N_t} |e_E^n|{\thinspace .}\end{split}\]</div>
<p>Alternatively, we can compute other norms involving integration over
all mesh points, but we are often interested in worst case deviation
of the energy, and then the maximum value is of particular relevance.</p>
<p>A vectorized Python implementation takes the form</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># import numpy as np and compute u, t</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">E</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
<span class="n">E0</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">V</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">**</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">I</span><span class="o">**</span><span class="mi">2</span>
<span class="n">e_E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">E0</span>
<span class="n">e_E_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">e_E</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
<p>The convergence rates of the quantity <code class="docutils literal"><span class="pre">e_E_norm</span></code> can be used for verification.
The value of <code class="docutils literal"><span class="pre">e_E_norm</span></code> is also useful for comparing schemes
through their ability to preserve energy. Below is a table demonstrating
the error in total energy for various schemes. We clearly see that
the Crank-Nicolson and 4th-order Runge-Kutta schemes are superior to
the 2nd-order Runge-Kutta method and better compared to the Forward
and Backward Euler schemes.</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="11%" />
<col width="18%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Method</th>
<th class="head"><span class="math">\(T\)</span></th>
<th class="head"><span class="math">\(\Delta t\)</span></th>
<th class="head"><span class="math">\(\max \left\vert e_E^n\right\vert\)</span></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Forward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(1.113\cdot 10^{2}\)</span></td>
</tr>
<tr class="row-odd"><td>Forward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(3.312\cdot 10^{1}\)</span></td>
</tr>
<tr class="row-even"><td>Backward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(1.683\cdot 10^{1}\)</span></td>
</tr>
<tr class="row-odd"><td>Backward Euler</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(1.231\cdot 10^{1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(8.401\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 2nd-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(9.637\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(9.389\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-odd"><td>Crank-Nicolson</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.025\)</span></td>
<td><span class="math">\(2.411\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(2.387\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(1\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(6.476\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(3.389\)</span></td>
</tr>
<tr class="row-odd"><td>Crank-Nicolson</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(9.389\cdot 10^{-1}\)</span></td>
</tr>
<tr class="row-even"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.1\)</span></td>
<td><span class="math">\(3.686\)</span></td>
</tr>
<tr class="row-odd"><td>Runge-Kutta 4th-order</td>
<td><span class="math">\(10\)</span></td>
<td><span class="math">\(0.05\)</span></td>
<td><span class="math">\(6.928\cdot 10^{-1}\)</span></td>
</tr>
</tbody>
</table>
<p>[<strong>hpl 6</strong>: The error reductions are not directly in accordance with the order of the schemes, probably caused by <span class="math">\(\Delta t\)</span> not being in the asympotic regime.]</p>
</div>
</div>
<div class="section" id="the-euler-cromer-method">
<span id="vib-model2x2-eulercromer"></span><h1>The Euler-Cromer method<a class="headerlink" href="#the-euler-cromer-method" title="Permalink to this headline">¶</a></h1>
<p>While the 4th-order Runge-Kutta method and a
Crank-Nicolson scheme work well for vibration equation modeled as a
first-order ODE system,
both were inferior to the straightforward centered
difference scheme for the second-order equation
<span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span>. However, there is a similarly successful scheme
available for the first-order system <span class="math">\(u^{\prime}=v\)</span>, <span class="math">\(v'=-\omega^2u\)</span>, to be
presented next.</p>
<div class="section" id="forward-backward-discretization">
<span id="index-24"></span><h2>Forward-backward discretization<a class="headerlink" href="#forward-backward-discretization" title="Permalink to this headline">¶</a></h2>
<p>The idea is to apply a Forward Euler discretization to the first
equation and a Backward Euler discretization to the second. In operator
notation this is stated as</p>
<div class="math">
\[\lbrack D_t^+u = v\rbrack^n,\]</div>
<div class="math">
\[\lbrack D_t^-v = -\omega u\rbrack^{n+1}
{\thinspace .}\]</div>
<p>We can write out the formulas and collect the unknowns on the left-hand side:</p>
<div class="math" id="equation-vib:model2x2:EulerCromer:ueq1">
<span id="eq-vib-model2x2-eulercromer-ueq1"></span><span class="eqno">(30)</span>\[     u^{n+1} = u^n + \Delta t v^n,\]</div>
<div class="math" id="equation-vib:model2x2:EulerCromer:veq1">
<span id="eq-vib-model2x2-eulercromer-veq1"></span><span class="eqno">(31)</span>\[     v^{n+1} = v^n -\Delta t \omega^2u^{n+1}\]\[     {\thinspace .}\]</div>
<p>We realize that after <span class="math">\(u^{n+1}\)</span> has been computed from
<a href="#equation-vib:model2x2:EulerCromer:ueq1">(30)</a>, it may be used directly
in
<a href="#equation-vib:model2x2:EulerCromer:veq1">(31)</a> to compute <span class="math">\(v^{n+1}\)</span>.</p>
<p>In physics, it is more common to update the <span class="math">\(v\)</span> equation first, with
a forward difference, and thereafter the <span class="math">\(u\)</span> equation, with a backward
difference that applies the most recently computed <span class="math">\(v\)</span> value:</p>
<div class="math" id="equation-vib:model2x2:EulerCromer:veq1b">
<span id="eq-vib-model2x2-eulercromer-veq1b"></span><span class="eqno">(32)</span>\[     v^{n+1} = v^n -\Delta t \omega^2u^{n},\]</div>
<div class="math" id="equation-vib:model2x2:EulerCromer:ueq1b">
<span id="eq-vib-model2x2-eulercromer-ueq1b"></span><span class="eqno">(33)</span>\[     u^{n+1} = u^n + \Delta t v^{n+1}{\thinspace .}\]</div>
<p>The advantage of ordering the ODEs as in
<a href="#equation-vib:model2x2:EulerCromer:veq1b">(32)</a>-<a href="#equation-vib:model2x2:EulerCromer:ueq1b">(33)</a>
becomes evident
when consider complicated models. Such models are included if
we write our vibration ODE more generally as</p>
<div class="math">
\[\ddot u + g(u, u^{\prime}, t)=0{\thinspace .}\]</div>
<p>We can rewrite this second-order ODE as two first-order ODEs,</p>
<div class="math">
\[\begin{split}v' &amp;= -g(u,v,t),\\
u^{\prime} &amp;= v{\thinspace .}\end{split}\]</div>
<p>This rewrite allows the following scheme to be used:</p>
<div class="math">
\[\begin{split}v^{n+1} &amp;= v^n -\Delta t\, g(u^n,v^n,t),\\
u^{n+1} &amp;= u^n + \Delta t\, v^{n+1}{\thinspace .}\end{split}\]</div>
<p>We realize that the first update works well with any <span class="math">\(g\)</span> since old
values <span class="math">\(u^n\)</span> and <span class="math">\(v^n\)</span> are used. Switching the equations would
demand <span class="math">\(u^n{+1}\)</span> and <span class="math">\(v^{n+1}\)</span> values in <span class="math">\(g\)</span>.</p>
<p>The scheme
<a href="#equation-vib:model2x2:EulerCromer:veq1b">(32)</a>-<a href="#equation-vib:model2x2:EulerCromer:ueq1b">(33)</a>
goes under several names: forward-backward scheme, <a class="reference external" href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method">semi-implicit Euler method</a>, semi-explicit Euler,
symplectic Euler,
Newton-Stormer-Verlet,
and Euler-Cromer.
We shall stick to the latter name.
Since both time discretizations are based on first-order difference
approximation, one may think that the scheme is only of first-order,
but this is not true: the use of a forward and then a backward
difference make errors cancel so that the overall error in the scheme
is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>. This is explained below.</p>
</div>
<div class="section" id="equivalence-with-the-scheme-for-the-second-order-ode">
<span id="vib-model2x2-eulercromer-equiv"></span><h2>Equivalence with the scheme for the second-order ODE<a class="headerlink" href="#equivalence-with-the-scheme-for-the-second-order-ode" title="Permalink to this headline">¶</a></h2>
<p>We may eliminate the <span class="math">\(v^n\)</span> variable from
<a href="#equation-vib:model2x2:EulerCromer:ueq1">(30)</a>-<a href="#equation-vib:model2x2:EulerCromer:veq1">(31)</a>
or
<a href="#equation-vib:model2x2:EulerCromer:veq1b">(32)</a>-<a href="#equation-vib:model2x2:EulerCromer:ueq1b">(33)</a>.
The <span class="math">\(v^{n+1}\)</span> term in <a href="#equation-vib:model2x2:EulerCromer:veq1b">(32)</a> can
be eliminated from <a href="#equation-vib:model2x2:EulerCromer:ueq1b">(33)</a>:</p>
<div class="math" id="equation-vib:model2x2:EulerCromer:elim1">
<span id="eq-vib-model2x2-eulercromer-elim1"></span><span class="eqno">(34)</span>\[     u^{n+1} = u^n + \Delta t (v^n - \omega^2\Delta t^2 u^n){\thinspace .}\]</div>
<p>The <span class="math">\(v^{n}\)</span> quantity can be expressed by <span class="math">\(u^n\)</span> and <span class="math">\(u^{n-1}\)</span>
using <a href="#equation-vib:model2x2:EulerCromer:ueq1b">(33)</a>:</p>
<div class="math">
\[v^{n} = \frac{u^n - u^{n-1}}{\Delta t},\]</div>
<p>and when this is inserted in <a href="#equation-vib:model2x2:EulerCromer:elim1">(34)</a> we get</p>
<div class="math">
\[u^{n+1} = 2u^n - u^{n-1} - \Delta t^2 \omega^2u^{n},\]</div>
<p>which is nothing but the centered scheme <a href="#equation-vib:ode1:step4">(7)</a>!
The two seemingly different numerical methods are mathematically
equivalent. Consequently,
the previous analysis of
<a href="#equation-vib:ode1:step4">(7)</a> also applies to the Euler-Cromer
method. In particular, the amplitude is constant, given that the stability
criterion is fulfilled, but there is always an angular frequency error
<a href="#equation-vib:ode1:tildeomega:series">(12)</a>. <a class="reference internal" href="._main_vib002.html#vib-exer-eulercromer-analysis"><span class="std std-ref">Exercise 17: Analysis of the Euler-Cromer scheme</span></a>
gives guidance on how to derive the exact discrete solution of
the two equations in the Euler-Cromer method.</p>
<p>Although the Euler-Cromer scheme and the method <a href="#equation-vib:ode1:step4">(7)</a> are
equivalent, there could be differences in the way they handle
the initial conditions. Let is look into this topic.
The initial condition <span class="math">\(u^{\prime}=0\)</span> means <span class="math">\(u^{\prime}=v=0\)</span>.  From
<a href="#equation-vib:model2x2:EulerCromer:ueq1b">(33)</a> we get <span class="math">\(v^1=-\omega^2 u^0\)</span>
and <span class="math">\(u^1=u^0 - \omega^2\Delta t^2 u^0\)</span>. When using
a centered approximation of <span class="math">\(u^{\prime}(0)=0\)</span> combined with the
discretization <a href="#equation-vib:ode1:step4">(7)</a> of the second-order ODE, we
get <span class="math">\(u^1=u^0 - \frac{1}{2}\omega^2\Delta t^2 u^0\)</span>. The difference
is <span class="math">\(\frac{1}{2}\omega^2\Delta t^2 u^0\)</span>, which is of second order in <span class="math">\(\Delta t\)</span>,
seemingly
consistent with the overall error in the scheme for the differential equation
model.</p>
<p>A different view can also be taken.
If we approximate <span class="math">\(u^{\prime}(0)=0\)</span> by a backward difference,
<span class="math">\((u^0-u^{-1})/\Delta t =0\)</span>, we get <span class="math">\(u^{-1}=u^0\)</span>, and when combined
with <a href="#equation-vib:ode1:step4">(7)</a>, it results in
<span class="math">\(u^1=u^0 - \omega^2\Delta t^2 u^0\)</span>. This means that
the Euler-Cromer method based on
<a href="#equation-vib:model2x2:EulerCromer:ueq1b">(33)</a>-<a href="#equation-vib:model2x2:EulerCromer:veq1b">(32)</a>
corresponds to using only a first-order approximation to the initial condition
in the method from the section <a class="reference internal" href="#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a>.</p>
<p>Correspondingly, using the formulation
<a href="#equation-vib:model2x2:EulerCromer:ueq1">(30)</a>-<a href="#equation-vib:model2x2:EulerCromer:veq1">(31)</a>
with <span class="math">\(v^n=0\)</span> leads to <span class="math">\(u^1=u^0\)</span>, which can be interpreted as using
a forward difference approximation for the initial condition <span class="math">\(u^{\prime}(0)=0\)</span>.
Both Euler-Cromer formulations lead to slightly different values for
<span class="math">\(u^1\)</span> compared to the method in the section <a class="reference internal" href="#vib-ode1-fdm"><span class="std std-ref">A centered finite difference scheme</span></a>.
The error is <span class="math">\(\frac{1}{2}\omega^2\Delta t^2 u^0\)</span> and of the same order
as the overall scheme.</p>
</div>
<div class="section" id="implementation-2">
<span id="vib-model2x2-eulercromer-impl"></span><h2>Implementation  (2)<a class="headerlink" href="#implementation-2" title="Permalink to this headline">¶</a></h2>
<p>The function below, found in <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_EulerCromer.py">vib_EulerCromer.py</a> implements the Euler-Cromer scheme
<a href="#equation-vib:model2x2:EulerCromer:veq1b">(32)</a>-<a href="#equation-vib:model2x2:EulerCromer:ueq1b">(33)</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">linspace</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve v&#39; = - w**2*u, u&#39;=v for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by an Euler-Cromer method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>Since the Euler-Cromer scheme is equivalent to the finite difference
method for the second-order ODE <span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span> (see the section <a class="reference internal" href="#vib-model2x2-eulercromer-equiv"><span class="std std-ref">Equivalence with the scheme for the second-order ODE</span></a>), the performance of the above
<code class="docutils literal"><span class="pre">solver</span></code> function is the same as for the <code class="docutils literal"><span class="pre">solver</span></code> function in the section <a class="reference internal" href="#vib-impl1"><span class="std std-ref">Implementation  (1)</span></a>. The only difference is the formula for the first time
step, as discussed above.  This deviation in the Euler-Cromer scheme
means that the discrete solution listed in the section <a class="reference internal" href="#vib-ode1-analysis-sol"><span class="std std-ref">Exact discrete solution</span></a> is not a solution of the Euler-Cromer
scheme!</p>
<p>To verify the implementation of the Euler-Cromer method we
can adjust <code class="docutils literal"><span class="pre">v[1]</span></code> so that the computer-generated values can be
compared with the formula
<a href="#equation-vib:ode1:un:exact">(13)</a> from in the section <a class="reference internal" href="#vib-ode1-analysis-sol"><span class="std std-ref">Exact discrete solution</span></a>. This
adjustment is done in an alternative solver function, <code class="docutils literal"><span class="pre">solver_ic_fix</span></code>
in <code class="docutils literal"><span class="pre">vib_EulerCromer.py</span></code>. Since we now have an exact solution of the
discrete equations available, we can write a test function
<code class="docutils literal"><span class="pre">test_solver</span></code> for checking the equality of computed values with the
formula <a href="#equation-vib:ode1:un:exact">(13)</a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_solver</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test solver with fixed initial condition against</span>
<span class="sd">    equivalent scheme for the 2nd-order ODE u&#39;&#39; + u = 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mf">1.2</span><span class="p">;</span> <span class="n">w</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span> <span class="n">T</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="n">w</span>  <span class="c"># longest possible time step</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver_ic_fix</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="n">solver</span> <span class="k">as</span> <span class="n">solver2</span>  <span class="c"># 2nd-order ODE</span>
    <span class="n">u2</span><span class="p">,</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">solver2</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">error</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u2</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1E-14</span>
    <span class="k">assert</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">tol</span>
</pre></div>
</div>
<p>Another function, <code class="docutils literal"><span class="pre">demo</span></code>,
visualizes the difference between Euler-Cromer scheme and the scheme
<a href="#equation-vib:ode1:step4">(7)</a>
for the second-oder ODE, arising from the mismatch in the first time level.</p>
<p>[<strong>hpl 7</strong>: Odespy&#8217;s Euler-Cromer, but it needs more work with the example code.]</p>
</div>
<div class="section" id="the-velocity-verlet-algorithm">
<h2>The velocity Verlet algorithm<a class="headerlink" href="#the-velocity-verlet-algorithm" title="Permalink to this headline">¶</a></h2>
<p>Another very popular algorithm for vibration problems <span class="math">\(u^{\prime\prime}+\omega^2u=0\)</span>
can be derived as follows. First, we step <span class="math">\(u\)</span> forward from <span class="math">\(t_n\)</span> to
<span class="math">\(t_{n+1}\)</span> using a three-term Taylor series,</p>
<div class="math">
\[u(t_{n+1}) = u(t_n) + u^{\prime}(t_n)\Delta t + \frac{1}{2}u^{\prime\prime}(t_n)\Delta t^2{\thinspace .}\]</div>
<p>Using <span class="math">\(u^{\prime}=v\)</span> and <span class="math">\(u^{\prime\prime}=-\omega^2u\)</span>, we get the updating formula</p>
<div class="math">
\[u^{n+1} = u^n + v^n\Delta t - \frac{1}{2}\Delta^2\omega^2u^n{\thinspace .}\]</div>
<p>Second, the first-order equation for <span class="math">\(v\)</span>,</p>
<div class="math">
\[v'=-\omega^2u,\]</div>
<p>is discretized by a centered difference
in a Crank-Nicolson fashion at <span class="math">\(t_{n+\frac{1}{2}}\)</span>:</p>
<div class="math">
\[\frac{v^{n+1}-v^n}{\Delta t} = -\omega^2\frac{1}{2}(u^n + u^{n+1}){\thinspace .}\]</div>
<p>To summarize, we have the scheme</p>
<div class="math" id="equation-vib:model2x2:Verlet:dueq">
<span id="eq-vib-model2x2-verlet-dueq"></span><span class="eqno">(35)</span>\[     u^{n+1} = u^n + v^n\Delta t - \frac{1}{2}\Delta^2\omega^2u^n\]</div>
<div class="math" id="equation-vib:model2x2:Verlet:dveq">
<span id="eq-vib-model2x2-verlet-dveq"></span><span class="eqno">(36)</span>\[     v^{n+1} = v^n -\frac{1}{2}\Delta t\omega^2 (u^n + u^{n+1}),\]</div>
<p>known as the <em>velocity Verlet</em> algorithm.
Observe that this scheme is explicit since <span class="math">\(u^{n+1}\)</span> in
<a href="#equation-vib:model2x2:Verlet:dveq">(36)</a> is already computed
from <a href="#equation-vib:model2x2:Verlet:dueq">(35)</a>.</p>
<p>The algorithm can be straightforwardly implemented as shown below (the
code appears in the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib_undamped_velocity_Verlet.py">vib_undamped_velocity_Verlet.py</a>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">vib_undamped</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">zeros</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span>
    <span class="n">convergence_rates</span><span class="p">,</span>
    <span class="n">main</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">return_v</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve u&#39;=v, v&#39;=-w**2*u for t in (0,T], u(0)=I and v(0)=0,</span>
<span class="sd">    by the velocity Verlet method with time step dt.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nt</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="n">dt</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">return_v</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Return just u and t as in the vib_undamped.py&#39;s solver</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>We provide the option that this <code class="docutils literal"><span class="pre">solver</span></code> function returns the same data
as the <code class="docutils literal"><span class="pre">solver</span></code> function from the section <a class="reference internal" href="#vib-impl1-solver"><span class="std std-ref">Making a solver function</span></a> (if <code class="docutils literal"><span class="pre">return_v</span></code>
is <code class="docutils literal"><span class="pre">False</span></code>), but we may return <code class="docutils literal"><span class="pre">v</span></code> along with <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">t</span></code>.</p>
<p>The error in the Taylor series expansion behind
<a href="#equation-vib:model2x2:Verlet:dueq">(35)</a> is <span class="math">\({\mathcal{O}(\Delta t^3)}\)</span>, while the error
in the central difference for <span class="math">\(v\)</span> is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>.  The overall
error is then no better than <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>, which can be verified
empirically using the <code class="docutils literal"><span class="pre">convergence_rates</span></code> function from
<a class="reference internal" href="#vib-ode1-verify"><span class="std std-ref">Verification  (1)</span></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">vib_undamped_velocity_Verlet</span> <span class="kn">as</span> <span class="nn">m</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">convergence_rates</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">solver_function</span><span class="o">=</span><span class="n">m</span><span class="o">.</span><span class="n">solver</span><span class="p">)</span>
<span class="go">[2.0036366687367346, 2.0009497328124835, 2.000240105995295]</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Finite difference discretization</a><ul>
<li><a class="reference internal" href="#a-basic-model-for-vibrations">A basic model for vibrations</a></li>
<li><a class="reference internal" href="#a-centered-finite-difference-scheme">A centered finite difference scheme</a><ul>
<li><a class="reference internal" href="#step-1-discretizing-the-domain">Step 1: Discretizing the domain</a></li>
<li><a class="reference internal" href="#step-2-fulfilling-the-equation-at-discrete-time-points">Step 2: Fulfilling the equation at discrete time points</a></li>
<li><a class="reference internal" href="#step-3-replacing-derivatives-by-finite-differences">Step 3: Replacing derivatives by finite differences</a></li>
<li><a class="reference internal" href="#step-4-formulating-a-recursive-algorithm">Step 4: Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#computing-the-first-step">Computing the first step</a></li>
<li><a class="reference internal" href="#the-computational-algorithm">The computational algorithm</a></li>
<li><a class="reference internal" href="#operator-notation">Operator notation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-1">Implementation  (1)</a><ul>
<li><a class="reference internal" href="#making-a-solver-function">Making a solver function</a><ul>
<li><a class="reference internal" href="#computing">Computing <span class="math">\(u^{\prime}\)</span></a></li>
</ul>
</li>
<li><a class="reference internal" href="#verification-1">Verification  (1)</a><ul>
<li><a class="reference internal" href="#manual-calculation">Manual calculation</a></li>
<li><a class="reference internal" href="#testing-very-simple-solutions">Testing very simple solutions</a></li>
<li><a class="reference internal" href="#checking-convergence-rates">Checking convergence rates</a></li>
</ul>
</li>
<li><a class="reference internal" href="#scaled-model">Scaled model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#long-time-simulations">Long time simulations</a><ul>
<li><a class="reference internal" href="#using-a-moving-plot-window">Using a moving plot window</a></li>
<li><a class="reference internal" href="#making-animations">Making animations</a><ul>
<li><a class="reference internal" href="#producing-standard-video-formats">Producing standard video formats</a></li>
<li><a class="reference internal" href="#paying-png-files-in-a-web-browser">Paying PNG files in a web browser</a></li>
<li><a class="reference internal" href="#making-animated-gif-files">Making animated GIF files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-a-line-by-line-ascii-plotter">Using a line-by-line ascii plotter</a></li>
<li><a class="reference internal" href="#empirical-analysis-of-the-solution">Empirical analysis of the solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#analysis-of-the-numerical-scheme">Analysis of the numerical scheme</a><ul>
<li><a class="reference internal" href="#deriving-a-solution-of-the-numerical-scheme">Deriving a solution of the numerical scheme</a></li>
<li><a class="reference internal" href="#exact-discrete-solution">Exact discrete solution</a></li>
<li><a class="reference internal" href="#convergence">Convergence</a></li>
<li><a class="reference internal" href="#the-global-error">The global error</a></li>
<li><a class="reference internal" href="#stability">Stability</a></li>
<li><a class="reference internal" href="#about-the-accuracy-at-the-stability-limit">About the accuracy at the stability limit</a></li>
</ul>
</li>
<li><a class="reference internal" href="#alternative-schemes-based-on-1st-order-equations">Alternative schemes based on 1st-order equations</a><ul>
<li><a class="reference internal" href="#the-forward-euler-scheme">The Forward Euler scheme</a></li>
<li><a class="reference internal" href="#the-backward-euler-scheme">The Backward Euler scheme</a></li>
<li><a class="reference internal" href="#the-crank-nicolson-scheme">The Crank-Nicolson scheme</a></li>
<li><a class="reference internal" href="#comparison-of-schemes">Comparison of schemes</a></li>
<li><a class="reference internal" href="#runge-kutta-methods">Runge-Kutta methods</a></li>
<li><a class="reference internal" href="#analysis-of-the-forward-euler-scheme">Analysis of the Forward Euler scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#energy-considerations">Energy considerations</a><ul>
<li><a class="reference internal" href="#derivation-of-the-energy-expression">Derivation of the energy expression</a><ul>
<li><a class="reference internal" href="#energy-of-the-exact-solution">Energy of the exact solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#an-error-measure-based-on-energy">An error measure based on energy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-euler-cromer-method">The Euler-Cromer method</a><ul>
<li><a class="reference internal" href="#forward-backward-discretization">Forward-backward discretization</a></li>
<li><a class="reference internal" href="#equivalence-with-the-scheme-for-the-second-order-ode">Equivalence with the scheme for the second-order ODE</a></li>
<li><a class="reference internal" href="#implementation-2">Implementation  (2)</a></li>
<li><a class="reference internal" href="#the-velocity-verlet-algorithm">The velocity Verlet algorithm</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_vib000.html"
                        title="previous chapter">Finite difference methods for vibration problems</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_vib002.html"
                        title="next chapter">Generalization: damping, nonlinear spring, and external excitation</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._main_vib001.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_vib002.html" title="Generalization: damping, nonlinear spring, and external excitation"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_vib000.html" title="Finite difference methods for vibration problems"
             >previous</a> |</li>
        <li><a href="index.html">Finite difference methods for vibration problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>