

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Generalization: damping, nonlinear spring, and external excitation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite difference methods for vibration problems" href="index.html" />
    <link rel="prev" title="Finite difference discretization" href="._main_vib001.html" />
 
  
   <style type="text/css">
     div.admonition {
       background-color: whiteSmoke;
       border: 1px solid #bababa;
     }
   </style>
  </head>

  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_vib001.html" title="Finite difference discretization"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Finite difference methods for vibration problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="generalization-damping-nonlinear-spring-and-external-excitation">
<span id="vib-model2"></span><h1>Generalization: damping, nonlinear spring, and external excitation<a class="headerlink" href="#generalization-damping-nonlinear-spring-and-external-excitation" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><p id="index-2">We shall now generalize the simple model problem from
the section <a class="reference internal" href="._main_vib001.html#vib-model1"><em>Finite difference discretization</em></a> to include a possibly nonlinear damping term <span class="math">\(f(u')\)</span>,
a possibly nonlinear spring (or restoring) force <span class="math">\(s(u)\)</span>, and
some external excitation <span class="math">\(F(t)\)</span>:</p>
<div class="math" id="equation-vib:ode2">
<span id="eq-vib-ode2"></span><span class="eqno">(1)</span>\[     mu'' + f(u') + s(u) = F(t),\quad u(0)=I,\ u'(0)=V,\ t\in (0,T]
     {\thinspace .}\]</div>
<p>We have also included a possibly nonzero initial value of <span class="math">\(u'(0)\)</span>.
The parameters <span class="math">\(m\)</span>, <span class="math">\(f(u')\)</span>, <span class="math">\(s(u)\)</span>, <span class="math">\(F(t)\)</span>, <span class="math">\(I\)</span>, <span class="math">\(V\)</span>, and <span class="math">\(T\)</span> are
input data.</p>
<p>There are two main types of damping (friction) forces: linear <span class="math">\(f(u')=bu\)</span>, or
quadratic <span class="math">\(f(u')=bu'|u'|\)</span>. Spring systems often feature linear
damping, while air resistance usually gives rise to quadratic damping.
Spring forces are often linear: <span class="math">\(s(u)=cu\)</span>, but nonlinear versions
are also common, the most famous is the gravity force on a pendulum
that acts as a spring with <span class="math">\(s(u)\sim \sin(u)\)</span>.</p>
<div class="section" id="a-centered-scheme-for-linear-damping">
<span id="vib-ode2-fdm-flin"></span><h2>A centered scheme for linear damping<a class="headerlink" href="#a-centered-scheme-for-linear-damping" title="Permalink to this headline">¶</a></h2>
<p>Sampling <a href="#equation-vib:ode2">(1)</a> at a mesh point <span class="math">\(t_n\)</span>, replacing
<span class="math">\(u''(t_n)\)</span> by <span class="math">\([D_tD_tu]^n\)</span>, and <span class="math">\(u'(t_n)\)</span> by <span class="math">\([D_{2t}u]^n\)</span> results
in the discretization</p>
<div class="math">
\[[mD_tD_t u + f(D_{2t}u) + s(u) = F]^n,\]</div>
<p>which written out means</p>
<div class="math" id="equation-vib:ode2:step3b">
<span id="eq-vib-ode2-step3b"></span><span class="eqno">(2)</span>\[     m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
     + f(\frac{u^{n+1}-u^{n-1}}{2\Delta t}) + s(u^n) = F^n,\]</div>
<p>where <span class="math">\(F^n\)</span> as usual means <span class="math">\(F(t)\)</span> evaluated at <span class="math">\(t=t_n\)</span>.
Solving <a href="#equation-vib:ode2:step3b">(2)</a> with respect to the unknown
<span class="math">\(u^{n+1}\)</span> gives a problem: the <span class="math">\(u^{n+1}\)</span> inside the <span class="math">\(f\)</span> function
makes the equation <em>nonlinear</em> unless <span class="math">\(f(u')\)</span> is a linear function,
<span class="math">\(f(u')=bu'\)</span>. For now we shall assume that <span class="math">\(f\)</span> is linear in <span class="math">\(u'\)</span>.
Then</p>
<div class="math" id="equation-vib:ode2:step3b2">
<span id="eq-vib-ode2-step3b2"></span><span class="eqno">(3)</span>\[     m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
     + b\frac{u^{n+1}-u^{n-1}}{2\Delta t} + s(u^n) = F^n,\]</div>
<p>which gives an explicit formula for <span class="math">\(u\)</span> at each
new time level:</p>
<div class="math" id="equation-vib:ode2:step4">
<span id="eq-vib-ode2-step4"></span><span class="eqno">(4)</span>\[     u^{n+1} = (2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
     \Delta t^2(F^n - s(u^n)))(m + \frac{b}{2}\Delta t)^{-1}\]\[     {\thinspace .}\]</div>
<p>For the first time step we need to discretize <span class="math">\(u'(0)=V\)</span>
as <span class="math">\([D_{2t}u = V]^0\)</span> and combine
with <a href="#equation-vib:ode2:step4">(4)</a> for <span class="math">\(n=0\)</span>. The discretized initial condition
leads to</p>
<div class="math" id="equation-vib:ode2:ic:du">
<span id="eq-vib-ode2-ic-du"></span><span class="eqno">(5)</span>\[     u^{-1} = u^{1} - 2\Delta t V,\]</div>
<p>which inserted in <a href="#equation-vib:ode2:step4">(4)</a> for <span class="math">\(n=0\)</span> gives an equation
that can be solved for
<span class="math">\(u^1\)</span>:</p>
<div class="math" id="equation-vib:ode2:step4b">
<span id="eq-vib-ode2-step4b"></span><span class="eqno">(6)</span>\[     u^1 = u^0 + \Delta t\, V
     + \frac{\Delta t^2}{2m}(-bV - s(u^0) + F^0)
     {\thinspace .}\]</div>
</div>
<div class="section" id="a-centered-scheme-for-quadratic-damping">
<span id="vib-ode2-fdm-fquad"></span><h2>A centered scheme for quadratic damping<a class="headerlink" href="#a-centered-scheme-for-quadratic-damping" title="Permalink to this headline">¶</a></h2>
<p>When <span class="math">\(f(u')=bu'|u'|\)</span>, we get a quadratic equation for <span class="math">\(u^{n+1}\)</span>
in <a href="#equation-vib:ode2:step3b">(2)</a>. This equation can straightforwardly
be solved, but we can also avoid the nonlinearity by
performing an approximation that is within
other numerical errors that we have already committed by replacing
derivatives with finite differences.</p>
<span class="target" id="index-3"></span><p id="index-4">The idea is to reconsider <a href="#equation-vib:ode2">(1)</a> and only replace
<span class="math">\(u''\)</span> by <span class="math">\(D_tD_tu\)</span>, giving</p>
<div class="math" id="equation-vib:ode2:quad:idea1">
<span id="eq-vib-ode2-quad-idea1"></span><span class="eqno">(7)</span>\[     [mD_tD_t u + bu'|u'| + s(u) = F]^n,\]</div>
<p>Here, <span class="math">\(u'|u'|\)</span> is to be computed at time <span class="math">\(t_n\)</span>. We can introduce
a <em>geometric mean</em>, defined by</p>
<div class="math">
\[(w^2)^n \approx w^{n-\frac{1}{2}}w^{n+\frac{1}{2}},\]</div>
<p>for some quantity <span class="math">\(w\)</span> depending on time. The error in the geometric mean
approximation is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>, the same as in the
approximation <span class="math">\(u''\approx D_tD_tu\)</span>. With <span class="math">\(w=u'\)</span> it follows
that</p>
<div class="math">
\[[u'|u'|]^n \approx u'(t_n+\frac{1}{2})|u'(t_n-\frac{1}{2})|{\thinspace .}\]</div>
<p>The next step is to approximate
<span class="math">\(u'\)</span> at <span class="math">\(t_{n\pm 1/2}\)</span>, but here a centered difference can be used:</p>
<div class="math" id="equation-vib:ode2:quad:idea2">
<span id="eq-vib-ode2-quad-idea2"></span><span class="eqno">(8)</span>\[     u'(t_{n+1/2})\approx [D_t u]^{n+\frac{1}{2}},\quad u'(t_{n-1/2})\approx [D_t u]^{n-\frac{1}{2}}
     {\thinspace .}\]</div>
<p>We then get</p>
<div class="math">
\[[u'|u'|]^n
\approx [D_tu]^{n+\frac{1}{2}}|[D_tu]^{n-\frac{1}{2}}| = \frac{u^{n+1}-u^n}{\Delta t}
\frac{|u^n-u^{n-1}|}{\Delta t}
{\thinspace .}\]</div>
<p>The counterpart to <a href="#equation-vib:ode2:step3b">(2)</a> is then</p>
<div class="math" id="equation-vib:ode2:step3b:quad">
<span id="eq-vib-ode2-step3b-quad"></span><span class="eqno">(9)</span>\[     m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
     + b\frac{u^{n+1}-u^n}{\Delta t}\frac{|u^n-u^{n-1}|}{\Delta t}
     + s(u^n) = F^n,\]</div>
<p>which is linear in <span class="math">\(u^{n+1}\)</span>. Therefore, we can easily solve
with respect to <span class="math">\(u^{n+1}\)</span> and achieve
the explicit updating formula</p>
<div class="math">
\[u^{n+1} =  \left( m + b|u^n-u^{n-1}|\right)^{-1}\times \nonumber\]</div>
<div class="math" id="equation-vib:ode2:step4:quad">
<span id="eq-vib-ode2-step4-quad"></span><span class="eqno">(10)</span>\[      \qquad \left(2m u^n - mu^{n-1} + bu^n|u^n-u^{n-1}| + \Delta t^2 (F^n - s(u^n))
     \right)
     {\thinspace .}\]</div>
<p>In the derivation of a special equation for the first
time step we run into some trouble: inserting <a href="#equation-vib:ode2:ic:du">(5)</a>
in <a href="#equation-vib:ode2:step4:quad">(10)</a> for <span class="math">\(n=0\)</span> results in a complicated nonlinear
equation for <span class="math">\(u^1\)</span>. By thinking differently about the problem we can
easily get away with the nonlinearity again. We have for <span class="math">\(n=0\)</span> that
<span class="math">\(b[u'|u'|]^0 = bV|V|\)</span>. Using this value in <a href="#equation-vib:ode2:quad:idea1">(7)</a>
gives</p>
<div class="math">
\[[mD_tD_t u + bV|V| + s(u) = F]^0
{\thinspace .}\]</div>
<p>Writing this equation out and using <a href="#equation-vib:ode2:ic:du">(5)</a> results in the
special equation for the first time step:</p>
<div class="math" id="equation-vib:ode2:step4b:quad">
<span id="eq-vib-ode2-step4b-quad"></span><span class="eqno">(11)</span>\[     u^1 = u^0 + \Delta t V + \frac{\Delta t^2}{2m}\left(-bV|V| - s(u^0) + F^0\right)
     {\thinspace .}\]</div>
</div>
<div class="section" id="a-forward-backward-discretization-of-the-quadratic-damping-term">
<h2>A forward-backward discretization of the quadratic damping term<a class="headerlink" href="#a-forward-backward-discretization-of-the-quadratic-damping-term" title="Permalink to this headline">¶</a></h2>
<p>The previous section first proposed to discretize
the quadratic damping term <span class="math">\(|u'|u'\)</span> using centered differences:
<span class="math">\([|D_{2t}|D_{2t}u]^n\)</span>. As this gives rise to a nonlinearity in
<span class="math">\(u^{n+1}\)</span>, it was instead proposed to use a geometric mean combined
with centered differences.
But there are other alternatives. To get rid of the nonlinearity
in <span class="math">\([|D_{2t}|D_{2t}u]^n\)</span>, one can think differently:
apply a backward difference to <span class="math">\(|u'|\)</span>, such that the term involves known
values, and apply a forward difference to <span class="math">\(u'\)</span> to make the term linear
in the unknown <span class="math">\(u^{n+1}\)</span>. With mathematics,</p>
<div class="math">
\[[\beta |u'|u']^n \approx \beta |[D_t^-u]^n|[D_t^+ u]^n =
\beta\left\vert\frac{u^-u^{n-1}}{\Delta t}\right\vert
\frac{u^{n+1}-u^n}{\Delta t}{\thinspace .}\]</div>
<p>The forward and backward differences have both an error proportional
to <span class="math">\(\Delta t\)</span> so one may think the discretization above leads to
a first-order scheme.
However, by looking at the formulas, we realize that the forward-backward
differences result in exactly the same scheme as when we
used a geometric mean and centered differences. Therefore, the forward-backward
differences act in a symmetric way and actually produce a second-order
accurate discretization of the quadratic damping term.</p>
</div>
<div class="section" id="implementation-3">
<span id="vib-ode2-solver"></span><h2>Implementation  (3)<a class="headerlink" href="#implementation-3" title="Permalink to this headline">¶</a></h2>
<p>The algorithm arising from the methods in the sections <a class="reference internal" href="#vib-ode2-fdm-flin"><em>A centered scheme for linear damping</em></a>
and <a class="reference internal" href="#vib-ode2-fdm-fquad"><em>A centered scheme for quadratic damping</em></a> is very similar to the undamped case in
the section <a class="reference internal" href="._main_vib001.html#vib-ode1-fdm"><em>A centered finite difference scheme</em></a>. The difference is
basically a question of different formulas for <span class="math">\(u^1\)</span> and
<span class="math">\(u^{n+1}\)</span>. This is actually quite remarkable. The equation
<a href="#equation-vib:ode2">(1)</a> is normally impossible to solve by pen and paper, but
possible for some special choices of <span class="math">\(F\)</span>, <span class="math">\(s\)</span>, and <span class="math">\(f\)</span>. On the
contrary, the complexity of the
nonlinear generalized model <a href="#equation-vib:ode2">(1)</a> versus the
simple undamped model is not a big deal when we solve the
problem numerically!</p>
<p>The computational algorithm takes the form</p>
<blockquote>
<div><ol class="arabic simple">
<li><span class="math">\(u^0=I\)</span></li>
<li>compute <span class="math">\(u^1\)</span> from <a href="#equation-vib:ode2:step4b">(6)</a> if linear
damping or <a href="#equation-vib:ode2:step4b:quad">(11)</a> if quadratic damping</li>
<li>for <span class="math">\(n=1,2,\ldots,N_t-1\)</span>:</li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>compute <span class="math">\(u^{n+1}\)</span> from <a href="#equation-vib:ode2:step4">(4)</a> if linear
damping or <a href="#equation-vib:ode2:step4:quad">(10)</a> if quadratic damping</li>
</ol>
</div></blockquote>
</div></blockquote>
<p>Modifying the <tt class="docutils literal"><span class="pre">solver</span></tt> function for the undamped case is fairly
easy, the big difference being many more terms and if tests on
the type of damping:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve m*u&#39;&#39; + f(u&#39;) + s(u) = F(t) for t in (0,T],</span>
<span class="sd">    u(0)=I and u&#39;(0)=V,</span>
<span class="sd">    by a central finite difference method with time step dt.</span>
<span class="sd">    If damping is &#39;linear&#39;, f(u&#39;)=b*u, while if damping is</span>
<span class="sd">    &#39;quadratic&#39;, f(u&#39;)=b*u&#39;*abs(u&#39;).</span>
<span class="sd">    F(t) and s(u) are Python functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">);</span> <span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">);</span> <span class="n">m</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="c"># avoid integer div.</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nt</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">Nt</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span>
    <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;quadratic&#39;</span><span class="p">:</span>
        <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">V</span> <span class="o">+</span> \
               <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="n">V</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">V</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                      <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">damping</span> <span class="o">==</span> <span class="s">&#39;quadratic&#39;</span><span class="p">:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                      <span class="o">+</span> <span class="n">dt</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="o">-</span> <span class="n">s</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">])))</span><span class="o">/</span>\
                      <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span>
</pre></div>
</div>
<p>The complete code resides in the file <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib.py">vib.py</a>.</p>
</div>
<div class="section" id="verification-2">
<span id="vib-ode2-verify"></span><h2>Verification  (2)<a class="headerlink" href="#verification-2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="constant-solution">
<h3>Constant solution<a class="headerlink" href="#constant-solution" title="Permalink to this headline">¶</a></h3>
<p>For debugging and initial verification, a constant solution is often
very useful. We choose <span class="math">\({u_{\small\mbox{e}}}(t)=I\)</span>, which implies <span class="math">\(V=0\)</span>.
Inserted in the ODE, we get
<span class="math">\(F(t)=s(I)\)</span> for any choice of <span class="math">\(f\)</span>. Since the discrete derivative
of a constant vanishes (in particular, <span class="math">\([D_{2t}I]^n=0\)</span>,
<span class="math">\([D_tI]^n=0\)</span>, and <span class="math">\([D_tD_t I]^n=0\)</span>), the constant solution also fulfills
the discrete equations. The constant should therefore be reproduced
to machine precision.</p>
</div>
<div class="section" id="linear-solution">
<h3>Linear solution<a class="headerlink" href="#linear-solution" title="Permalink to this headline">¶</a></h3>
<p>Now we choose a linear solution: <span class="math">\({u_{\small\mbox{e}}} = ct + d\)</span>. The initial condition
<span class="math">\(u(0)=I\)</span> implies <span class="math">\(d=I\)</span>, and <span class="math">\(u'(0)=V\)</span> forces <span class="math">\(c\)</span> to be <span class="math">\(V\)</span>.
Inserting <span class="math">\({u_{\small\mbox{e}}}=Vt+I\)</span> in the ODE with linear damping results in</p>
<div class="math">
\[0 + bV + s(Vt+I) = F(t),\]</div>
<p>while quadratic damping requires the source term</p>
<div class="math">
\[0 + b|V|V + s(Vt+I) = F(t){\thinspace .}\]</div>
<p>Since the finite difference approximations used to compute <span class="math">\(u'\)</span> all
are exact for a linear function, it turns out that the linear <span class="math">\({u_{\small\mbox{e}}}\)</span>
is also a solution of the discrete equations.
<a class="reference internal" href="#vib-exer-verify-gen-linear"><em>Exercise 9: Use linear/quadratic functions for verification</em></a> asks you to carry out
all the details.</p>
</div>
<div class="section" id="quadratic-solution">
<h3>Quadratic solution<a class="headerlink" href="#quadratic-solution" title="Permalink to this headline">¶</a></h3>
<p>Choosing <span class="math">\({u_{\small\mbox{e}}} = bt^2 + Vt + I\)</span>, with <span class="math">\(b\)</span> arbitrary,
fulfills the initial conditions and
fits the ODE if <span class="math">\(F\)</span> is adjusted properly. The solution also solves
the discrete equations with linear damping. However, this quadratic
polynomial in <span class="math">\(t\)</span> does not fulfill the discrete equations in case
of quadratic damping, because the geometric mean used in the approximation
of this term introduces an error.
Doing <a class="reference internal" href="#vib-exer-verify-gen-linear"><em>Exercise 9: Use linear/quadratic functions for verification</em></a> will reveal
the details. One can fit <span class="math">\(F^n\)</span> in the discrete equations such that
the quadratic polynomial is reproduced by the numerical method (to
machine precision).</p>
</div>
</div>
<div class="section" id="visualization">
<span id="vib-ode2-viz"></span><h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<p>The functions for visualizations differ significantly from
those in the undamped case in the <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> program because
we in the present general case do not have an exact solution to
include in the plots. Moreover, we have no good estimate of
the periods of the oscillations as there will be one period
determined by the system parameters, essentially the
approximate frequency <span class="math">\(\sqrt{s'(0)/m}\)</span> for linear <span class="math">\(s\)</span> and small damping,
and one period dictated by <span class="math">\(F(t)\)</span> in case the excitation is periodic.
This is, however,
nothing that the program can depend on or make use of.
Therefore, the user has to specify <span class="math">\(T\)</span> and the window width
in case of a plot that moves with the graph and shows
the most recent parts of it in long time simulations.</p>
<p>The <tt class="docutils literal"><span class="pre">vib.py</span></tt> code
contains several functions for analyzing the time series signal
and for visualizing the solutions.</p>
</div>
<div class="section" id="user-interface">
<span id="vib-ode2-ui"></span><h2>User interface<a class="headerlink" href="#user-interface" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-5"></span><p id="index-6">The <tt class="docutils literal"><span class="pre">main</span></tt> function has substantial changes from
the <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> code since we need to
specify the new data <span class="math">\(c\)</span>, <span class="math">\(s(u)\)</span>, and <span class="math">\(F(t)\)</span>.  In addition, we must
set <span class="math">\(T\)</span> and the plot window width (instead of the number of periods we
want to simulate as in <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt>). To figure out whether we
can use one plot for the whole time series or if we should follow the
most recent part of <span class="math">\(u\)</span>, we can use the <tt class="docutils literal"><span class="pre">plot_empricial_freq_and_amplitude</span></tt>
function&#8217;s estimate of the number of local maxima. This number is now
returned from the function and used in <tt class="docutils literal"><span class="pre">main</span></tt> to decide on the
visualization technique.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--I&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--V&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--m&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--c&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--s&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--F&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;0&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--dt&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--T&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">140</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--damping&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s">&#39;linear&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--window_width&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s">&#39;--savefig&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s">&#39;store_true&#39;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">StringFunction</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;u&#39;</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">StringFunction</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> <span class="n">independent_variable</span><span class="o">=</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">,</span> <span class="n">damping</span> <span class="o">=</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">V</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">window_width</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">savefig</span><span class="p">,</span> \
       <span class="n">a</span><span class="o">.</span><span class="n">damping</span>

    <span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">num_periods</span> <span class="o">=</span> <span class="n">empirical_freq_and_amplitude</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">num_periods</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">:</span>
        <span class="n">figure</span><span class="p">()</span>
        <span class="n">visualize</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">visualize_front</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">window_width</span><span class="p">,</span> <span class="n">savefig</span><span class="p">)</span>
    <span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The program <tt class="docutils literal"><span class="pre">vib.py</span></tt> contains
the above code snippets and can solve the model problem
<a href="#equation-vib:ode2">(1)</a>. As a demo of <tt class="docutils literal"><span class="pre">vib.py</span></tt>, we consider the case
<span class="math">\(I=1\)</span>, <span class="math">\(V=0\)</span>, <span class="math">\(m=1\)</span>, <span class="math">\(c=0.03\)</span>, <span class="math">\(s(u)=\sin(u)\)</span>, <span class="math">\(F(t)=3\cos(4t)\)</span>,
<span class="math">\(\Delta t = 0.05\)</span>, and <span class="math">\(T=140\)</span>. The relevant command to run is</p>
<div class="highlight-text"><div class="highlight"><pre>Terminal&gt; python vib.py --s &#39;sin(u)&#39; --F &#39;3*cos(4*t)&#39; --c 0.03
</pre></div>
</div>
<p>This results in a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-vib/vib_generalized_dt0.05/index.html">moving window following the function</a> on the screen.
Figure <a class="reference internal" href="#vib-ode2-fig-demo"><em>Damped oscillator excited by a sinusoidal function</em></a> shows a part of the time series.</p>
<div class="figure" id="vib-ode2-fig-demo">
<a class="reference internal image-reference" href="_images/vib_gen_demo.png"><img alt="_images/vib_gen_demo.png" src="_images/vib_gen_demo.png" style="width: 600px;" /></a>
<p class="caption"><em>Damped oscillator excited by a sinusoidal function</em></p>
</div>
</div>
<div class="section" id="the-euler-cromer-scheme-for-the-generalized-model">
<h2>The Euler-Cromer scheme for the generalized model<a class="headerlink" href="#the-euler-cromer-scheme-for-the-generalized-model" title="Permalink to this headline">¶</a></h2>
<p>The ideas of the Euler-Cromer method from the section <a class="reference internal" href="._main_vib001.html#vib-model2x2-eulercromer"><em>The Euler-Cromer method</em></a>
carry over to the generalized model. We write <a href="#equation-vib:ode2">(1)</a>
as two equations for <span class="math">\(u\)</span> and <span class="math">\(v=u'\)</span>. The first equation is taken as the
one with <span class="math">\(v'\)</span> on the left-hand side:</p>
<div class="math" id="equation-vib:ode2:EulerCromer:veq">
<span id="eq-vib-ode2-eulercromer-veq"></span><span class="eqno">(12)</span>\[     v' = \frac{1}{m}(F(t)-s(u)-f(v)),\]</div>
<div class="math" id="equation-vib:ode2:EulerCromer:ueq">
<span id="eq-vib-ode2-eulercromer-ueq"></span><span class="eqno">(13)</span>\[     u' = v{\thinspace .}\]</div>
<p>The idea is to step <a href="#equation-vib:ode2:EulerCromer:veq">(12)</a> forward using
a standard Forward Euler method, while we update <span class="math">\(u\)</span> from
<a href="#equation-vib:ode2:EulerCromer:ueq">(13)</a> with a Backward Euler method,
utilizing the recent, computed <span class="math">\(v^{n+1}\)</span> value. In detail,</p>
<div class="math" id="equation-vib:ode2:EulerCromer:dveq0">
<span id="eq-vib-ode2-eulercromer-dveq0"></span><span class="eqno">(14)</span>\[     \frac{v^{n+1}-v^n}{\Delta t} = \frac{1}{m}(F(t_n)-s(u^n)-f(v^n)),\]</div>
<div class="math" id="equation-vib:ode2:EulerCromer:dueq0">
<span id="id1"></span><span class="eqno">(15)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = v^{n+1},\]</div>
<p>resulting in the explicit scheme</p>
<div class="math" id="equation-vib:ode2:EulerCromer:dveq">
<span id="eq-vib-ode2-eulercromer-dveq"></span><span class="eqno">(16)</span>\[     v^{n+1} = v^n + \Delta t\frac{1}{m}(F(t_n)-s(u^n)-f(v^n)),\]</div>
<div class="math" id="equation-vib:ode2:EulerCromer:dueq0">
<span id="id3"></span><span class="eqno">(17)</span>\[     u^{n+1} = u^n + \Delta t\,v^{n+1}{\thinspace .}\]</div>
<p>We immediately note one very favorable feature of this scheme: all the
nonlinearities in <span class="math">\(s(u)\)</span> and <span class="math">\(f(v)\)</span> are evaluated at a previous time
level. This makes the Euler-Cromer method easier to apply and
hence much more convenient than the centered scheme for the second-order
ODE <a href="#equation-vib:ode2">(1)</a>.</p>
<p>The initial conditions are trivially set as</p>
<div class="math">
\[v^0 = V,\]</div>
<div class="math">
\[u^0 = I{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="exercises-and-problems">
<h1>Exercises and Problems<a class="headerlink" href="#exercises-and-problems" title="Permalink to this headline">¶</a></h1>
<div class="section" id="problem-1-use-linear-quadratic-functions-for-verification">
<span id="vib-exer-undamped-verify-linquad"></span><h2>Problem 1: Use linear/quadratic functions for verification<a class="headerlink" href="#problem-1-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h2>
<p>Consider the ODE problem</p>
<div class="math">
\[u'' + \omega^2u=f(t), \quad u(0)=I,\ u'(0)=V,\ t\in(0,T]{\thinspace .}\]</div>
<p>Discretize this equation according to
<span class="math">\([D_tD_t u + \omega^2 u = f]^n\)</span>.</p>
<p><strong>a)</strong>
Derive the equation for the
first time step (<span class="math">\(u^1\)</span>).</p>
<p><strong>b)</strong>
For verification purposes,
we use the method of manufactured solutions (MMS) with the
choice of <span class="math">\({u_{\small\mbox{e}}}(x,t)= ct+d\)</span>.
Find restrictions on <span class="math">\(c\)</span> and <span class="math">\(d\)</span> from
the initial conditions. Compute the corresponding source term <span class="math">\(f\)</span> by term.
Show that <span class="math">\([D_tD_t t]^n=0\)</span> and use the fact
that the <span class="math">\(D_tD_t\)</span> operator is linear,
<span class="math">\([D_tD_t (ct+d)]^n = c[D_tD_t t]^n + [D_tD_t d]^n = 0\)</span>, to show that
<span class="math">\({u_{\small\mbox{e}}}\)</span> is also a perfect solution of the discrete equations.</p>
<p><strong>c)</strong>
Use <tt class="docutils literal"><span class="pre">sympy</span></tt> to do the symbolic calculations above. Here is a
sketch of the program <tt class="docutils literal"><span class="pre">vib_undamped_verify_mms.py</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">sympy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="n">V</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;V t I w dt&#39;</span><span class="p">)</span>  <span class="c"># global symbols</span>
<span class="n">f</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c"># global variable for the source term in the ODE</span>

<span class="k">def</span> <span class="nf">ode_source_term</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the terms in the ODE that the source term</span>
<span class="sd">    must balance, here u&#39;&#39; + w**2*u.</span>
<span class="sd">    u is symbolic Python function of t.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the residual of the discrete eq. at the first</span>
<span class="sd">    step with u inserted.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">return</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">DtDt</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return 2nd-order finite difference for u_tt.</span>
<span class="sd">    u is a symbolic Python function of t.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given some chosen solution u (as a function of t, implemented</span>
<span class="sd">    as a Python function), use the method of manufactured solutions</span>
<span class="sd">    to compute the source term f, and check if u also solves</span>
<span class="sd">    the discrete equations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">print</span> <span class="s">&#39;=== Testing exact solution: </span><span class="si">%s</span><span class="s"> ===&#39;</span> <span class="o">%</span> <span class="n">u</span>
    <span class="k">print</span> <span class="s">&quot;Initial conditions u(0)=</span><span class="si">%s</span><span class="s">, u&#39;(0)=</span><span class="si">%s</span><span class="s">:&quot;</span> <span class="o">%</span> \
          <span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">sp</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">subs</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="c"># Method of manufactured solution requires fitting f</span>
    <span class="k">global</span> <span class="n">f</span>  <span class="c"># source term in the ODE</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">ode_lhs</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>

    <span class="c"># Residual in discrete equations (should be 0)</span>
    <span class="k">print</span> <span class="s">&#39;residual step1:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq_step1</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="k">print</span> <span class="s">&#39;residual:&#39;</span><span class="p">,</span> <span class="n">residual_discrete_eq</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">linear</span><span class="p">():</span>
    <span class="n">main</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">V</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">I</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">linear</span><span class="p">()</span>
</pre></div>
</div>
<p>Fill in the various functions such that the calls in the <tt class="docutils literal"><span class="pre">main</span></tt>
function works.</p>
<p><strong>d)</strong>
The purpose now is to choose a quadratic function
<span class="math">\({u_{\small\mbox{e}}} = bt^2 + ct + d\)</span> as exact solution. Extend the <tt class="docutils literal"><span class="pre">sympy</span></tt>
code above with a function <tt class="docutils literal"><span class="pre">quadratic</span></tt> for fitting <tt class="docutils literal"><span class="pre">f</span></tt> and checking
if the discrete equations are fulfilled. (The function is very similar
to <tt class="docutils literal"><span class="pre">linear</span></tt>.)</p>
<p><strong>e)</strong>
Will a polynomial of degree three fulfill the discrete equations?</p>
<p><strong>f)</strong>
Implement a <tt class="docutils literal"><span class="pre">solver</span></tt> function for computing the numerical
solution of this problem.</p>
<p><strong>g)</strong>
Write a nose test for checking that the quadratic solution
is computed to correctly (too machine precision, but the
round-off errors accumulate and increase with <span class="math">\(T\)</span>) by the <tt class="docutils literal"><span class="pre">solver</span></tt>
function.</p>
<p>Filenames: <tt class="docutils literal"><span class="pre">vib_undamped_verify_mms.pdf</span></tt>, <tt class="docutils literal"><span class="pre">vib_undamped_verify_mms.py</span></tt>.</p>
</div>
<div class="section" id="exercise-2-show-linear-growth-of-the-phase-with-time">
<span id="vib-exer-phase-err-growth"></span><h2>Exercise 2: Show linear growth of the phase with time<a class="headerlink" href="#exercise-2-show-linear-growth-of-the-phase-with-time" title="Permalink to this headline">¶</a></h2>
<p>Consider an exact solution <span class="math">\(I\cos (\omega t)\)</span> and an
approximation <span class="math">\(I\cos(\tilde\omega t)\)</span>.
Define the phase error as time lag between the peak <span class="math">\(I\)</span>
in the exact solution and the corresponding peak in the approximation
after <span class="math">\(m\)</span> periods of oscillations. Show that this phase error
is linear in <span class="math">\(m\)</span>.
Filename: <tt class="docutils literal"><span class="pre">vib_phase_error_growth.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-3-improve-the-accuracy-by-adjusting-the-frequency">
<span id="vib-exer-w-adjust"></span><h2>Exercise 3: Improve the accuracy by adjusting the frequency<a class="headerlink" href="#exercise-3-improve-the-accuracy-by-adjusting-the-frequency" title="Permalink to this headline">¶</a></h2>
<p>According to <a class="reference internal" href="._main_vib001.html#eq-vib-ode1-tildeomega-series"><em>(2.11)</em></a>, the numerical
frequency deviates from the exact frequency by a (dominating) amount
<span class="math">\(\omega^3\Delta t^2/24 &gt;0\)</span>. Replace the <tt class="docutils literal"><span class="pre">w</span></tt> parameter in the algorithm
in the <tt class="docutils literal"><span class="pre">solver</span></tt> function in <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> by <tt class="docutils literal"><span class="pre">w*(1</span> <span class="pre">-</span>
<span class="pre">(1./24)*w**2*dt**2</span></tt> and test how this adjustment in the numerical
algorithm improves the accuracy (use <span class="math">\(\Delta t =0.1\)</span> and simulate
for 80 periods, with and without adjustment of <span class="math">\(\omega\)</span>).
Filename: <tt class="docutils literal"><span class="pre">vib_adjust_w.py</span></tt>.</p>
</div>
<div class="section" id="exercise-4-see-if-adaptive-methods-improve-the-phase-error">
<span id="vib-exer-undamped-adaptive"></span><h2>Exercise 4: See if adaptive methods improve the phase error<a class="headerlink" href="#exercise-4-see-if-adaptive-methods-improve-the-phase-error" title="Permalink to this headline">¶</a></h2>
<p>Adaptive methods for solving ODEs aim at adjusting <span class="math">\(\Delta t\)</span> such
that the error is within a user-prescribed tolerance. Implement the
equation <span class="math">\(u''+u=0\)</span> in the <a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a>
software. Use the example <a class="reference external" href="http://tinyurl.com/opdfafk/pub/sphinx-decay/._main_decay007.html#example-adaptive-runge-kutta-methods">on adaptive
schemes</a>
in <a class="reference internal" href="#ref1" id="id4">[Ref1]</a>.  Run the scheme with a very low
tolerance (say <span class="math">\(10^{-14}\)</span>) and for a long time, check the number of
time points in the solver&#8217;s mesh (<tt class="docutils literal"><span class="pre">len(solver.t_all)</span></tt>), and compare
the phase error with that produced by the simple finite difference
method from the section <a class="reference internal" href="._main_vib001.html#vib-ode1-fdm"><em>A centered finite difference scheme</em></a> with the same number of (equally
spaced) mesh points. The question is whether it pays off to use an
adaptive solver or if equally many points with a simple method gives
about the same accuracy.
Filename: <tt class="docutils literal"><span class="pre">vib_undamped_adaptive.py</span></tt>.</p>
</div>
<div class="section" id="exercise-5-use-a-taylor-polynomial-to-compute">
<span id="vib-exer-step4b-alt"></span><h2>Exercise 5: Use a Taylor polynomial to compute <span class="math">\(u^1\)</span><a class="headerlink" href="#exercise-5-use-a-taylor-polynomial-to-compute" title="Permalink to this headline">¶</a></h2>
<p>As an alternative to the derivation of <a class="reference internal" href="._main_vib001.html#eq-vib-ode1-step4b"><em>(2.8)</em></a> for
computing <span class="math">\(u^1\)</span>, one can use a Taylor polynomial with three terms
for <span class="math">\(u^1\)</span>:</p>
<div class="math">
\[u(t_1) \approx u(0) + u'(0)\Delta t + {\frac{1}{2}}u''(0)\Delta t^2\]</div>
<p>With <span class="math">\(u''=-\omega^2 u\)</span> and <span class="math">\(u'(0)=0\)</span>, show that this method also leads to
<a class="reference internal" href="._main_vib001.html#eq-vib-ode1-step4b"><em>(2.8)</em></a>. Generalize the condition on <span class="math">\(u'(0)\)</span> to
be <span class="math">\(u'(0)=V\)</span> and compute <span class="math">\(u^1\)</span> in this case with both methods.
Filename: <tt class="docutils literal"><span class="pre">vib_first_step.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-6-find-the-minimal-resolution-of-an-oscillatory-function">
<span id="vib-exer-wdt-limit"></span><h2>Exercise 6: Find the minimal resolution of an oscillatory function<a class="headerlink" href="#exercise-6-find-the-minimal-resolution-of-an-oscillatory-function" title="Permalink to this headline">¶</a></h2>
<p>Sketch the function on a given mesh which has the highest possible
frequency. That is, this oscillatory &#8220;cos-like&#8221; function has its
maxima and minima at every two grid points.  Find an expression for
the frequency of this function, and use the result to find the largest
relevant value of <span class="math">\(\omega\Delta t\)</span> when <span class="math">\(\omega\)</span> is the frequency
of an oscillating function and <span class="math">\(\Delta t\)</span> is the mesh spacing.
Filename: <tt class="docutils literal"><span class="pre">vib_largest_wdt.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-7-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">
<span id="vib-exer-fd-exp-plot"></span><h2>Exercise 7: Visualize the accuracy of finite differences for a cosine function<a class="headerlink" href="#exercise-7-visualize-the-accuracy-of-finite-differences-for-a-cosine-function" title="Permalink to this headline">¶</a></h2>
<p>We introduce the error fraction</p>
<div class="math">
\[E = \frac{[D_tD_t u]^n}{u''(t_n)}\]</div>
<p>to measure the error in the finite difference approximation <span class="math">\(D_tD_tu\)</span> to
<span class="math">\(u''\)</span>.
Compute <span class="math">\(E\)</span>
for the specific choice of a cosine/sine function of the
form <span class="math">\(u=\exp{(i\omega t)}\)</span> and show that</p>
<div class="math">
\[E = \left(\frac{2}{\omega\Delta t}\right)^2
\sin^2(\frac{\omega\Delta t}{2})
{\thinspace .}\]</div>
<p>Plot <span class="math">\(E\)</span> as a function of <span class="math">\(p=\omega\Delta t\)</span>. The relevant
values of <span class="math">\(p\)</span> are <span class="math">\([0,\pi]\)</span> (see <a class="reference internal" href="#vib-exer-wdt-limit"><em>Exercise 6: Find the minimal resolution of an oscillatory function</em></a>
for why <span class="math">\(p&gt;\pi\)</span> does not make sense).
The deviation of the curve from unity visualizes the error in the
approximation. Also expand <span class="math">\(E\)</span> as a Taylor polynomial in <span class="math">\(p\)</span> up to
fourth degree (use, e.g., <tt class="docutils literal"><span class="pre">sympy</span></tt>).
Filename: <tt class="docutils literal"><span class="pre">vib_plot_fd_exp_error.py</span></tt>.</p>
</div>
<div class="section" id="exercise-8-verify-convergence-rates-of-the-error-in-energy">
<span id="vib-exer-energy-convrate"></span><h2>Exercise 8: Verify convergence rates of the error in energy<a class="headerlink" href="#exercise-8-verify-convergence-rates-of-the-error-in-energy" title="Permalink to this headline">¶</a></h2>
<p>We consider the ODE problem <span class="math">\(u'' + \omega^2u=0\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(u'(0)=V\)</span>,
for <span class="math">\(t\in (0,T]\)</span>. The total energy of the solution
<span class="math">\(E(t)=\frac{1}{2}(u')^2 + \frac{1}{2}\omega^2 u^2\)</span> should stay
constant.
The error in energy can be computed as explained in
the section <a class="reference internal" href="._main_vib001.html#vib-model1-energy"><em>Energy considerations</em></a>.</p>
<p>Make a nose test in a file <tt class="docutils literal"><span class="pre">test_error_conv.py</span></tt>, where code from
<tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> is imported, but the <tt class="docutils literal"><span class="pre">convergence_rates</span></tt> and
<tt class="docutils literal"><span class="pre">test_convergence_rates</span></tt> functions are copied and modified to also
incorporate computations of the error in energy and the convergence
rate of this error. The expected rate is 2.
Filename: <tt class="docutils literal"><span class="pre">test_error_conv.py</span></tt>.</p>
</div>
<div class="section" id="exercise-9-use-linear-quadratic-functions-for-verification">
<span id="vib-exer-verify-gen-linear"></span><h2>Exercise 9: Use linear/quadratic functions for verification<a class="headerlink" href="#exercise-9-use-linear-quadratic-functions-for-verification" title="Permalink to this headline">¶</a></h2>
<p>This exercise is a generalization of <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><em>Problem 1: Use linear/quadratic functions for verification</em></a> to the extended model problem
<a href="#equation-vib:ode2">(1)</a> where the damping term is either linear or quadratic.
Solve the various subproblems and see how the results and problem
settings change with the generalized ODE in case of linear or
quadratic damping. By modifying the code from <a class="reference internal" href="#vib-exer-undamped-verify-linquad"><em>Problem 1: Use linear/quadratic functions for verification</em></a>, <tt class="docutils literal"><span class="pre">sympy</span></tt> will do most
of the work required to analyze the generalized problem.
Filename: <tt class="docutils literal"><span class="pre">vib_verify_mms.py</span></tt>.</p>
</div>
<div class="section" id="exercise-10-use-an-exact-discrete-solution-for-verification">
<span id="vib-exer-discrete-omega"></span><h2>Exercise 10: Use an exact discrete solution for verification<a class="headerlink" href="#exercise-10-use-an-exact-discrete-solution-for-verification" title="Permalink to this headline">¶</a></h2>
<p>Write a nose test function in a separate file
that employs the exact discrete solution
<a class="reference internal" href="._main_vib001.html#eq-vib-ode1-un-exact"><em>(2.12)</em></a> to verify the implementation of the
<tt class="docutils literal"><span class="pre">solver</span></tt> function in the file <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt>.
Filename: <tt class="docutils literal"><span class="pre">test_vib_undamped_exact_discrete_sol.py</span></tt>.</p>
</div>
<div class="section" id="exercise-11-use-analytical-solution-for-convergence-rate-tests">
<span id="vib-exer-conv-rate"></span><h2>Exercise 11: Use analytical solution for convergence rate tests<a class="headerlink" href="#exercise-11-use-analytical-solution-for-convergence-rate-tests" title="Permalink to this headline">¶</a></h2>
<p>The purpose of this exercise is to perform convergence tests of the
problem <a href="#equation-vib:ode2">(1)</a> when <span class="math">\(s(u)=\omega^2u\)</span> and <span class="math">\(F(t)=A\sin\phi t\)</span>.
Find the complete analytical solution to the problem in this case
(most textbooks on mechanics or ordinary differential equations list
the various elements you need to write down the exact solution).
Modify the <tt class="docutils literal"><span class="pre">convergence_rate</span></tt> function from the <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt>
program to perform experiments with the extended model.  Verify that
the error is of order <span class="math">\(\Delta t^2\)</span>.
Filename: <tt class="docutils literal"><span class="pre">vib_conv_rate.py</span></tt>.</p>
</div>
<div class="section" id="exercise-12-investigate-the-amplitude-errors-of-many-solvers">
<span id="vib-exer-undamped-odespy"></span><h2>Exercise 12: Investigate the amplitude errors of many solvers<a class="headerlink" href="#exercise-12-investigate-the-amplitude-errors-of-many-solvers" title="Permalink to this headline">¶</a></h2>
<p>Use the program <tt class="docutils literal"><span class="pre">vib_undamped_odespy.py</span></tt> from the section <a class="reference internal" href="._main_vib001.html#vib-undamped-1stode"><em>Standard methods for 1st-order ODE systems</em></a>
and the amplitude estimation from the <tt class="docutils literal"><span class="pre">amplitudes</span></tt> function
in the <tt class="docutils literal"><span class="pre">vib_undamped.py</span></tt> file (see the section <a class="reference internal" href="._main_vib001.html#vib-ode1-empirical"><em>Empirical analysis of the solution</em></a>)
to investigate how well famous methods for 1st-order ODEs
can preserve the amplitude of <span class="math">\(u\)</span> in undamped oscillations.
Test, for example, the 3rd- and 4th-order Runge-Kutta methods
(<tt class="docutils literal"><span class="pre">RK3</span></tt>, <tt class="docutils literal"><span class="pre">RK4</span></tt>), the Crank-Nicolson method (<tt class="docutils literal"><span class="pre">CrankNicolson</span></tt>),
the 2nd- and 3rd-order Adams-Bashforth methods (<tt class="docutils literal"><span class="pre">AdamsBashforth2</span></tt>,
<tt class="docutils literal"><span class="pre">AdamsBashforth3</span></tt>), and a 2nd-order Backwards scheme (<tt class="docutils literal"><span class="pre">Backward2Step</span></tt>).
The relevant governing equations are listed in
the section <em class="xref std std-ref">vib:model2x2:ueq</em>.
Filename: <tt class="docutils literal"><span class="pre">vib_amplitude_errors.py</span></tt>.</p>
</div>
<div class="section" id="exercise-13-minimize-memory-usage-of-a-vibration-solver">
<span id="vib-exer-memsave"></span><h2>Exercise 13: Minimize memory usage of a vibration solver<a class="headerlink" href="#exercise-13-minimize-memory-usage-of-a-vibration-solver" title="Permalink to this headline">¶</a></h2>
<p>The program <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib.py">vib.py</a>
store the complete solution <span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> in memory, which is
convenient for later plotting.
Make a memory minimizing version of this program where only the last three
<span class="math">\(u^{n+1}\)</span>, <span class="math">\(u^n\)</span>, and <span class="math">\(u^{n-1}\)</span> values are stored in memory.
Write each computed <span class="math">\((t_{n+1}, u^{n+1})\)</span> pair to file.
Visualize the data in the file (a cool solution is to
read one line at a time and
plot the <span class="math">\(u\)</span> value using the line-by-line plotter in the
<tt class="docutils literal"><span class="pre">visualize_front_ascii</span></tt> function - this technique makes it trivial
to visualize very long time simulations).
Filename: <tt class="docutils literal"><span class="pre">vib_memsave.py</span></tt>.</p>
</div>
<div class="section" id="exercise-14-implement-the-solver-via-classes">
<span id="vib-exer-gen-class"></span><h2>Exercise 14: Implement the solver via classes<a class="headerlink" href="#exercise-14-implement-the-solver-via-classes" title="Permalink to this headline">¶</a></h2>
<p>Reimplement the <tt class="docutils literal"><span class="pre">vib.py</span></tt>
program
using a class <tt class="docutils literal"><span class="pre">Problem</span></tt> to hold all the physical parameters of the problem,
a class <tt class="docutils literal"><span class="pre">Solver</span></tt> to hold the numerical parameters and compute the
solution, and a class <tt class="docutils literal"><span class="pre">Visualizer</span></tt> to display the solution.</p>
<p><strong>Hint.</strong>
Use the ideas and examples
for an <a class="reference external" href="http://tinyurl.com/opdfafk/pub/sphinx-decay/main_decay.html#implementing-simple-problem-and-solver-classes">ODE model</a>.
More specifically, make a superclass <tt class="docutils literal"><span class="pre">Problem</span></tt> for holding the scalar
physical parameters of a problem and let subclasses implement the
<span class="math">\(s(u)\)</span> and <span class="math">\(F(t)\)</span> functions as methods.
Try to call up as much existing functionality in <tt class="docutils literal"><span class="pre">vib.py</span></tt> as possible.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">vib_class.py</span></tt>.</p>
</div>
<div class="section" id="exercise-15-interpret-as-a-forward-backward-difference">
<span id="vib-exer-dtdt-asdtpdtm"></span><h2>Exercise 15: Interpret <span class="math">\([D_tD_t u]^n\)</span> as a forward-backward difference<a class="headerlink" href="#exercise-15-interpret-as-a-forward-backward-difference" title="Permalink to this headline">¶</a></h2>
<p>Show that the difference <span class="math">\([D_t D_tu]^n\)</span> is equal to <span class="math">\([D_t^+D_t^-u]^n\)</span>
and <span class="math">\(D_t^-D_t^+u]^n\)</span>. That is, instead of applying a centered difference
twice one can alternatively apply a mixture forward and backward
differences.
Filename: <tt class="docutils literal"><span class="pre">vib_DtDt_fw_bw.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-16-use-the-forward-backward-scheme-with-quadratic-damping">
<span id="vib-exer-quad-damping-fwbw"></span><h2>Exercise 16: Use the forward-backward scheme with quadratic damping<a class="headerlink" href="#exercise-16-use-the-forward-backward-scheme-with-quadratic-damping" title="Permalink to this headline">¶</a></h2>
<p>We consider the generalized model with quadratic damping, expressed
as a system of two first-order equations as in the section <em class="xref std std-ref">vib:ode2:staggered</em>:</p>
<div class="math">
\[\begin{split}u' &amp;= v,\\
v' &amp;= \frac{1}{m}\left( F(t) - \beta |v|v - s(u)\right){\thinspace .}\end{split}\]</div>
<p>However, contrary to what is done in the section <em class="xref std std-ref">vib:ode2:staggered</em>,
we want to apply the idea of the forward-backward discretization
in the section <a class="reference internal" href="._main_vib001.html#vib-model2x2-eulercromer"><em>The Euler-Cromer method</em></a>. Express the idea in operator
notation and write out the scheme. Unfortunately, the backward
difference for the <span class="math">\(v\)</span> equation creates a nonlinearity <span class="math">\(|v^{n+1}|v^{n}\)</span>.
To linearize this nonlinearity, use the known value <span class="math">\(v^n\)</span> inside
the absolute value factor, i.e., <span class="math">\(|v^{n+1}|v^{n}\approx |v^n|v^{n+1}\)</span>.
Show that the resulting scheme is equivalent to the one in
the section <em class="xref std std-ref">vib:ode2:staggered</em> for some time level <span class="math">\(n\geq 1\)</span>.</p>
<p>What we learn from this exercise is that the first-order differences
and the linearization trick play together in &#8220;the right way&#8221; such that
the scheme is as good as when we (in the section <em class="xref std std-ref">vib:ode2:staggered</em>)
carefully apply centered differences and a geometric mean on a
staggered mesh to achieve second-order accuracy.  There is a
difference in the handling of the initial conditions, though, as
explained at the end of the section <a class="reference internal" href="._main_vib001.html#vib-model2x2-eulercromer"><em>The Euler-Cromer method</em></a>.
Filename: <tt class="docutils literal"><span class="pre">vib_gen_bwdamping.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-17-use-a-backward-difference-for-the-damping-term">
<span id="vib-exer-quad-damping-bw"></span><h2>Exercise 17: Use a backward difference for the damping term<a class="headerlink" href="#exercise-17-use-a-backward-difference-for-the-damping-term" title="Permalink to this headline">¶</a></h2>
<p>As an alternative to discretizing the damping terms <span class="math">\(\beta u'\)</span> and
<span class="math">\(\beta |u'|u'\)</span> by centered differences, we may apply
backward differences:</p>
<div class="math">
\[\begin{split}[u']^n &amp;\approx [D_t^-u]^n,\\
&amp; [|u'|u']^n &amp;\approx [|D_t^-u|D_t^-u]^n
= |[D_t^-u]^n|[D_t^-u]^n{\thinspace .}\end{split}\]</div>
<p>The advantage of the backward difference is that the damping term is
evaluated using known values <span class="math">\(u^n\)</span> and <span class="math">\(u^{n-1}\)</span> only.
Extend the <a class="reference external" href="http://tinyurl.com/nm5587k/vib/vib.py">vib.py</a> code with a scheme based
on using backward differences in the damping terms. Add statements
to compare the original approach with centered difference and the
new idea launched in this exercise. Perform numerical experiments
to investigate how much accuracy that is lost by using the backward
differences.
Filename: <tt class="docutils literal"><span class="pre">vib_gen_bwdamping.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-18-simulate-a-bouncing-ball">
<span id="vib-exer-bouncing-ball"></span><h2>Exercise 18: Simulate a bouncing ball<a class="headerlink" href="#exercise-18-simulate-a-bouncing-ball" title="Permalink to this headline">¶</a></h2>
<p>A bouncing ball is a body in free vertically fall until it impacts the
ground. During the impact, some kinetic energy is lost, and a new
motion upwards with reduced velocity starts.  At some point the
velocity close to the ground is so small that the ball is considered
to be finally at rest.</p>
<p>The motion of the ball falling in air is governed by Newton&#8217;s second
law <span class="math">\(F=ma\)</span>, where <span class="math">\(a\)</span> is the acceleration of the body, <span class="math">\(m\)</span> is the mass,
and <span class="math">\(F\)</span> is the sum of all forces. Here, we neglect the air resistance
so that gravity <span class="math">\(-mg\)</span> is the only force. The height of the ball is
denoted by <span class="math">\(h\)</span> and <span class="math">\(v\)</span> is the velocity. The relations between <span class="math">\(h\)</span>, <span class="math">\(v\)</span>, and
<span class="math">\(a\)</span>,</p>
<div class="math">
\[h'(t)= v(t),\quad v'(t) = a(t),\]</div>
<p>combined with Newton&#8217;s second law gives the ODE model</p>
<div class="math" id="equation-vib:exer:bouncing:ball:h2eq">
<span id="eq-vib-exer-bouncing-ball-h2eq"></span><span class="eqno">(18)</span>\[     h''(t) = -g,\]</div>
<p>or expressed alternatively as a system of first-order equations:</p>
<div class="math" id="equation-vib:exer:bouncing:ball:veq">
<span id="eq-vib-exer-bouncing-ball-veq"></span><span class="eqno">(19)</span>\[     v'(t) = -g,\]</div>
<div class="math" id="equation-vib:exer:bouncing:ball:heq">
<span id="eq-vib-exer-bouncing-ball-heq"></span><span class="eqno">(20)</span>\[     h'(t) = v(t){\thinspace .}\]</div>
<p>These equations govern the motion as long as the ball is away from
the ground by a small distance <span class="math">\(\epsilon_h &gt; 0\)</span>. When <span class="math">\(h&lt;\epsilon_h\)</span>,
we have two cases.</p>
<ol class="arabic simple">
<li>The ball impacts the ground, recognized by a sufficiently large negative
velocity (<span class="math">\(v&lt;-\epsilon_v\)</span>). The velocity then changes sign and is
reduced by a factor <span class="math">\(C_R\)</span>, known as the <a class="reference external" href="http://en.wikipedia.org/wiki/Coefficient_of_restitution">coefficient of restitution</a>.
For plotting purposes, one may set <span class="math">\(h=0\)</span>.</li>
<li>The motion stops, recognized by a sufficiently small velocity
(<span class="math">\(|v|&lt;\epsilon_v\)</span>) close to the ground.</li>
</ol>
<p>Choose one of the models, <a href="#equation-vib:exer:bouncing:ball:h2eq">(18)</a> or
<a href="#equation-vib:exer:bouncing:ball:veq">(19)</a>-<a href="#equation-vib:exer:bouncing:ball:heq">(20)</a>,
and simulate a bouncing ball. Plot <span class="math">\(h(t)\)</span>. Think about how to
plot <span class="math">\(v(t)\)</span>.</p>
<p><strong>Hint.</strong>
A naive implementation may get stuck in repeated impacts for large time
step sizes. To avoid this situation, one can introduce a state
variable that holds the mode of the motion: free fall, impact, or rest.
Two consecutive impacts imply that the motion has stopped.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">bouncing_ball.py</span></tt>.</p>
</div>
<div class="section" id="exercise-19-simulate-an-elastic-pendulum">
<span id="vib-exer-elastic-pendulum"></span><h2>Exercise 19: Simulate an elastic pendulum<a class="headerlink" href="#exercise-19-simulate-an-elastic-pendulum" title="Permalink to this headline">¶</a></h2>
<p>Consider an elastic pendulum fixed to the point <span class="math">\(\boldsymbol{r}_0=(0,L_0)\)</span>.
The length of the pendulum wire when not stretched is <span class="math">\(L_0\)</span>.
The wire is massless and always straight. At the end point
<span class="math">\(\boldsymbol{r}\)</span>, we have a mass <span class="math">\(m\)</span>.
Stretching the elastic wire a distance <span class="math">\(s\)</span>
gives rise to a spring force <span class="math">\(ks\)</span> in the opposite direction of the
stretching. Let <span class="math">\(\boldsymbol{n}\)</span> be a unit normal vector along the wire:</p>
<div class="math">
\[\boldsymbol{n} = \frac{\boldsymbol{r}-\boldsymbol{r}_0}{||\boldsymbol{r}-\boldsymbol{r}_0||}{\thinspace .}\]</div>
<p>The stretch <span class="math">\(s\)</span> in the wire is the current length <span class="math">\(||\boldsymbol{r}-\boldsymbol{r}_0||\)</span>
at some time <span class="math">\(t\)</span> minus the original length <span class="math">\(L_0\)</span>:</p>
<div class="math">
\[s = ||\boldsymbol{r}-\boldsymbol{r}_0|| - L_0{\thinspace .}\]</div>
<p>The force in the wire is then <span class="math">\(\boldsymbol{F}_w=-ks\boldsymbol{n}\)</span>.
Newton&#8217;s second law of motion applied to the mass results in</p>
<div class="math" id="equation-vib:exer:elastic:pendulum:eq1">
<span id="eq-vib-exer-elastic-pendulum-eq1"></span><span class="eqno">(21)</span>\[     m\ddot{\boldsymbol{r}} = -ks\boldsymbol{n} - mg\boldsymbol{j},\]</div>
<p>where <span class="math">\(\boldsymbol{j}\)</span> is a unit vector in the upward vertical direction.
Let <span class="math">\(\boldsymbol{r}=(x,y)\)</span> and <span class="math">\(\boldsymbol{n}=(n_x,n_y)\)</span>. The two components of
<a href="#equation-vib:exer:elastic:pendulum:eq1">(21)</a> then becomes</p>
<div class="math">
\[\ddot x = -m^{-1}ksn_x,\]</div>
<div class="math" id="equation-vib:exer:elastic:pendulum:eq2a">
<span id="eq-vib-exer-elastic-pendulum-eq2a"></span></div>
<div class="math" id="equation-vib:exer:elastic:pendulum:eq2b">
<span id="eq-vib-exer-elastic-pendulum-eq2b"></span><span class="eqno">(23)</span>\[     \ddot y = - m^{-1}ksn_y - g
     {\thinspace .}\]</div>
<p>The mass point <span class="math">\((x,y)\)</span> will undergo a two-dimensional motion, but
if the wire is stiff (large <span class="math">\(k\)</span>), the elastic pendulum will approach
the classical one where the mass point moves along a circle.
However, the elastic pendulum is modeled by a direct application of
Newton&#8217;s second law, because the force in the wire is known (as a
function of the motion), while the classical pendulum involves
constrained motion, which requires elimination of an unknown via
the constraint (by invoking polar coordinates).</p>
<p>In equilibrium, the mass hangs in the position <span class="math">\((0,y_0)\)</span> determined by</p>
<div class="math">
\[0 = - m^{-1}ksn_y - g = m^{-1}k(y_0-L_0) - g\quad\Rightarrow\quad
y_0 = L_0 + mg/k = L{\thinspace .}\]</div>
<p>We then displace the mass an angle <span class="math">\(\theta_0\)</span> to the right. The initial
position <span class="math">\((x(0),y(0))\)</span> then becomes</p>
<div class="math">
\[x(0)=L\sin\theta_0,\quad y(0)=L_0 - L\cos\theta_0{\thinspace .}\]</div>
<p>The velocity is zero, <span class="math">\(x'(0)=y'(0)=0\)</span>.</p>
<p><strong>a)</strong>
Write a code that can simulate such an elastic pendulum. Plot
<span class="math">\(y\)</span> against <span class="math">\(x\)</span> in a plot with the same length scale on the
axis such that we get a correct picture of the motion.
Also plot the angle the pendulum: <span class="math">\(\theta = \tan^{-1}x/(L_0-y)\)</span>.</p>
<p>A possible set of parameters is <span class="math">\(L_0=9.81\)</span> m, <span class="math">\(m=1\)</span> kg, <span class="math">\(theta_0=30\)</span>
degrees.</p>
<p><strong>Hint 1.</strong>
The associated classical pendulum, for large <span class="math">\(k\)</span>, has an equation
<span class="math">\(\ddot\theta + g/L_0\theta =0\)</span>. With <span class="math">\(g=L_0\)</span>, the period is <span class="math">\(2\pi\)</span>:
<span class="math">\(\theta(t) = \theta_0\cos(t)\)</span>. One can compare in a plot the angle
of the elastic solution (<span class="math">\(\theta = \tan^{-1}x/(L_0-y)\)</span>)
with the solution of the classical pendulum problem.</p>
<p><strong>Hint 2.</strong>
The equation of motion is subject to round-off errors for large <span class="math">\(k\)</span>,
because <span class="math">\(s\)</span> is then small such that <span class="math">\(ks\)</span> is a product of a large and
a small number. Moreover, in this stiff case,
<span class="math">\(m^{-1}ksn_y\)</span> is close to <span class="math">\(g\)</span> such that we
also subtract two almost equal numbers in the force term in the
equation. For the given parameters, <span class="math">\(k=150\)</span> is a large value and
gives a solution close to the motion of a perfect classical pendulum.
Much larger values gives unstable solutions.</p>
<p><strong>b)</strong>
Air resistance is a force <span class="math">\(\frac{1}{2}\varrho C_D A||bm{v}||\boldsymbol{v}\)</span>,
where <span class="math">\(C_D\)</span> is a drag coefficient (0.2 for a sphere), <span class="math">\(\varrho\)</span>
is the density of air (1.2 <span class="math">\(\hbox{kg }\,{\hbox{m}}^{-3}\)</span>), <span class="math">\(A\)</span> is the
cross section area (<span class="math">\(A=\pi R^2\)</span> for a sphere, where <span class="math">\(R\)</span> is the radius),
and <span class="math">\(\boldsymbol{v}\)</span> is the velocity: <span class="math">\(\boldsymbol{v} = \dot{\boldsymbol{r}}\)</span>.
Include air resistance in the model and show plots comparing the
motion with and without air resistance.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">elastic_pendulum.py</span></tt>.</p>
</div>
<div class="section" id="exercise-20-analysis-of-the-euler-cromer-scheme">
<span id="vib-exer-eulercromer-analysis"></span><h2>Exercise 20: Analysis of the Euler-Cromer scheme<a class="headerlink" href="#exercise-20-analysis-of-the-euler-cromer-scheme" title="Permalink to this headline">¶</a></h2>
<p>The Euler-Cromer scheme for the model problem
<span class="math">\(u'' + \omega^2 u =0\)</span>, <span class="math">\(u(0)=I\)</span>, <span class="math">\(u'(0)=0\)</span>, is given in
<a class="reference internal" href="._main_vib001.html#eq-vib-model2x2-eulercromer-ueq1b"><em>(2.26)</em></a>-<a class="reference internal" href="._main_vib001.html#eq-vib-model2x2-eulercromer-veq1b"><em>(2.25)</em></a>.
Find the exact discrete solutions of this scheme and show that the solution
for <span class="math">\(u^n\)</span> coincides with that found in the section <a class="reference internal" href="._main_vib001.html#vib-ode1-analysis"><em>Analysis of the numerical scheme</em></a>.</p>
<p><strong>Hint.</strong>
Use an &#8220;ansatz&#8221; <span class="math">\(u^n=I\exp{(i\tilde\omega\Delta t\,n)}\)</span> and
<span class="math">\(v^=qu^n\)</span>, where <span class="math">\(\tilde\omega\)</span> and <span class="math">\(q\)</span> are unknown parameters. The formula</p>
<div class="math">
\[\exp{(i\tilde\omega(\Delta t))} + \exp{(i\tilde\omega(-\Delta t))} - 2
= 2\left(\cosh(i\tilde\omega\Delta t) -1 \right)
=-4\sin^2(\frac{\tilde\omega\Delta t}{2}),\]</div>
<p>becomes handy.</p>
</div>
</div>
<div class="section" id="references">
<h1>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h1>
<table class="docutils citation" frame="void" id="ref1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[Ref1]</a></td><td><strong>H. P. Langtangen</strong>. Introduction to Computing With Finite Difference Methods,
<em>Simula Research Laboratory and University of Oslo</em>,
2013,
<a class="reference external" href="http://hplgit.github.com/INF5620/doc/notes/decay-sphinx/main_decay.html">http://hplgit.github.com/INF5620/doc/notes/decay-sphinx/main_decay.html</a>.</td></tr>
</tbody>
</table>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Generalization: damping, nonlinear spring, and external excitation</a><ul>
<li><a class="reference internal" href="#a-centered-scheme-for-linear-damping">A centered scheme for linear damping</a></li>
<li><a class="reference internal" href="#a-centered-scheme-for-quadratic-damping">A centered scheme for quadratic damping</a></li>
<li><a class="reference internal" href="#a-forward-backward-discretization-of-the-quadratic-damping-term">A forward-backward discretization of the quadratic damping term</a></li>
<li><a class="reference internal" href="#implementation-3">Implementation  (3)</a></li>
<li><a class="reference internal" href="#verification-2">Verification  (2)</a><ul>
<li><a class="reference internal" href="#constant-solution">Constant solution</a></li>
<li><a class="reference internal" href="#linear-solution">Linear solution</a></li>
<li><a class="reference internal" href="#quadratic-solution">Quadratic solution</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization">Visualization</a></li>
<li><a class="reference internal" href="#user-interface">User interface</a></li>
<li><a class="reference internal" href="#the-euler-cromer-scheme-for-the-generalized-model">The Euler-Cromer scheme for the generalized model</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-and-problems">Exercises and Problems</a><ul>
<li><a class="reference internal" href="#problem-1-use-linear-quadratic-functions-for-verification">Problem 1: Use linear/quadratic functions for verification</a></li>
<li><a class="reference internal" href="#exercise-2-show-linear-growth-of-the-phase-with-time">Exercise 2: Show linear growth of the phase with time</a></li>
<li><a class="reference internal" href="#exercise-3-improve-the-accuracy-by-adjusting-the-frequency">Exercise 3: Improve the accuracy by adjusting the frequency</a></li>
<li><a class="reference internal" href="#exercise-4-see-if-adaptive-methods-improve-the-phase-error">Exercise 4: See if adaptive methods improve the phase error</a></li>
<li><a class="reference internal" href="#exercise-5-use-a-taylor-polynomial-to-compute">Exercise 5: Use a Taylor polynomial to compute <span class="math">\(u^1\)</span></a></li>
<li><a class="reference internal" href="#exercise-6-find-the-minimal-resolution-of-an-oscillatory-function">Exercise 6: Find the minimal resolution of an oscillatory function</a></li>
<li><a class="reference internal" href="#exercise-7-visualize-the-accuracy-of-finite-differences-for-a-cosine-function">Exercise 7: Visualize the accuracy of finite differences for a cosine function</a></li>
<li><a class="reference internal" href="#exercise-8-verify-convergence-rates-of-the-error-in-energy">Exercise 8: Verify convergence rates of the error in energy</a></li>
<li><a class="reference internal" href="#exercise-9-use-linear-quadratic-functions-for-verification">Exercise 9: Use linear/quadratic functions for verification</a></li>
<li><a class="reference internal" href="#exercise-10-use-an-exact-discrete-solution-for-verification">Exercise 10: Use an exact discrete solution for verification</a></li>
<li><a class="reference internal" href="#exercise-11-use-analytical-solution-for-convergence-rate-tests">Exercise 11: Use analytical solution for convergence rate tests</a></li>
<li><a class="reference internal" href="#exercise-12-investigate-the-amplitude-errors-of-many-solvers">Exercise 12: Investigate the amplitude errors of many solvers</a></li>
<li><a class="reference internal" href="#exercise-13-minimize-memory-usage-of-a-vibration-solver">Exercise 13: Minimize memory usage of a vibration solver</a></li>
<li><a class="reference internal" href="#exercise-14-implement-the-solver-via-classes">Exercise 14: Implement the solver via classes</a></li>
<li><a class="reference internal" href="#exercise-15-interpret-as-a-forward-backward-difference">Exercise 15: Interpret <span class="math">\([D_tD_t u]^n\)</span> as a forward-backward difference</a></li>
<li><a class="reference internal" href="#exercise-16-use-the-forward-backward-scheme-with-quadratic-damping">Exercise 16: Use the forward-backward scheme with quadratic damping</a></li>
<li><a class="reference internal" href="#exercise-17-use-a-backward-difference-for-the-damping-term">Exercise 17: Use a backward difference for the damping term</a></li>
<li><a class="reference internal" href="#exercise-18-simulate-a-bouncing-ball">Exercise 18: Simulate a bouncing ball</a></li>
<li><a class="reference internal" href="#exercise-19-simulate-an-elastic-pendulum">Exercise 19: Simulate an elastic pendulum</a></li>
<li><a class="reference internal" href="#exercise-20-analysis-of-the-euler-cromer-scheme">Exercise 20: Analysis of the Euler-Cromer scheme</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_vib001.html"
                        title="previous chapter">Finite difference discretization</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._main_vib002.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_vib001.html" title="Finite difference discretization"
             >previous</a> |</li>
        <li><a href="index.html">Finite difference methods for vibration problems</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>