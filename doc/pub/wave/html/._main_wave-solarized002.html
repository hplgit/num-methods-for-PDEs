<!--
Automatically generated HTML file from Doconce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Doconce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Finite difference methods for wave motion">
<meta name="keywords" content="waves on a string,wave equation 1D,wave equation 1D, finite difference method,mesh finite differences,stencil 1D wave equation,mesh function,wave equation 1D, implementation,unit testing,software testing nose,vectorization,scalar code,array slices,slice,lambda function (Python),Neumann conditions,Dirichlet conditions,homogeneous Neumann conditions,homogeneous Dirichlet conditions,boundary conditions Neumann,boundary conditions Dirichlet,stencil Neumann boundary,index set notation,geometric mean,arithmetic mean,harmonic average,averaging geometric,averaging arithmetic,averaging harmonic,wave equation 1D, analytical properties,Fourier series,Fourier transform,discrete Fourier transform,wave equation 1D, exact numerical solution,Courant number,stability criterion,wave equation 1D, stability,wave equation 2D, implementation,index set notation,Cython,declaration of variables in Cython,C extension module,wrapper code,Fortran subroutine,row-major ordering,column-major ordering,Fortran array storage,C/Python array storage,radiation condition,open boundary condition,boundary condition open (radiation),periodic boundary conditions,boundary conditions periodic">




<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="http://www.peterhaschke.com/assets/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>

</head>

<!-- tocinfo
{'highest level': 1,
 'sections': [(' Simulation of waves on a string ',
               1,
               'wave:string',
               'wave:string'),
              (' Discretizing the domain ',
               2,
               'wave:string:mesh',
               'wave:string:mesh'),
              (' Uniform meshes ', 3, None, '___sec2'),
              (' The discrete solution ',
               2,
               'wave:string:numerical:sol',
               'wave:string:numerical:sol'),
              (' Fulfilling the equation at the mesh points ',
               2,
               'wave:string:samplingPDE',
               'wave:string:samplingPDE'),
              (' Replacing derivatives by finite differences ',
               2,
               'wave:string:fd',
               'wave:string:fd'),
              (' Algebraic version of the PDE ', 3, None, '___sec6'),
              (' Algebraic version of the initial conditions ',
               3,
               None,
               '___sec7'),
              (' Formulating a recursive algorithm ',
               2,
               'wave:string:alg',
               'wave:string:alg'),
              (' Sketch of an implementation ',
               2,
               'wave:string:impl',
               'wave:string:impl'),
              (' Verification ', 1, None, '___sec10'),
              (' A slightly generalized model problem ',
               2,
               'wave:pde2:fd',
               'wave:pde2:fd'),
              (' Using an analytical solution of physical significance ',
               2,
               'wave:pde2:fd:standing:waves',
               'wave:pde2:fd:standing:waves'),
              (' Manufactured solution ',
               2,
               'wave:pde2:fd:MMS',
               'wave:pde2:fd:MMS'),
              (' Constructing an exact solution of the discrete equations ',
               2,
               'wave:pde2:fd:verify:quadratic',
               'wave:pde2:fd:verify:quadratic'),
              (' Implementation ', 1, 'wave:pde1:impl', 'wave:pde1:impl'),
              (' Making a solver function ',
               2,
               'wave:pde1:impl:solver',
               'wave:pde1:impl:solver'),
              (' Verification: exact quadratic solution ',
               2,
               'wave:pde1:impl:verify:quadratic',
               'wave:pde1:impl:verify:quadratic'),
              (' Visualization: animating the solution ',
               2,
               'wave:pde1:impl:animate',
               'wave:pde1:impl:animate'),
              (' Visualization via SciTools ', 3, None, '___sec19'),
              (' Making movie files ', 3, None, '___sec20'),
              (' Skipping frames for animation speed ', 3, None, '___sec21'),
              (' Visualization via Matplotlib ', 3, None, '___sec22'),
              (' Running a case ',
               2,
               'wave:pde1:guitar:data',
               'wave:pde1:guitar:data'),
              (' The benefits of scaling ', 2, None, '___sec24'),
              (' Vectorization ',
               1,
               'wave:pde1:impl:vec',
               'wave:pde1:impl:vec'),
              (' Operations on slices of arrays ',
               2,
               'wave:pde1:impl:vec:slices:basics',
               'wave:pde1:impl:vec:slices:basics'),
              (' Finite difference schemes expressed as slices ',
               2,
               'wave:pde1:impl:vec:slices:fdm',
               'wave:pde1:impl:vec:slices:fdm'),
              (' Verification ',
               2,
               'wave:pde1:impl:vec:verify:quadratic',
               'wave:pde1:impl:vec:verify:quadratic'),
              (' Efficiency measurements ', 2, None, '___sec29'),
              (' Exercises ', 1, None, '___sec30'),
              (' Exercise 1: Simulate a standing wave ',
               2,
               'wave:exer:standingwave',
               'wave:exer:standingwave'),
              (' Remarks ', 3, None, '___sec32'),
              (' Exercise 2: Add storage of solution in a user action function ',
               2,
               'wave:exer:store:list',
               'wave:exer:store:list'),
              (' Exercise 3: Use a class for the user action function ',
               2,
               'wave:exer:store:list:class',
               'wave:exer:store:list:class'),
              (' Exercise 4: Compare several Courant numbers in one movie ',
               2,
               'wave:exer:multiple:C',
               'wave:exer:multiple:C'),
              (' Project 5: Calculus with 1D mesh functions ',
               2,
               'wave:exer:mesh1D:calculus',
               'wave:exer:mesh1D:calculus'),
              (' Generalization: reflecting boundaries ',
               1,
               'wave:pde2:Neumann',
               'wave:pde2:Neumann'),
              (' Neumann boundary condition ',
               2,
               'wave:pde2:Neumann:bc',
               'wave:pde2:Neumann:bc'),
              (' Discretization of derivatives at the boundary ',
               2,
               'wave:pde2:Neumann:discr',
               'wave:pde2:Neumann:discr'),
              (' Implementation of Neumann conditions ',
               2,
               'wave:pde2:Neumann:impl',
               'wave:pde2:Neumann:impl'),
              (' Index set notation ', 2, 'wave:indexset', 'wave:indexset'),
              (' Alternative implementation via ghost cells ',
               2,
               'wave:pde1:Neumann:ghost',
               'wave:pde1:Neumann:ghost'),
              (' Idea ', 3, None, '___sec43'),
              (' Implementation ', 3, None, '___sec44'),
              (' Generalization: variable wave velocity ',
               1,
               'wave:pde2:var:c',
               'wave:pde2:var:c'),
              (' The model PDE with a variable coefficient ',
               2,
               None,
               '___sec46'),
              (' Discretizing the variable coefficient ',
               2,
               'wave:pde2:var:c:ideas',
               'wave:pde2:var:c:ideas'),
              (' Computing the coefficient between mesh points ',
               2,
               'wave:pde2:var:c:means',
               'wave:pde2:var:c:means'),
              (' How a variable coefficient affects the stability ',
               2,
               'wave:pde2:var:c:stability',
               'wave:pde2:var:c:stability'),
              (' Neumann condition and a variable coefficient ',
               2,
               'wave:pde2:var:c:Neumann',
               'wave:pde2:var:c:Neumann'),
              (' Implementation of variable coefficients ',
               2,
               'wave:pde2:var:c:impl',
               'wave:pde2:var:c:impl'),
              (' A more general model PDE with variable coefficients ',
               2,
               None,
               '___sec52'),
              (' Generalization: damping ', 2, None, '___sec53'),
              (' Building a general 1D wave equation solver ',
               1,
               'wave:pde2:software',
               'wave:pde2:software'),
              (' User action function as a class ', 2, None, '___sec55'),
              (' Pulse propagation in two media ', 2, None, '___sec56'),
              (' Exercises ', 1, None, '___sec57'),
              (' Exercise 6: Find the analytical solution to a damped wave equation ',
               2,
               'wave:exer:standingwave:damped:uex',
               'wave:exer:standingwave:damped:uex'),
              (' Problem 7: Explore symmetry boundary conditions ',
               2,
               'wave:exer:symmetry:bc',
               'wave:exer:symmetry:bc'),
              (' Exercise 8: Send pulse waves through a layered medium ',
               2,
               'wave:app:exer:pulse1D',
               'wave:app:exer:pulse1D'),
              (' Exercise 9: Compare discretizations of a Neumann condition ',
               2,
               None,
               '___sec61'),
              (' Exercise 10: Verification by a cubic polynomial in space ',
               2,
               'wave:fd2:exer:verify:cubic',
               'wave:fd2:exer:verify:cubic'),
              (' Analysis of the difference equations ',
               1,
               'wave:pde1:analysis',
               'wave:pde1:analysis'),
              (' Properties of the solution of the wave equation ',
               2,
               'wave:pde1:properties',
               'wave:pde1:properties'),
              (' More precise definition of Fourier representations ',
               2,
               'wave:pde1:Fourier',
               'wave:pde1:Fourier'),
              (' Stability ',
               2,
               'wave:pde1:stability',
               'wave:pde1:stability'),
              (' Preliminary results ', 3, None, '___sec67'),
              (' Numerical wave propagation ', 3, None, '___sec68'),
              (' Numerical dispersion relation ',
               2,
               'wave:pde1:num:dispersion',
               'wave:pde1:num:dispersion'),
              (' Extending the analysis to 2D and 3D ',
               2,
               'wave:pde1:analysis:2D3D',
               'wave:pde1:analysis:2D3D'),
              (' Finite difference methods for 2D and 3D wave equations ',
               1,
               'wave:2D3D',
               'wave:2D3D'),
              (' Multi-dimensional wave equations ',
               2,
               'wave:2D3D:models',
               'wave:2D3D:models'),
              (' Mesh ', 2, 'wave:2D3D:mesh', 'wave:2D3D:mesh'),
              (' Discretization ', 2, 'wave:2D3D:models', 'wave:2D3D:models'),
              (' Discretizing the PDEs ', 3, None, '___sec75'),
              (' Handling boundary conditions where is $u$ known ',
               3,
               None,
               '___sec76'),
              (' Discretizing the Neumann condition ', 3, None, '___sec77'),
              (' Implementation ', 1, 'wave:2D3D:impl', 'wave:2D3D:impl'),
              (' Scalar computations ',
               2,
               'wave2D3D:impl:scalar',
               'wave2D3D:impl:scalar'),
              (' Domain and mesh ', 3, None, '___sec80'),
              (' Solution arrays ', 3, None, '___sec81'),
              (' Index sets ', 3, None, '___sec82'),
              (' Computing the solution ', 3, None, '___sec83'),
              (' Vectorized computations ',
               2,
               'wave2D3D:impl:vectorized',
               'wave2D3D:impl:vectorized'),
              (' Verification ',
               2,
               'wave2D3D:impl:verify',
               'wave2D3D:impl:verify'),
              (' Testing a quadratic solution ', 3, None, '___sec86'),
              (' Migrating loops to Cython ',
               1,
               'wave2D3D:impl:Cython',
               'wave2D3D:impl:Cython'),
              (' Declaring variables and annotating the code ',
               2,
               None,
               '___sec88'),
              (' Visual inspection of the C translation ',
               2,
               None,
               '___sec89'),
              (' Building the extension module ', 2, None, '___sec90'),
              (' Calling the Cython function from Python ',
               2,
               None,
               '___sec91'),
              (' Efficiency ', 3, None, '___sec92'),
              (' Migrating loops to Fortran ', 1, None, '___sec93'),
              (' The Fortran subroutine ', 2, None, '___sec94'),
              (' Building the Fortran module with f2py ',
               2,
               None,
               '___sec95'),
              (' How to avoid array copying ', 2, None, '___sec96'),
              (' Efficiency ', 3, None, '___sec97'),
              (' Migrating loops to C via Cython ', 1, None, '___sec98'),
              (' Translating index pairs to single indices ',
               2,
               None,
               '___sec99'),
              (' The complete C code ', 2, None, '___sec100'),
              (' The Cython interface file ', 2, None, '___sec101'),
              (' Building the extension module ', 2, None, '___sec102'),
              (' Efficiency ', 3, None, '___sec103'),
              (' Migrating loops to C via f2py ', 1, None, '___sec104'),
              (' Migrating loops to C++ via f2py ', 2, None, '___sec105'),
              (' Using classes to implement a simulator ',
               1,
               None,
               '___sec106'),
              (' Exercises ', 1, None, '___sec107'),
              (' Exercise 11: Check that a solution fulfills the discrete model ',
               2,
               'wave:exer:quadratic:2D',
               'wave:exer:quadratic:2D'),
              (' Project 12: Calculus with 2D/3D mesh functions ',
               2,
               'wave:exer:mesh3D:calculus',
               'wave:exer:mesh3D:calculus'),
              (' Exercise 13: Implement Neumann conditions in 2D ',
               2,
               'wave:app:exer:wave2D:Neumann',
               'wave:app:exer:wave2D:Neumann'),
              (' Exercise 14: Test the efficiency of compiled loops in 3D ',
               2,
               'wave:exer:3D:f77:cy:efficiency',
               'wave:exer:3D:f77:cy:efficiency'),
              (' Applications of wave equations ', 1, 'wave:app', 'wave:app'),
              (' Waves on a string ',
               2,
               'wave:app:string',
               'wave:app:string'),
              (' Damping ', 3, None, '___sec114'),
              (' External forcing ', 3, None, '___sec115'),
              (' Modeling the tension via springs ', 3, None, '___sec116'),
              (' Waves on a membrane ',
               2,
               'wave:app:membrane',
               'wave:app:membrane'),
              (' Elastic waves in a rod ',
               2,
               'wave:app:elastic:rod',
               'wave:app:elastic:rod'),
              (' The acoustic model for seismic waves ',
               2,
               'wave:app:acoustic:seismic',
               'wave:app:acoustic:seismic'),
              (' Anisotropy ', 3, None, '___sec120'),
              (' Sound waves in liquids and gases ',
               2,
               'wave:app:sound',
               'wave:app:sound'),
              (' Spherical waves ',
               2,
               'wave:app:spherical',
               'wave:app:spherical'),
              (' The linear shallow water equations ',
               2,
               'wave:app:sw:2D',
               'wave:app:sw:2D'),
              (' Wind drag on the surface ', 3, None, '___sec124'),
              (' Bottom drag ', 3, None, '___sec125'),
              (" Effect of the Earth's rotation ", 3, None, '___sec126'),
              (' Waves in blood vessels ',
               2,
               'wave:app:blood',
               'wave:app:blood'),
              (' Electromagnetic waves ',
               2,
               'wave:app:light',
               'wave:app:light'),
              (' Exercises ', 1, 'wave:app:exer', 'wave:app:exer'),
              (' Exercise 15: Simulate waves on a non-homogeneous string ',
               2,
               'wave:app:exer:string:discont',
               'wave:app:exer:string:discont'),
              (' Exercise 16: Simulate damped waves on a string ',
               2,
               'wave:app:exer:string:damping',
               'wave:app:exer:string:damping'),
              (' Exercise 17: Simulate elastic waves in a rod ',
               2,
               'wave:app:exer:rod',
               'wave:app:exer:rod'),
              (' Exercise 18: Simulate spherical waves ',
               2,
               'wave:app:exer:spherical',
               'wave:app:exer:spherical'),
              (' Exercise 19: Explain why numerical noise occurs ',
               2,
               'wave:app:exer:pulse1D:analysis',
               'wave:app:exer:pulse1D:analysis'),
              (' Exercise 20: Investigate harmonic averaging in a 1D model ',
               2,
               'wave:app:exer:pulse1D:harmonic',
               'wave:app:exer:pulse1D:harmonic'),
              (' Problem 21: Implement open boundary conditions ',
               2,
               'wave:app:exer:radiationBC',
               'wave:app:exer:radiationBC'),
              (' Remarks ', 3, None, '___sec137'),
              (' Exercise 22: Implement periodic boundary conditions ',
               2,
               'wave:exer:periodic',
               'wave:exer:periodic'),
              (' Problem 23: Earthquake-generated tsunami over a subsea hill ',
               2,
               'wave:app:exer:tsunami1D:hill',
               'wave:app:exer:tsunami1D:hill'),
              (' Problem 24: Earthquake-generated tsunami over a 3D hill ',
               2,
               'wave:app:exer:tsunami2D:hill',
               'wave:app:exer:tsunami2D:hill'),
              (' Problem 25: Investigate Matplotlib for visualization ',
               2,
               'wave:app:exer:tsunami:hill:viz:matplotlib',
               'wave:app:exer:tsunami:hill:viz:matplotlib'),
              (' Problem 26: Investigate visualization packages ',
               2,
               'wave:app:exer:tsunami:hill:viz:packages',
               'wave:app:exer:tsunami:hill:viz:packages'),
              (' Problem 27: Implement loops in compiled languages ',
               2,
               'wave:app:exer:tsunami2D:hill:compiled',
               'wave:app:exer:tsunami2D:hill:compiled'),
              (' Exercise 28: Simulate seismic waves in 2D ',
               2,
               'wave:app:exer:seismic2D',
               'wave:app:exer:seismic2D'),
              (' Project 29: Model 3D acoustic waves in a room ',
               2,
               'wave:app:exer:acoustics',
               'wave:app:exer:acoustics'),
              (' Project 30: Solve a 1D transport equation ',
               2,
               'wave:app:exer:advec1D',
               'wave:app:exer:advec1D'),
              (' Problem 31: General analytical solution of a 1D damped wave equation ',
               2,
               'wave:app:exer:anal:damped:wave1D',
               'wave:app:exer:anal:damped:wave1D'),
              (' Problem 32: General analytical solution of a 2D damped wave equation ',
               2,
               'wave:app:exer:anal:damped:wave2D',
               'wave:app:exer:anal:damped:wave2D')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\tp}{\thinspace .}
\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\renewcommand{\u}{\boldsymbol{u}}
\newcommand{\f}{\boldsymbol{f}}
\newcommand{\stress}{\boldsymbol{\sigma}}
\newcommand{\I}{\boldsymbol{I}}
\newcommand{\T}{\boldsymbol{T}}
\newcommand{\ii}{\boldsymbol{i}}
\newcommand{\jj}{\boldsymbol{j}}
\newcommand{\kk}{\boldsymbol{k}}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\Iz}{\mathcal{I}_z}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Integer}{\mathbb{Z}}
$$




    
<a name="part0002"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_wave-solarized001.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_wave-solarized003.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1>Implementation <a name="wave:pde1:impl"></a></h1>

This section present the complete computational algorithm, its
implementation in Python code, animation of the solution,
and verification of the implementation.

<p>
A real implementation of the basic computational algorithm
from the sections <a href="._main_wave-solarized001.html#wave:string:alg">Formulating a recursive algorithm</a> and <a href="._main_wave-solarized001.html#wave:string:impl">Sketch of an implementation</a> can be
encapsulated in a function,
taking all the input data for the problem as arguments.  The physical
input data consists of \( c \), \( I(x) \), \( V(x) \), \( f(x,t) \), \( L \), and \( T \).
The numerical input is the mesh parameters \( \Delta t \) and \( \Delta x \).

<p>
Instead of specifying \( \Delta t \) <em>and</em> \( \Delta x \), we can specify
one of them and the Courant number \( C \) instead, since having
explicit control of the Courant number is convenient when investigating
the numerical method. Many find it natural to prescribe the
resolution of the spatial grid and set \( N_x \). The solver function
can then compute \( \Delta t = CL/(cN_x) \). However, for comparing
\( u(x,t) \) curves (as functions of \( x \)) for various Courant numbers,
especially in animations in time,
it is more convenient to keep \( \Delta t \) fixed for all \( C \) and
let \( \Delta x \) vary according to \( \Delta x = c\Delta t/C \).
(With \( \Delta t \) fixed, all frames correspond to the same time \( t \),
and plotting curves with different spatial resolution is trivial.)

<p>
The solution at all spatial points at a new time level is stored in an
array <code>u</code> (of length \( N_x+1 \)). We need to decide what do to with
this solution, e.g., visualize the curve, analyze the values, or write
the array to file for later use. The decision what to do is left to
the user in a suppled function
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">user_action</span>(u, x, t, n):
</pre></div>
<p>
where <code>u</code> is the solution at the spatial points <code>x</code> at time <code>t[n]</code>.

<h2>Making a solver function <a name="wave:pde1:impl:solver"></a></h2>

A first attempt at a solver function is listed below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, V, f, c, L, dt, C, T, user_action=<span style="color: #658b00">None</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Solve u_tt=c^2*u_xx + f on (0,L)x(0,T].&quot;&quot;&quot;</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    t = linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Mesh points in time</span>
    dx = dt*c/<span style="color: #658b00">float</span>(C)
    Nx = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(L/dx))
    x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)       <span style="color: #228B22"># Mesh points in space</span>
    C2 = C**<span style="color: #B452CD">2</span>                      <span style="color: #228B22"># Help variable in the scheme</span>
    <span style="color: #8B008B; font-weight: bold">if</span> f <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span> <span style="color: #8B008B">or</span> f == <span style="color: #B452CD">0</span> :
        f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">if</span> V <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span> <span style="color: #8B008B">or</span> V == <span style="color: #B452CD">0</span>:
        V = <span style="color: #8B008B; font-weight: bold">lambda</span> x: <span style="color: #B452CD">0</span>

    u   = zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution array at new time level</span>
    u_1 = zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution at 1 time level back</span>
    u_2 = zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution at 2 time levels back</span>

    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>;  t0 = time.clock()  <span style="color: #228B22"># for measuring CPU time</span>

    <span style="color: #228B22"># Load initial condition into u_1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,Nx+<span style="color: #B452CD">1</span>):
        u_1[i] = I(x[i])

    <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
        user_action(u_1, x, t, <span style="color: #B452CD">0</span>)

    <span style="color: #228B22"># Special formula for first time step</span>
    n = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        u[i] = u_1[i] + dt*V(x[i]) + \ 
               <span style="color: #B452CD">0.5</span>*C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>]) + \ 
               <span style="color: #B452CD">0.5</span>*dt**<span style="color: #B452CD">2</span>*f(x[i], t[n])
    u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>

    <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
        user_action(u, x, t, <span style="color: #B452CD">1</span>)

    <span style="color: #228B22"># Switch variables before next step</span>
    u_2[:], u_1[:] = u_1, u

    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
        <span style="color: #228B22"># Update all inner points at time t[n+1]</span>
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
            u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
                     C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>]) + \ 
                     dt**<span style="color: #B452CD">2</span>*f(x[i], t[n])

        <span style="color: #228B22"># Insert boundary conditions</span>
        u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>
        <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            <span style="color: #8B008B; font-weight: bold">if</span> user_action(u, x, t, n+<span style="color: #B452CD">1</span>):
                <span style="color: #8B008B; font-weight: bold">break</span>

        <span style="color: #228B22"># Switch variables before next step</span>
        u_2[:], u_1[:] = u_1, u

    cpu_time = t0 - time.clock()
    <span style="color: #8B008B; font-weight: bold">return</span> u, x, t, cpu_time
</pre></div>
<p>
<!-- Too trivial here: -->
<!-- Checking that a solution \( u^n_i \) stays constant throughout some -->
<!-- time steps is often of considerable help in tracking down bugs -->
<!-- in an implementation. A constant solution \( \uex = Q \) fulfills -->
<!-- the PDE problem <a href="._main_wave-solarized001.html#mjx-eqn-12">(12)</a>-<a href="._main_wave-solarized001.html#mjx-eqn-16">(16)</a> -->
<!-- if \( I(x)=Q \), \( V=0 \), \( u(0,t)=u(L,t)=Q \), and \( f=0 \) -->

<h2>Verification: exact quadratic solution <a name="wave:pde1:impl:verify:quadratic"></a></h2>

We use the test problem derived in the section <a href="._main_wave-solarized001.html#wave:pde2:fd">A slightly generalized model problem</a> for
verification. Here is a function realizing this verification as a
<!-- cite -->
nose test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">nose.tools</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">nt</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_quadratic</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Check that u(x,t)=x(L-x)(1+t/2) is exactly reproduced.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(x, t):
        <span style="color: #8B008B; font-weight: bold">return</span> x*(L-x)*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> u_exact(x, <span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">V</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0.5</span>*u_exact(x, <span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x, t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2</span>*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)*c**<span style="color: #B452CD">2</span>

    L = <span style="color: #B452CD">2.5</span>
    c = <span style="color: #B452CD">1.5</span>
    C = <span style="color: #B452CD">0.75</span>
    Nx = <span style="color: #B452CD">3</span>  <span style="color: #228B22"># Very coarse mesh for this exact test</span>
    dt = C*(L/Nx)/c
    T = <span style="color: #B452CD">18</span>

    u, x, t, cpu = solver(I, V, f, c, L, dt, C, T)
    u_e = u_exact(x, t[-<span style="color: #B452CD">1</span>])
    diff = <span style="color: #658b00">abs</span>(u - u_e).max()
    nt.assert_almost_equal(diff, <span style="color: #B452CD">0</span>, places=<span style="color: #B452CD">14</span>)
</pre></div>

<h2>Visualization: animating the solution <a name="wave:pde1:impl:animate"></a></h2>

Now that we have verified the implementation it is time to do a
real computation where we also display the evolution of the waves
on the screen.

<h3>Visualization via SciTools  <a name="___sec19"></a></h3>

The following <code>viz</code> function defines a <code>user_action</code>
callback function for plotting the solution at each time level:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">viz</span>(I, V, f, c, L, dt, C, T, umin, umax, animate=<span style="color: #658b00">True</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Run solver and visualize u at each time level.&quot;&quot;&quot;</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>, <span style="color: #008b45; text-decoration: underline">glob</span>, <span style="color: #008b45; text-decoration: underline">os</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">plot_u</span>(u, x, t, n):
        <span style="color: #CD5555">&quot;&quot;&quot;user_action function for solver.&quot;&quot;&quot;</span>
        plt.plot(x, u, <span style="color: #CD5555">&#39;r-&#39;</span>,
                 xlabel=<span style="color: #CD5555">&#39;x&#39;</span>, ylabel=<span style="color: #CD5555">&#39;u&#39;</span>,
                 axis=[<span style="color: #B452CD">0</span>, L, umin, umax],
                 title=<span style="color: #CD5555">&#39;t=%f&#39;</span> % t[n], show=<span style="color: #658b00">True</span>)
        <span style="color: #228B22"># Let the initial condition stay on the screen for 2</span>
        <span style="color: #228B22"># seconds, else insert a pause of 0.2 s between each plot</span>
        time.sleep(<span style="color: #B452CD">2</span>) <span style="color: #8B008B; font-weight: bold">if</span> t[n] == <span style="color: #B452CD">0</span> <span style="color: #8B008B; font-weight: bold">else</span> time.sleep(<span style="color: #B452CD">0.2</span>)
        plt.savefig(<span style="color: #CD5555">&#39;frame_%04d.png&#39;</span> % n)  <span style="color: #228B22"># for movie making</span>

    <span style="color: #228B22"># Clean up old movie frames</span>
    <span style="color: #8B008B; font-weight: bold">for</span> filename <span style="color: #8B008B">in</span> glob.glob(<span style="color: #CD5555">&#39;frame_*.png&#39;</span>):
        os.remove(filename)

    user_action = plot_u <span style="color: #8B008B; font-weight: bold">if</span> animate <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #658b00">None</span>
    u, x, t, cpu = solver(I, V, f, c, L, dt, C, T, user_action)

    <span style="color: #228B22"># Make movie files</span>
    fps = <span style="color: #B452CD">4</span>  <span style="color: #228B22"># Frames per second</span>
    plt.movie(<span style="color: #CD5555">&#39;frame_*.png&#39;</span>, encoder=<span style="color: #CD5555">&#39;html&#39;</span>, fps=fps,
              output_file=<span style="color: #CD5555">&#39;movie.html&#39;</span>)
    codec2ext = <span style="color: #658b00">dict</span>(flv=<span style="color: #CD5555">&#39;flv&#39;</span>, libx264=<span style="color: #CD5555">&#39;mp4&#39;</span>, libvpx=<span style="color: #CD5555">&#39;webm&#39;</span>,
                     libtheora=<span style="color: #CD5555">&#39;ogg&#39;</span>)
    filespec = <span style="color: #CD5555">&#39;frame_%04d.png&#39;</span>
    movie_program = <span style="color: #CD5555">&#39;avconv&#39;</span>  <span style="color: #228B22"># or &#39;ffmpeg&#39;</span>
    <span style="color: #8B008B; font-weight: bold">for</span> codec <span style="color: #8B008B">in</span> codec2ext:
        ext = codec2ext[codec]
        cmd = <span style="color: #CD5555">&#39;%(movie_program)s -r %(fps)d -i %(filespec)s &#39;</span>\ 
              <span style="color: #CD5555">&#39;-vcodec %(codec)s movie.%(ext)s&#39;</span> % <span style="color: #658b00">vars</span>()
        os.system(cmd)
</pre></div>
<p>
A function inside another function, like <code>plot_u</code> in the above code
segment, has access to <em>and remembers</em> all the local variables
in the surrounding code inside the <code>viz</code> function (!). This is known
in computer science as a <em>closure</em> and is very convenient to
program with. For example,
the <code>plt</code> and <code>time</code> modules defined outside <code>plot_u</code> are accessible for
<code>plot_u</code> when
the function is called (as <code>user_action</code>) in the <code>solver</code> function.
Some may think, however, that a class instead of a closure is a cleaner
and easier-to-understand implementation of
the user action function, see the section <a href="._main_wave-solarized003.html#wave:pde2:software">Building a general 1D wave equation solver</a>.

<h3>Making movie files  <a name="___sec20"></a></h3>

Several hardcopies of the animation are made from the
<code>frame_*.png</code> files. We use
the <code>avconv</code> (or <code>ffmpeg</code>) programs to combine individual
plot files to movies in modern
formats: Flash, MP4, Webm, and Ogg.
A typical <code>avconv</code> (or <code>ffmpeg</code>) command for creating a movie file
in Ogg format
with 4 frames per second built from a collection of
plot files with names generated by <code>frame_%04d.png</code>,
look like

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; avconv -r 4 -i frame_%04d.png -c:v libtheora movie.ogg
</pre></div>
<p>
The different formats require different video encoders (<code>-c:v</code>) to
be installed: Flash applies <code>flv</code>, WebM applies <code>libvpx</code>, and MP4
applies <code>libx264</code>:

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; avconv -r 4 -i frame_%04d.png -c:v flv movie.flv
Terminal&gt; avconv -r 4 -i frame_%04d.png -c:v libvpx movie.webm
Terminal&gt; avconv -r 4 -i frame_%04d.png -c:v libx264 movie.mp4
</pre></div>
<p>
Players like <code>vlc</code>, <code>mplayer</code>, <code>gxine</code>, and <code>totem</code>
can be used to play these movie files.

<p>
Note that padding the frame counter with zeros in the <code>frame_*.png</code>
files, as specified by the <code>%04d</code> format, is essential so that the wildcard
notation <code>frame_*.png</code> expands to the correct set of files.

<p>
The
<code>plt.movie</code> function also creates a <code>movie.html</code> file with a movie player
for displaying the <code>frame_*.png</code> files in a web browser.
This movie player can
be generated from the command line too

<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; scitools movie encoder=html output_file=movie.html \ 
          fps=4 frame_*.png
</pre></div>

<h3>Skipping frames for animation speed  <a name="___sec21"></a></h3>

Sometimes the time step is small and \( T \) is large, leading to an
inconveniently large number of plot files and a slow animation on the
screen. The solution to such a problem is to decide on a total number
of frames in the animation, <code>num_frames</code>, and plot the solution only at
every <code>every</code> frame. The total number of time levels (i.e., maximum
possible number of frames) is the length of <code>t</code>, <code>t.size</code>, and if we
want <code>num_frames</code>, we need to plot every <code>t.size/num_frames</code> frame:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">every = <span style="color: #658b00">int</span>(t.size/<span style="color: #658b00">float</span>(num_frames))
<span style="color: #8B008B; font-weight: bold">if</span> n % every == <span style="color: #B452CD">0</span> <span style="color: #8B008B">or</span> n == t.size-<span style="color: #B452CD">1</span>:
    st.plot(x, u, <span style="color: #CD5555">&#39;r-&#39;</span>, ...)
</pre></div>
<p>
The initial condition (<code>n=0</code>) is natural to include,
and as <code>n % every == 0</code> will very seldom be true for the
very final frame, we also ensure that <code>n == t.size-1</code> and hence
the final frame is included.

<p>
A simple choice of numbers may illustrate the formulas: say we have
801 frames in total (<code>t.size</code>) and we allow only 60 frames to be
plotted. Then we need to plot every 801/60 frame, which with integer
division yields 13 as <code>every</code>. Using the mod function, <code>n % every</code>,
this operation is zero every time <code>n</code> can be divided by 13 without a
remainder. That is, the <code>if</code> test is true when <code>n</code> equals \( 0, 13, 26,
39, ..., 780, 801 \). The associated code is included in the <code>plot_u</code>
function in the file <a href="http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_u0v.py" target="_self"><tt>wave1D_u0v.py</tt></a>.

<h3>Visualization via Matplotlib  <a name="___sec22"></a></h3>

The previous code based on the <code>plot</code> interface from <code>scitools.std</code>
can be run with Matplotlib as the visualization backend, but if one
desires to program directly with Matplotlib, quite different code
is needed. Matplotlib's interactive mode must be turned on:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
plt.ion()  <span style="color: #228B22"># interactive mode on</span>
</pre></div>
<p>
The most
commonly used animation technique with Matplotlib
is to update the data in the plot at each time level:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Make a first plot</span>
lines = plt.plot(t, u)
<span style="color: #228B22"># call plt.axis, plt.xlabel, plt.ylabel, etc. as desired</span>

<span style="color: #228B22"># At later time levels</span>
lines[<span style="color: #B452CD">0</span>].set_ydata(u)
plt.legend(<span style="color: #CD5555">&#39;t=%g&#39;</span> % t[n])
plt.draw()  <span style="color: #228B22"># make updated plot</span>
plt.savefig(...)
</pre></div>
<p>
An alternative is to rebuild the plot at every time level:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">plt.clf()        <span style="color: #228B22"># delete any previous curve(s)</span>
plt.axis([...])
plt.plot(t, u)
<span style="color: #228B22"># plt.xlabel, plt.legend and other decorations</span>
plt.draw()
plt.savefig(...)
</pre></div>
<p>
Many prefer to work with figure and axis objects as in MATLAB:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">fig = plt.figure()
...
fig.clf()
ax = fig.gca()
ax.axis(...)
ax.plot(t, u)
<span style="color: #228B22"># ax.set_xlabel, ax.legend and other decorations</span>
plt.draw()
fig.savefig(...)
</pre></div>
<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 1</b>: hardcopies via scitools movie or mencoder directly)</font>
<!-- end inline comment -->


<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 2</b>: need implementations!)</font>
<!-- end inline comment -->

<h2>Running a case <a name="wave:pde1:guitar:data"></a></h2>

The first demo of our 1D wave equation solver concerns vibrations of a
string that is initially deformed to a triangular shape, like when picking
a guitar string:

$$
\begin{equation}
I(x) = \left\lbrace
\begin{array}{ll}
ax/x_0, & x < x_0,\\ 
a(L-x)/(L-x_0), & \hbox{otherwise}
\end{array}\right.
\tag{119}
\end{equation}
$$

We choose \( L=75 \) cm, \( x_0=0.8L \), \( a=5 \) mm, and a time frequency
\( \nu = 440 \) Hz. The relation between the wave speed \( c \) and \( \nu \) is
\( c=\nu\lambda \), where \( \lambda \) is the wavelength, taken as \( 2L \) because
the longest wave on the string form half a wavelength. There is no
external force, so \( f=0 \), and the string is at rest initially so
that \( V=0 \).

<p>
Regarding numerical parameters, we need to specify a \( \Delta t \).
Sometimes it is more natural to think of a spatial resolution instead
of a time step. A natural semi-coarse spatial resolution in the present
problem is \( N_x=50 \). We can then choose the associated \( \Delta t \) (as required
by the <code>viz</code> and <code>solver</code> functions) as the stability limit:
\( \Delta t = L/(N_xc) \). This is the \( \Delta t \) to be specified,
but notice that if \( C<1 \), the actual \( \Delta x \) computed in <code>solver</code> gets
larger than \( L/N_x \): \( \Delta x = c\Delta t/C = L/(N_xC) \). (The reason
is that we fix \( \Delta t \) and adjust \( \Delta x \), so if \( C \) gets
smaller, the code implements this effect in terms of a larger \( \Delta x \).)

<p>
A function for setting the physical and numerical parameters and
calling <code>viz</code> in this application goes as follows:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">guitar</span>(C):
    <span style="color: #CD5555">&quot;&quot;&quot;Triangular wave (pulled guitar string).&quot;&quot;&quot;</span>
    L = <span style="color: #B452CD">0.75</span>
    x0 = <span style="color: #B452CD">0.8</span>*L
    a = <span style="color: #B452CD">0.005</span>
    freq = <span style="color: #B452CD">440</span>
    wavelength = <span style="color: #B452CD">2</span>*L
    c = freq*wavelength
    omega = <span style="color: #B452CD">2</span>*pi*freq
    num_periods = <span style="color: #B452CD">1</span>
    T = <span style="color: #B452CD">2</span>*pi/omega*num_periods
    <span style="color: #228B22"># Choose dt the same as the stability limit for Nx=50</span>
    dt = L/<span style="color: #B452CD">50.</span>/c

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> a*x/x0 <span style="color: #8B008B; font-weight: bold">if</span> x &lt; x0 <span style="color: #8B008B; font-weight: bold">else</span> a/(L-x0)*(L-x)

    umin = -<span style="color: #B452CD">1.2</span>*a;  umax = -umin
    cpu = viz(I, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0</span>, c, L, dt, C, T, umin, umax, animate=<span style="color: #658b00">True</span>)
</pre></div>
<p>
The associated program has the name <a href="http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_u0.py" target="_self"><tt>wave1D_u0.py</tt></a>. Run
the program and watch the <a href="http://tinyurl.com/k3sdbuv/pub/mov-wave/guitar_C0.8/index.html" target="_self">movie of the vibrating string</a>.

<p>

<!-- begin inline comment -->
<font color="red">(<b>hpl 3</b>: Must recompute these movies as \( \Delta t \) is different when \( C<1 \).)</font>
<!-- end inline comment -->

<h2>The benefits of scaling  <a name="___sec24"></a></h2>

The previous example demonstrated that quite some work is needed
with establishing relevant physical parameters for a case. By <em>scaling</em>
the mathematical problem we can often reduce the need to estimate
physical parameters dramatically. A scaling consists of introducing new
independent and dependent variables, with the aim that the absolute
value of these vary between 0 and 1:
$$ \bar x = \frac{x}{L},\quad \bar t = \frac{c}{L}t,\quad
\bar u = \frac{u}{a}
\tp
$$

Replacing old by new variables in the PDE, using \( f=0 \),
and dropping the bars, results in the <em>scaled equation</em>
\( u_{tt} = u_{xx} \). This equation has no physical parameter (!).

<p>
If we have a program implemented for the physical wave equation with
dimensions, we can obtain the dimensionless, scaled version by
setting \( c=1 \). The initial condition
corresponds to <a href="._main_wave-solarized010.html#mjx-eqn-119">(119)</a>, but with setting
\( a=1 \), \( L=1 \), and \( x_0\in [0,1] \). This means that we only need to
decide on the \( x_0 \) value as a fraction of unity, because
the scaled problem corresponds to setting all
other parameters to unity! In the code we can just set
<code>a=c=L=1</code>, <code>x0=0.8</code>, and there is no need to calculate with
wavelengths and frequencies to estimate \( c \).

<p>
The only non-trivial parameter to estimate in the scaled problem
is the final end time of the simulation, or more precisely, how it relates
to periods in periodic solutions in time, since we often want to
express the end time as a certain number of periods.
Suppose as \( u \) behaves as \( \sin (\omega t) \) in time in variables
with dimension. The corresponding period is \( P=2\pi/\omega \).
The frequency \( \omega \) is related to the wavelength \( \lambda \) of the waves
through the relations \( \omega = kc \) and \( k=2\pi/\lambda \), giving
\( \omega = 2\pi c/\lambda \) and \( P=\lambda/c \). It remains to estimate \( \lambda \).
With \( u(x,t)=F(x)\sin\omega t \) we find from \( u_{tt}=c^2u_{xx} \)
that \( c^2F'' + \omega^2F=0 \), and the boundary conditions demand
\( F(0)=F(L)=0 \). The solution is \( F(x)=\sin(x\pi/L) \), which has
wavelength \( \lambda = 2\pi/(\pi/L)=2L \). One period is therefore
given by \( P=2L/c \). The dimensionless period is \( \bar P=Pc/L = 2 \).

<h1>Vectorization <a name="wave:pde1:impl:vec"></a></h1>

The computational algorithm for solving the wave equation visits one
mesh point at a time and evaluates a formula for the new value \( u_i^{n+1} \)
at
that point. Technically, this is implemented by a loop over array
elements in a program. Such loops may run slowly in Python (and
similar interpreted languages such as R and MATLAB).
One technique for speeding up loops is to
perform operations on entire arrays instead of working with one element
at a time. This is referred to as <em>vectorization</em>, <em>vector computing</em>,
or <em>array computing</em>.
Operations on whole arrays are possible if the computations
involving each element is independent of each other and therefore can,
at least in principle, be performed simultaneously.
Vectorization not only speeds up the code on serial computers, but it
also makes it easy to exploit parallel computing.

<h2>Operations on slices of arrays <a name="wave:pde1:impl:vec:slices:basics"></a></h2>

Efficient computing with <code>numpy</code> arrays demands that we avoid loops
and compute with entire arrays at once (or at least large portions of them).
Consider this calculation of differences \( d_i = u_{i+1}-u_i \):
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">n = u.size
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, n-<span style="color: #B452CD">1</span>):
    d[i] = u[i+<span style="color: #B452CD">1</span>] - u[i]
</pre></div>
<p>
All the differences here are independent of each other.
The computation of <code>d</code> can therefore alternatively be done by
subtracting the array \( (u_0,u_1,\ldots,u_{n-1}) \) from
the array where the elements are shifted one index upwards:
\( (u_1,u_2,\ldots,u_n) \), see Figure <a href="#wave:pde1:vec:fig1">3</a>.
The former subset of the array can be
expressed by <code>u[0:n-1]</code>,
<code>u[0:-1]</code>, or just
<code>u[:-1]</code>, meaning from index 0 up to,
but not including, the last element (<code>-1</code>). The latter subset
is obtained by <code>u[1:n]</code> or <code>u[1:]</code>,
meaning from index 1 and the rest of the array.
The computation of <code>d</code> can now be done without an explicit Python loop:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">d = u[<span style="color: #B452CD">1</span>:] - u[:-<span style="color: #B452CD">1</span>]
</pre></div>
<p>
or with explicit limits if desired:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">d = u[<span style="color: #B452CD">1</span>:n] - u[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">1</span>]
</pre></div>
<p>
Indices with a colon, going from an index to (but not including) another
index are called <em>slices</em>. With <code>numpy</code> arrays, the computations
are still done by loops, but in efficient, compiled, highly optimized code
in C or Fortran. Such array operations can also easily be distributed
among many processors on parallel computers. We say that the <em>scalar code</em>
above, working on an element (a scalar) at a time, has been replaced by
an equivalent <em>vectorized code</em>. The process of vectorizing code is called
<em>vectorization</em>.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 3:  Illustration of subtracting two slices of two arrays. <a name="wave:pde1:vec:fig1"></a> </p></center>
<p><img src="fig-wave/vectorized_diff.png" align="bottom" width=400,></p>
</center>

<p>
<div class="alert alert-block alert-question alert-text-normal">
<b>Test the understanding.</b>
<p>
Newcomers to vectorization are encouraged to choose
a small array <code>u</code>, say with five elements,
and simulate with pen and paper
both the loop version and the vectorized version.
</div>


<p>
Finite difference schemes basically contains differences between array
elements with shifted indices. Consider the updating formula

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, n-<span style="color: #B452CD">1</span>):
    u2[i] = u[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u[i] + u[i+<span style="color: #B452CD">1</span>]
</pre></div>
<p>
The vectorization consists of replacing the loop by arithmetics on
slices of arrays of length <code>n-2</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u2 = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:]
u2 = u[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:n]   <span style="color: #228B22"># alternative</span>
</pre></div>
<p>
Note that <code>u2</code> here gets length <code>n-2</code>. If <code>u2</code> is already an array of
length <code>n</code> and we want to use the formula to update all the "inner"
elements of <code>u2</code>, as we will when solving a 1D wave equation, we can write
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]  = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:]
u2[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:n]   <span style="color: #228B22"># alternative</span>
</pre></div>
<p>
Pen and paper calculations with a small array will demonstrate what is
actually going on. The expression on the right-hand side are done in the
following steps, involving temporary arrays with intermediate results,
since we can only work with two arrays at a time in
arithmetic expressions:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">temp1 = <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]
temp2 = u[<span style="color: #B452CD">0</span>:-<span style="color: #B452CD">2</span>] - temp1
temp3 = temp2 + u[<span style="color: #B452CD">2</span>:]
u2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = temp3
</pre></div>
<p>
We can extend the previous example to a formula with an additional term computed
by calling a function:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x):
    <span style="color: #8B008B; font-weight: bold">return</span> x**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>

<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, n-<span style="color: #B452CD">1</span>):
    u2[i] = u[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u[i] + u[i+<span style="color: #B452CD">1</span>] + f(x[i])
</pre></div>
<p>
Assuming <code>u2</code>, <code>u</code>, and <code>x</code> all have length <code>n</code>, the vectorized
version becomes
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:] + f(x[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>])
</pre></div>

<h2>Finite difference schemes expressed as slices <a name="wave:pde1:impl:vec:slices:fdm"></a></h2>

We now have the necessary tools to vectorize the algorithm for
the wave equation. There are three loops: one for the initial condition,
one for the first time step, and finally the loop that is repeated for
all subsequent time levels. Since only the latter is repeated a potentially
large number of times, we limit the efforts of vectorizing the code
to this loop:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    u[i] = <span style="color: #B452CD">2</span>*u_1[i] - u_2[i] + \ 
           C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])
</pre></div>
<p>
The vectorized version becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = - u_2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + \ 
          C2*(u_1[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u_1[<span style="color: #B452CD">2</span>:])
</pre></div>
<p>
or
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:Nx] = <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:Nx]- u_2[<span style="color: #B452CD">1</span>:Nx] + \ 
          C2*(u_1[<span style="color: #B452CD">0</span>:Nx-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:Nx] + u_1[<span style="color: #B452CD">2</span>:Nx+<span style="color: #B452CD">1</span>])
</pre></div>
<p>
<!-- We may vectorize the other loops regarding the initial condition and -->
<!-- the first time step, but the effect will hardly be -->
<!-- noticeable in long time simulations. -->

<p>
The program
<a href="http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_u0v.py" target="_self"><tt>wave1D_u0v.py</tt></a>
contains a new version of the function <code>solver</code> where both the scalar
and the vectorized loops are included (the argument <code>version</code> is
set to <code>scalar</code> or <code>vectorized</code>, respectively).

<h2>Verification <a name="wave:pde1:impl:vec:verify:quadratic"></a></h2>

We may reuse the quadratic solution \( \uex(x,t)=x(L-x)(1+{\half}t) \) for
verifying also the vectorized code. A nose test can now test
both the scalar and the vectorized version. Moreover, we may
use a <code>user_action</code> function that compares the computed and exact
solution at each time level and performs a test:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_quadratic</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Check the scalar and vectorized versions work for</span>
<span style="color: #CD5555">    a quadratic u(x,t)=x(L-x)(1+t/2) that is exactly reproduced.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># The following function must work for x as array or scalar</span>
    u_exact = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: x*(L - x)*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)
    I = <span style="color: #8B008B; font-weight: bold">lambda</span> x: u_exact(x, <span style="color: #B452CD">0</span>)
    V = <span style="color: #8B008B; font-weight: bold">lambda</span> x: <span style="color: #B452CD">0.5</span>*u_exact(x, <span style="color: #B452CD">0</span>)
    <span style="color: #228B22"># f is a scalar (zeros_like(x) works for scalar x too)</span>
    f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: zeros_like(x) + <span style="color: #B452CD">2</span>*c**<span style="color: #B452CD">2</span>*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)

    L = <span style="color: #B452CD">2.5</span>
    c = <span style="color: #B452CD">1.5</span>
    C = <span style="color: #B452CD">0.75</span>
    Nx = <span style="color: #B452CD">3</span>  <span style="color: #228B22"># Very coarse mesh for this exact test</span>
    dt = C*(L/Nx)/c
    T = <span style="color: #B452CD">18</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assert_no_error</span>(u, x, t, n):
        u_e = u_exact(x, t[n])
        diff = <span style="color: #658b00">abs</span>(u - u_e).max()
        nt.assert_almost_equal(diff, <span style="color: #B452CD">0</span>, places=<span style="color: #B452CD">13</span>)

    solver(I, V, f, c, L, dt, C, T,
           user_action=assert_no_error, version=<span style="color: #CD5555">&#39;scalar&#39;</span>)
    solver(I, V, f, c, L, dt, C, T,
           user_action=assert_no_error, version=<span style="color: #CD5555">&#39;vectorized&#39;</span>)
</pre></div>
<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Lambda functions.</b>
<p>
The code segment above demonstrates how to achieve very
compact code with the use of lambda functions for the various
input parameters that require a Python function. In essence,

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%">f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: L*(x-t)**<span style="color: #B452CD">2</span>
</pre></div>
<p>
is equivalent to

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x, t):
    <span style="color: #8B008B; font-weight: bold">return</span> L(x-t)**<span style="color: #B452CD">2</span>
</pre></div>
<p>
Note that lambda functions can just contain a single expression and no
statements.

<p>
One advantage with lambda functions is that they can be used directly
in calls:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eee8d5"><pre style="line-height: 125%">solver(I=<span style="color: #8B008B; font-weight: bold">lambda</span> x: sin(pi*x/L), V=<span style="color: #B452CD">0</span>, f=<span style="color: #B452CD">0</span>, ...)
</pre></div>

</div>


<h2>Efficiency measurements  <a name="___sec29"></a></h2>

Running the <code>wave1D_u0v.py</code> code with the previous string vibration example
for \( N_x=50,100,200,400,800 \), and measuring the CPU time
(see the <code>run_efficiency_experiments</code> function), shows that the vectorized
code runs substantially faster: the scalar code uses approximately
a factor \( N_x/5 \) more time!

<p>
<!-- ===== Profiling code ===== better in 2D -->

<p>
<!-- ======= Storing simulation data ======= -->
<!-- plain files, NUumPyDB, XDMF, joblib, exercises with retrieval and comparison -->

<p>
<!-- ======= Programming with classes ======= -->
<!-- can integrate data storage and check pointing, or maybe do it later in 2D -->
<!-- with Cython, Fortran and C? Might have a very simple version here and -->
<!-- then a new, more sophisticated version in 2D. -->
<!-- Think about grabbing out all soft eng and -->
<!-- present in short course. Need to be self-contained. -->

<h1>Exercises  <a name="___sec30"></a></h1>

<!-- --- begin exercise --- -->

<h2>Exercise 1: Simulate a standing wave <a name="wave:exer:standingwave"></a></h2>

The purpose of this exercise is to simulate standing waves on \( [0,L] \)
and illustrate the error in the simulation.
Standing waves arise from an initial condition

$$ u(x,0)= A \sin\left(\frac{\pi}{L}mx\right),$$

where \( m \) is an integer and \( A \) is a freely chosen amplitude.
The corresponding exact solution can be computed and reads

$$ \uex(x,t) =  A\sin\left(\frac{\pi}{L}mx\right)
\cos\left(\frac{\pi}{L}mct\right)\tp
$$


<p>
<b>a)</b>
Explain that for a function \( \sin kx\cos \omega t \) the wave length
in space is \( \lambda = 2\pi /k \) and the period in time is \( P=2\pi/\omega \).
Use these expressions to find the wave length in space and period in
time of \( \uex \) above.

<p>
<b>b)</b>
Import the <code>solver</code> function <code>wave1D_u0.py</code> into a new file
where the <code>viz</code> function is reimplemented such that it
plots either the numerical <em>and</em> the exact solution, <em>or</em> the error.

<p>
<b>c)</b>
Make animations where you illustrate how the error
\( e^n_i =\uex(x_i, t_n)- u^n_i \)
develops and increases in time. Also make animations of
\( u \) and \( \uex \) simultaneously.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint 1.</b>
Quite long time simulations are needed in order to display significant
discrepancies between the numerical and exact solution.

<p>
<!-- --- end hint in exercise --- -->

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint 2.</b>
A possible set of parameters is \( L=12 \), \( m=9 \), \( c=2 \), \( A=1 \), \( N_x=80 \),
\( C=0.8 \). The error mesh function \( e^n \) can be simulated for 10 periods,
while 20-30 periods are needed to show significant differences between
the curves for the numerical and exact solution.

<p>
<!-- --- end hint in exercise --- -->

<p>
Filename: <code>wave_standing.py</code>.

<p>
<!-- Closing remarks for this Exercise -->

<h3>Remarks  <a name="___sec32"></a></h3>

The important
parameters for numerical quality are \( C \) and \( k\Delta x \), where
\( C=c\Delta t/\Delta x \) is the Courant number and \( k \) is defined above
(\( k\Delta x \) is proportional to how many mesh points we have per wave length
in space, see the section <a href="._main_wave-solarized004.html#wave:pde1:num:dispersion">Numerical dispersion relation</a> for explanation).

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 2: Add storage of solution in a user action function <a name="wave:exer:store:list"></a></h2>

Extend the <code>plot_u</code> function in the file <code>wave1D_u0.py</code> to also store
the solutions <code>u</code> in a list.
To this end, declare <code>all_u</code> as
an empty list in the <code>viz</code> function, outside <code>plot_u</code>, and perform
an append operation inside the <code>plot_u</code> function. Note that a
function, like <code>plot_u</code>, inside another function, like <code>viz</code>,
remembers all local variables in <code>viz</code> function, including <code>all_u</code>,
even when <code>plot_u</code> is called (as <code>user_action</code>) in the <code>solver</code> function.
Test both <code>all_u.append(u)</code> and <code>all_u.append(u.copy())</code>.
Why does one of these constructions fail to store the solution correctly?
Let the <code>viz</code> function return the <code>all_u</code> list
converted to a two-dimensional <code>numpy</code> array.
Filename: <code>wave1D_u0_s_store.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 3: Use a class for the user action function <a name="wave:exer:store:list:class"></a></h2>

Redo <a href="#wave:exer:store:list">Exercise 2: Add storage of solution in a user action function</a> using a class for the
user action function. That is, define a class <code>Action</code> where
the <code>all_u</code> list is an attribute, and implement the user action
function as a method (the special method <code>__call__</code> is a natural
choice). The class versions avoids that the user action function
depends on parameters defined outside the function (such as <code>all_u</code>
in <a href="#wave:exer:store:list">Exercise 2: Add storage of solution in a user action function</a>).
Filename: <code>wave1D_u0_s2c.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Exercise 4: Compare several Courant numbers in one movie <a name="wave:exer:multiple:C"></a></h2>

The goal of this exercise is to make movies where several curves,
corresponding to different Courant numbers, are visualized.
Import the <code>solver</code> function from the <code>wave1D_u0_s</code> movie
in a new file <code>wave_compare.py</code>. Reimplement the <code>viz</code> function
such that it can take a list of <code>C</code> values as argument
and create a movie with solutions corresponding to the given <code>C</code>
values. The <code>plot_u</code> function must be changed to store the solution
in an array (see <a href="#wave:exer:store:list">Exercise 2: Add storage of solution in a user action function</a> or
<a href="#wave:exer:store:list:class">Exercise 3: Use a class for the user action function</a> for details), <code>solver</code> must be
computed for each value of the Courant number, and finally
one must run through each time step and plot all the spatial
solution curves in one figure and store it in a file.

<p>
The challenge in such a visualization is to ensure that the curves in
one plot corresponds to the same time point. The easiest remedy is to
keep the time and space resolution constant and change the wave
velocity \( c \) to change the Courant number.
Filename: <code>wave_numerics_comparison.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<!-- --- begin exercise --- -->

<h2>Project 5: Calculus with 1D mesh functions <a name="wave:exer:mesh1D:calculus"></a></h2>

This project explores integration and differentiation of
mesh functions, both with scalar and vectorized implementations.
We are given a mesh function \( f_i \) on a spatial one-dimensional
mesh \( x_i=i\Delta x \), \( i=0,\ldots,N_x \), over the interval \( [a,b] \).

<p>
<b>a)</b>
Define the discrete derivative of \( f_i \) by using centered
differences at internal mesh points and one-sided differences
at the end points. Implement a scalar version of
the computation in a Python function and supply a nose test
for the linear case \( f(x)=4x-2.5 \) where the discrete derivative should
be exact.

<p>
<b>b)</b>
Vectorize the implementation of the discrete derivative.
Extend the nose test to check the validity of the implementation.

<p>
<b>c)</b>
To compute the discrete integral \( F_i \) of \( f_i \), we assume that
the mesh function \( f_i \) varies linearly between the mesh points.
Let \( f(x) \) be such a linear interpolant of \( f_i \). We then
have

$$ F_i = \int_{x_0}^{x_i} f(x) dx\tp$$

The exact integral of a piecewise linear function \( f(x) \) is
given by the Trapezoidal rule. S
how that if \( F_{i} \) is already computed, we can find \( F_{i+1} \)
from

$$ F_{i+1} = F_i + \half(f_i + f_{i+1})\Delta x\tp$$

Make a function for a scalar implementation of the discrete integral
as a mesh function. That is, the function should return
\( F_i \) for \( i=0,\ldots,N_x \).
For a nose test one can use the fact that the above defined
discrete integral of a linear
function (say \( f(x)=4x-2.5 \)) is exact.

<p>
<b>d)</b>
Vectorize the implementation of the discrete integral.
Extend the nose test to check the validity of the implementation.

<p>
<!-- --- begin hint in exercise --- -->

<p>
<b>Hint.</b>
Interpret the recursive formula for \( F_{i+1} \) as a sum.
Make an array with each element of the sum and use the "cumsum"
(<code>numpy.cumsum</code>) operation to compute the accumulative sum:
<code>numpy.cumsum([1,3,5])</code> is <code>[1,4,9]</code>.

<p>
<!-- --- end hint in exercise --- -->

<p>
<b>e)</b>
Create a class <code>MeshCalculus</code> that can integrate and differentiate
mesh functions. The class can just define some methods that call
the previously implemented Python functions. Here is an example
on the usage:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
calc = MeshCalculus(vectorized=<span style="color: #658b00">True</span>)
x = np.linspace(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">11</span>)        <span style="color: #228B22"># mesh</span>
f = np.exp(x)                    <span style="color: #228B22"># mesh function</span>
df = calc.differentiate(f, x)    <span style="color: #228B22"># discrete derivative</span>
F = calc.integrate(f, x)         <span style="color: #228B22"># discrete anti-derivative</span>
</pre></div>
<p>
Filename: <code>mesh_calculus_1D.py</code>.

<p>
<!-- --- end exercise --- -->

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._main_wave-solarized001.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._main_wave-solarized003.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

