
# Information about all exercises in the file main_wave.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.main_wave.exerinfo', 'r')
# exer = eval(f.read())
#
[{'answer': '',
  'closing_remarks': 'The important\nparameters for numerical quality are $C$ and $k\\Delta x$, where\n$C=c\\Delta t/\\Delta x$ is the Courant number and $k$ is defined above\n($k\\Delta x$ is proportional to how many mesh points we have per wave length\nin space, see Section ref{wave:pde1:num:dispersion} for explanation).',
  'file': ['wave_standing.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:standingwave',
  'no': 1,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Explain that for a function $\\sin kx\\cos \\omega t$ the wave length\nin space is $\\lambda = 2\\pi /k$ and the period in time is $P=2\\pi/\\omega$.\nUse these expressions to find the wave length in space and period in\ntime of $\\uex$ above.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Import the `solver` function `wave1D_u0.py` into a new file\nwhere the `viz` function is reimplemented such that it\nplots either the numerical *and* the exact solution, *or* the error.'},
            {'answer': '',
             'file': None,
             'hints': ['Quite long time simulations are needed in order to display significant\ndiscrepancies between the numerical and exact solution.',
                       'A possible set of parameters is $L=12$, $m=9$, $c=2$, $A=1$, $N_x=80$,\n$C=0.8$. The error mesh function $e^n$ can be simulated for 10 periods,\nwhile 20-30 periods are needed to show significant differences between\nthe curves for the numerical and exact solution.'],
             'solution': '',
             'text': 'Make animations where you illustrate how the error\n$e^n_i =\\uex(x_i, t_n)- u^n_i$\ndevelops and increases in time. Also make animations of\n$u$ and $\\uex$ simultaneously.'}],
  'text': 'The purpose of this exercise is to simulate standing waves on $[0,L]$\nand illustrate the error in the simulation.\nStanding waves arise from an initial condition\n\n!bt\n\\[ u(x,0)= A \\sin\\left(\\frac{\\pi}{L}mx\\right),\\]\n\n!et\nwhere $m$ is an integer and $A$ is a freely chosen amplitude.\nThe corresponding exact solution can be computed and reads\n\n!bt\n\\[ \\uex(x,t) =  A\\sin\\left(\\frac{\\pi}{L}mx\\right)\n\\cos\\left(\\frac{\\pi}{L}mct\\right)\\tp\n\\]\n\n!et',
  'title': 'Simulate a standing wave',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_u0_s_store.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:store:list',
  'no': 2,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Extend the `plot_u` function in the file `wave1D_u0.py` to also store\nthe solutions `u` in a list.\nTo this end, declare `all_u` as\nan empty list in the `viz` function, outside `plot_u`, and perform\nan append operation inside the `plot_u` function. Note that a\nfunction, like `plot_u`, inside another function, like `viz`,\nremembers all local variables in `viz` function, including `all_u`,\neven when `plot_u` is called (as `user_action`) in the `solver` function.\nTest both `all_u.append(u)` and `all_u.append(u.copy())`.\nWhy does one of these constructions fail to store the solution correctly?\nLet the `viz` function return the `all_u` list\nconverted to a two-dimensional `numpy` array.',
  'title': 'Add storage of solution in a user action function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_u0_s2c.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:store:list:class',
  'no': 3,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Redo Exercise ref{wave:exer:store:list} using a class for the\nuser action function. That is, define a class `Action` where\nthe `all_u` list is an attribute, and implement the user action\nfunction as a method (the special method `__call__` is a natural\nchoice). The class versions avoids that the user action function\ndepends on parameters defined outside the function (such as `all_u`\nin Exercise ref{wave:exer:store:list}).',
  'title': 'Use a class for the user action function',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave_numerics_comparison.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:multiple:C',
  'no': 4,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The goal of this exercise is to make movies where several curves,\ncorresponding to different Courant numbers, are visualized.\nImport the `solver` function from the `wave1D_u0_s` movie\nin a new file `wave_compare.py`. Reimplement the `viz` function\nsuch that it can take a list of `C` values as argument\nand create a movie with solutions corresponding to the given `C`\nvalues. The `plot_u` function must be changed to store the solution\nin an array (see Exercise ref{wave:exer:store:list} or\nref{wave:exer:store:list:class} for details), `solver` must be\ncomputed for each value of the Courant number, and finally\none must run through each time step and plot all the spatial\nsolution curves in one figure and store it in a file.\n\nThe challenge in such a visualization is to ensure that the curves in\none plot corresponds to the same time point. The easiest remedy is to\nkeep the time and space resolution constant and change the wave\nvelocity $c$ to change the Courant number.',
  'title': 'Compare several Courant numbers in one movie',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['mesh_calculus_1D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:mesh1D:calculus',
  'no': 5,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Define the discrete derivative of $f_i$ by using centered\ndifferences at internal mesh points and one-sided differences\nat the end points. Implement a scalar version of\nthe computation in a Python function and supply a nose test\nfor the linear case $f(x)=4x-2.5$ where the discrete derivative should\nbe exact.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Vectorize the implementation of the discrete derivative.\nExtend the nose test to check the validity of the implementation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'To compute the discrete integral $F_i$ of $f_i$, we assume that\nthe mesh function $f_i$ varies linearly between the mesh points.\nLet $f(x)$ be such a linear interpolant of $f_i$. We then\nhave\n\n!bt\n\\[ F_i = \\int_{x_0}^{x_i} f(x) dx\\tp\\]\n\n!et\nThe exact integral of a piecewise linear function $f(x)$ is\ngiven by the Trapezoidal rule. S\nhow that if $F_{i}$ is already computed, we can find $F_{i+1}$\nfrom\n\n!bt\n\\[ F_{i+1} = F_i + \\half(f_i + f_{i+1})\\Delta x\\tp\\]\n\n!et\nMake a function for a scalar implementation of the discrete integral\nas a mesh function. That is, the function should return\n$F_i$ for $i=0,\\ldots,N_x$.\nFor a nose test one can use the fact that the above defined\ndiscrete integral of a linear\nfunction (say $f(x)=4x-2.5$) is exact.'},
            {'answer': '',
             'file': None,
             'hints': ['Interpret the recursive formula for $F_{i+1}$ as a sum.\nMake an array with each element of the sum and use the "cumsum"\n(`numpy.cumsum`) operation to compute the accumulative sum:\n`numpy.cumsum([1,3,5])` is `[1,4,9]`.'],
             'solution': '',
             'text': 'Vectorize the implementation of the discrete integral.\nExtend the nose test to check the validity of the implementation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Create a class `MeshCalculus` that can integrate and differentiate\nmesh functions. The class can just define some methods that call\nthe previously implemented Python functions. Here is an example\non the usage:\n\n!bc pycod\nimport numpy as np\ncalc = MeshCalculus(vectorized=True)\nx = np.linspace(0, 1, 11)        # mesh\nf = np.exp(x)                    # mesh function\ndf = calc.differentiate(f, x)    # discrete derivative\nF = calc.integrate(f, x)         # discrete anti-derivative\n\n!ec'}],
  'text': 'This project explores integration and differentiation of\nmesh functions, both with scalar and vectorized implementations.\nWe are given a mesh function $f_i$ on a spatial one-dimensional\nmesh $x_i=i\\Delta x$, $i=0,\\ldots,N_x$, over the interval $[a,b]$.',
  'title': 'Calculus with 1D mesh functions',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['damped_waves.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:standingwave:damped:uex',
  'no': 6,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Consider the wave equation with damping (ref{wave:pde3}).\nThe goal is to find an exact solution to a wave problem with damping.\nA starting point is the standing wave solution from\nExercise ref{wave:exer:standingwave}. It becomes necessary to\ninclude a damping term $e^{-ct}$ and also have both a sine and cosine\ncomponent in time:\n\n!bt\n\\[ \\uex(x,t) =  e^{-\\beta t}\n\\sin kx \\left( A\\cos\\omega t\n+ B\\sin\\omega t\\right)\n\\tp\n\\]\n\n!et\nFind $k$ from the boundary conditions\n$u(0,t)=u(L,t)=0$. Then use the PDE to find constraints on\n$\\beta$, $\\omega$, $A$, and $B$.\nSet up a complete initial-boundary value problem\nand its solution.',
  'title': 'Find the analytical solution to a damped wave equation',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_symmetric'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:symmetry:bc',
  'no': 7,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': ['Symmetry of a function about $x=x_0$ means that\n$f(x_0+h) = f(x_0-h)$.'],
             'solution': '',
             'text': 'Argue why the symmetry boundary condition\nis $u_x=0$ at $x=0$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Perform simulations of the complete wave problem from\non $[-L,L]$. Thereafter, utilize the\nsymmetry of the solution and run a simulation\nin half of the domain $[0,L]$, using a boundary condition\nat $x=0$. Compare the two solutions and\nmake sure that they are the same.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Prove the symmetry property of the solution\nby setting up the complete initial-boundary value problem\nand showing that if $u(x,t)$ is a solution, then also $u(-x,t)$\nis a solution.'}],
  'text': 'Consider the simple "plug" wave where $\\Omega = [-L,L]$ and\n\n!bt\n\\begin{equation*} I(x) = \\left\\lbrace\\begin{array}{ll}\n1, & x\\in [-\\delta, \\delta],\\\\ \n0, & \\hbox{otherwise}\n\\end{array}\\right.\n\\end{equation*}\n\n!et\nfor some number $0 < \\delta < L$. The other initial condition is\n$u_t(x,0)=0$ and there is no source term $f$.\nThe boundary conditions can be set to $u=0$.\nThe solution to this problem is symmetric around $x=0$.\nThis means that we can simulate the wave process in only the half\nof the domain $[0,L]$.',
  'title': 'Explore symmetry boundary conditions',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['pulse1D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:pulse1D',
  'no': 8,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Use the `pulse` function in `wave1D_dn_vc.py` to investigate\nsending a pulse, located with its peak at $x=0$, through the\nmedium to the right where it hits another medium for $x\\in [0.7,0.9]$\nwhere the wave velocity is decreased by a factor $s_f$.\nReport what happens with a Gaussian pulse, a "cosine hat" pulse,\nhalf a "cosine hat" pulse, and a plug pulse for resolutions\n$N_x=40,80,160$, and $s_f=2,4$.  Use $C=1$\nin the medium outside $[0.7,0.9]$. Simulate until $T=2$.',
  'title': 'Send pulse waves through a layered medium',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 9,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Perform numerical experiments and find the convergence rate of the\nerror using\nthe approximation\nand (ref{wave:pde2:var:c:scheme:impl:Neumann2}).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': "Switch to $q(x)=\\cos(\\pi x/L)$, which is symmetric at $x=0,L$,\nand check the convergence rate\nof the scheme\n(ref{wave:pde2:var:c:scheme:impl:Neumann2}). Now,\n$q_{i-1/2}$ is a 2nd-order approximation to $q_i$,\n$q_{i-1/2}=q_i + 0.25q_i''\\Delta x^2 + \\cdots$, because $q_i'=0$\nfor $i=N_x$ (a similar argument can be applied to the case $i=0$)."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'A third discretization can be based on a simple and convenient,\nbut less accurate, one-sided difference:\n$u_{i}-u_{i-1}=0$ at $i=N_x$ and $u_{i+1}-u_i=0$ at $i=0$.\nDerive the resulting scheme in detail and implement it.\nRun experiments to establish the rate of convergence.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'A fourth technique is to view the scheme as\n\n!bt\n\\[ [D_tD_tu]^n_i = \\frac{1}{\\Delta x}\\left(\n[qD_xu]_{i+\\half}^n - [qD_xu]_{i-\\half}^n\\right)\n+ [f]_i^n,\\]\n\n!et\nand place the boundary at $x_{i+\\half}$, $i=N_x$, instead of\nexactly at the physical boundary. With this idea,\nwe can just set $[qD_xu]_{i+\\half}^n=0$. Derive the complete scheme\nusing this technique. The implementation of the boundary condition at\n$L-\\Delta x/2$ is $\\Oof{\\Delta x^2}$ accurate, but the interesting question\nis what impact the movement of the boundary has on the convergence\nrate (compute the errors as usual over the entire mesh).'}],
  'text': 'We have a 1D wave equation with variable wave velocity:\n$u_t=(qu_x)_x$.\nA Neumann condition $u_x$ at $x=0, L$ can be\ndiscretized as shown in (ref{wave:pde2:var:c:scheme:impl:Neumann})\nand (ref{wave:pde2:var:c:scheme:impl:Neumann2}).\n\nThe aim of this exercise is to examine the rate of the numerical\nerror when using different ways of discretizing the Neumann condition.\nAs test problem, $q=1+(x-L/2)^4$ can be used, with $f(x,t)$\nadapted such that the solution has a simple form, say\n$u(x,t)=\\cos (\\pi x/L)\\cos (\\omega t)$ for some $\\omega = \\sqrt{q}\\pi/L$.',
  'title': 'Compare discretizations of a Neumann condition',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_n0_test_cubic.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:fd2:exer:verify:cubic',
  'no': 10,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': ["To turn a `sympy` expression `e`, depending on a series of\nsymbols, say `x`, `t`, `dx`, `dt`, `L`, and `c`, into plain\nPython function `e_exact(x,t,L,dx,dt,c)`, one can write\n\n!bc pycod\ne_exact = sm.lambdify([x,t,L,dx,dt,c], e, 'numpy')\n\n!ec\nThe `'numpy'` argument is a good habit as the `e_exact` function\nwill then work with array arguments if it contains mathematical\nfunctions (but here we only do plain arithmetics, which automatically\nwork with arrays)."],
             'solution': '',
             'text': "One can insert $u$ in the discretized PDE and find the corresponding $f$.\nThen one can insert $u$ in the discretized boundary conditions.\nThis yields two equations for the four coefficients $a_0,\\ldots,a_3$.\nTo find the coefficients, one can set $a_0=0$ and $a_1=1$ for\nsimplicity and then determine $a_2$ and $a_3$. This approach will make\n$a_2$ and $a_3$ depend on $\\Delta x$ and $f$ will depend on both\n$\\Delta x$ and $\\Delta t$.\n\nUse `sympy` to perform analytical computations.\nA starting point is to define $u$ as follows:\n\n!bc pycod\ndef test_cubic1():\n    import sympy as sm\n    x, t, c, L, dx, dt = sm.symbols('x t c L dx dt')\n    i, n = sm.symbols('i n', integer=True)\n\n    # Assume discrete solution is a polynomial of degree 3 in x\n    T = lambda t: 1 + sm.Rational(1,2)*t  # Temporal term\n    a = sm.symbols('a_0 a_1 a_2 a_3')\n    X = lambda x: sum(a[q]*x**q for q in range(4))  # Spatial term\n    u = lambda x, t: X(x)*T(t)\n\n!ec\nThe symbolic expression for $u$ is reached by calling `u(x,t)`\nwith `x` and `t` as `sympy` symbols.\n\nDefine `DxDx(u, i, n)`, `DtDt(u, i, n)`, and `D2x(u, i, n)`\nas Python functions for returning the difference\napproximations $[D_xD_x u]^n_i$, $[D_tD_t u]^n_i$, and\n$[D_{2x}u]^n_i$. The next step is to set up the residuals\nfor the equations $[D_{2x}u]^n_0=0$ and $[D_{2x}u]^n_{N_x}=0$,\nwhere $N_x=L/\\Delta x$. Call the residuals `R_0` and `R_L`.\nSubstitute $a_0$ and $a_1$ by 0 and 1, respectively, in\n`R_0`, `R_L`, and `a`:\n\n!bc pycod\nR_0 = R_0.subs(a[0], 0).subs(a[1], 1)\nR_L = R_L.subs(a[0], 0).subs(a[1], 1)\na = list(a)  # enable in-place assignment\na[0:2] = 0, 1\n\n!ec\nDetermining $a_2$ and $a_3$ from the discretized boundary conditions\nis then about solving two equations with respect to $a_2$ and $a_3$,\ni.e., `a[2:]`:\n\n!bc pycod\ns = sm.solve([R_0, R_L], a[2:])\n# s is dictionary with the unknowns a[2] and a[3] as keys\na[2:] = s[a[2]], s[a[3]]\n\n!ec\nNow, `a` contains computed values and `u` will automatically use\nthese new values since `X` accesses `a`.\n\nCompute the source term $f$ from the discretized PDE:\n$f^n_i = [D_tD_t u - c^2D_xD_x u]^n_i$. Turn $u$, the time\nderivative $u_t$ (needed for the initial condition $V(x)$),\nand $f$ into Python functions. Set numerical values for\n$L$, $N_x$, $C$, and $c$. Prescribe the time interval as\n$\\Delta t = CL/(N_xc)$, which imply $\\Delta x = c\\Delta t/C = L/N_x$.\nDefine new functions `I(x)`, `V(x)`, and `f(x,t)` as wrappers of the ones\nmade above, where fixed values of $L$, $c$, $\\Delta x$, and $\\Delta t$\nare inserted, such that `I`, `V`, and `f` can be passed on to the\n`solver` function. Finally, call `solver` with a `user_action`\nfunction that compares the numerical solution to this exact\nsolution $u$ of the discrete PDE problem."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': "An alternative way of determining $a_0,\\ldots,a_3$ is to reason as\nfollows. We first construct $X(x)$ such that the boundary conditions\nare fulfilled: $X=x(L-x)$. However, to compensate for the fact\nthat this choice of $X$ does not fulfill the discrete boundary\ncondition, we seek $u$ such that\n\n!bt\n\\[ u_x = \\frac{\\partial}{\\partial x}x(L-x)T(t) - \\frac{1}{6}u_{xxx}\\Delta x^2,\\]\n\n!et\nsince this $u$ will fit the discrete boundary condition.\nAssuming $u=T(t)\\sum_{j=0}^3a_jx^j$, we can use the above equation to\ndetermine the coefficients $a_1,a_2,a_3$. A value, e.g., 1 can be used for\n$a_0$. The following `sumpy` code computes this $u$:\n\n!bc pycod\ndef test_cubic2():\n    import sympy as sm\n    x, t, c, L, dx = sm.symbols('x t c L dx')\n    T = lambda t: 1 + sm.Rational(1,2)*t  # Temporal term\n    # Set u as a 3rd-degree polynomial in space\n    X = lambda x: sum(a[i]*x**i for i in range(4))\n    a = sm.symbols('a_0 a_1 a_2 a_3')\n    u = lambda x, t: X(x)*T(t)\n    # Force discrete boundary condition to be zero by adding\n    # a correction term the analytical suggestion x*(L-x)*T\n    # u_x = x*(L-x)*T(t) - 1/6*u_xxx*dx**2\n    R = sm.diff(u(x,t), x) - (\n        x*(L-x) - sm.Rational(1,6)*sm.diff(u(x,t), x, x, x)*dx**2)\n    # R is a polynomial: force all coefficients to vanish.\n    # Turn R to Poly to extract coefficients:\n    R = sm.poly(R, x)\n    coeff = R.all_coeffs()\n    s = sm.solve(coeff, a[1:])  # a[0] is not present in R\n    # s is dictionary with a[i] as keys\n    # Fix a[0] as 1\n    s[a[0]] = 1\n    X = lambda x: sm.simplify(sum(s[a[i]]*x**i for i in range(4)))\n    u = lambda x, t: X(x)*T(t)\n    print 'u:', u(x,t)\n\n!ec\n\nThe next step is to find the source term `f_e` by inserting `u_e`\nin the PDE. Thereafter, turn `u`, `f`, and the time derivative of `u`\ninto plain Python functions as in a), and then wrap these functions\nin new functions `I`, `V`, and `f`, with the right signature as\nrequired by the `solver` function. Set parameters as in a) and\ncheck that the solution is exact to machine precision at each\ntime level using an appropriate `user_action` function."}],
  'text': 'The purpose of this exercise is to verify the implementation of the\n`solver` function in the program "`wave1D_n0.py`":\n"http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_n0.py" by using an exact numerical solution\nfor the wave equation $u_{tt}=c^2u_{xx} + f$ with Neumann boundary\nconditions $u_x(0,t)=u_x(L,t)=0$.\n\nA similar verification is used in the file "`wave1D_u0.py`":\n"http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_u0.py", which solves the same PDE, but with\nDirichlet boundary conditions $u(0,t)=u(L,t)=0$.  The idea of the\nverification test in function `test_quadratic` in `wave1D_u0.py` is to\na solution that is a lower-order polynomial such that both the PDE\nproblem, the boundary conditions, and all the discrete equations are\nexactly fulfilled. Then the `solver` function should reproduce this\nexact solution to machine precision.  More precisely, we seek\n$u=X(x)T(t)$, with $T(t)$ as a linear function and $X(x)$ as a\nparabola that fulfills the boundary conditions.  Inserting this $u$ in\nthe PDE determines $f$.  It tuns out that $u$ also fulfills the\ndiscrete equations, because the truncation error of the discretized\nPDE has derivatives in $x$ and $t$ of order four and higher. These\nderivatives all vanish for a quadratic $X(x)$ and linear $T(t)$.\n\nIt would be attractive to use a similar approach in the case of\nNeumann conditions. We set $u=X(x)T(t)$ and seek lower-order\npolynomials $X$ and $T$.\nTo force $u_x$ to vanish at the boundary, we let $X_x$ be\na parabola. Then $X$ is a cubic polynomial. The fourth-order\nderivative of a cubic polynomial vanishes, so $u=X(x)T(t)$\nwill fulfill the discretized PDE also in this case, if $f$\nis adjusted such that $u$ fulfills the PDE.\n\nHowever, the discrete boundary condition is not exactly fulfilled\nby this choice of $u$. The reason is that\n\n!bt\n\\begin{equation}\n[D_{2x}u]^n_i = u_{x}(x_i,t_n) + \\frac{1}{6}u_{xxx}(x_i,t_n)\\Delta x^2\n+ \\Oof{\\Delta x^4}\\tp\nlabel{wave:fd2:exer:verify:cubic:D2x}\n\\end{equation}\n\n!et\nAt the boundary two boundary points, $X_x(x)=0$ such that $u_x=0$.\nHowever, $u_{xxx}$ is a constant and not zero\nwhen $X(x)$ is a cubic polynomial.\nTherefore, our $u=X(x)T(t)$ fulfills\n\n!bt\n\\[ [D_{2x}u]^n_i = \\frac{1}{6}u_{xxx}(x_i,t_n)\\Delta x^2,\n\\]\n\n!et\nand not\n\n!bt\n\\[ [D_{2x}u]^n_i =0,quad i=0,N_x,\\]\n\n!et\nas it should. (Note that all the higher-order terms $\\Oof{\\Delta x^4}$\nalso have higher-order derivatives that vanish for a cubic polynomial.)\nSo to summarize, the fundamental problem is that $u$ as a product of\na cubic polynomial and a linear or quadratic polynomial in time\nis not an exact solution of the discrete boundary conditions.\n\nTo make progress,\nwe assume that $u=X(x)T(t)$, where $T$ for simplicity is taken as a\nprescribed linear function $1+\\frac{1}{2}t$, and $X(x)$ is taken\nas an *unknown* cubic polynomial $\\sum_{j=0}^3 a_jx^j$.\nThere are two different ways of determining the coefficients\n$a_0,\\ldots,a_3$ such that both the discretized PDE and the\ndiscretized boundary conditions are fulfilled, under the\nconstraint that we can specify a function $f(x,t)$ for the PDE to feed\nto the `solver` function in `wave1D_n0.py`. Both approaches\nare explained in the subexercises.\n\n\n#{wave:fd2:exer:verify:cubic:D2x}',
  'title': 'Verification by a cubic polynomial in space',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['check_quadratic_solution.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:quadratic:2D',
  'no': 11,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Carry out all mathematical details to show that\n(ref{wave2D3D:impl:verify:quadratic}) is indeed a solution of the\ndiscrete model for a 2D wave equation with $u=0$ on the boundary.\nOne must check the boundary conditions, the initial conditions,\nthe general discrete equation at a time level and the special\nversion of this equation for the first time level.',
  'title': 'Check that a solution fulfills the discrete model',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['mesh_calculus_3D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:mesh3D:calculus',
  'no': 12,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The goal of this project is to redo\nProject ref{wave:exer:mesh1D:calculus} with 2D and 3D\nmesh functions ($f_{i,j}$ and $_{fi,j,k}$).\n\n__Differentiation.__\nThe differentiation results in a discrete gradient\nfunction, which in the 2D case can be represented by a three-dimensional\narray `df[d,i,j]` where `d` represents the direction of\nthe derivative and `i` and `j` are mesh point counters in 2D\n(the 3D counterpart is `df[d,i,j,k]`).\n\n__Integration.__\nThe integral of a 2D mesh function $f_{i,j}$ is defined as\n\n!bt\n\\[ F_{i,j} = \\int_{y_0}^{y_j} \\int_{x_0}^{x_i} f(x,y)dxdy,\\]\n\n!et\nwhere $f(x,y)$ is a function that takes on the values of the\ndiscrete mesh function $f_{i,j}$ at the mesh points, but can also\nbe evaluated in between the mesh points. The particular variation\nbetween mesh points can be taken as bilinear, but this is not\nimportant as we will use a product Trapezoidal rule to approximate\nthe integral over a cell in the mesh and then we only need to\nevaluate $f(x,y)$ at the mesh points.\n\nSuppose $F_{i,j}$ is computed. The calculation of $F_{i+1,j}$\nis then\n\n!bt\n\\begin{align*}\nF_{i+1,j} &= F_{i,j} + \\int_{x_i}^{x_{i+1}}\\int_{y_0}^{y_j} f(x,y)dydx\\\\ \n&\\approx \\Delta x \\int_{y_0}^{y_j} f(x_{i+\\half},y)dy\\\\ \n& \\approx \\Delta x \\half\\left(\n\\int_{y_0}^{y_j} f(x_{i},y)dy\n+ \\int_{y_0}^{y_j} f(x_{i+1},y)dy\\right)\n\\end{align*}\n\n!et\nThe integrals in the $y$ direction can be approximated by a Trapezoidal\nrule. A similar idea can be used to compute $F_{i,j+1}$. Thereafter,\n$F_{i+1,j+1}$ can be computed by adding the integral over the final\ncorner cell to $F_{i+1,j} + F_{i,j+1} - F_{i,j}$. Carry out the\ndetails of these computations and extend the ideas to 3D.',
  'title': 'Calculus with 2D/3D mesh functions',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave2D_dn.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:wave2D:Neumann',
  'no': 13,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Modify the "`wave2D_u0.py`": "http://tinyurl.com/jvzzcfn/wave/wave2D_u0/wave2D_u0.py"\nprogram, which solves the 2D wave equation $u_{tt}=c^2(u_{xx}+u_{yy})$\nwith constant wave velocity $c$ and $u=0$ on the boundary, to have\nNeumann boundary conditions: $\\partial u/\\partial n=0$.\nInclude both scalar code (for debugging and reference) and\nvectorized code (for speed).\n\nTo test the code, use $u=1.2$ as solution ($I(x,y)=1.2$, $V=f=0$, and\n$c$ arbitrary), which should be exactly reproduced with any mesh\nas long as the stability criterion is satisfied.\nAnother test is to use the plug-shaped pulse\nin the `pulse` function from Section ref{wave:pde2:software}\nand the "`wave1D_dn_vc.py`": "http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_dn_vc.py"\nprogram. This pulse\nis exactly propagated in 1D if $c\\Delta t/\\Delta x=1$. Check\nthat also the 2D program can propagate this pulse exactly\nin $x$ direction ($c\\Delta t/\\Delta x=1$, $\\Delta y$ arbitrary)\nand $y$ direction ($c\\Delta t/\\Delta y=1$, $\\Delta x$ arbitrary).',
  'title': 'Implement Neumann conditions in 2D',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave3D_u0.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:3D:f77:cy:efficiency',
  'no': 14,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Extend the `wave2D_u0.py` code and the Cython, Fortran, and C versions to 3D.\nSet up an efficiency experiment to determine the relative efficiency of\npure scalar Python code, vectorized code, Cython-compiled loops,\nFortran-compiled loops, and C-compiled loops.\nNormalize the CPU time for each mesh by the fastest version.',
  'title': 'Test the efficiency of compiled loops in 3D',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_u0_sv_discont.py'],
  'heading': '=====',
  'hints': ['According to Section ref{wave:app:string},\nthe density enters the mathematical model as $\\varrho$ in\n$\\varrho u_{tt} = Tu_{xx}$, where $T$ is the string tension. Modify, e.g., the\n`wave1D_u0v.py` code to incorporate the tension and two density values.\nMake a mesh function `rho` with density values at each spatial mesh point.\nA value for the tension may be 150 N. Corresponding density values can\nbe computed from the wave velocity estimations in the `guitar` function\nin the `wave1D_u0v.py` file.'],
  'keywords': None,
  'label': 'wave:app:exer:string:discont',
  'no': 15,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Simulate waves on a string that consists of two materials with\ndifferent density. The tension in the string is constant, but the\ndensity has a jump at the middle of the string.  Experiment with\ndifferent sizes of the jump and produce animations that visualize the\neffect of the jump on the wave motion.',
  'title': 'Simulate waves on a non-homogeneous string',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_u0_sv_damping.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:string:damping',
  'no': 16,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Formulate a mathematical model for damped waves on a string.\nUse data from Section ref{wave:pde1:guitar:data}, and\ntune the damping parameter so that the string is very close to\nthe rest state after 15 s. Make a movie of the wave motion.',
  'title': 'Simulate damped waves on a string',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave_rod.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:rod',
  'no': 17,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'A hammer hits the end of an elastic rod. The exercise is to simulate\nthe resulting wave motion using the model (ref{wave:app:elastic:rod:eq})\nfrom Section ref{wave:app:elastic:rod}. Let the rod have length\n$L$ and let the boundary $x=L$ be stress free so that $\\sigma_{xx}=0$,\nimplying that $\\partial u/\\partial x=0$. The left end $x=0$ is\nsubject to a strong stress pulse (the hammer), modeled as\n\n!bt\n\\[ \\sigma_{xx}(t) = \\left\\lbrace\\begin{array}{ll}\nS,& 0 < t \\leq t_s,\\\\ \n0, & t > t_s\n\\end{array}\\right.\n\\]\n\n!et\nThe corresponding condition on $u$ becomes $u_x= S/E$\nfor $t\\leq t_s$ and zero afterwards (recall that\n$\\sigma_{xx} = Eu_x$). This is a non-homogeneous\nNeumann condition, and you will need to approximate this condition\nand combine it with the scheme (the ideas and manipulations follow\nclosely the handling of a non-zero initial condition\n$u_t=V$ in wave PDEs or the corresponding\nsecond-order ODEs for vibrations).',
  'title': 'Simulate elastic waves in a rod',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['wave1D_spherical.py'],
  'heading': '=====',
  'hints': ['Use the program `wave1D_u0v.py` as a starting point. Let `solver`\ncompute the $v$ function and then set $u=v/r$. However,\n$u=v/r$ for $r=0$ requires special treatment. One possibility is\nto compute `u[1:] = v[1:]/r[1:]` and then set `u[0]=u[1]`. The latter\nmakes it evident that $\\partial u/\\partial r = 0$ in a plot.'],
  'keywords': None,
  'label': 'wave:app:exer:spherical',
  'no': 18,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Implement a model for spherically symmetric waves using the method\ndescribed in Section ref{wave:app:spherical}. The boundary condition\nat $r=0$ must be $\\partial u/\\partial r=0$, while the condition at\n$r=R$ can either be $u=0$ or a radiation condition as described\nin Problem ref{wave:app:exer:radiationBC}. The $u=0$ condition is\nsufficient if $R$ is so large that the amplitude of the spherical\nwave has become insignificant. Make movie(s) of the case where the source\nterm is located around $r=0$ and sends out pulses\n\n!bt\n\\[ f(r,t) = \\left\\lbrace\\begin{array}{ll}\nQ\\exp{(-\\frac{r^2}{2\\Delta r^2})}\\sin\\omega t,& \\sin\\omega t\\geq 0\\\\ \n0, & \\sin\\omega t < 0\n\\end{array}\\right.\n\\]\n\n!et\nHere, $Q$ and $\\omega$ are constants to be chosen.',
  'title': 'Simulate spherical waves',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['pulse1D_analysis.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:pulse1D:analysis',
  'no': 19,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The experiments performed in Exercise ref{wave:app:exer:pulse1D} shows\nconsiderable numerical noise in the form of non-physical waves,\nespecially for $s_f=4$ and the plug pulse or the half a "cosinehat"\npulse. The noise is much less visible for a Gaussian pulse. Run the\ncase with the plug and half a "cosinehat" pulses for $s_f=1$, $C=0.9,\n0.25$, and $N_x=40,80,160$. Use the numerical dispersion relation to\nexplain the observations.',
  'title': 'Explain why numerical noise occurs',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['pulse1D_harmonic.pdf', 'pulse1D_harmonic.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:pulse1D:harmonic',
  'no': 20,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Harmonic means are often used if the wave velocity is non-smooth or\ndiscontinuous.  Will harmonic averaging of the wave velocity give less\nnumerical noise for the case $s_f=4$ in Exercise\nref{wave:app:exer:pulse1D}?',
  'title': 'Investigate harmonic averaging in a 1D model',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': 'The condition (ref{wave:app:exer:radiationBC:eq})\nworks perfectly in 1D when $c$ is known. In 2D and 3D, however, the\ncondition reads $u_t + c_x u_x + c_y u_y=0$, where $c_x$ and\n$c_y$ are the wave speeds in the $x$ and $y$ directions. Estimating\nthese components (i.e., the direction of the wave) is often\nchallenging. Other methods are normally used in 2D and 3D to\nlet waves move out of a computational domain.',
  'file': ['wave1D_open_BC.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:radiationBC',
  'no': 21,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'A natural idea for discretizing\nthe condition (ref{wave:app:exer:radiationBC:eq})\nat the spatial end point $i=N_x$ is to apply\ncentered differences in time and space:\n\n!bt\n\\begin{equation}\n[D_{2t}u + cD_{2x}u =0]^n_{i},\\quad i=N_x\\tp\nlabel{wave:app:exer:radiationBC:eq:op}\n\\end{equation}\n\n!et\nEliminate the fictitious value $u_{N_x+1}^n$ by using\nthe discrete equation at the same point.\n\nThe equation for the first step, $u_i^1$, is in principle also affected,\nbut we can then use the condition $u_{N_x}=0$ since the wave\nhas not yet reached the right boundary.'},
            {'answer': '',
             'file': None,
             'hints': ['Modify the solver function in\n"`wave1D_dn.py`": "http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_dn.py".'],
             'solution': '',
             'text': 'A much more convenient implementation of the open boundary condition\nat $x=L$ can be based on an explicit discretization\n\n!bt\n\\begin{equation}\n[D^+_tu + cD_x^- u = 0]_i^n,\\quad i=N_x\\tp\nlabel{wave:app:exer:radiationBC:eq:op:1storder}\n\\end{equation}\n\n!et\nFrom this equation, one can solve for $u^{n+1}_{N_x}$ and apply the\nformula as a Dirichlet condition at the boundary point.\nHowever, the finite difference approximations involved are of\nfirst order.\n\nImplement this scheme for a wave equation\n$u_{tt}=c^2u_{xx}$ in a domain $[0,L]$,\nwhere you have $u_x=0$ at $x=0$, the condition (ref{wave:app:exer:radiationBC:eq})\nat $x=L$, and an initial disturbance in the middle\nof the domain, e.g., a plug profile like\n\n!bt\n\\[ u(x,0) = \\left\\lbrace\\begin{array}{ll} 1,& L/2-\\ell \\leq x \\leq  L/2+\\ell,\\\\ \n0,\\hbox{otherwise}\\end{array}\\right.\n\\]\n\n!et\nObserve that the initial wave is split in two, the left-going wave\nis reflected at $x=0$, and both waves travel out of $x=L$,\nleaving the solution as $u=0$ in $[0,L]$. Use a unit Courant number\nsuch that the numerical solution is exact.\nMake a movie to illustrate what happens.\n\nBecause this simplified\nimplementation of the open boundary condition works, there is no\nneed to pursue the more complicated discretization in a).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Add the possibility to have either $u_x=0$ or an open boundary\ncondition at the left boundary. The latter condition is discretized\nas\n\n!bt\n\\begin{equation}\n[D^+_tu - cD_x^+ u = 0]_i^n,\\quad i=0,\nlabel{wave:app:exer:radiationBC:eq:op:1storder2}\n\\end{equation}\n\n!et\nleading to an explicit update of the boundary value $u^{n+1}_0$.\n\nThe implementation can be tested with a Gaussian function as initial condition:\n\n!bt\n\\[ g(x;m,s) = \\frac{1}{\\sqrt{2\\pi}s}e^{-\\frac{(x-m)^2}{2s^2}}\\tp\\]\n\n!et\nRun two tests:\n\n o Disturbance in the middle of the domain, $I(x)=g(x;L/2,s)$, and\n   open boundary condition at the left end.\n o Disturbance at the left end, $I(x)=g(x;0,s)$, and $u_x=0$\n   as symmetry boundary condition at this end.\n\nMake nose tests for both cases, testing that the solution is zero\nafter the waves have left the domain.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'In 2D and 3D it is difficult to compute the correct wave velocity\nnormal to the boundary, which is needed in generalizations of\nthe open boundary conditions in higher dimensions. Test the effect\nof having a slightly wrong wave velocity in\n(ref{wave:app:exer:radiationBC:eq:op:1storder}).\nMake a movies to illustrate what happens.'}],
  'text': '# Solution file is actually periodic.py from Exer ref{wave:exer:periodic},\n# just remove the periodc stuff ;-)\n\nidx{radiation condition}\nidx{open boundary condition}\nidx{boundary condition!open (radiation)}\n\nTo enable a wave to leave the computational domain and travel\nundisturbed through\nthe boundary $x=L$, one can in a one-dimensional problem impose the\nfollowing condition, called a *radiation condition* or\n*open boundary condition*:\n\n!bt\n\\begin{equation}\n\\frac{\\partial u}{\\partial t} + c\\frac{\\partial u}{\\partial x} = 0\\tp\nlabel{wave:app:exer:radiationBC:eq}\n\\end{equation}\n\n!et\nThe parameter $c$ is the wave velocity.\n\nShow that (ref{wave:app:exer:radiationBC:eq}) accepts\na solution $u = g_R(x-ct)$ (right-going wave),\nbut not $u = g_L(x+ct)$ (left-going wave). This means\nthat (ref{wave:app:exer:radiationBC:eq}) will allow any\nright-going wave $g_R(x-ct)$ to pass through the boundary undisturbed.\n\nA corresponding open boundary condition for a left-going wave\nthrough $x=0$ is\n\n!bt\n\\begin{equation}\n\\frac{\\partial u}{\\partial t} - c\\frac{\\partial u}{\\partial x} = 0\\tp\nlabel{wave:app:exer:radiationBC:eqL}\n\\end{equation}\n\n!et',
  'title': 'Implement open boundary conditions',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['periodic.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:exer:periodic',
  'no': 22,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'idx{periodic boundary conditions}\nidx{boundary conditions!periodic}\n\nIt is frequently of interest to follow wave motion over large\ndistances and long times. A straightforward approach is to\nwork with a very large domain, but might lead to a lot of\ncomputations in areas of the domain where the waves cannot\nbe noticed. A more efficient approach is to let a right-going\nwave out of the domain and at the same time let it enter\nthe domain on the left. This is called a *periodic boundary\ncondition*.\n\nThe boundary condition at the right end $x=L$ is an open boundary\ncondition (see Exercise ref{wave:app:exer:radiationBC}) to let a\nright-going wave out of the domain.  At the left end, $x=0$, we apply,\nin the beginning of the simulation, either a symmetry boundary\ncondition (see Exercise ref{wave:exer:symmetry:bc}) $u_x=0$, or an\nopen boundary condition.\n\nThis initial wave will split in two and either reflected or\ntransported out of the domain at $x=0$. The purpose of the exercise is\nto follow the right-going wave. We can do that with a *periodic\nboundary condition*.  This means that when the right-going wave hits\nthe boundary $x=L$, the open boundary condition lets the wave out of\nthe domain, but at the same time we use a boundary condition on the\nleft end $x=0$ that feeds the outgoing wave into the domain\nagain. This periodic condition is simply $u(0)=u(L)$. The switch from\n$u_x=0$ or an open boundary condition at the left end to a periodic\ncondition can happen when $u(L,t)>\\epsilon$, where $\\epsilon =10^{-4}$\nmight be an appropriate value for determining when the right-going\nwave hits the boundary $x=L$.\n\nThe open boundary conditions can conveniently be discretized as\nexplained in Exercise ref{wave:app:exer:radiationBC}.  Implement the\ndescribed type of boundary conditions and test them on two different\ninitial shapes: a plug $u(x,0)=1$ for $x\\leq 0.1$, $u(x,0)=0$ for\n$x>0.1$, and a Gaussian function in the middle of the domain:\n$u(x,0)=\\exp{(-\\frac{1}{2}(x-0.5)^2/0.05)}$. The domain is the unit\ninterval $[0,1]$. Run these two shapes for Courant numbers 1 and\n0.5. Assume constant wave velocity.  Make movies of the four cases.\nReason why the solutions are correct.',
  'title': 'Implement periodic boundary conditions',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami1D_hill.py', 'tsunami1D_hill.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami1D:hill',
  'no': 23,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'A subsea earthquake leads to an immediate lift of the water surface, see\nFigure ref{wave:app:fig:1D:tsunami:flat}.  The lifted water surface\nsplits into two\ntsunamis, one traveling to the right and one to the left, as depicted\nin Figure ref{wave:app:fig:1D:tsunami:2waves}.  Since tsunamis are\nnormally very long waves, compared to the depth, with a small\namplitude, compared to the wave length, the wave equation model\ndescribed in Section ref{wave:app:sw:2D} is relevant:\n\n!bt\n\\[ \\eta_{tt} = (gH(x)\\eta_x)_x,\\]\n\n!et\nwhere $g$ is the acceleration of gravity, and $H(x)$ is the still water depth.\n\nFIGURE: [fig-wave/earthquake_tsunami_flat, width=800, frac=1.2] Sketch of initial water surface due to a subsea earthquake. label{wave:app:fig:1D:tsunami:flat}\n\nFIGURE: [fig-wave/earthquake_tsunami_2waves, width=800, frac=1.2] An initial surface elevation is split into two waves. label{wave:app:fig:1D:tsunami:2waves}\n\n\nTo simulate the right-going tsunami, we can impose\na symmetry boundary at $x=0$: $\\partial\\eta\\ \\partial x =0$.\nWe then simulate the wave motion\nin $[0,L]$. Unless the ocean ends at $x=L$, the waves should travel\nundisturbed through the boundary $x=L$. A radiation condition\nas explained in Problem ref{wave:app:exer:radiationBC} can be\nused for this purpose. Alternatively, one can just stop the simulations\nbefore the wave hits the boundary at $x=L$. In that case it does not\nmatter what kind of boundary condition we use\nat $x=L$. Imposing $\\eta =0$ and stopping the simulations when\n$|\\eta_i^n| > \\epsilon$, $i=N_x-1$, is a possibility ($\\epsilon$ is a\nsmall parameter).\n\nThe shape of the initial surface can be taken as a\nGaussian function,\n\n!bt\n\\begin{equation}\nI(x;I_0,I_a,I_m,I_s) =\nI_0 + I_a\\exp{\\left(-\\left(\\frac{x-I_m}{I_s}\\right)^2\\right)},\n\\end{equation}\n\n!et\nwith $I_m=0$ reflecting the location of the peak of $I(x)$ and\n$I_s$ being a measure of the width of the function $I(x)$\n($I_s$ is $\\sqrt{2}$ times the standard deviation of the familiar\nnormal distribution curve).\n\nNow we extend the problem with a hill at the sea\nbottom, see Figure ref{wave:app:fig:1D:tsunami:hill}. The wave speed\n$c=\\sqrt{gH(x)} = \\sqrt{g(H_0-B(x))}$ will then be reduced in the\nshallow water above the hill.\n\nFIGURE: [fig-wave/earthquake_tsunami_hill, width=800, frac=1.2] Sketch of an earthquake-generated tsunami passing over a subsea hill. label{wave:app:fig:1D:tsunami:hill}\n\nOne possible form of the\nhill is a Gaussian function,\n\n!bt\n\\begin{equation}\nB(x;B_0,B_a,B_m,B_s) =\nB_0 + B_a\\exp{\\left(-\\left(\\frac{x-B_m}{B_s}\\right)^2\\right)},\nlabel{wave:app:exer:tsunami1D:hill:Gauss}\n\\end{equation}\n\n!et\nbut many other shapes are also possible, e.g., a "cosine hat" where\n\n!bt\n\\begin{equation}\nB(x; B_0, B_a, B_m, B_s) = B_0 + B_a\\cos{\\left( \\pi\\frac{x-B_m}{2B_s}\\right)},\nlabel{wave:app:exer:tsunami1D:hill:cohat}\n\\end{equation}\n\n!et\nwhen $x\\in [B_m - B_s, B_m + B_s]$ while $B=B_0$ outside this\ninterval.\n\nAlso an abrupt construction may be tried:\n!bt\n\\begin{equation}\nB(x; B_0, B_a, B_m, B_s) = B_0 + B_a,\nlabel{wave:app:exer:tsunami1D:hill:box}\n\\end{equation}\n\n!et\nfor $x\\in [B_m - B_s, B_m + B_s]$ while $B=B_0$ outside this\ninterval.\n\nThe "`wave1D_dn_vc.py`": "http://tinyurl.com/jvzzcfn/wave/wave1D/wave1D_dn_vc.py"\nprogram can be used as starting point for the implementation.\nVisualize both the bottom topography and the\nwater surface elevation in\nthe same plot.\nAllow for a flexible choice of bottom shape:\n(ref{wave:app:exer:tsunami1D:hill:Gauss}),\n(ref{wave:app:exer:tsunami1D:hill:cohat}),\n(ref{wave:app:exer:tsunami1D:hill:box}), or $B(x)=B_0$ (flat).\n\nThe purpose of this problem is to explore the quality of the numerical\nsolution $\\eta^n_i$ for different shapes of the bottom obstruction.\nThe "cosine hat" and the box-shaped hills have abrupt changes in the\nderivative of $H(x)$ and are more likely to generate numerical noise\nthan the smooth Gaussian shape of the hill. Investigate if this is true.',
  'title': 'Earthquake-generated tsunami over a subsea hill',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami2D_hill.py', 'tsunami2D_hill.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami2D:hill',
  'no': 24,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'This problem extends Problem ref{wave:app:exer:tsunami1D:hill}\nto a three-dimensional wave phenomenon, governed by the 2D PDE\n(ref{wave:app:sw:2D:eta:2ndoeq}). We assume that the earthquake\narise from a fault along the line $x=0$ in the $xy$-plane so that\nthe initial lift of the surface can be taken as $I(x)$ in\nProblem ref{wave:app:exer:tsunami1D:hill}. That is, a plane wave is\npropagating to the right, but will experience bending because of\nthe bottom.\n\nThe bottom shape is now a function of $x$ and $y$.\nAn "elliptic" Gaussian function in two dimensions, with its peak\nat $(B_{mx}, B_{my})$, generalizes\n(ref{wave:app:exer:tsunami1D:hill:Gauss}):\n\n!bt\n\\begin{equation}\nB(x;B_0,B_a,B_{mx}, B_{my} ,B_s, b) =\nB_0 + B_a\\exp{\\left(-\\left(\\frac{x-B_{mx}}{B_s}\\right)^2\n-\\left(\\frac{y-B_{my}}{bB_s}\\right)^2\\right)},\nlabel{wave:app:exer:tsunami2D:hill:Gauss}\n\\end{equation}\n\n!et\nwhere $b$ is a scaling parameter: $b=1$ gives a circular Gaussian\nfunction with circular contour lines, while $b\\neq 1$ gives an elliptic\nshape with elliptic contour lines.\n\nThe "cosine hat" (ref{wave:app:exer:tsunami1D:hill:cohat}) can also be\ngeneralized to\n\n!bt\n\\begin{equation}\nB(x; B_0, B_a, B_{mx}, B_{my}, B_s) =\nB_0 + B_a\\cos{\\left( \\pi\\frac{x-B_{mx}}{2B_s}\\right)}\n\\cos{\\left( \\pi\\frac{y-B_{my}}{2B_s}\\right)},\nlabel{wave:app:exer:tsunami2D:hill:cohat}\n\\end{equation}\n\n!et\nwhen $0 \\leq \\sqrt{x^2+y^2} \\leq B_s$ and $B=B_0$ outside this circle.\n\nA box-shaped obstacle means that\n!bt\n\\begin{equation}\nB(x; B_0, B_a, B_m, B_s, b) = B_0 + B_a\nlabel{wave:app:exer:tsunami2D:hill:box}\n\\end{equation}\n\n!et\nfor $x$ and $y$ inside a rectangle\n!bt\n\\[ B_{mx}-B_s \\leq  x \\leq B_{mx} + B_s,\\quad\nB_{my}-bB_s \\leq  y \\leq B_{my} + bB_s,\n\\]\n\n!et\nand $B=B_0$ outside this rectangle.\nThe $b$ parameter controls the rectangular shape of the cross section of\nthe box.\n\nNote that the initial condition and the listed bottom shapes are\nsymmetric around the line $y=B_{my}$. We therefore expect the surface\nelevation also to be symmetric with respect to this line.  This means\nthat we can halve the computational domain by working with\n$[0,L_x]\\times [0, B_{my}]$. Along the upper boundary, $y=B_{my}$, we\nmust impose the symmetry condition $\\partial \\eta/\\partial n=0$.  Such\na symmetry condition ($-\\eta_x=0$) is also needed at the $x=0$\nboundary because the initial condition has a symmetry here. At the\nlower boundary $y=0$ we also set a Neumann condition (which becomes\n$-\\eta_y=0$).  The wave motion is to be simulated until the wave hits\nthe reflecting boundaries where $\\partial\\eta/\\partial n =\\eta_x =0$\n(one can also set $\\eta =0$ - the particular condition does not matter\nas long as the simulation is stopped before the wave is influenced\nby the boundary condition).\n\nVisualize the surface elevation.  Investigate how different hill shapes,\ndifferent sizes of the water gap above the hill, and different\nresolutions $\\Delta x = \\Delta y = h$ and $\\Delta t$ influence\nthe numerical quality of the solution.',
  'title': 'Earthquake-generated tsunami over a 3D hill',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami2D_hill_mpl.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami:hill:viz:matplotlib',
  'no': 25,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Play with native Matplotlib code for visualizing 2D\nsolutions of the wave equation with variable wave velocity.\nSee if there\nare effective ways to visualize both the solution and the wave\nvelocity.',
  'title': 'Investigate Matplotlib for visualization',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami2D_hill_viz.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami:hill:viz:packages',
  'no': 26,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Create some fancy 3D visualization of the water waves *and* the subsea hill\nin Problem ref{wave:app:exer:tsunami2D:hill}.\nTry to make the hill transparent. Possible visualization tools are\n\n  * "Mayavi": "http://code.enthought.com/projects/mayavi/"\n  * "Paraview": "http://www.paraview.org/"\n  * "OpenDX": "http://www.opendx.org/"',
  'title': 'Investigate visualization packages',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['tsunami2D_hill_compiled.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:tsunami2D:hill:compiled',
  'no': 27,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Extend the program from Problem ref{wave:app:exer:tsunami2D:hill} such\nthat the loops over mesh points, inside the time loop, are\nimplemented in compiled languages.\nConsider implementations in\nCython, Fortran via `f2py`, C via Cython, C via `f2py`, C/C++ via Instant,\nand C/C++ via `scipy.weave`.\nPerform efficiency experiments to investigate the relative performance\nof the various implementations. It is often advantageous to normalize\nCPU times by the fastest method on a given mesh.',
  'title': 'Implement loops in compiled languages',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['seismic2D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:seismic2D',
  'no': 28,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': "The goal of this exercise is to simulate seismic waves using the\nPDE model (ref{wave:app:acoustic:seismic:accoustic1a}) in a\n2D $xz$ domain with geological layers.\nIntroduce $m$ horizontal layers of thickness $h_i$, $i=0,\\ldots,m-1$.\nInside layer number $i$ we have a vertical wave velocity $c_{z,i}$\nand a horizontal wave velocity $c_{h,i}$. Make a program\nfor simulating such 2D waves. Test it on a case with 3 layers where\n\n!bt\n\\[ c_{z,0}=c_{z,1}=c_{z,2},\\quad c_{h,0}=c_{h,2},\\quad c_{h,1} \\ll c_{h,0}\n\\tp\n\\]\n\n!et\nLet $s$ be a localized point source at the middle of the Earth's surface\n(the upper boundary)\nand investigate how the resulting wave travels through the medium.\nThe source can be a localized Gaussian peak that oscillates in\ntime for some time interval.\nPlace the boundaries far enough from the expanding wave so that the\nboundary conditions do not disturb the wave. Then the type of\nboundary condition does not matter, except that we physically need\nto have $p=p_0$, where $p_0$ is the atmospheric pressure,\nat the upper boundary.",
  'title': 'Simulate seismic waves in 2D',
  'type': 'Exercise',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['acoustics.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:acoustics',
  'no': 29,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The equation for sound waves in air is derived in Section ref{wave:app:sound}\nand reads\n\n!bt\n\\[ p_{tt} = c^2\\nabla^2 p,\\]\n\n!et\nwhere $p(x,y,z,t)$ is the pressure and $c$\nis the speed of sound, taken as 340 m/s.\n#air at a room temperature 20 C, $p_0$ is reference pressure in the\n#air, typically 1 atm (approximately $10^5$ Pa), and $\\varrho_0$ is\n#the density of air, taken as $1.225\\mbox{ kg/m}^3$.\nHowever, sound is absorbed in the air due to relaxation of molecules\nin the gas. A model for simple relaxation, valid for gases consisting\nonly of one type of molecules, is a term $c^2\\tau_s\\nabla^2 p_t$ in\nthe PDE, where $\\tau_s$ is the relaxation time. If we generate sound\nfrom, e.g., a loudspeaker in the room, this sound source must also\nbe added to the governing equation.\n\nThe PDE with the mentioned type of damping and source then becomes\n\n!bt\n\\begin{equation}\np_tt = c^2\\nabla^p + c^2\\tau_s\\nabla^2 p_t + f,\n\\end{equation}\n\n!et\nwhere $f(x,y,z,t)$ is the source term.\n\nThe walls can absorb some sound. A possible model is to have a "wall layer"\n(thicker than the physical wall)\noutside the room where $c$ is changed such that some of the wave energy\nis reflected and some is absorbed in the wall. The absorption of\nenergy can be taken care of by adding a damping term $bp_t$ in\nthe equation:\n\n!bt\n\\begin{equation}\np_tt + bp_t = c^2\\nabla^p + c^2\\tau_s\\nabla^2 p_t + f\\tp\n\\end{equation}\n\n!et\nTypically, $b=0$ in the room and $b>0$ in the wall. A discontinuity in $b$\nor $c$ will give rise to reflections. It can be wise to use a constant\n$c$ in the wall to control reflections because of the discontinuity between\n$c$ in the air and in the wall, while $b$ is gradually increased\nas we go into the wall to avoid reflections because of rapid changes in $b$.\nAt the outer boundary of the wall the condition $p=0$ or $\\partial p/\\partial n=0$ can be imposed. The waves should anyway be approximately dampened\nto $p=0$ this far out in the wall layer.\n\nThere are two strategies for discretizing the $\\nabla^2 p_t$ term: using\na center difference between times $n+1$ and $n-1$ (if the equation is\nsampled at level $n$), or use a one-sided difference based on levels $n$\nand $n-1$. The latter has the advantage of not leading to any equation system,\nwhile the former is second-order accurate as the scheme for the\nsimple wave equation $p_tt = c^2\\nabla^2 p$. To avoid an equation system,\ngo for the one-sided difference such that the overall scheme becomes\nexplicit and only of first order in time.\n\nDevelop a 3D solver for the specified PDE and introduce a wall layer.\nTest the solver with the method of manufactured solutions. Make some\ndemonstrations where the wall reflects and absorbs the waves (reflection\nbecause of discontinuity in $b$ and absorption because of growing $b$).\nExperiment with the impact of the $\\tau_s$ parameter.',
  'title': 'Model 3D acoustic waves in a room',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['advec1D.py'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:advec1D',
  'no': 30,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show that under the assumption of $a=\\hbox{const}$,\n\n!bt\n\\begin{equation}\nu(x,t) = I(x - ct)\nlabel{wave:app:exer:advec1D:uexact}\n\\end{equation}\n\n!et\nfulfills the PDE as well as the initial and boundary condition\n(provided $I(0)=I(L)$).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up a computational algorithm and implement it in a function.\nAssume $a$ is constant and positive.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Test implementation by using the remarkable property that\nthe numerical solution is exact at the mesh points if\n$\\Delta t = c^{-1}\\Delta x$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Make a movie comparing the numerical and exact solution for the\nfollowing two choices of initial conditions:\n\n!bt\n\\begin{equation}\n I(x) = \\left\\lbrack\\sin\\left(\\pi\\frac{x}{L}\\right)\\right\\rbrack^{2n}\nlabel{wave:app:exer:advec1D:I:sin}\n\\end{equation}\n\n!et\nwhere $n$ is an integer, typically $n=5$,\nand\n\n!bt\n\\begin{equation}\nI(x) = \\exp{\\left( -\\frac{(x-L/2)^2}{2\\sigma2}\\right)} \\tp\n\\end{equation}\nlabel{wave:app:exer:advec1D:I:gauss}\n\n!et\nChoose $\\Delta t = c^{-1}\\Delta x, 0.9c^{-1}\\Delta x, 0.5c^{-1}\\Delta x$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'The performance of the suggested numerical scheme can be investigated\nby analyzing the numerical dispersion relation.\nAnalytically, we have that the *Fourier component*\n\n!bt\n\\[ u(x,t) = e^{i(kx-\\omega t)},\\]\n\n!et\nis a solution of the PDE if $\\omega = kc$. This is the *analytical\ndispersion relation*. A complete solution of the PDE can be built by\nadding up such Fourier components with different amplitudes, where the\ninitial condition $I$ determines the amplitudes. The solution $u$ is\nthen represented by a Fourier series.\n\nA similar discrete Fourier component at $(x_p,t_n)$ is\n\n!bt\n\\[ u_p^q = e^{i(kp\\Delta x -\\tilde\\omega n\\Delta t)},\\]\n\n!et\nwhere in general $\\tilde\\omega$ is a function of $k$, $\\Delta t$, and\n$\\Delta x$, and differs from the exact $\\omega =kc$.\n\nInsert the discrete Fourier component in the numerical scheme and\nderive an expression for $\\tilde\\omega$, i.e.,\nthe discrete dispersion relation. Show in particular that if\nthe $\\Delta t/(c\\Delta x)=1$, the discrete solution coincides with the\nexact solution at the mesh points, regardless of the mesh resolution (!).\nShow that if the stability condition\n\n!bt\n\\[ \\frac{\\Delta t}{c\\Delta x}\\leq 1,\\]\n\n!et\nthe discrete Fourier component cannot grow (i.e., $\\tilde\\omega$ is real).'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Write a test for your implementation where you try to use information\nfrom the numerical dispersion relation.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Set up a computational algorithm for the variable\ncoefficient case and implement it in a function.\nMake a test that the function works for constant $a$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': "Let $\\xi = C(x) - t$.\nWe have that\n!bt\n\\[ u_t = f'(\\xi)(-1),\\]\n\n!et\nwhile\n!bt\n\\[ u_x = f'(\\xi)C'(x) = f'(\\xi)\\frac{1}{c(x)},\\]\n\n!et\nimplying that $au_x = f'(\\xi)$. Then we have $u_t + cu_x= -f'(\\xi) +\nf'(\\xi) = 0$.",
             'text': "It can be shown that\nfor an observer moving with velocity $c(x)$, $u$ is constant.\nThis can be used to derive an exact solution when $a$ varies\nwith $x$. Show first that\n\n!bt\n\\begin{equation}\nu(x,t) = f(C(x) - t),\nlabel{wave:app:exer:advec1D:u:avar:sol}\n\\end{equation}\n\n!et\nwhere\n\n!bt\n\\[ C'(x) = \\frac{1}{c(x)},\\]\n\n!et\nis a solution of (ref{wave:app:exer:advec1D:ueq}) for any\ndifferentiable function $f$."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': 'In general we have $u(x,t) = f(C(x)-t)$ and the solution is\nof this form with $f(\\xi)=I(C^{-1}(\\xi))$.\nMoreover, at $t=0$ we have\n$I(C^{-1}(C(x)))=I(x)$, which is the required initial condition.',
             'text': 'Use the initial condition to show that an exact solution is\n\n!bt\n\\[ u(x,t) = I(C^{-1}(C(x)-t)),\\]\n\n!et\nwith $C^{-1}$ being the inverse function of $C = \\int c^{1}dx$.\nSince $C(x)$ is an integral $\\int_0^x (1/c)dx$,\n$C(x)$ is monotonically increasing and there exists hence an\ninverse function $C^{-1}$ with values in $[0,L]$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Implement a function for computing $C(x_i)$ and one for computing\n$C^{-1}(x)$ for any $x$. Use these two functions for computing\nthe exact solution $I(C^{-1}(C(x)-t))$.\nEnd up with a function `u_exact_variable_c(x, n, c, I)` that returns\nthe value of $I(C^{-1}(C(x)-t_n))$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Make movies showing a comparison of the numerical and exact solutions\nfor the two initial conditions\n(ref{wave:app:exer:advec1D:I:sin}) and (ref{wave:app:exer:advec1D:I:gauss}).\nChoose $\\Delta t = \\Delta x /\\max_{0,L} c(x)$\nand the velocity of the medium as\n\n o $c(x) = 1 + \\epsilon\\sin(k\\pi x/L)$, $\\epsilon <1$,\n o $c(x) = 1 + I(x)$, where $I$ is given by\n   (ref{wave:app:exer:advec1D:I:sin}) or (ref{wave:app:exer:advec1D:I:gauss}).\n\nThe PDE $u_t + cu_x=0$ expresses that the initial condition $I(x)$\nis transported with velocity $c(x)$.'}],
  'text': 'We shall study the wave equation\n\n!bt\n\\begin{equation}\nu_t + cu_x = 0,\\quad x\\in (0,L],\\ t\\in (0, T],\nlabel{wave:app:exer:advec1D:ueq}\n\\end{equation}\n\n!et\nwith initial condition\n\n!bt\n\\begin{equation}\nu(x,0) = I(x),\\quad x\\in [0,L],\n\\end{equation}\n\n!et\nand *one* periodic boundary condition\n\n!bt\n\\begin{equation}\nu(0,t) = u(L,t)\n\\tp\n\\end{equation}\n\n!et\nThis boundary condition means that what goes out of the domain at $x=L$\ncomes in at $x=0$. Roughly speaking,\nwe need only one boundary condition because of\nthe spatial derivative is of first order only.\n\n__Physical interpretation.__\nThe parameter $c$ can be constant or variable, $c=c(x)$. The\nequation (ref{wave:app:exer:advec1D:ueq}) arises in *transport*\nproblems where a quantity $u$, which could be temperature or\nconcentration of some contaminant, is transported with the velocity\n$c$ of a fluid. In addition to the transport imposed by "travelling with\nthe fluid", $u$ may also be transported by diffusion (such as\nheat conduction or Fickian diffusion), but we have in\nthe model $u_t + cu_x$ assumed that diffusion effects are negligible,\nwhich they often are.\n\n\nA widely used numerical scheme for (ref{wave:app:exer:advec1D:ueq})\napplies a forward difference in time and a backward difference in\nspace when $c>0$:\n\n!bt\n\\begin{equation}\n[D_t^+ u + cD_x^-u = 0]_i^n\nlabel{wave:app:exer:advec1D:u:upwind}\n\\tp\n\\end{equation}\n\n!et\nFor $c<0$ we use a forward difference in space: $[cD_x^+u]_i^n$.\n\n\n\n\n\n\n\nWe shall hereafter assume that $=c(x)>0$.\n\n\n\n\nTo compute (ref{wave:app:exer:advec1D:u:avar:sol}) we need to integrate\n$1/c$ to obtain $C$ and then compute the inverse of $C$.\n\nThe inverse function computation can be easily done if we first think\ndiscretely. Say we have some function $y=g(x)$ and seeks its inverse.\nPlotting $(x_i,y_i)$, where $y_i=g(x_i)$ for some mesh points $x_i$,\ndisplays $g$ as a function of $x$.\nThe inverse function is simply $x$ as a function of $g$, i.e., the\ncurve with points $(y_i,x_i)$. We can therefore quickly compute points\nat the curve of the inverse function. One way of extending these\npoints to a continuous function is to assume a linear variation\n(known as linear interpolation)\nbetween the points (which actually means to draw straight lines between\nthe points, exactly as done by a plotting program).\n\nThe function `wrap2callable` in `scitools.std` can take a set of points\nand return a continuous function that corresponds to linear\nvariation between the points. The computation of the inverse of a\nfunction $g$ on $[0,L]$ can then be done by\n\n!bc pycod\ndef inverse(g, domain, resolution=101):\n    x = linspace(domain[0], domain[L], resolution)\n    y = g(x)\n    from scitools.std import wrap2callable\n    g_inverse = wrap2callable((y, x))\n    return g_inverse\n\n!ec\n\nTo compute $C(x)$ we need to integrate $1/c$, which can be done by\na Trapezoidal rule. Suppose we have computed $C(x_i)$ and need\nto compute $C(x_{i+1})$. Using the Trapezoidal rule with $m$ subintervals\nover the integration domain $[x_i,x_{i+1}]$ gives\n\n!bt\n\\begin{equation}\nC(x_{i+1}) = C(x_i) + \\int_{x_i}^{x_{i+1}} \\frac{dx}{c}\n\\approx h\\left(\n\\half\\frac{1}{c(x_i)} + \\half\\frac{1}{c(x_{i+1})}\n+ \\sum_{j=1}^{m-1} \\frac{1}{c(x_i + jh)}\\right),\nlabel{wave:app:exer:advec1D:C:recursion}\n\\end{equation}\n\n!et\nwhere $h=(x_{i+1}-x_i)/m$ is the length of the subintervals used\nfor the integral over $[x_i,x_{i+1}]$.\nWe observe that (ref{wave:app:exer:advec1D:C:recursion}) is a\n*difference equation* which we can solve by repeatedly\napplying (ref{wave:app:exer:advec1D:C:recursion}) for\n$i=0,1,\\ldots,N_x-1$ if a mesh $x_0,x_,\\ldots,x_{N_x}$ is prescribed.\nNote that $C(0)=0$.',
  'title': 'Solve a 1D transport equation',
  'type': 'Project',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['damped_wave1D.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:anal:damped:wave1D',
  'no': 31,
  'solution': '',
  'solution_file': None,
  'subex': [{'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': "Seek a solution on the form $u(x,t)=X(x)T(t)$. Insert this solution in\nthe PDE and show that it leads to two differential equations for $X$ and $T$:\n\n!bt\n\\[ T'' + bT' + \\lambda T = 0,\\quad c^2 X'' +\\lambda X = 0, \\]\n\n!et\nwith $X(0)=X(L)=0$ as boundary conditions, and $\\lambda$ as a constant\nto be determined."},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Show that $X(x)$ is on the form\n\n!bt\n\\[ X_n(x) = C_n\\sin kx,\\quad k = \\frac{n\\pi}{L},\\quad n=1,2,\\ldots\\]\n\n!et\nwhere $C_n$ is an arbitrary constant.\n\n# lambda = k**2'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Under the assumption that $(b/2)^2 < k^2$, show that $T(t)$ is on\nthe form\n\n!bt\n\\[ T_n(t) = e^{-{\\half}bt}(a_n\\cos\\omega t + b_n\\sin\\omega t),\n\\quad\\omega = \\sqrt{k^2 - \\frac{1}{4}b^2},\\quad n=1,2,\\ldots \\]\n\n!et\nThe complete solution is then\n\n!bt\n\\[ u(x,t) = \\sum_{n=1}^\\infty \\sin kx e^{-{\\half}bt}(\nA_n\\cos\\omega t + B_n\\sin\\omega t),\\]\n\n!et\nwhere the constants $A_n$ and $B_n$ must be computed from the initial\nconditions.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Derive a formula for $A_n$ from $u(x,0)=I(x)$ and developing $I(x)$ as a sine\nFourier series on $[0,L]$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Derive a formula for $B_n$ from $u_t(x,0)=V(x)$ and developing $V(x)$ as\na sine Fourier series on $[0,L]$.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Calculate $A_n$ and $B_n$ from vibrations of a string where $V(x)=0$ and\n\n!bt\n\\begin{equation}\nI(x) = \\left\\lbrace\n\\begin{array}{ll}\nax/x_0, & x < x_0,\\\\ \na(L-x)/(L-x_0), & \\hbox{otherwise}\n\\end{array}\\right.\nlabel{wave:pde1:guitar:I}\n\\end{equation}\n\n!et'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'Implement the series for $u(x,t)$ in a function `u_series(x, t, tol=1E-10)`,\nwhere `tol` is a tolerance for truncating the series. Simply sum\nthe terms until $|a_n|$ and $|b_b|$ both are less than `tol`.'},
            {'answer': '',
             'file': None,
             'hints': [],
             'solution': '',
             'text': 'What will change in the derivation of the analytical solution if we\nhave $u_x(0,t)=u_x(L,t)=0$ as boundary conditions?\nAnd how will you solve the problem with $u(0,t)=0$ and $u_x(L,t)=0$?\n\n# sin goes to cos, k changes as cos(kL)=0'}],
  'text': 'We consider an initial-boundary value problem for the damped wave equation:\n\n!bt\n\\begin{align*}\nu_{tt} +bu_t &= c^2 u_{xx}, \\quad &x\\in (0,L),\\ t\\in (0,T]\\\\ \nu(0,t) &= 0,\\\\ \nu(L,t) &=0,\\\\ \nu(x, 0) &= I(x),\\\\ \nu_t(x, 0) &= V(x)\\tp\n\\end{align*}\n\n!et\nHere, $b\\geq 0$ and $c$ are given constants. The aim is to derive a general\nanalytical solution of this problem. Familiarity with the method of\nseparation of variables for solving PDEs will be assumed.',
  'title': 'General analytical solution of a 1D damped wave equation',
  'type': 'Problem',
  'type_visible': True},
 {'answer': '',
  'closing_remarks': '',
  'file': ['damped_wave2D.pdf'],
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': 'wave:app:exer:anal:damped:wave2D',
  'no': 32,
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'Carry out Problem ref{wave:app:exer:anal:damped:wave1D} in the 2D\ncase: $u_{tt}+bu_t = c^2(u_{xx}+u_{yy})$, where $(x,y)\\in (0,L_x)\\times\n(0,L_y)$. Assume a solution on the form $u(x,y,t)=X(x)Y(y)T(t)$.',
  'title': 'General analytical solution of a 2D damped wave equation',
  'type': 'Problem',
  'type_visible': True}]