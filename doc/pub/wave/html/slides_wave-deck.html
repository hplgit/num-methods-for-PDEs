<!DOCTYPE html>

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Study guide: Finite difference methods for wave motion">
<meta name="keywords" content="waves on a string,wave equation 1D,mesh finite differences,stencil 1D wave equation,mesh function,wave equation 1D, implementation,unit testing,software testing nose,vectorization,scalar code,array slices,slice,lambda function (Python),Neumann conditions,Dirichlet conditions,homogeneous Neumann conditions,homogeneous Dirichlet conditions,stencil Neumann boundary,index set notation,wave equation 2D, implementation,wave equation 1D, analytical properties,wave equation 1D, exact numerical solution,stability criterion,wave equation 1D, stability">

<title>Study guide: Finite difference methods for wave motion</title>







<!-- deck.js: https://github.com/imakewebthings/deck.js -->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=1024, user-scalable=no">

<!-- Required stylesheet -->
<link rel="stylesheet" href="deck.js/core/deck.core.css">

<!-- Extension CSS files go here. Remove or add as needed.
deck.goto: Adds a shortcut key to jump to any slide number.
Hit g, type in the slide number, and hit enter.

deck.hash: Enables internal linking within slides, deep
linking to individual slides, and updates the address bar and
a permalink anchor with each slide change.

deck.menu: Adds a menu view, letting you see all slides in a grid.
Hit m to toggle to menu view, continue navigating your deck,
and hit m to return to normal view. Touch devices can double-tap
the deck to switch between views.

deck.navigation: Adds clickable left and right buttons for the
less keyboard inclined.

deck.status: Adds a page number indicator. (current/total).

deck.scale: Scales each slide to fit within the deck container
using CSS Transforms for those browsers that support them.

deck.pointer: Turn mouse into laser pointer (toggle with p).
(Requires https://github.com/mikeharris100/deck.pointer.js)
-->

<link rel="stylesheet" href="deck.js/extensions/menu/deck.menu.css">
<link rel="stylesheet" href="deck.js/extensions/navigation/deck.navigation.css">
<link rel="stylesheet" href="deck.js/extensions/scale/deck.scale.css">
<link rel="stylesheet" href="deck.js/extensions/pointer/deck.pointer.css">
<link rel="stylesheet" href="deck.js/extensions/notes/deck.notes.css">
<!--
<link rel="stylesheet" href="deck.js/extensions/goto/deck.goto.css">
<link rel="stylesheet" href="deck.js/extensions/hash/deck.hash.css">
<link rel="stylesheet" href="deck.js/extensions/status/deck.status.css">
-->

<!-- Style theme. More available in themes/style/ or create your own. -->
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">

<!--
<link rel="stylesheet" href="deck.js/themes/style/neon.css">
<link rel="stylesheet" href="deck.js/themes/style/swiss.css">
<link rel="stylesheet" href="deck.js/themes/style/web-2.0.css">

git clone git://github.com/duijf/mnml.git
<link rel="stylesheet" href="deck.js/themes/style/mnml.css">

git://github.com/groovecoder/deckjs-theme-mozilla.git
<link rel="stylesheet" href="deck.js/themes/style/sandstone.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.aurora.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.dark.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.default.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.firefox.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.light.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.mdn.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.nightly.css">
<link rel="stylesheet" href="deck.js/themes/style/sandstone.cbc.css">

git://github.com/barraq/deck.ext.js.git
<link rel="stylesheet" href="deck.js/themes/style/beamer.css">
-->

<!--
Transition theme. More available in /themes/transition/ or create your own. -->
<!--
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/fade.css">
<link rel="stylesheet" href="deck.js/themes/transition/vertical-slide.css">
<link rel="stylesheet" href="deck.js/themes/transition/horizontal-slide.css">
-->

<!-- Required Modernizr file -->
<script src="deck.js/modernizr.custom.js"></script>

<style type="text/css">
/* Override h1, h2, ... styles */
h1 { font-size: 2.8em; }
h2 { font-size: 1.5em; }
h3 { font-size: 1.4em; }
h4 { font-size: 1.3em; }
h1, h2, h3, h4 { font-weight: bold; line-height: 1.2; }
body { overflow: auto; } /* vertical scrolling */

hr { border: 0; width: 80%; border-bottom: 1px solid #aaa}
p.caption { width: 80%; font-size: 60%; font-style: italic; text-align: left; }
hr.figure { border: 0; width: 80%; border-bottom: 1px solid #aaa}
.slide .alert-text-small   { font-size: 80%;  }
.slide .alert-text-large   { font-size: 130%; }
.slide .alert-text-normal  { font-size: 90%;  }
.slide .alert {
     padding:8px 35px 8px 14px; margin-bottom:18px;
     text-shadow:0 1px 0 rgba(255,255,255,0.5);
     border:5px solid #bababa;
       -webkit-border-radius:14px; -moz-border-radius:14px;
     border-radius:14px
     background-position: 10px 10px;
     background-repeat: no-repeat;
     background-size: 38px;
     padding-left: 30px; /* 55px; if icon */
 }
 .slide .alert-block {padding-top:14px; padding-bottom:14px}
 .slide .alert-block > p, .alert-block > ul {margin-bottom:0}
 /*.slide .alert li {margin-top: 1em}*/
 .deck .alert-block p+p {margin-top:5px}
 /*.slide .alert-notice { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_notice.png); }
 .slide .alert-summary  { background-image:url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_summary.png); }
 .slide .alert-warning { background-image: url(http://hplgit.github.io/doconce/bundled/html_images//small_gray_warning.png); }
 .slide .alert-question {background-image:url(http://hplgit.github.io/doconce/bundled/html_images/small_gray_question.png); } */

</style>



<!-- Styles for table layout of slides -->
<style type="text/css">
td.padding {
  padding-top:20px;
  padding-bottom:20px;
  padding-right:50px;
  padding-left:50px;
}
</style>

</head>

<body class="deck-container">

<header>
<!-- Here goes a potential header -->
</header>

<!-- do not use the article tag - it gives strange sizings -->





<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands_keep.tex -->
$$
\newcommand{\half}{\frac{1}{2}}
\newcommand{\halfi}{{1/2}}
\newcommand{\uex}{{u_{\small\mbox{e}}}}
\newcommand{\xpoint}{\boldsymbol{x}}
\newcommand{\normalvec}{\boldsymbol{n}}
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\Ix}{\mathcal{I}_x}
\newcommand{\Iy}{\mathcal{I}_y}
\newcommand{\It}{\mathcal{I}_t}
\newcommand{\setb}[1]{#1^0}    % set begin
\newcommand{\sete}[1]{#1^{-1}} % set end
\newcommand{\setl}[1]{#1^-}
\newcommand{\setr}[1]{#1^+}
\newcommand{\seti}[1]{#1^i}
\newcommand{\Real}{\mathbb{R}}
$$




    



<section class="slide">
<!-- ------------------- main content ---------------------- -->

<h2 style="text-align: center;">Study guide: Finite difference methods for wave motion</h2>  <!-- document title -->

<p>
<!-- author(s): Hans Petter Langtangen -->

<center>
<b style="font-weight: bold">Hans Petter Langtangen</b> [1, 2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b style="font-weight: bold">Center for Biomedical Computing, Simula Research Laboratory</b></center>
<center>[2] <b style="font-weight: bold">Department of Informatics, University of Oslo</b></center>
<br>
<p>
<center><b style="font-weight: bold">Sep 17, 2015</b></center> <!-- date -->
<br>
</section>


<section class="slide">

<h1 id="wave:string">Finite difference methods for waves on a string</h1>

<p>
Waves on a string can be modeled by the <em>wave equation</em>

<p>&nbsp;<br>
$$ \frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2 u}{\partial x^2} $$
<p>&nbsp;<br>

<p>
\( u(x,t) \) is the displacement of the string

<p>
<a href="http://phet.colorado.edu/sims/wave-on-a-string/wave-on-a-string_en.html" target="_self">Demo of waves on a string</a>.
</section>


<section class="slide">

<h2 id="___sec1">The complete initial-boundary value problem </h2>

<p>&nbsp;<br>
$$
\begin{align}
\frac{\partial^2 u}{\partial t^2} &=
c^2 \frac{\partial^2 u}{\partial x^2}, \quad &x\in (0,L),\ t\in (0,T]
\tag{1}\\ 
u(x,0) &= I(x), \quad &x\in [0,L]
\tag{2}\\ 
\frac{\partial}{\partial t}u(x,0) &= 0, \quad &x\in [0,L]
\tag{3}\\ 
u(0,t) & = 0, \quad  &t\in (0,T]
\tag{4}\\ 
u(L,t) & = 0, \quad  &t\in (0,T]
\tag{5}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec2">Input data in the problem </h2>

<ul>
 <p><li> Initial condition \( u(x,0)=I(x) \): initial string shape</li>
 <p><li> Initial condition \( u_t(x,0)=0 \): string starts from rest</li>
 <p><li> \( c=\sqrt{T/\varrho} \): velocity of waves on the string</li>
 <p><li> (\( T \) is the tension in the string, \( \varrho \) is density of the string)</li>
 <p><li> Two boundary conditions on \( u \): \( u=0 \) means fixed ends (no displacement)</li>
</ul>
<p>

Rule for number of initial and boundary conditions:

<ul>
 <p><li> \( u_{tt} \) in the PDE: two initial conditions, on \( u \) and \( u_t \)</li>
 <p><li> \( u_{t} \) (and no \( u_{tt} \)) in the PDE: one initial conditions, on \( u \)</li>
 <p><li> \( u_{xx} \) in the PDE: one boundary condition on \( u \) at each boundary point</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec3">Demo of a vibrating string (\( C=0.8 \)) </h2>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-wave/guitar_C0.8/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/guitar_C0.8/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>



<ul>
 <p><li> Our numerical method is sometimes exact (!)</li>
 <p><li> Our numerical method is sometimes subject to serious
   non-physical effects</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec4">Demo of a vibrating string (\( C=1.0012 \)) </h2>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-wave/guitar_C1.0012/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/guitar_C1.0012/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
Ooops!
</section>


<section class="slide">

<h2 id="wave:string:mesh">Step 1: Discretizing the domain</h2>

<p>
Mesh in time:

<p>&nbsp;<br>
$$
\begin{equation}
0 = t_0 < t_1 < t_2 < \cdots < t_{N_t-1} < t_{N_t} = T    \tag{6}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Mesh in space:

<p>&nbsp;<br>
$$
\begin{equation}
0 = x_0 < x_1 < x_2 < \cdots < x_{N_x-1} < x_{N_x} = L    \tag{7}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Uniform mesh with constant mesh spacings \( \Delta t \) and \( \Delta x \):

<p>&nbsp;<br>
$$
\begin{equation}
x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
t_i = n\Delta t,\ n=0,\ldots,N_t
\tag{8}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="wave:string:numerical:sol">The discrete solution</h2>

<ul>
 <p><li> The numerical solution is a mesh function: \( u_i^n \approx \uex(x_i,t_n) \)</li>
 <p><li> Finite difference stencil (or scheme): equation for \( u^n_i \) involving
   neighboring space-time points</li>
</ul>
<p>

<center><p><img src="mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/stencil_n_interior.png" align="bottom" width=500></p></center>
</section>


<section class="slide">

<h2 id="wave:string:samplingPDE">Step 2: Fulfilling the equation at the mesh points</h2>

<p>
Let the PDE be satisfied at all <em>interior</em> mesh points:

<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial^2}{\partial t^2} u(x_i, t_n) =
c^2\frac{\partial^2}{\partial x^2} u(x_i, t_n),
\tag{9}
\end{equation}
$$
<p>&nbsp;<br>

for \( i=1,\ldots,N_x-1 \) and \( n=1,\ldots,N_t-1 \).

<p>
For \( n=0 \) we have the initial conditions \( u=I(x) \) and \( u_t=0 \),
and at the boundaries \( i=0,N_x \) we have the boundary condition \( u=0 \).
</section>


<section class="slide">

<h2 id="wave:string:fd">Step 3: Replacing derivatives by finite differences</h2>

<p>
Widely used finite difference formula for
the second-order derivative:

<p>&nbsp;<br>
$$ \frac{\partial^2}{\partial t^2}u(x_i,t_n)\approx
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}= [D_tD_t u]^n_i$$
<p>&nbsp;<br>

<p>
and

<p>&nbsp;<br>
$$ \frac{\partial^2}{\partial x^2}u(x_i,t_n)\approx
\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2} = [D_xD_x u]^n_i
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec9">Step 3: Algebraic version of the PDE </h2>

<p>
Replace derivatives by differences:

<p>&nbsp;<br>
$$
\begin{equation}
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2} =
c^2\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2},
\tag{10}
\end{equation}
$$
<p>&nbsp;<br>

<p>
In operator notation:

<p>&nbsp;<br>
$$
\begin{equation}
[D_tD_t u = c^2 D_xD_x]^{n}_i
\tag{11}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec10">Step 3: Algebraic version of the initial conditions </h2>

<ul>
 <p><li> Need to replace the derivative in the initial condition
   \( u_t(x,0)=0 \) by a finite difference approximation</li>
 <p><li> The differences for \( u_{tt} \) and \( u_{xx} \) have second-order accuracy</li>
 <p><li> Use a centered difference for \( u_t(x,0) \)</li>
</ul>
<p>&nbsp;<br>
$$ [D_{2t} u]^n_i = 0,\quad n=0\quad\Rightarrow\quad
u^{n-1}_i=u^{n+1}_i,\quad i=0,\ldots,N_x$$
<p>&nbsp;<br>

<p>
The other initial condition \( u(x,0)=I(x) \) can be computed by

<p>&nbsp;<br>
$$ u_i^0 = I(x_i),\quad i=0,\ldots,N_x$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="wave:string:alg">Step 4: Formulating a recursive algorithm</h2>

<ul>
 <p><li> Nature of the algorithm: compute \( u \) in space at \( t=\Delta t, 2\Delta t, 3\Delta t,... \)</li>
 <p><li> Three time levels are involved in the general discrete equation:
   \( n+1 \), \( n \), \( n-1 \)</li>
 <p><li> \( u^n_i \) and \( u^{n-1}_i \) are then already computed for \( i=0,\ldots,N_x \),
   and \( u^{n+1}_i \) is the unknown quantity</li>
</ul>
<p>

Write out \( [D_tD_t u = c^2 D_xD_x]^{n}_i \)
and solve for \( u^{n+1}_i \),

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right)
\tag{12}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec12">The Courant number </h2>

<p>&nbsp;<br>
$$
\begin{equation}
C = c\frac{\Delta t}{\Delta x},
\tag{13}
\end{equation}
$$
<p>&nbsp;<br>

is known as the (dimensionless) <em>Courant number</em>

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Observe.</b>
<p>
There is only one parameter, \( C \), in the discrete model:
\( C \) lumps mesh parameters \( \Delta t \) and \( \Delta x \)
with the only physical parameter, the wave velocity \( c \).
The value \( C \) and the smoothness of \( I(x) \)
govern the quality of the numerical solution.
</div>
</section>


<section class="slide">

<h2 id="___sec13">The finite difference stencil </h2>

<p>
<center><p><img src="mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/stencil_n_interior.png" align="bottom" width=500></p></center>
</section>


<section class="slide">

<h2 id="___sec14">The stencil for the first time level </h2>

<ul>
 <p><li> Problem: the stencil for \( n=1 \) involves \( u^{-1}_i \), but time
   \( t=-\Delta t \) is outside the mesh</li>
 <p><li> Remedy: use the initial condition \( u_t=0 \) together with the
   stencil to eliminate \( u^{-1}_i \)</li>
</ul>
<p>

Initial condition:

<p>&nbsp;<br>
$$ [D_{2t}u=0]^0_i\quad\Rightarrow\quad u^{-1}_i=u^1_i$$
<p>&nbsp;<br>

<p>
Insert in stencil \( [D_tD_tu = c^2D_xD_x]^0_i \) to get

<p>&nbsp;<br>
$$
\begin{equation}
u_i^1 = u^0_i - \half
C^2\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right)
\tag{14}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec15">The algorithm </h2>

<ol>
<p><li> Compute \( u^0_i=I(x_i) \) for \( i=0,\ldots,N_x \)</li>
<p><li> Compute \( u^1_i \) by <a href="#mjx-eqn-14">(14)</a> and set \( u_i^1=0 \)
   for the boundary points \( i=0 \) and \( i=N_x \), for \( n=1,2,\ldots,N-1 \),</li>
<p><li> For each time level \( n=1,2,\ldots,N_t-1 \)</li>

<ol>

<p><li> apply <a href="#mjx-eqn-12">(12)</a> to find \( u^{n+1}_i \) for \( i=1,\ldots,N_x-1 \)</li>

<p><li> set \( u^{n+1}_i=0 \) for the boundary points \( i=0 \), \( i=N_x \).</li>
</ol>
<p>
</ol>
</section>


<section class="slide">

<h2 id="___sec16">Moving finite difference stencil </h2>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<a href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/index.html" target="_self">web page</a>
or a <a href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/movie.ogg" target="_self">movie file</a>.
</section>


<section class="slide">

<h2 id="wave:string:impl">Sketch of an implementation (1)</h2>

<ul>
 <p><li> Arrays:</li>

<ul>

<p><li> <code>u[i]</code> stores \( u^{n+1}_i \)</li>

<p><li> <code>u_1[i]</code> stores \( u^n_i \)</li>

<p><li> <code>u_2[i]</code> stores \( u^{n-1}_i \)</li>
</ul>
<p>
</ul>
<p>

<div class="alert alert-block alert-notice alert-text-normal">
<b style="font-weight: bold">Naming convention.</b>
<p>
<code>u</code> is the unknown to be computed (a spatial mesh
function), <code>u_k</code> is the computed spatial mesh function <code>k</code>
time steps back in time.
</div>
</section>


<section class="slide">

<h2 id="___sec18">PDE solvers should save memory </h2>

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b style="font-weight: bold">Important to minimize the memory usage.</b>
<p>
The algorithm only needs to access the
<em>three most recent time levels</em>, so we need only three arrays for
\( u_i^{n+1} \), \( u_i^n \), and \( u_i^{n-1} \), \( i=0,\ldots,N_x \).
Storing all the solutions in a two-dimensional array of
size \( (N_x+1)\times (N_t+1) \)
would be possible in this simple one-dimensional PDE problem, but not
in large 2D problems and not even in small 3D problems.
</div>
</section>


<section class="slide">

<h2 id="___sec19">Sketch of an implementation (2) </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #228B22"># Given mesh points as arrays x and t (x[i], t[n])</span>
dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
dt = t[<span style="color: #B452CD">1</span>] - t[<span style="color: #B452CD">0</span>]
C = c*dt/dx            <span style="color: #228B22"># Courant number</span>
Nt = <span style="color: #658b00">len</span>(t)-<span style="color: #B452CD">1</span>
C2 = C**<span style="color: #B452CD">2</span>              <span style="color: #228B22"># Help variable in the scheme</span>

<span style="color: #228B22"># Set initial condition u(x,0) = I(x)</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>):
    u_1[i] = I(x[i])

<span style="color: #228B22"># Apply special formula for first step, incorporating du/dt=0</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    u[i] = u_1[i] - <span style="color: #B452CD">0.5</span>*C**<span style="color: #B452CD">2</span>(u_1[i+<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i-<span style="color: #B452CD">1</span>])
u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>   <span style="color: #228B22"># Enforce boundary conditions</span>

<span style="color: #228B22"># Switch variables before next step</span>
u_2[:], u_1[:] = u_1, u

<span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
    <span style="color: #228B22"># Update all inner mesh points at time t[n+1]</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        u[i] = <span style="color: #B452CD">2</span>u_1[i] - u_2[i] - \ 
               C**<span style="color: #B452CD">2</span>(u_1[i+<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i-<span style="color: #B452CD">1</span>])

    <span style="color: #228B22"># Insert boundary conditions</span>
    u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>

    <span style="color: #228B22"># Switch variables before next step</span>
    u_2[:], u_1[:] = u_1, u
</pre></div>
</section>


<section class="slide">

<h1 id="___sec20">Verification </h1>

<ul>
 <p><li> Think about testing and verification before you start implementing
   the algorithm!</li>
 <p><li> Powerful testing tool: method of manufactured solutions and
   computation of convergence rates</li>
 <p><li> Will need a source term in the PDE and \( u_t(x,0)\neq 0 \)</li>
 <p><li> Even more powerful method: exact solution of the scheme</li>
</ul>
</section>


<section class="slide">

<h2 id="wave:pde2:fd">A slightly generalized model problem</h2>

<p>
Add source term \( f \) and nonzero initial condition \( u_t(x,0) \):

<p>&nbsp;<br>
$$
\begin{align}
u_{tt} &= c^2 u_{xx} + f(x,t),
\tag{15}\\ 
u(x,0) &= I(x), \quad &x\in [0,L]
\tag{16}\\ 
u_t(x,0) &= V(x), \quad &x\in [0,L]
\tag{17}\\ 
u(0,t) & = 0, \quad & t>0,
\tag{18}\\ 
u(L,t) & = 0, \quad  &t>0
\tag{19}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec22">Discrete model for the generalized model problem </h2>

<p>&nbsp;<br>
$$
\begin{equation}
[D_tD_t u = c^2 D_xD_x + f]^{n}_i
\tag{20}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Writing out and solving for the unknown \( u^{n+1}_i \):

<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}) + \Delta t^2 f^n_i
\tag{21}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec23">Modified equation for the first time level </h2>

<p>
Centered difference for \( u_t(x,0) = V(x) \):

<p>&nbsp;<br>
$$ [D_{2t}u = V]^0_i\quad\Rightarrow\quad u^{-1}_i = u^{1}_i - 2\Delta t V_i,$$
<p>&nbsp;<br>

<p>
Inserting this in the stencil <a href="#mjx-eqn-21">(21)</a> for \( n=0 \) leads to

<p>&nbsp;<br>
$$
\begin{equation}
u^{1}_i = u^0_i - \Delta t V_i + {\half}
C^2
\left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right) + \half\Delta t^2 f^n_i
\tag{22}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec24">Using an analytical solution of physical significance </h2>

<ul>
 <p><li> Standing waves occur in real life on a string</li>
 <p><li> Can be analyzed mathematically (known exact solution)</li>
</ul>
<p>&nbsp;<br>
$$
\begin{equation}
\uex(x,y,t)) = A\sin\left(\frac{\pi}{L}x\right)
\cos\left(\frac{\pi}{L}ct\right)
\tag{23}
\end{equation}
$$
<p>&nbsp;<br>


<ul>
 <p><li> PDE data: \( f=0 \), boundary conditions
   \( \uex(0,t)=\uex(L,0)=0 \), initial
   conditions \( I(x)=A\sin\left(\frac{\pi}{L}x\right) \) and \( V=0 \)</li>
 <p><li> Note: \( u_i^{n+1}\neq\uex(x_i,t_{n+1} \), and we do not know
   the error, so testing must aim at reproducing the expected
   convergence rates</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec25">Manufactured solution: principles </h2>

<ul>
 <p><li> Disadvantage with the previous physical solution:
   it does not test \( V\neq 0 \) and \( f\neq 0 \)</li>
 <p><li> Method of manufactured solution:</li>

<ul>

<p><li> Choose some \( \uex(x,t) \)</li>

<p><li> Insert in PDE and fit \( f \)</li>

<p><li> Set boundary and initial conditions compatible with the chosen \( \uex(x,t) \)</li>
</ul>
<p>
</ul>
</section>


<section class="slide">

<h2 id="___sec26">Manufactured solution: example </h2>

<p>&nbsp;<br>
$$ \uex(x,t) = x(L-x)\sin t$$
<p>&nbsp;<br>

<p>
PDE \( u_{tt}=c^2u_{xx}+f \):

<p>&nbsp;<br>
$$ -x(L-x)\sin t = -2\sin t + f\quad\Rightarrow f = (2 - x(L-x))\sin t$$
<p>&nbsp;<br>

<p>
Implied initial conditions:

<p>&nbsp;<br>
$$
\begin{align*}
u(x,0) &= I(x) = 0\\ 
u_t(x,0) &= V(x) = - x(L-x)
\end{align*}
$$
<p>&nbsp;<br>

<p>
Boundary conditions:

<p>&nbsp;<br>
$$ u(x,0) = u(x,L) = 0 $$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec27">Testing a manufactured solution </h2>

<ul>
 <p><li> Introduce common mesh parameter: \( h=\Delta t \), \( \Delta x =ch/C \)</li>
 <p><li> This \( h \) keeps \( C \) and \( \Delta t/\Delta x \) constant</li>
 <p><li> Select coarse mesh \( h \): \( h_0 \)</li>
 <p><li> Run experiments with \( h_i=2^{-i}h_0 \) (halving the cell size), \( i=0,\ldots,m \)</li>
 <p><li> Record the error \( E_i \) and \( h_i \) in each experiment</li>
 <p><li> Compute pariwise convergence rates \( r_i=
   \ln E_{i+1}/E_{i}/\ln h_{i+1}/h_{i} \)</li>
 <p><li> Verification: \( r_i\rightarrow 2 \) as \( i \) increases</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec28">Constructing an exact solution of the discrete equations </h2>

<ul>
 <p><li> Manufactured solution with computation of
   convergence rates: much manual work</li>
 <p><li> Simpler and more powerful: use an exact solution for \( u^{n}_i \)</li>
 <p><li> A linear or quadratic \( \uex \) in \( x \) and \( t \) is often a good candidate</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec29">Analytical work with the PDE problem </h2>

<p>
Here, choose \( \uex \) such that \( \uex(x,0)=\uex(L,0)=0 \):

<p>&nbsp;<br>
$$ \uex (x,t) = x(L-x)(1+{\half}t), $$
<p>&nbsp;<br>

<p>
Insert in the PDE and find \( f \):

<p>&nbsp;<br>
$$ f(x,t)=2(1+t)c^2$$
<p>&nbsp;<br>

<p>
Initial conditions:

<p>&nbsp;<br>
$$ I(x) = x(L-x),\quad V(x)={\half}x(L-x) $$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec30">Analytical work with the discrete equations (1) </h2>

<p>
We want to show that \( \uex \) also solves the discrete equations!

<p>
Useful preliminary result:
<p>&nbsp;<br>
$$
\begin{align}
\lbrack D_tD_t t^2\rbrack^n &= \frac{t_{n+1}^2 - 2t_n^2 + t_{n-1}^2}{\Delta t^2}
= (n+1)^2 -n^2 + (n-1)^2 = 2
\tag{24}\\ 
\lbrack D_tD_t t\rbrack^n &= \frac{t_{n+1} - 2t_n + t_{n-1}}{\Delta t^2}
= \frac{((n+1) -n + (n-1))\Delta t}{\Delta t^2} = 0
\tag{25}
\end{align}
$$
<p>&nbsp;<br>

<p>
Hence,
<p>&nbsp;<br>
$$ [D_tD_t \uex]^n_i = x_i(L-x_i)[D_tD_t (1+{\half}t)]^n =
x_i(L-x_i){\half}[D_tD_t t]^n = 0$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec31">Analytical work with the discrete equations (1) </h2>

<p>&nbsp;<br>
$$
\begin{align*}
\lbrack D_xD_x \uex\rbrack^n_i &=
(1+{\half}t_n)\lbrack D_xD_x (xL-x^2)\rbrack_i =
(1+{\half}t_n)\lbrack LD_xD_x x - D_xD_x x^2\rbrack_i \\ 
&= -2(1+{\half}t_n)
\end{align*}
$$
<p>&nbsp;<br>

<p>
Now, \( f^n_i = 2(1+{\half}t_n)c^2 \) and we get

<p>&nbsp;<br>
$$ [D_tD_t \uex - c^2D_xD_x\uex - f]^n_i = 0 - c^2(-1)2(1 + {\half}t_n
+ 2(1+{\half}t_n)c^2 = 0$$
<p>&nbsp;<br>

<p>
Moreover, \( \uex(x_i,0)=I(x_i) \),
\( \partial \uex/\partial t = V(x_i) \) at \( t=0 \), and
\( \uex(x_0,t)=\uex(x_{N_x},0)=0 \). Also the modified scheme for the
first time step is fulfilled by \( \uex(x_i,t_n) \).
</section>


<section class="slide">

<h2 id="___sec32">Testing with the exact discrete solution </h2>

<ul>
 <p><li> We have established that \( u^{n+1}_i = \uex(x_i,t_{n+1})=x_i(L-x_i)(1+t_{n+1}/2) \)</li>
 <p><li> Run <em>one</em> simulation with one choice of \( c \), \( \Delta t \), and \( \Delta x \)</li>
 <p><li> Check that \( \max_i |u^{n+1}_i - \uex(x_i,t_{n+1})| < \epsilon \),
   \( \epsilon\sim 10^{-14} \) (machine precision + some round-off errors)</li>
 <p><li> This is the simplest and best verification test</li>
</ul>
<p>


<p class="slide">

Later we show that the exact solution of the discrete equations
can be obtained by \( C=1 \) (!)

</p>
</section>


<section class="slide">

<h1 id="wave:pde1:impl">Implementation</h1>
</section>


<section class="slide">

<h2 id="___sec34">The algorithm </h2>

<ol>
<p><li> Compute \( u^0_i=I(x_i) \) for \( i=0,\ldots,N_x \)</li>
<p><li> Compute \( u^1_i \) by <a href="#mjx-eqn-14">(14)</a> and set \( u_i^1=0 \)
   for the boundary points \( i=0 \) and \( i=N_x \), for \( n=1,2,\ldots,N-1 \),</li>
<p><li> For each time level \( n=1,2,\ldots,N_t-1 \)</li>

<ol>

<p><li> apply <a href="#mjx-eqn-12">(12)</a> to find \( u^{n+1}_i \) for \( i=1,\ldots,N_x-1 \)</li>

<p><li> set \( u^{n+1}_i=0 \) for the boundary points \( i=0 \), \( i=N_x \).</li>
</ol>
<p>
</ol>
</section>


<section class="slide">

<h2 id="___sec35">What do to with the solution? </h2>

<ul>
 <p><li> Different problem settings demand different actions with the
   computed \( u^{n+1}_i \) at each time step</li>
 <p><li> Solution: let the solver function make a callback to a
   user function where the user can do whatever is desired with
   the solution</li>
 <p><li> Advantage: solver just solves and user uses the solution</li>
</ul>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">user_action</span>(u, x, t, n):
    <span style="color: #228B22"># u[i] at spatial mesh points x[i] at time t[n]</span>
    <span style="color: #228B22"># plot u</span>
    <span style="color: #228B22"># or store u</span>
</pre></div>
</section>


<section class="slide">

<h2 id="___sec36">Making a solver function </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, V, f, c, L, dt, C, T, user_action=<span style="color: #658b00">None</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;Solve u_tt=c^2*u_xx + f on (0,L)x(0,T].&quot;&quot;&quot;</span>
    Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/dt))
    t = np.linspace(<span style="color: #B452CD">0</span>, Nt*dt, Nt+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Mesh points in time</span>
    dx = dt*c/<span style="color: #658b00">float</span>(C)
    Nx = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(L/dx))
    x = np.linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)       <span style="color: #228B22"># Mesh points in space</span>
    C2 = C**<span style="color: #B452CD">2</span>                      <span style="color: #228B22"># Help variable in the scheme</span>
    <span style="color: #8B008B; font-weight: bold">if</span> f <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span> <span style="color: #8B008B">or</span> f == <span style="color: #B452CD">0</span> :
        f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">if</span> V <span style="color: #8B008B">is</span> <span style="color: #658b00">None</span> <span style="color: #8B008B">or</span> V == <span style="color: #B452CD">0</span>:
        V = <span style="color: #8B008B; font-weight: bold">lambda</span> x: <span style="color: #B452CD">0</span>

    u   = np.zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution array at new time level</span>
    u_1 = np.zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution at 1 time level back</span>
    u_2 = np.zeros(Nx+<span style="color: #B452CD">1</span>)   <span style="color: #228B22"># Solution at 2 time levels back</span>

    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>;  t0 = time.clock()  <span style="color: #228B22"># for measuring CPU time</span>

    <span style="color: #228B22"># Load initial condition into u_1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>,Nx+<span style="color: #B452CD">1</span>):
        u_1[i] = I(x[i])

    <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
        user_action(u_1, x, t, <span style="color: #B452CD">0</span>)

    <span style="color: #228B22"># Special formula for first time step</span>
    n = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
        u[i] = u_1[i] + dt*V(x[i]) + \ 
               <span style="color: #B452CD">0.5</span>*C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>]) + \ 
               <span style="color: #B452CD">0.5</span>*dt**<span style="color: #B452CD">2</span>*f(x[i], t[n])
    u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>

    <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
        user_action(u, x, t, <span style="color: #B452CD">1</span>)

    <span style="color: #228B22"># Switch variables before next step</span>
    u_2[:] = u_1;  u_1[:] = u

    <span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nt):
        <span style="color: #228B22"># Update all inner points at time t[n+1]</span>
        <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
            u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
                     C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>]) + \ 
                     dt**<span style="color: #B452CD">2</span>*f(x[i], t[n])

        <span style="color: #228B22"># Insert boundary conditions</span>
        u[<span style="color: #B452CD">0</span>] = <span style="color: #B452CD">0</span>;  u[Nx] = <span style="color: #B452CD">0</span>
        <span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
            <span style="color: #8B008B; font-weight: bold">if</span> user_action(u, x, t, n+<span style="color: #B452CD">1</span>):
                <span style="color: #8B008B; font-weight: bold">break</span>

        <span style="color: #228B22"># Switch variables before next step</span>
        u_2[:] = u_1;  u_1[:] = u

    cpu_time = t0 - time.clock()
    <span style="color: #8B008B; font-weight: bold">return</span> u, x, t, cpu_time
</pre></div>
</section>


<section class="slide">

<h2 id="___sec37">Verification: exact quadratic solution </h2>

<p>
Exact solution of the PDE problem <em>and</em> the discrete equations:
\( \uex (x,t) = x(L-x)(1+{\half}t) \)

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_quadratic</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;Check that u(x,t)=x(L-x)(1+t/2) is exactly reproduced.&quot;&quot;&quot;</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">u_exact</span>(x, t):
        <span style="color: #8B008B; font-weight: bold">return</span> x*(L-x)*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> u_exact(x, <span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">V</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0.5</span>*u_exact(x, <span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x, t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2</span>*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)*c**<span style="color: #B452CD">2</span>

    L = <span style="color: #B452CD">2.5</span>
    c = <span style="color: #B452CD">1.5</span>
    C = <span style="color: #B452CD">0.75</span>
    Nx = <span style="color: #B452CD">6</span>  <span style="color: #228B22"># Very coarse mesh for this exact test</span>
    dt = C*(L/Nx)/c
    T = <span style="color: #B452CD">18</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assert_no_error</span>(u, x, t, n):
        u_e = u_exact(x, t[n])
        diff = np.abs(u - u_e).max()
        tol = <span style="color: #B452CD">1E-13</span>
        <span style="color: #8B008B; font-weight: bold">assert</span> diff &lt; tol

    solver(I, V, f, c, L, dt, C, T,
           user_action=assert_no_error)
</pre></div>
</section>


<section class="slide">

<h2 id="___sec38">Visualization: animating \( u(x,t) \) </h2>

<p>
Make a <code>viz</code> function for animating the curve, with plotting
in a <code>user_action</code> function <code>plot_u</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">viz</span>(
    I, V, f, c, L, dt, C, T,  <span style="color: #228B22"># PDE paramteres</span>
    umin, umax,               <span style="color: #228B22"># Interval for u in plots</span>
    animate=<span style="color: #658b00">True</span>,             <span style="color: #228B22"># Simulation with animation?</span>
    tool=<span style="color: #CD5555">&#39;matplotlib&#39;</span>,        <span style="color: #228B22"># &#39;matplotlib&#39; or &#39;scitools&#39;</span>
    solver_function=solver,   <span style="color: #228B22"># Function with numerical algorithm</span>
    ):
    <span style="color: #CD5555">&quot;&quot;&quot;Run solver and visualize u at each time level.&quot;&quot;&quot;</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">plot_u_st</span>(u, x, t, n):
        <span style="color: #CD5555">&quot;&quot;&quot;user_action function for solver.&quot;&quot;&quot;</span>
        plt.plot(x, u, <span style="color: #CD5555">&#39;r-&#39;</span>,
                 xlabel=<span style="color: #CD5555">&#39;x&#39;</span>, ylabel=<span style="color: #CD5555">&#39;u&#39;</span>,
                 axis=[<span style="color: #B452CD">0</span>, L, umin, umax],
                 title=<span style="color: #CD5555">&#39;t=%f&#39;</span> % t[n], show=<span style="color: #658b00">True</span>)
        <span style="color: #228B22"># Let the initial condition stay on the screen for 2</span>
        <span style="color: #228B22"># seconds, else insert a pause of 0.2 s between each plot</span>
        time.sleep(<span style="color: #B452CD">2</span>) <span style="color: #8B008B; font-weight: bold">if</span> t[n] == <span style="color: #B452CD">0</span> <span style="color: #8B008B; font-weight: bold">else</span> time.sleep(<span style="color: #B452CD">0.2</span>)
        plt.savefig(<span style="color: #CD5555">&#39;frame_%04d.png&#39;</span> % n)  <span style="color: #228B22"># for movie making</span>

    <span style="color: #8B008B; font-weight: bold">class</span> <span style="color: #008b45; font-weight: bold">PlotMatplotlib</span>:
        <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">__call__</span>(<span style="color: #658b00">self</span>, u, x, t, n):
            <span style="color: #CD5555">&quot;&quot;&quot;user_action function for solver.&quot;&quot;&quot;</span>
            <span style="color: #8B008B; font-weight: bold">if</span> n == <span style="color: #B452CD">0</span>:
                plt.ion()
                <span style="color: #658b00">self</span>.lines = plt.plot(x, u, <span style="color: #CD5555">&#39;r-&#39;</span>)
                plt.xlabel(<span style="color: #CD5555">&#39;x&#39;</span>);  plt.ylabel(<span style="color: #CD5555">&#39;u&#39;</span>)
                plt.axis([<span style="color: #B452CD">0</span>, L, umin, umax])
                plt.legend([<span style="color: #CD5555">&#39;t=%f&#39;</span> % t[n]], loc=<span style="color: #CD5555">&#39;lower left&#39;</span>)
            <span style="color: #8B008B; font-weight: bold">else</span>:
                <span style="color: #658b00">self</span>.lines[<span style="color: #B452CD">0</span>].set_ydata(u)
                plt.legend([<span style="color: #CD5555">&#39;t=%f&#39;</span> % t[n]], loc=<span style="color: #CD5555">&#39;lower left&#39;</span>)
                plt.draw()
            time.sleep(<span style="color: #B452CD">2</span>) <span style="color: #8B008B; font-weight: bold">if</span> t[n] == <span style="color: #B452CD">0</span> <span style="color: #8B008B; font-weight: bold">else</span> time.sleep(<span style="color: #B452CD">0.2</span>)
            plt.savefig(<span style="color: #CD5555">&#39;tmp_%04d.png&#39;</span> % n)  <span style="color: #228B22"># for movie making</span>

    <span style="color: #8B008B; font-weight: bold">if</span> tool == <span style="color: #CD5555">&#39;matplotlib&#39;</span>:
        <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
        plot_u = PlotMatplotlib()
    <span style="color: #8B008B; font-weight: bold">elif</span> tool == <span style="color: #CD5555">&#39;scitools&#39;</span>:
        <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">scitools.std</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>  <span style="color: #228B22"># scitools.easyviz interface</span>
        plot_u = plot_u_st
    <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">time</span>, <span style="color: #008b45; text-decoration: underline">glob</span>, <span style="color: #008b45; text-decoration: underline">os</span>

    <span style="color: #228B22"># Clean up old movie frames</span>
    <span style="color: #8B008B; font-weight: bold">for</span> filename <span style="color: #8B008B">in</span> glob.glob(<span style="color: #CD5555">&#39;tmp_*.png&#39;</span>):
        os.remove(filename)

    <span style="color: #228B22"># Call solver and do the simulaton</span>
    user_action = plot_u <span style="color: #8B008B; font-weight: bold">if</span> animate <span style="color: #8B008B; font-weight: bold">else</span> <span style="color: #658b00">None</span>
    u, x, t, cpu = solver_function(
        I, V, f, c, L, dt, C, T, user_action)

    <span style="color: #228B22"># Make video files</span>
    fps = <span style="color: #B452CD">4</span>  <span style="color: #228B22"># frames per second</span>
    codec2ext = <span style="color: #658b00">dict</span>(flv=<span style="color: #CD5555">&#39;flv&#39;</span>, libx264=<span style="color: #CD5555">&#39;mp4&#39;</span>, libvpx=<span style="color: #CD5555">&#39;webm&#39;</span>,
                     libtheora=<span style="color: #CD5555">&#39;ogg&#39;</span>)  <span style="color: #228B22"># video formats</span>
    filespec = <span style="color: #CD5555">&#39;tmp_%04d.png&#39;</span>
    movie_program = <span style="color: #CD5555">&#39;ffmpeg&#39;</span>  <span style="color: #228B22"># or &#39;avconv&#39;</span>
    <span style="color: #8B008B; font-weight: bold">for</span> codec <span style="color: #8B008B">in</span> codec2ext:
        ext = codec2ext[codec]
        cmd = <span style="color: #CD5555">&#39;%(movie_program)s -r %(fps)d -i %(filespec)s &#39;</span>\ 
              <span style="color: #CD5555">&#39;-vcodec %(codec)s movie.%(ext)s&#39;</span> % <span style="color: #658b00">vars</span>()
        os.system(cmd)

    <span style="color: #8B008B; font-weight: bold">if</span> tool == <span style="color: #CD5555">&#39;scitools&#39;</span>:
        <span style="color: #228B22"># Make an HTML play for showing the animation in a browser</span>
        plt.movie(<span style="color: #CD5555">&#39;tmp_*.png&#39;</span>, encoder=<span style="color: #CD5555">&#39;html&#39;</span>, fps=fps,
                  output_file=<span style="color: #CD5555">&#39;movie.html&#39;</span>)
    <span style="color: #8B008B; font-weight: bold">return</span> cpu
</pre></div>
<p>
Note: <code>plot_u</code> is function inside function and remembers the
local variables in <code>viz</code> (known as a closure).
</section>


<section class="slide">

<h2 id="___sec39">Making movie files </h2>

<ul>
 <p><li> Store spatial curve in a file, for each time level</li>
 <p><li> Name files like <code>'something_%04d.png' % frame_counter</code></li>
 <p><li> Combine files to a movie</li>
</ul>
<p>

<!-- code=text (!bc sys) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Terminal&gt; scitools movie encoder=html output_file=movie.html \ 
          fps=4 frame_*.png  # web page with a player
Terminal&gt; avconv -r 4 -i frame_%04d.png -c:v flv       movie.flv
Terminal&gt; avconv -r 4 -i frame_%04d.png -c:v libtheora movie.ogg
Terminal&gt; avconv -r 4 -i frame_%04d.png -c:v libx264   movie.mp4
Terminal&gt; avconv -r 4 -i frame_%04d.png -c:v libpvx    movie.webm
</pre></div>
<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b style="font-weight: bold">Important.</b>
<ul>
 <p><li> Zero padding (<code>%04d</code>) is essential for correct sequence of
   frames in <code>something_*.png</code> (Unix alphanumeric sort)</li>
 <p><li> Remove old <code>frame_*.png</code> files before making a new movie</li>
</ul>
</div>
</section>


<section class="slide">

<h2 id="wave:pde1:guitar:data">Running a case</h2>

<ul>
 <p><li> Vibrations of a guitar string</li>
 <p><li> Triangular initial shape (at rest)</li>
</ul>
<p>&nbsp;<br>
$$
\begin{equation}
I(x) = \left\lbrace
\begin{array}{ll}
ax/x_0, & x < x_0\\ 
a(L-x)/(L-x_0), & \hbox{otherwise}
\end{array}\right.
\tag{26}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Appropriate data:

<ul>

<p><li> \( L=75 \) cm, \( x_0=0.8L \), \( a=5 \) mm, time frequency \( \nu = 440 \) Hz</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec41">Implementation of the case </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">guitar</span>(C):
    <span style="color: #CD5555">&quot;&quot;&quot;Triangular wave (pulled guitar string).&quot;&quot;&quot;</span>
    L = <span style="color: #B452CD">0.75</span>
    x0 = <span style="color: #B452CD">0.8</span>*L
    a = <span style="color: #B452CD">0.005</span>
    freq = <span style="color: #B452CD">440</span>
    wavelength = <span style="color: #B452CD">2</span>*L
    c = freq*wavelength
    omega = <span style="color: #B452CD">2</span>*pi*freq
    num_periods = <span style="color: #B452CD">1</span>
    T = <span style="color: #B452CD">2</span>*pi/omega*num_periods
    <span style="color: #228B22"># Choose dt the same as the stability limit for Nx=50</span>
    dt = L/<span style="color: #B452CD">50.</span>/c

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x):
        <span style="color: #8B008B; font-weight: bold">return</span> a*x/x0 <span style="color: #8B008B; font-weight: bold">if</span> x &lt; x0 <span style="color: #8B008B; font-weight: bold">else</span> a/(L-x0)*(L-x)

    umin = -<span style="color: #B452CD">1.2</span>*a;  umax = -umin
    cpu = viz(I, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">0</span>, c, L, dt, C, T, umin, umax,
              animate=<span style="color: #658b00">True</span>, tool=<span style="color: #CD5555">&#39;scitools&#39;</span>)
</pre></div>
<p>
Program: <a href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_u0.py" target="_self"><tt>wave1D_u0.py</tt></a>.
</section>


<section class="slide">

<h2 id="___sec42">Resulting movie for \( C=0.8 \) </h2>

<p>

<div>
<video  loop controls width='800' height='365' preload='none'>
    <source src='mov-wave/guitar_C0.8/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/guitar_C0.8/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<a href="http://tinyurl.com/opdfafk/pub/mov-wave/guitar_C0.8/index.html" target="_self">Movie of the vibrating string</a>
</section>


<section class="slide">

<h2 id="___sec43">The benefits of scaling </h2>

<ul>
 <p><li> It is difficult to figure out all the physical parameters of a case</li>
 <p><li> And it is not necessary because of a powerful: <em>scaling</em></li>
</ul>
<p>

Introduce new \( x \), \( t \), and \( u \) without dimension:

<p>&nbsp;<br>
$$ \bar x = \frac{x}{L},\quad \bar t = \frac{c}{L}t,\quad
\bar u = \frac{u}{a}
$$
<p>&nbsp;<br>

<p>
Insert this in the PDE (with \( f=0 \)) and dropping bars

<p>&nbsp;<br>
$$ u_{tt} = u_{xx}$$
<p>&nbsp;<br>

<p>
Initial condition: set \( a=1 \), \( L=1 \), and
\( x_0\in [0,1] \) in <a href="#mjx-eqn-26">(26)</a>.

<p>
In the code: set <code>a=c=L=1</code>, <code>x0=0.8</code>, and there is no need to calculate with
wavelengths and frequencies to estimate \( c \)!

<p>
Just one challenge: determine the period of the waves and an
appropriate end time (see the text for details).
</section>


<section class="slide">

<h1 id="wave:pde1:impl:vec">Vectorization</h1>

<ul>
 <p><li> Problem: Python loops over long arrays are slow</li>
 <p><li> One remedy: use vectorized (<code>numpy</code>) code instead of explicit loops</li>
 <p><li> Other remedies: use Cython, port spatial loops to Fortran or C</li>
 <p><li> Speedup: 100-1000 (varies with \( N_x \))</li>
</ul>
<p>

Next: vectorized loops
</section>


<section class="slide">

<h2 id="___sec45">Operations on slices of arrays </h2>

<ul>
 <p><li> Introductory example: compute \( d_i = u_{i+1}-u_i \)</li>
</ul>
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">n = u.size
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, n-<span style="color: #B452CD">1</span>):
    d[i] = u[i+<span style="color: #B452CD">1</span>] - u[i]
</pre></div>
<ul>
 <p><li> Note: all the differences here are independent of each other.</li>
 <p><li> Therefore \( d = (u_1,u_2,\ldots,u_n) - (u_0,u_1,\ldots,u_{n-1}) \)</li>
 <p><li> In <code>numpy</code> code: <code>u[1:n] - u[0:n-1]</code> or just <code>u[1:] - u[:-1]</code></li>
</ul>
<p>

<center><p><img src="fig-wave/vectorized_diff.png" align="bottom" width=400></p></center>
</section>


<section class="slide">

<h2 id="___sec46">Test the understanding </h2>

<p>
Newcomers to vectorization are encouraged to choose
a small array <code>u</code>, say with five elements,
and simulate with pen and paper
both the loop version and the vectorized version.
</section>


<section class="slide">

<h2 id="___sec47">Vectorization of finite difference schemes (1) </h2>

<p>
Finite difference schemes basically contains differences between array
elements with shifted indices. Consider the updating formula

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, n-<span style="color: #B452CD">1</span>):
    u2[i] = u[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u[i] + u[i+<span style="color: #B452CD">1</span>]
</pre></div>
<p>
The vectorization consists of replacing the loop by arithmetics on
slices of arrays of length <code>n-2</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u2 = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:]
u2 = u[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:n]   <span style="color: #228B22"># alternative</span>
</pre></div>
<p>
Note: <code>u2</code> gets length <code>n-2</code>.

<p>
If <code>u2</code> is already an array of length <code>n</code>, do update on "inner" elements

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]  = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:]
u2[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] = u[<span style="color: #B452CD">0</span>:n-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:n-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:n]   <span style="color: #228B22"># alternative</span>
</pre></div>
</section>


<section class="slide">

<h2 id="___sec48">Vectorization of finite difference schemes (2) </h2>

<p>
Include a function evaluation too:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x):
    <span style="color: #8B008B; font-weight: bold">return</span> x**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>

<span style="color: #228B22"># Scalar version</span>
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, n-<span style="color: #B452CD">1</span>):
    u2[i] = u[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u[i] + u[i+<span style="color: #B452CD">1</span>] + f(x[i])

<span style="color: #228B22"># Vectorized version</span>
u2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = u[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u[<span style="color: #B452CD">2</span>:] + f(x[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>])
</pre></div>
</section>


<section class="slide">

<h2 id="___sec49">Vectorized implementation in the solver function </h2>

<p>
Scalar loop:
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    u[i] = <span style="color: #B452CD">2</span>*u_1[i] - u_2[i] + \ 
           C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])
</pre></div>
<p>
Vectorized loop:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = - u_2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + \ 
          C2*(u_1[:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u_1[<span style="color: #B452CD">2</span>:])
</pre></div>
<p>
or
<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:Nx] = <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:Nx]- u_2[<span style="color: #B452CD">1</span>:Nx] + \ 
          C2*(u_1[<span style="color: #B452CD">0</span>:Nx-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:Nx] + u_1[<span style="color: #B452CD">2</span>:Nx+<span style="color: #B452CD">1</span>])
</pre></div>
<p>
Program: <a href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_u0v.py" target="_self"><tt>wave1D_u0v.py</tt></a>
</section>


<section class="slide">

<h2 id="___sec50">Verification of the vectorized version </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_quadratic</span>():
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Check the scalar and vectorized versions work for</span>
<span style="color: #CD5555">    a quadratic u(x,t)=x(L-x)(1+t/2) that is exactly reproduced.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># The following function must work for x as array or scalar</span>
    u_exact = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: x*(L - x)*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)
    I = <span style="color: #8B008B; font-weight: bold">lambda</span> x: u_exact(x, <span style="color: #B452CD">0</span>)
    V = <span style="color: #8B008B; font-weight: bold">lambda</span> x: <span style="color: #B452CD">0.5</span>*u_exact(x, <span style="color: #B452CD">0</span>)
    <span style="color: #228B22"># f is a scalar (zeros_like(x) works for scalar x too)</span>
    f = <span style="color: #8B008B; font-weight: bold">lambda</span> x, t: np.zeros_like(x) + <span style="color: #B452CD">2</span>*c**<span style="color: #B452CD">2</span>*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)

    L = <span style="color: #B452CD">2.5</span>
    c = <span style="color: #B452CD">1.5</span>
    C = <span style="color: #B452CD">0.75</span>
    Nx = <span style="color: #B452CD">3</span>  <span style="color: #228B22"># Very coarse mesh for this exact test</span>
    dt = C*(L/Nx)/c
    T = <span style="color: #B452CD">18</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assert_no_error</span>(u, x, t, n):
        u_e = u_exact(x, t[n])
        tol = <span style="color: #B452CD">1E-13</span>
        diff = np.abs(u - u_e).max()
        <span style="color: #8B008B; font-weight: bold">assert</span> diff &lt; tol

    solver(I, V, f, c, L, dt, C, T,
           user_action=assert_no_error, version=<span style="color: #CD5555">&#39;scalar&#39;</span>)
    solver(I, V, f, c, L, dt, C, T,
           user_action=assert_no_error, version=<span style="color: #CD5555">&#39;vectorized&#39;</span>)
</pre></div>
<p>
Note:

<ul>
 <p><li> Compact code with lambda functions</li>
 <p><li> The scalar \( f \) value needs careful coding: return constant array
   if vectorized code, else number</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec51">Efficiency measurements </h2>

<ul>
 <p><li> Run <code>wave1D_u0v.py</code> for \( N_x \) as 50,100,200,400,800
   and measuring the CPU time</li>
 <p><li> Observe substantial speed-up: vectorized version is
   about \( N_x/5 \) times faster</li>
</ul>
<p>

Much bigger improvements for 2D and 3D codes!
</section>


<section class="slide">

<h1 id="___sec52">Generalization: reflecting boundaries </h1>

<ul>
 <p><li> Boundary condition \( u=0 \): \( u \) changes sign</li>
 <p><li> Boundary condition \( u_x=0 \): wave is perfectly reflected</li>
 <p><li> How can we implement \( u_x \)? (more complicated than \( u=0 \))</li>
</ul>
<p>


<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-wave/demo_BC_gaussian/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/demo_BC_gaussian/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<a href="http://phet.colorado.edu/sims/wave-on-a-string/wave-on-a-string_en.html" target="_self">Demo of boundary conditions</a>
</section>


<section class="slide">

<h2 id="wave:pde2:Neumann">Neumann boundary condition</h2>

<p>&nbsp;<br>
$$
\begin{equation}
 \frac{\partial u}{\partial n} \equiv \normalvec\cdot\nabla u = 0
\tag{27}
\end{equation}
$$
<p>&nbsp;<br>

<p>
For a 1D domain \( [0,L] \):

<p>&nbsp;<br>
$$
\left.\frac{\partial}{\partial n}\right\vert_{x=L} =
\frac{\partial}{\partial x},\quad
\left.\frac{\partial}{\partial n}\right\vert_{x=0} = -
\frac{\partial}{\partial x}
$$
<p>&nbsp;<br>

<p>
Boundary condition terminology:

<ul>

<p><li> \( u_x \) specified: <a href="http://en.wikipedia.org/wiki/Neumann_boundary_condition" target="_self">Neumann</a> condition</li>

<p><li> \( u \) specified: <a href="http://en.wikipedia.org/wiki/Dirichlet_conditions" target="_self">Dirichlet</a> condition</li>
</ul>
</section>


<section class="slide">

<h2 id="wave:pde2:Neumann:discr">Discretization of derivatives at the boundary (1)</h2>

<ul>
 <p><li> How can we incorporate the condition \( u_x=0 \)
   in the finite difference scheme?</li>
 <p><li> We used centeral differences for \( u_{tt} \) and \( u_{xx} \): \( \Oof{\Delta t^2, \Delta x^2} \) accuracy</li>
 <p><li> Also for \( u_t(x,0) \)</li>
 <p><li> Should use central difference for \( u_x \) to preserve second order accuracy</li>
</ul>
<p>&nbsp;<br>
$$
\begin{equation}
\frac{u_{-1}^n - u_1^n}{2\Delta x} = 0
\tag{28}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec55">Discretization of derivatives at the boundary (2) </h2>

<p>&nbsp;<br>
$$
\frac{u_{-1}^n - u_1^n}{2\Delta x} = 0
$$
<p>&nbsp;<br>


<ul>
 <p><li> Problem: \( u_{-1}^n \) is outside the mesh (fictitious value)</li>
 <p><li> Remedy: use the stencil at the boundary to eliminate \( u_{-1}^n \);
   just replace \( u_{-1}^n \) by \( u_{1}^n \)</li>
</ul>
<p>&nbsp;<br>
$$
\begin{equation}
u^{n+1}_i = -u^{n-1}_i  + 2u^n_i + 2C^2
\left(u^{n}_{i+1}-u^{n}_{i}\right),\quad i=0    \tag{29}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec56">Visualization of modified boundary stencil </h2>

<p>
Discrete equation
for computing \( u^3_0 \) in terms of \( u^2_0 \), \( u^1_0 \), and
\( u^2_1 \):

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
Animation
in a <a href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/index.html" target="_self">web page</a>
or a <a href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.ogg" target="_self">movie file</a>.
</section>


<section class="slide">

<h2 id="wave:pde2:Neumann:impl">Implementation of Neumann conditions</h2>

<ul>
 <p><li> Use the general stencil for interior points also on the boundary</li>
 <p><li> Replace \( u_{i-1}^n \) by \( u_{i+1}^n \) for \( i=0 \)</li>
 <p><li> Replace \( u_{i+1}^n \) by \( u_{i-1}^n \) for \( i=N_x \)</li>
</ul>
<p>

<!-- code=text (!bc cod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">i = 0
ip1 = i+1
im1 = ip1  # i-1 -&gt; i+1
u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])

i = Nx
im1 = i-1
ip1 = im1  # i+1 -&gt; i-1
u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])

# Or just one loop over all points

for i in range(0, Nx+1):
    ip1 = i+1 if i &lt; Nx else i-1
    im1 = i-1 if i &gt; 0  else i+1
    u[i] = u_1[i] + C2*(u_1[im1] - 2*u_1[i] + u_1[ip1])
</pre></div>
<p>
Program <a href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn0.py" target="_self"><tt>wave1D_dn0.py</tt></a>
</section>


<section class="slide">

<h2 id="___sec58">Moving finite difference stencil </h2>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>

<p>
<a href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/index.html" target="_self">web page</a>
or a <a href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Neumann_stencil_gpl/movie.ogg" target="_self">movie file</a>.
</section>


<section class="slide">

<h2 id="wave:indexset">Index set notation</h2>

<ul>
 <p><li> Tedious to write index sets like \( i=0,\ldots,N_x \) and
   \( n=0,\ldots,N_t \)</li>
 <p><li> Notation not valid if \( i \) or \( n \) starts at 1 instead...</li>
 <p><li> Both in math and code it is advantageous to use <em>index sets</em></li>
 <p><li> \( i\in\Ix \) instead of \( i=0,\ldots,N_x \)</li>
 <p><li> Definition: \( \Ix =\{0,\ldots,N_x\} \)</li>
 <p><li> The first index: \( i=\setb{\Ix} \)</li>
 <p><li> The last index: \( i=\sete{\Ix} \)</li>
 <p><li> All interior points: \( i\in\seti{\Ix} \), \( \seti{\Ix}=\{1,\ldots,N_x-1\} \)</li>
 <p><li> \( \setl{\Ix} \) means \( \{0,\ldots,N_x-1\} \)</li>
 <p><li> \( \setr{\Ix} \) means \( \{1,\ldots,N_x\} \)</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec60">Index set notation in code </h2>

<p>
<table border="1">
<thead>
<tr><th align="center">    Notation    </th> <th align="center">        Python       </th> </tr>
</thead>
<tbody>
<tr><td align="left">   \( \Ix \)           </td> <td align="left">   <code>Ix</code>          </td> </tr>
<tr><td align="left">   \( \setb{\Ix} \)    </td> <td align="left">   <code>Ix[0]</code>       </td> </tr>
<tr><td align="left">   \( \sete{\Ix} \)    </td> <td align="left">   <code>Ix[-1]</code>      </td> </tr>
<tr><td align="left">   \( \setl{\Ix} \)    </td> <td align="left">   <code>Ix[1:]</code>      </td> </tr>
<tr><td align="left">   \( \setr{\Ix} \)    </td> <td align="left">   <code>Ix[:-1]</code>     </td> </tr>
<tr><td align="left">   \( \seti{\Ix} \)    </td> <td align="left">   <code>Ix[1:-1]</code>    </td> </tr>
</tbody>
</table>
</section>


<section class="slide">

<h2 id="___sec61">Index sets in action (1) </h2>

<p>
Index sets for a problem in the \( x,t \) plane:

<p>&nbsp;<br>
$$
\begin{equation}
\Ix = \{0,\ldots,N_x\},\quad \It = \{0,\ldots,N_t\},
\tag{30}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Implemented in Python as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Ix = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nx+<span style="color: #B452CD">1</span>)
It = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, Nt+<span style="color: #B452CD">1</span>)
</pre></div>
</section>


<section class="slide">

<h2 id="___sec62">Index sets in action (2) </h2>

<p>
A finite difference scheme can with the index set notation be specified as

<p>&nbsp;<br>
$$
\begin{align*}
u^{n+1}_i &= -u^{n-1}_i  + 2u^n_i + C^2
\left(u^{n}_{i+1}-2u^{n}_{i}+u^{n}_{i-1}\right),
\quad i\in\seti{\Ix},\ n\in\seti{\It}\\ 
u_i &= 0,
\quad i=\setb{\Ix},\ n\in\seti{\It}\\ 
u_i &= 0,
\quad i=\sete{\Ix},\ n\in\seti{\It}
\end{align*}
$$
<p>&nbsp;<br>

<p>
Corresponding implementation:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> n <span style="color: #8B008B">in</span> It[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
        u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
               C2*(u_1[i-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i] + u_1[i+<span style="color: #B452CD">1</span>])
    i = Ix[<span style="color: #B452CD">0</span>];  u[i] = <span style="color: #B452CD">0</span>
    i = Ix[-<span style="color: #B452CD">1</span>]; u[i] = <span style="color: #B452CD">0</span>
</pre></div>
<p>
Program <a href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn.py" target="_self"><tt>wave1D_dn.py</tt></a>
</section>


<section class="slide">

<h2 id="wave:pde1:Neumann:ghost">Alternative implementation via ghost cells</h2>

<ul>
 <p><li> Instead of modifying the stencil at the boundary,
   we extend the mesh to cover \( u_{-1}^n \) and \( u_{N_x+1}^n \)</li>
 <p><li> The extra left and right cell are called <em>ghost cells</em></li>
 <p><li> The extra points are called <em>ghost points</em></li>
 <p><li> The \( u_{-1}^n \) and \( u_{N_x+1}^n \) values are called <em>ghost values</em></li>
 <p><li> Update ghost values as \( u_{i-1}^n = u_{i+1}^n \) for \( i=0 \) and \( i=N_x \)</li>
 <p><li> Then the stencil becomes right at the boundary</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec64">Implementation of ghost cells (1) </h2>

<p>
Add ghost points:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u   = zeros(Nx+<span style="color: #B452CD">3</span>)
u_1 = zeros(Nx+<span style="color: #B452CD">3</span>)
u_2 = zeros(Nx+<span style="color: #B452CD">3</span>)

x = linspace(<span style="color: #B452CD">0</span>, L, Nx+<span style="color: #B452CD">1</span>)  <span style="color: #228B22"># Mesh points without ghost points</span>
</pre></div>
<ul>
 <p><li> A major indexing problem arises with ghost cells since
   Python indices <em>must</em> start at 0.</li>
 <p><li> <code>u[-1]</code> will always mean the last element in <code>u</code></li>
 <p><li> Math indexing: \( -1,0,1,2,\ldots,N_x+1 \)</li>
 <p><li> Python indexing: <code>0,..,Nx+2</code></li>
 <p><li> Remedy: use index sets</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec65">Implementation of ghost cells (2) </h2>

<p>

<!-- code=text (!bc cod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u = zeros(Nx+3)
Ix = range(1, u.shape[0]-1)

# Boundary values: u[Ix[0]], u[Ix[-1]]

# Set initial conditions
for i in Ix:
    u_1[i] = I(x[i-Ix[0]])  # Note i-Ix[0]

# Loop over all physical mesh points
for i in Ix:
    u[i] = - u_2[i] + 2*u_1[i] + \ 
           C2*(u_1[i-1] - 2*u_1[i] + u_1[i+1])

# Update ghost values
i = Ix[0]          # x=0 boundary
u[i-1] = u[i+1]
i = Ix[-1]         # x=L boundary
u[i-1] = u[i+1]
</pre></div>
<p>
Program: <a href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn0_ghost.py" target="_self"><tt>wave1D_dn0_ghost.py</tt></a>.
</section>


<section class="slide">

<h1 id="wave:pde2:var:c">Generalization: variable wave velocity</h1>

<p>
Heterogeneous media: varying \( c=c(x) \)

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-wave/pulse1_in_two_media/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/pulse1_in_two_media/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>
</section>


<section class="slide">

<h2 id="___sec67">The model PDE with a variable coefficient </h2>

<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} =
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) + f(x,t)
\tag{31}
\end{equation}
$$
<p>&nbsp;<br>

<p>
This equation sampled at a mesh point \( (x_i,t_n) \):
<p>&nbsp;<br>
$$
\frac{\partial^2 }{\partial t^2} u(x_i,t_n) =
\frac{\partial}{\partial x}\left( q(x_i)
\frac{\partial}{\partial x} u(x_i,t_n)\right) + f(x_i,t_n),
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="wave:pde2:var:c:ideas">Discretizing the variable coefficient (1)</h2>

<p>
The principal idea is to <em>first discretize the outer derivative</em>.

<p>
Define
<p>&nbsp;<br>
$$ \phi = q(x)
\frac{\partial u}{\partial x}
$$
<p>&nbsp;<br>

<p>
Then use a centered derivative around \( x=x_i \) for the derivative of \( \phi \):

<p>&nbsp;<br>
$$
\left[\frac{\partial\phi}{\partial x}\right]^n_i
\approx \frac{\phi_{i+\half} - \phi_{i-\half}}{\Delta x}
= [D_x\phi]^n_i
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec69">Discretizing the variable coefficient (2) </h2>

<p>
Then discretize the inner operators:
<p>&nbsp;<br>
$$
\phi_{i+\half}  = q_{i+\half}
\left[\frac{\partial u}{\partial x}\right]^n_{i+\half}
\approx q_{i+\half} \frac{u^n_{i+1} - u^n_{i}}{\Delta x}
= [q D_x u]_{i+\half}^n
$$
<p>&nbsp;<br>

<p>
Similarly,
<p>&nbsp;<br>
$$
\phi_{i-\half}  = q_{i-\half}
\left[\frac{\partial u}{\partial x}\right]^n_{i-\half}
\approx q_{i-\half} \frac{u^n_{i} - u^n_{i-1}}{\Delta x}
= [q D_x u]_{i-\half}^n
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec70">Discretizing the variable coefficient (3) </h2>

<p>
These intermediate results are now combined to

<p>&nbsp;<br>
$$
\begin{equation}
\left[
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\right]^n_i
\approx \frac{1}{\Delta x^2}
\left( q_{i+\half} \left({u^n_{i+1} - u^n_{i}}\right)
- q_{i-\half} \left({u^n_{i} - u^n_{i-1}}\right)\right)
\tag{32}
\end{equation}
$$
<p>&nbsp;<br>

<p>
In operator notation:
<p>&nbsp;<br>
$$
\begin{equation}
\left[
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right)\right]^n_i
\approx [D_xq D_x u]^n_i
\tag{33}
\end{equation}
$$
<p>&nbsp;<br>

<p>
<div class="alert alert-block alert-warning alert-text-normal">
<b style="font-weight: bold">Remark.</b>
<p>
Many are tempted to use the chain rule on the
term \( \frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) \), but this is not a good idea!
</div>

<p>
<!-- Needs some better explanation here - maybe the exact solution of a -->
<!-- poisson type problem (piecewise linear solution) failes if we use -->
<!-- the chain rule? -->
</section>


<section class="slide">

<h2 id="wave:pde2:var:c:means">Computing the coefficient between mesh points</h2>

<ul>
 <p><li> Given \( q(x) \): compute \( q_{i+\half} \) as \( q(x_{i+\half}) \)</li>
 <p><li> Given \( q \) at the mesh points: \( q_i \), use an average</li>
</ul>
<p>&nbsp;<br>
$$
\begin{align}
q_{i+\half} &\approx
\half\left( q_{i} + q_{i+1}\right) =
[\overline{q}^{x}]_i
\quad &\hbox{(arithmetic mean)}
\tag{34}\\ 
q_{i+\half} &\approx
2\left( \frac{1}{q_{i}} + \frac{1}{q_{i+1}}\right)^{-1}
\quad &\hbox{(harmonic mean)}
\tag{35}\\ 
q_{i+\half} &\approx
\left(q_{i}q_{i+1}\right)^{1/2}
\quad &\hbox{(geometric mean)}
\tag{36}
\end{align}
$$
<p>&nbsp;<br>

<p>
The arithmetic mean in <a href="#mjx-eqn-34">(34)</a> is by
far the most used averaging technique.
</section>


<section class="slide">

<h2 id="___sec72">Discretization of variable-coefficient wave equation in operator notation </h2>

<p>&nbsp;<br>
$$
\begin{equation}
\lbrack D_tD_t u = D_x\overline{q}^{x}D_x u + f\rbrack^{n}_i
\tag{37}
\end{equation}
$$
<p>&nbsp;<br>

<p>
We clearly see the type of finite differences and averaging!

<p>
Write out and solve wrt \( u_i^{n+1} \):

<p>&nbsp;<br>
$$
\begin{align}
u^{n+1}_i &= - u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta t}{\Delta x}\right)^2\times \nonumber\\ 
&\quad  \left(
\half(q_{i} + q_{i+1})(u_{i+1}^n - u_{i}^n) -
\half(q_{i} + q_{i-1})(u_{i}^n - u_{i-1}^n)\right)
+ \nonumber\\ 
& \quad \Delta t^2 f^n_i
\tag{38}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="wave:pde2:var:c:Neumann">Neumann condition and a variable coefficient</h2>

<p>
Consider \( \partial u/\partial x=0 \) at \( x=L=N_x\Delta x \):

<p>&nbsp;<br>
$$ \frac{u_{i+1}^{n} - u_{i-1}^n}{2\Delta x} = 0\quad u_{i+1}^n = u_{i-1}^n,
\quad i=N_x
$$
<p>&nbsp;<br>

<p>
Insert \( u_{i+1}^n=u_{i-1}^n \) in the stencil
<a href="#mjx-eqn-38">(38)</a>
for \( i=N_x \) and obtain

<p>&nbsp;<br>
$$
u^{n+1}_i \approx
- u_i^{n-1}  + 2u_i^n + \left(\frac{\Delta t}{\Delta x}\right)^2
2q_{i}(u_{i-1}^n - u_{i}^n) + \Delta t^2 f^n_i
$$
<p>&nbsp;<br>

<p>
(We have used \( q_{i+\half} + q_{i-\half}\approx 2q_i \).)

<p>
Alternative: assume \( dq/dx=0 \) (simpler).
</section>


<section class="slide">

<h2 id="wave:pde2:var:c:impl">Implementation of variable coefficients</h2>

<p>
Assume <code>c[i]</code> holds \( c_i \) the spatial mesh points

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">1</span>, Nx):
    u[i] = - u_2[i] + <span style="color: #B452CD">2</span>*u_1[i] + \ 
           C2*(<span style="color: #B452CD">0.5</span>*(q[i] + q[i+<span style="color: #B452CD">1</span>])*(u_1[i+<span style="color: #B452CD">1</span>] - u_1[i])  - \ 
               <span style="color: #B452CD">0.5</span>*(q[i] + q[i-<span style="color: #B452CD">1</span>])*(u_1[i] - u_1[i-<span style="color: #B452CD">1</span>])) + \ 
           dt2*f(x[i], t[n])
</pre></div>
<p>
Here: <code>C2=(dt/dx)**2</code>

<p>
Vectorized version:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = - u_2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + \ 
          C2*(<span style="color: #B452CD">0.5</span>*(q[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + q[<span style="color: #B452CD">2</span>:])*(u_1[<span style="color: #B452CD">2</span>:] - u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]) -
              <span style="color: #B452CD">0.5</span>*(q[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + q[:-<span style="color: #B452CD">2</span>])*(u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] - u_1[:-<span style="color: #B452CD">2</span>])) + \ 
          dt2*f(x[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>], t[n])
</pre></div>
<p>
Neumann condition \( u_x=0 \): same ideas as in 1D (modified stencil
or ghost cells).
</section>


<section class="slide">

<h2 id="___sec75">A more general model PDE with variable coefficients </h2>

<p>&nbsp;<br>
$$
\begin{equation}
\varrho(x)\frac{\partial^2 u}{\partial t^2} =
\frac{\partial}{\partial x}\left( q(x)
\frac{\partial u}{\partial x}\right) + f(x,t)
\tag{39}
\end{equation}
$$
<p>&nbsp;<br>

<p>
A natural scheme is

<p>&nbsp;<br>
$$
\begin{equation}
[\varrho D_tD_t u = D_x\overline{q}^xD_x u + f]^n_i
\tag{40}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Or

<p>&nbsp;<br>
$$
\begin{equation}
[D_tD_t u = \varrho^{-1}D_x\overline{q}^xD_x u + f]^n_i
\tag{41}
\end{equation}
$$
<p>&nbsp;<br>

<p>
No need to average \( \varrho \), just sample at \( i \)
</section>


<section class="slide">

<h2 id="___sec76">Generalization: damping </h2>

<p>
Why do waves die out?

<ul>
 <p><li> Damping (non-elastic effects, air resistance)</li>
 <p><li> 2D/3D: conservation of energy makes an amplitude reduction by
   \( 1/\sqrt{r} \) (2D) or \( 1/r \) (3D)</li>
</ul>
<p>

Simplest damping model (for physical behavior, see <a href="http://phet.colorado.edu/sims/wave-on-a-string/wave-on-a-string_en.html" target="_self">demo</a>):

<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} + \color{red}{b\frac{\partial u}{\partial t}}
= c^2\frac{\partial^2 u}{\partial x^2} + f(x,t),
\tag{42}
\end{equation}
$$
<p>&nbsp;<br>

<p>
\( b \geq 0 \): prescribed damping coefficient.

<p>
Discretization via centered differences to ensure \( \Oof{\Delta t^2} \) error:

<p>&nbsp;<br>
$$
\begin{equation}
[D_tD_t u + bD_{2t}u = c^2D_xD_x u + f]^n_i
\tag{43}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Need special formula for \( u^1_i \) + special stencil (or ghost cells)
for Neumann conditions.
</section>


<section class="slide">

<h1 id="wave:pde2:software">Building a general 1D wave equation solver</h1>

<p>
The program <a href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn_vc.py" target="_self"><tt>wave1D_dn_vc.py</tt></a>
solves a fairly general 1D wave equation:

<p>&nbsp;<br>
$$
\begin{align}
u_t &= (c^2(x)u_x)_x + f(x,t),\quad &x\in (0,L),\ t\in (0,T]
\tag{44}\\ 
u(x,0) &= I(x),\quad &x\in [0,L]
\tag{45}\\ 
u_t(x,0) &= V(t),\quad &x\in [0,L]
\tag{46}\\ 
u(0,t) &= U_0(t)\hbox{ or } u_x(0,t)=0,\quad &t\in (0,T]
\tag{47}\\ 
u(L,t) &= U_L(t)\hbox{ or } u_x(L,t)=0,\quad &t\in (0,T]
\tag{48}
\end{align}
$$
<p>&nbsp;<br>

<p>
Can be adapted to many needs.
</section>


<section class="slide">

<h2 id="___sec78">Collection of initial conditions </h2>

<p>
The function <code>pulse</code> in <code>wave1D_dn_vc.py</code> offers four
initial conditions:

<ol>
<p><li> a rectangular pulse ("plug")</li>
<p><li> a Gaussian function (<code>gaussian</code>)</li>
<p><li> a "cosine hat": one period of \( 1 + \cos (\pi x \), \( x\in [-1,1] \)</li>
<p><li> half a "cosine hat": half a period of \( \cos \pi x \),
   \( x\in [-{\half},{\half}] \)</li>
</ol>
<p>

Can locate the initial pulse at \( x=0 \) or in the middle

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">wave1D_dn_vc</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">w</span>
&gt;&gt;&gt; w.pulse(loc=<span style="color: #CD5555">&#39;left&#39;</span>, pulse_tp=<span style="color: #CD5555">&#39;cosinehat&#39;</span>, Nx=<span style="color: #B452CD">50</span>, every_frame=<span style="color: #B452CD">10</span>)
</pre></div>
</section>


<section class="slide">

<h1 id="wave:2D3D">Finite difference methods for 2D and 3D wave equations</h1>

<p>
Constant wave velocity \( c \):

<p>&nbsp;<br>
$$
\begin{equation}
\frac{\partial^2 u}{\partial t^2} = c^2\nabla^2 u\hbox{ for }\xpoint\in\Omega\subset\Real^d,\ t\in (0,T]
\tag{49}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Variable wave velocity:

<p>&nbsp;<br>
$$
\begin{equation}
\varrho\frac{\partial^2 u}{\partial t^2} = \nabla\cdot (q\nabla u) + f\hbox{ for }\xpoint\in\Omega\subset\Real^d,\ t\in (0,T]
\tag{50}
\end{equation}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec80">Examples on wave equations written out in 2D/3D </h2>
<div id="wave:2D3D:models"></div>

<p>
3D, constant \( c \):

<p>&nbsp;<br>
$$
\begin{equation*} \nabla^2 u = \frac{\partial^2 u}{\partial x^2} +
\frac{\partial^2 u}{\partial y^2} + \frac{\partial^2 u}{\partial z^2}
  \end{equation*}
$$
<p>&nbsp;<br>

<p>
2D, variable \( c \):

<p>&nbsp;<br>
$$
\begin{equation}
\varrho(x,y)
\frac{\partial^2 u}{\partial t^2} =
\frac{\partial}{\partial x}\left( q(x,y)
\frac{\partial u}{\partial x}\right)
+
\frac{\partial}{\partial y}\left( q(x,y)
\frac{\partial u}{\partial y}\right)
+ f(x,y,t)
\tag{51}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Compact notation:

<p>&nbsp;<br>
$$
\begin{align}
u_{tt} &= c^2(u_{xx} + u_{yy} + u_{zz}) + f,
\tag{52}\\ 
\varrho u_{tt} &= (q u_x)_x + (q u_z)_z + (q u_z)_z + f
\tag{53}
\end{align}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec81">Boundary and initial conditions </h2>

<p>
We need <em>one</em> boundary condition at <em>each point</em> on \( \partial\Omega \):

<ol>
 <p><li> \( u \) is prescribed (\( u=0 \) or known incoming wave)</li>
 <p><li> \( \partial u/\partial n = \normalvec\cdot\nabla u \) prescribed
    (\( =0 \): reflecting boundary)</li>
 <p><li> open boundary (radiation) condition: \( u_t + \boldsymbol{c}\cdot\nabla u =0 \)
    (let waves travel undisturbed out of the domain)</li>
</ol>
<p>

PDEs with <em>second-order</em> time derivative need <em>two</em> initial conditions:

<ol>
 <p><li> \( u=I \),</li>
 <p><li> \( u_t = V \).</li>
</ol>
</section>


<section class="slide">

<h2 id="___sec82">Example: 2D propagation of Gaussian function </h2>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-wave/Gaussian2D/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/Gaussian2D/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>
</section>


<section class="slide">

<h2 id="wave:2D3D:mesh">Mesh</h2>

<ul>
 <p><li> Mesh point: \( (x_i,y_j,z_k,t_n) \)</li>
 <p><li> \( x \) direction: \( x_0 < x_1 < \cdots < x_{N_x} \)</li>
 <p><li> \( y \) direction: \( y_0 < y_1 < \cdots < y_{N_y} \)</li>
 <p><li> \( z \) direction: \( z_0 < z_1 < \cdots < z_{N_z} \)</li>
 <p><li> \( u^{n}_{i,j,k} \approx \uex(x_i,y_j,z_k,t_n) \)</li>
</ul>
</section>


<section class="slide">

<h2 id="wave:2D3D:models">Discretization</h2>

<p>&nbsp;<br>
$$
[D_tD_t u = c^2(D_xD_x u + D_yD_yu) + f]^n_{i,j,k},
$$
<p>&nbsp;<br>

Written out in detail:

<p>&nbsp;<br>
$$
\begin{align*}
\frac{u^{n+1}_{i,j} - 2u^{n}_{i,j} + u^{n-1}_{i,j}}{\Delta t^2}
&= c^2
\frac{u^{n}_{i+1,j} - 2u^{n}_{i,j} + u^{n}_{i-1,j}}{\Delta x^2}
+ \nonumber\\ 
&\quad c^2\frac{u^{n}_{i,j+1} - 2u^{n}_{i,j} + u^{n}_{i,j-1}}{\Delta y^2}
+ f^n_{i,j},
\end{align*}
$$
<p>&nbsp;<br>

<p>
\( u^{n-1}_{i,j} \) and \( u^n_{i,j} \) are known, solve for
\( u^{n+1}_{i,j} \):

<p>&nbsp;<br>
$$ u^{n+1}_{i,j} = 2u^n_{i,j} + u^{n-1}_{i,j} + c^2\Delta t^2[D_xD_x u + D_yD_y u]^n_{i,j}$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec85">Special stencil for the first time step </h2>

<ul>
 <p><li> The stencil for \( u^1_{i,j} \) (\( n=0 \)) involves \( u^{-1}_{i,j} \)
   which is outside the time mesh</li>
 <p><li> Remedy: use discretized \( u_t(x,0)=V \) and the stencil for \( n=0 \)
   to develop a special stencil (as in the 1D case)</li>
</ul>
<p>&nbsp;<br>
$$ [D_{2t}u = V]^0_{i,j}\quad\Rightarrow\quad u^{-1}_{i,j} = u^1_{i,j} - 2\Delta t V_{i,j}
$$
<p>&nbsp;<br>

<p>&nbsp;<br>
$$ u^{n+1}_{i,j} = u^n_{i,j} -2\Delta V_{i,j} + {\half}
c^2\Delta t^2[D_xD_x u + D_yD_y u]^n_{i,j}$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec86">Variable coefficients (1) </h2>

<p>
3D wave equation:

<p>&nbsp;<br>
$$ \varrho u_{tt} = (qu_x)_x + (qu_y)_y + (qu_z)_z + f(x,y,z,t) $$
<p>&nbsp;<br>

<p>
Just apply the 1D discretization for each term:

<p>&nbsp;<br>
$$
\begin{equation}
[\varrho D_tD_t u = (D_x\overline{q}^x D_x u +
D_y\overline{q}^y D_yu + D_z\overline{q}^z D_z u) + f]^n_{i,j,k}
\tag{54}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Need special formula for \( u^1_{i,j,k} \)
(use \( [D_{2t}u=V]^0 \) and stencil for \( n=0 \)).
</section>


<section class="slide">

<h2 id="___sec87">Variable coefficients (2) </h2>

<p>
Written out:

<p>&nbsp;<br>
$$
\begin{align*}
u^{n+1}_{i,j,k} &= - u^{n-1}_{i,j,k}  + 2u^{n}_{i,j,k} + \\ 
&= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \half(q_{i,j,k} + q_{i+1,j,k})(u^{n}_{i+1,j,k} - u^{n}_{i,j,k}) - \\ 
&\qquad\quad \half(q_{i-1,j,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i-1,j,k})) + \\ 
&= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \half(q_{i,j,k} + q_{i,j+1,k})(u^{n}_{i,j+1,k} - u^{n}_{i,j,k}) - \\ 
&\qquad\quad\half(q_{i,j-1,k} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j-1,k})) + \\ 
&= \frac{1}{\varrho_{i,j,k}}\frac{1}{\Delta x^2} ( \half(q_{i,j,k} + q_{i,j,k+1})(u^{n}_{i,j,k+1} - u^{n}_{i,j,k}) -\\ 
&\qquad\quad \half(q_{i,j,k-1} + q_{i,j,k})(u^{n}_{i,j,k} - u^{n}_{i,j,k-1})) + \\ 
+ &\qquad \Delta t^2 f^n_{i,j,k}
\end{align*}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec88">Neumann boundary condition in 2D </h2>

<p>
Use ideas from 1D! Example: \( \frac{\partial u}{\partial n} \) at \( y=0 \),
\( \frac{\partial u}{\partial n} = -\frac{\partial u}{\partial y} \)

<p>
Boundary condition discretization:

<p>&nbsp;<br>
$$ [-D_{2y} u = 0]^n_{i,0}\quad\Rightarrow\quad \frac{u^n_{i,1}-u^n_{i,-1}}{2\Delta y} = 0,\ i\in\Ix
$$
<p>&nbsp;<br>

<p>
Insert \( u^n_{i,-1}=u^n_{i,1} \) in the stencil for \( u^{n+1}_{i,j=0} \) to
obtain a modified stencil on the boundary.

<p>
Pattern: use interior stencil also on the bundary, but replace
\( j-1 \) by \( j+1 \)

<p>
Alternative: use ghost cells and ghost values

<p>
<!-- Should have fig -->
</section>


<section class="slide">

<h1 id="wave:2D3D:impl">Implementation of 2D/3D problems</h1>

<p>&nbsp;<br>
$$
\begin{align}
u_t &= c^2(u_{xx} + u_{yy}) + f(x,y,t),\quad &(x,y)\in \Omega,\ t\in (0,T]
\tag{55}\\ 
u(x,y,0) &= I(x,y),\quad &(x,y)\in\Omega
\tag{56}\\ 
u_t(x,y,0) &= V(x,y),\quad &(x,y)\in\Omega
\tag{57}\\ 
u &= 0,\quad &(x,y)\in\partial\Omega,\ t\in (0,T]
\tag{58}
\end{align}
$$
<p>&nbsp;<br>

<p>
\( \Omega = [0,L_x]\times [0,L_y] \)

<p>
Discretization:

<p>&nbsp;<br>
$$ [D_t D_t u = c^2(D_xD_x u + D_yD_y u) + f]^n_{i,j},
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec90">Algorithm </h2>

<ol>
<p><li> Set initial condition \( u^0_{i,j}=I(x_i,y_j) \)</li>
<p><li> Compute \( u^1_{i,j} = \cdots \) for \( i\in\seti{\Ix} \) and \( j\in\seti{\Iy} \)</li>
<p><li> Set \( u^1_{i,j}=0 \) for the boundaries \( i=0,N_x \), \( j=0,N_y \)</li>
<p><li> For \( n=1,2,\ldots,N_t \):</li>

<ol>
 <p><li> Find \( u^{n+1}_{i,j} = \cdots \)
    for \( i\in\seti{\Ix} \) and \( j\in\seti{\Iy} \)</li>
 <p><li> Set \( u^{n+1}_{i,j}=0 \) for the boundaries \( i=0,N_x \), \( j=0,N_y \)</li>
</ol>
<p>
</ol>
</section>


<section class="slide">

<h2 id="wave2D3D:impl:scalar">Scalar computations: mesh</h2>

<p>
Program: <a href="http://tinyurl.com/nm5587k/wave/wave2D_u0/wave2D_u0.py" target="_self"><tt>wave2D_u0.py</tt></a>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">solver</span>(I, V, f, c, Lx, Ly, Nx, Ny, dt, T,
           user_action=<span style="color: #658b00">None</span>, version=<span style="color: #CD5555">&#39;scalar&#39;</span>):
</pre></div>
<p>
Mesh:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">x = linspace(<span style="color: #B452CD">0</span>, Lx, Nx+<span style="color: #B452CD">1</span>)                  <span style="color: #228B22"># mesh points in x dir</span>
y = linspace(<span style="color: #B452CD">0</span>, Ly, Ny+<span style="color: #B452CD">1</span>)                  <span style="color: #228B22"># mesh points in y dir</span>
dx = x[<span style="color: #B452CD">1</span>] - x[<span style="color: #B452CD">0</span>]
dy = y[<span style="color: #B452CD">1</span>] - y[<span style="color: #B452CD">0</span>]
Nt = <span style="color: #658b00">int</span>(<span style="color: #658b00">round</span>(T/<span style="color: #658b00">float</span>(dt)))
t = linspace(<span style="color: #B452CD">0</span>, N*dt, N+<span style="color: #B452CD">1</span>)                 <span style="color: #228B22"># mesh points in time</span>
Cx2 = (c*dt/dx)**<span style="color: #B452CD">2</span>;  Cy2 = (c*dt/dy)**<span style="color: #B452CD">2</span>    <span style="color: #228B22"># help variables</span>
dt2 = dt**<span style="color: #B452CD">2</span>
</pre></div>
</section>


<section class="slide">

<h2 id="___sec92">Scalar computations: arrays </h2>

<p>
Store \( u^{n+1}_{i,j} \), \( u^{n}_{i,j} \), and
\( u^{n-1}_{i,j} \) in three two-dimensional arrays:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u   = zeros((Nx+<span style="color: #B452CD">1</span>,Ny+<span style="color: #B452CD">1</span>))   <span style="color: #228B22"># solution array</span>
u_1 = zeros((Nx+<span style="color: #B452CD">1</span>,Ny+<span style="color: #B452CD">1</span>))   <span style="color: #228B22"># solution at t-dt</span>
u_2 = zeros((Nx+<span style="color: #B452CD">1</span>,Ny+<span style="color: #B452CD">1</span>))   <span style="color: #228B22"># solution at t-2*dt</span>
</pre></div>
<p>
\( u^{n+1}_{i,j} \) corresponds to <code>u[i,j]</code>, etc.
</section>


<section class="slide">

<h2 id="___sec93">Scalar computations: initial condition </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">Ix = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">0</span>])
Iy = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">1</span>])
It = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, t.shape[<span style="color: #B452CD">0</span>])

<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix:
    <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> Iy:
        u_1[i,j] = I(x[i], y[j])

<span style="color: #8B008B; font-weight: bold">if</span> user_action <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
    user_action(u_1, x, xv, y, yv, t, <span style="color: #B452CD">0</span>)
</pre></div>
<p>
Arguments <code>xv</code> and <code>yv</code>: for vectorized computations
</section>


<section class="slide">

<h2 id="___sec94">Scalar computations: primary stencil </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">advance_scalar</span>(u, u_1, u_2, f, x, y, t, n, Cx2, Cy2, dt2,
                   V=<span style="color: #658b00">None</span>, step1=<span style="color: #658b00">False</span>):
    Ix = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">0</span>]);  Iy = <span style="color: #658b00">range</span>(<span style="color: #B452CD">0</span>, u.shape[<span style="color: #B452CD">1</span>])
    <span style="color: #8B008B; font-weight: bold">if</span> step1:
        dt = sqrt(dt2)  <span style="color: #228B22"># save</span>
        Cx2 = <span style="color: #B452CD">0.5</span>*Cx2;  Cy2 = <span style="color: #B452CD">0.5</span>*Cy2; dt2 = <span style="color: #B452CD">0.5</span>*dt2  <span style="color: #228B22"># redefine</span>
        D1 = <span style="color: #B452CD">1</span>;  D2 = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">else</span>:
        D1 = <span style="color: #B452CD">2</span>;  D2 = <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
        <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> Iy[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]:
            u_xx = u_1[i-<span style="color: #B452CD">1</span>,j] - <span style="color: #B452CD">2</span>*u_1[i,j] + u_1[i+<span style="color: #B452CD">1</span>,j]
            u_yy = u_1[i,j-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[i,j] + u_1[i,j+<span style="color: #B452CD">1</span>]
            u[i,j] = D1*u_1[i,j] - D2*u_2[i,j] + \ 
                     Cx2*u_xx + Cy2*u_yy + dt2*f(x[i], y[j], t[n])
            <span style="color: #8B008B; font-weight: bold">if</span> step1:
                u[i,j] += dt*V(x[i], y[j])
    <span style="color: #228B22"># Boundary condition u=0</span>
    j = Iy[<span style="color: #B452CD">0</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix: u[i,j] = <span style="color: #B452CD">0</span>
    j = Iy[-<span style="color: #B452CD">1</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> Ix: u[i,j] = <span style="color: #B452CD">0</span>
    i = Ix[<span style="color: #B452CD">0</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> Iy: u[i,j] = <span style="color: #B452CD">0</span>
    i = Ix[-<span style="color: #B452CD">1</span>]
    <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> Iy: u[i,j] = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">return</span> u
</pre></div>
<p>
<code>D1</code> and <code>D2</code>: allow <code>advance_scalar</code> to be used also for \( u^1_{i,j} \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">u = advance_scalar(u, u_1, u_2, f, x, y, t,
                   n, <span style="color: #B452CD">0.5</span>*Cx2, <span style="color: #B452CD">0.5</span>*Cy2, <span style="color: #B452CD">0.5</span>*dt2, D1=<span style="color: #B452CD">1</span>, D2=<span style="color: #B452CD">0</span>)
</pre></div>
</section>


<section class="slide">

<h2 id="wave2D3D:impl:vectorized">Vectorized computations: mesh coordinates</h2>

<p>
Mesh with \( 30\times 30 \) cells: vectorization reduces the CPU
time by a factor of 70 (!).

<p>
Need special coordinate arrays <code>xv</code> and <code>yv</code> such that \( I(x,y) \)
and \( f(x,y,t) \) can be vectorized:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">import</span> newaxis
xv = x[:,newaxis]
yv = y[newaxis,:]

u_1[:,:] = I(xv, yv)
f_a[:,:] = f(xv, yv, t)
</pre></div>
</section>


<section class="slide">

<h2 id="___sec96">Vectorized computations: stencil </h2>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">advance_vectorized</span>(u, u_1, u_2, f_a, Cx2, Cy2, dt2,
                       V=<span style="color: #658b00">None</span>, step1=<span style="color: #658b00">False</span>):
    <span style="color: #8B008B; font-weight: bold">if</span> step1:
        dt = sqrt(dt2)  <span style="color: #228B22"># save</span>
        Cx2 = <span style="color: #B452CD">0.5</span>*Cx2;  Cy2 = <span style="color: #B452CD">0.5</span>*Cy2; dt2 = <span style="color: #B452CD">0.5</span>*dt2  <span style="color: #228B22"># redefine</span>
        D1 = <span style="color: #B452CD">1</span>;  D2 = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">else</span>:
        D1 = <span style="color: #B452CD">2</span>;  D2 = <span style="color: #B452CD">1</span>
    u_xx = u_1[:-<span style="color: #B452CD">2</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u_1[<span style="color: #B452CD">2</span>:,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]
    u_yy = u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,:-<span style="color: #B452CD">2</span>] - <span style="color: #B452CD">2</span>*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">2</span>:]
    u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] = D1*u_1[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] - D2*u_2[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] + \ 
                   Cx2*u_xx + Cy2*u_yy + dt2*f_a[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]
    <span style="color: #8B008B; font-weight: bold">if</span> step1:
        u[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>] += dt*V[<span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>:-<span style="color: #B452CD">1</span>]
    <span style="color: #228B22"># Boundary condition u=0</span>
    j = <span style="color: #B452CD">0</span>
    u[:,j] = <span style="color: #B452CD">0</span>
    j = u.shape[<span style="color: #B452CD">1</span>]-<span style="color: #B452CD">1</span>
    u[:,j] = <span style="color: #B452CD">0</span>
    i = <span style="color: #B452CD">0</span>
    u[i,:] = <span style="color: #B452CD">0</span>
    i = u.shape[<span style="color: #B452CD">0</span>]-<span style="color: #B452CD">1</span>
    u[i,:] = <span style="color: #B452CD">0</span>
    <span style="color: #8B008B; font-weight: bold">return</span> u

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">quadratic</span>(Nx, Ny, version):
    <span style="color: #CD5555">&quot;&quot;&quot;Exact discrete solution of the scheme.&quot;&quot;&quot;</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">exact_solution</span>(x, y, t):
        <span style="color: #8B008B; font-weight: bold">return</span> x*(Lx - x)*y*(Ly - y)*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x, y):
        <span style="color: #8B008B; font-weight: bold">return</span> exact_solution(x, y, <span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">V</span>(x, y):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">0.5</span>*exact_solution(x, y, <span style="color: #B452CD">0</span>)

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">f</span>(x, y, t):
        <span style="color: #8B008B; font-weight: bold">return</span> <span style="color: #B452CD">2</span>*c**<span style="color: #B452CD">2</span>*(<span style="color: #B452CD">1</span> + <span style="color: #B452CD">0.5</span>*t)*(y*(Ly - y) + x*(Lx - x))

    Lx = <span style="color: #B452CD">5</span>;  Ly = <span style="color: #B452CD">2</span>
    c = <span style="color: #B452CD">1.5</span>
    dt = -<span style="color: #B452CD">1</span> <span style="color: #228B22"># use longest possible steps</span>
    T = <span style="color: #B452CD">18</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">assert_no_error</span>(u, x, xv, y, yv, t, n):
        u_e = exact_solution(xv, yv, t[n])
        diff = <span style="color: #658b00">abs</span>(u - u_e).max()
        tol = <span style="color: #B452CD">1E-12</span>
        msg = <span style="color: #CD5555">&#39;diff=%g, step %d, time=%g&#39;</span> % (diff, n, t[n]))
        <span style="color: #8B008B; font-weight: bold">assert</span> diff &lt; tol, msg

    new_dt, cpu = solver(
        I, V, f, c, Lx, Ly, Nx, Ny, dt, T,
        user_action=assert_no_error, version=version)
    <span style="color: #8B008B; font-weight: bold">return</span> new_dt, cpu


<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">test_quadratic</span>():
    <span style="color: #228B22"># Test a series of meshes where Nx &gt; Ny and Nx &lt; Ny</span>
    versions = <span style="color: #CD5555">&#39;scalar&#39;</span>, <span style="color: #CD5555">&#39;vectorized&#39;</span>, <span style="color: #CD5555">&#39;cython&#39;</span>, <span style="color: #CD5555">&#39;f77&#39;</span>, <span style="color: #CD5555">&#39;c_cy&#39;</span>, <span style="color: #CD5555">&#39;c_f2py&#39;</span>
    <span style="color: #8B008B; font-weight: bold">for</span> Nx <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">2</span>, <span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>):
        <span style="color: #8B008B; font-weight: bold">for</span> Ny <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">2</span>, <span style="color: #B452CD">6</span>, <span style="color: #B452CD">2</span>):
            <span style="color: #8B008B; font-weight: bold">for</span> version <span style="color: #8B008B">in</span> versions:
                <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;testing&#39;</span>, version, <span style="color: #CD5555">&#39;for %dx%d mesh&#39;</span> % (Nx, Ny)
                quadratic(Nx, Ny, version)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">run_efficiency</span>(nrefinements=<span style="color: #B452CD">4</span>):
    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x, y):
        <span style="color: #8B008B; font-weight: bold">return</span> sin(pi*x/Lx)*sin(pi*y/Ly)

    Lx = <span style="color: #B452CD">10</span>;  Ly = <span style="color: #B452CD">10</span>
    c = <span style="color: #B452CD">1.5</span>
    T = <span style="color: #B452CD">100</span>
    versions = [<span style="color: #CD5555">&#39;scalar&#39;</span>, <span style="color: #CD5555">&#39;vectorized&#39;</span>, <span style="color: #CD5555">&#39;cython&#39;</span>, <span style="color: #CD5555">&#39;f77&#39;</span>,
               <span style="color: #CD5555">&#39;c_f2py&#39;</span>, <span style="color: #CD5555">&#39;c_cy&#39;</span>]
    <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39; &#39;</span>*<span style="color: #B452CD">15</span>, <span style="color: #CD5555">&#39;&#39;</span>.join([<span style="color: #CD5555">&#39;%-13s&#39;</span> % v <span style="color: #8B008B; font-weight: bold">for</span> v <span style="color: #8B008B">in</span> versions])
    <span style="color: #8B008B; font-weight: bold">for</span> Nx <span style="color: #8B008B">in</span> <span style="color: #B452CD">15</span>, <span style="color: #B452CD">30</span>, <span style="color: #B452CD">60</span>, <span style="color: #B452CD">120</span>:
        cpu = {}
        <span style="color: #8B008B; font-weight: bold">for</span> version <span style="color: #8B008B">in</span> versions:
            dt, cpu_ = solver(I, <span style="color: #658b00">None</span>, <span style="color: #658b00">None</span>, c, Lx, Ly, Nx, Nx,
                              -<span style="color: #B452CD">1</span>, T, user_action=<span style="color: #658b00">None</span>,
                              version=version)
            cpu[version] = cpu_
        cpu_min = <span style="color: #658b00">min</span>(<span style="color: #658b00">list</span>(cpu.values()))
        <span style="color: #8B008B; font-weight: bold">if</span> cpu_min &lt; <span style="color: #B452CD">1E-6</span>:
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Ignored %dx%d grid (too small execution time)&#39;</span> \ 
                  % (Nx, Nx)
        <span style="color: #8B008B; font-weight: bold">else</span>:
            cpu = {version: cpu[version]/cpu_min <span style="color: #8B008B; font-weight: bold">for</span> version <span style="color: #8B008B">in</span> cpu}
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;%-15s&#39;</span> % <span style="color: #CD5555">&#39;%dx%d&#39;</span> % (Nx, Nx),
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;&#39;</span>.join([<span style="color: #CD5555">&#39;%13.1f&#39;</span> % cpu[version] <span style="color: #8B008B; font-weight: bold">for</span> version <span style="color: #8B008B">in</span> versions])

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">gaussian</span>(plot_method=<span style="color: #B452CD">2</span>, version=<span style="color: #CD5555">&#39;vectorized&#39;</span>, save_plot=<span style="color: #658b00">True</span>):
    <span style="color: #CD5555">&quot;&quot;&quot;</span>
<span style="color: #CD5555">    Initial Gaussian bell in the middle of the domain.</span>
<span style="color: #CD5555">    plot_method=1 applies mesh function, =2 means surf, =0 means no plot.</span>
<span style="color: #CD5555">    &quot;&quot;&quot;</span>
    <span style="color: #228B22"># Clean up plot files</span>
    <span style="color: #8B008B; font-weight: bold">for</span> name <span style="color: #8B008B">in</span> glob(<span style="color: #CD5555">&#39;tmp_*.png&#39;</span>):
        os.remove(name)

    Lx = <span style="color: #B452CD">10</span>
    Ly = <span style="color: #B452CD">10</span>
    c = <span style="color: #B452CD">1.0</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">I</span>(x, y):
        <span style="color: #CD5555">&quot;&quot;&quot;Gaussian peak at (Lx/2, Ly/2).&quot;&quot;&quot;</span>
        <span style="color: #8B008B; font-weight: bold">return</span> exp(-<span style="color: #B452CD">0.5</span>*(x-Lx/<span style="color: #B452CD">2.0</span>)**<span style="color: #B452CD">2</span> - <span style="color: #B452CD">0.5</span>*(y-Ly/<span style="color: #B452CD">2.0</span>)**<span style="color: #B452CD">2</span>)

    <span style="color: #8B008B; font-weight: bold">if</span> plot_method == <span style="color: #B452CD">3</span>:
        <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">mpl_toolkits.mplot3d</span> <span style="color: #8B008B; font-weight: bold">import</span> axes3d
        <span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
        <span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">matplotlib</span> <span style="color: #8B008B; font-weight: bold">import</span> cm
        plt.ion()
        fig = plt.figure()
        u_surf = <span style="color: #658b00">None</span>

    <span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">plot_u</span>(u, x, xv, y, yv, t, n):
        <span style="color: #8B008B; font-weight: bold">if</span> t[n] == <span style="color: #B452CD">0</span>:
            time.sleep(<span style="color: #B452CD">2</span>)
        <span style="color: #8B008B; font-weight: bold">if</span> plot_method == <span style="color: #B452CD">1</span>:
            mesh(x, y, u, title=<span style="color: #CD5555">&#39;t=%g&#39;</span> % t[n], zlim=[-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>],
                 caxis=[-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>])
        <span style="color: #8B008B; font-weight: bold">elif</span> plot_method == <span style="color: #B452CD">2</span>:
            surfc(xv, yv, u, title=<span style="color: #CD5555">&#39;t=%g&#39;</span> % t[n], zlim=[-<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>],
                  colorbar=<span style="color: #658b00">True</span>, colormap=hot(), caxis=[-<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>],
                  shading=<span style="color: #CD5555">&#39;flat&#39;</span>)
        <span style="color: #8B008B; font-weight: bold">elif</span> plot_method == <span style="color: #B452CD">3</span>:
            <span style="color: #8B008B; font-weight: bold">print</span> <span style="color: #CD5555">&#39;Experimental 3D matplotlib...under development...&#39;</span>
            <span style="color: #228B22">#plt.clf()</span>
            ax = fig.add_subplot(<span style="color: #B452CD">111</span>, projection=<span style="color: #CD5555">&#39;3d&#39;</span>)
            u_surf = ax.plot_surface(xv, yv, u, alpha=<span style="color: #B452CD">0.3</span>)
            <span style="color: #228B22">#ax.contourf(xv, yv, u, zdir=&#39;z&#39;, offset=-100, cmap=cm.coolwarm)</span>
            <span style="color: #228B22">#ax.set_zlim(-1, 1)</span>
            <span style="color: #228B22"># Remove old surface before drawing</span>
            <span style="color: #8B008B; font-weight: bold">if</span> u_surf <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #658b00">None</span>:
                ax.collections.remove(u_surf)
            plt.draw()
            time.sleep(<span style="color: #B452CD">1</span>)
        <span style="color: #8B008B; font-weight: bold">if</span> plot_method &gt; <span style="color: #B452CD">0</span>:
            time.sleep(<span style="color: #B452CD">0</span>) <span style="color: #228B22"># pause between frames</span>
            <span style="color: #8B008B; font-weight: bold">if</span> save_plot:
                filename = <span style="color: #CD5555">&#39;tmp_%04d.png&#39;</span> % n
                savefig(filename)  <span style="color: #228B22"># time consuming!</span>

    Nx = <span style="color: #B452CD">40</span>; Ny = <span style="color: #B452CD">40</span>; T = <span style="color: #B452CD">20</span>
    dt, cpu = solver(I, <span style="color: #658b00">None</span>, <span style="color: #658b00">None</span>, c, Lx, Ly, Nx, Ny, -<span style="color: #B452CD">1</span>, T,
                     user_action=plot_u, version=version)



<span style="color: #8B008B; font-weight: bold">if</span> __name__ == <span style="color: #CD5555">&#39;__main__&#39;</span>:
    test_quadratic()
</pre></div>
</section>


<section class="slide">

<h2 id="wave2D3D:impl:verify">Verification: quadratic solution (1)</h2>

<p>
Manufactured solution:

<p>&nbsp;<br>
$$
\begin{equation}
\uex(x,y,t) = x(L_x-x)y(L_y-y)(1+{\half}t)
\tag{59}
\end{equation}
$$
<p>&nbsp;<br>

<p>
Requires \( f=2c^2(1+{\half}t)(y(L_y-y) +
x(L_x-x)) \).

<p>
This \( \uex \) is ideal because it also solves the discrete equations!
</section>


<section class="slide">

<h2 id="___sec98">Verification: quadratic solution (2) </h2>

<ul>
 <p><li> \( [D_t D_t 1]^n=0 \)</li>
 <p><li> \( [D_t D_t t]^n=0 \)</li>
 <p><li> \( [D_t D_t t^2]=2 \)</li>
 <p><li> \( D_tD_t \) is a linear operator: \( [D_tD_t (au+bv)]^n = a[D_tD_t u]^n +
   b[D_tD_t v]^n \)</li>
</ul>
<p>&nbsp;<br>
$$
\begin{align*}
[D_xD_x \uex]^n_{i,j} &= [y(L_y-y)(1+{\half}t) D_xD_x x(L_x-x)]^n_{i,j}\\ 
&= y_j(L_y-y_j)(1+{\half}t_n)2
\end{align*}
$$
<p>&nbsp;<br>


<ul>
 <p><li> Similar calculations for \( [D_yD_y\uex]^n_{i,j} \) and
   \( [D_tD_t \uex]^n_{i,j} \) terms</li>
 <p><li> Must also check the equation for \( u^1_{i,j} \)</li>
</ul>
</section>


<section class="slide">

<h1 id="___sec99">Analysis of the difference equations </h1>
<div id="wave:pde1:analysis"></div>

<p>
<center><p><img src="fig-wave/pulse2_in_two_media.png" align="bottom" width=800></p></center>
</section>


<section class="slide">

<h2 id="wave:pde1:properties">Properties of the solution of the wave equation</h2>

<p>&nbsp;<br>
$$
\begin{equation*} \frac{\partial^2 u}{\partial t^2} =
c^2 \frac{\partial^2 u}{\partial x^2}
\end{equation*}
$$
<p>&nbsp;<br>

<p>
Solutions:

<p>&nbsp;<br>
$$
u(x,t) = g_R(x-ct) + g_L(x+ct)
$$
<p>&nbsp;<br>

<p>
If \( u(x,0)=I(x) \) and \( u_t(x,0)=0 \):

<p>&nbsp;<br>
$$
u(x,t) = \half I(x-ct) + \half I(x+ct)
$$
<p>&nbsp;<br>

<p>
Two waves: one traveling to the right and one to the left
</section>


<section class="slide">

<h2 id="___sec101">Demo of the splitting of \( I(x) \) into two waves </h2>

<p>

<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src='mov-wave/demo_BC_gaussian/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/demo_BC_gaussian/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>
</section>


<section class="slide">

<h2 id="___sec102">Simulation of a case with variable wave velocity </h2>

<p>
A wave propagates perfectly (\( C=1 \)) and hits a medium with 1/4 of
the wave velocity (\( C=0.25 \)). A part of the wave is reflected and the rest
is transmitted.

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-wave/pulse1_in_two_media/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/pulse1_in_two_media/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>
</section>


<section class="slide">

<h2 id="___sec103">Let us change the shape of the initial condition slightly and see what happens </h2>

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-wave/pulse2_in_two_media/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/pulse2_in_two_media/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>
</section>


<section class="slide">

<h2 id="___sec104">Representation of waves as sum of sine/cosine waves </h2>

<p>
Build \( I(x) \) of wave components \( e^{ikx} = \cos kx + i\sin kx \):

<p>&nbsp;<br>
$$
I(x) \approx \sum_{k\in K} b_k e^{ikx}
$$
<p>&nbsp;<br>


<ul>
 <p><li> Fit \( b_k \) by a least squares or projection method</li>
 <p><li> \( k \) is the frequency of a component (\( \lambda = 2\pi/k \) is the wave length in space)</li>
 <p><li> \( K \) is some set of all \( k \) needed to approximate \( I(x) \) well</li>
 <p><li> \( b_k \) must be computed (Fourier coefficients)</li>
</ul>
<p>

Since \( u(x,t)=\half I(x-ct) + \half I(x+ct) \), the exact solution is

<p>&nbsp;<br>
$$
u(x,t) = \half \sum_{k\in K} b_k e^{ik(x - ct)}
+ \half \sum_{k\in K} b_k e^{ik(x + ct)}
$$
<p>&nbsp;<br>

<p>
Our interest: one component \( e^{i(kx -\omega t)} \), \( \omega = kc \)
</section>


<section class="slide">

<h2 id="wave:pde1:analysis">A similar wave component is also a solution of the finite difference scheme (!)</h2>

<p>
Idea: a similar discrete \( u^n_q = e^{i(kx_q - \tilde\omega t_n)} \) solution
(corresponding to the exact \( e^{i(kx - \omega t)} \)) solves

<p>&nbsp;<br>
$$
[D_tD_t u = c^2 D_xD_x u]^n_q
$$
<p>&nbsp;<br>

<p>
Note: we expect numerical frequency \( \tilde\omega\neq\omega \)

<ul>
 <p><li> How accurate is \( \tilde\omega \) compared to \( \omega \)?</li>
 <p><li> What about the wave amplitude (can \( \tilde\omega \) become complex)?</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec106">Preliminary results </h2>

<p>&nbsp;<br>
$$
[D_tD_t e^{i\omega t}]^n = -\frac{4}{\Delta t^2}\sin^2\left(
\frac{\omega\Delta t}{2}\right)e^{i\omega n\Delta t}
$$
<p>&nbsp;<br>

<p>
By \( \omega\rightarrow k \),
\( t\rightarrow x \), \( n\rightarrow q \)) it follows that

<p>&nbsp;<br>
$$
[D_xD_x e^{ikx}]_q = -\frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right)e^{ikq\Delta x}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec107">Insertion of the numerical wave component </h2>

<p>
Inserting a basic wave component \( u=e^{i(kx_q-\tilde\omega t_n)} \) in
the scheme requires computation of

<p>&nbsp;<br>
$$
\begin{align*}
\lbrack D_tD_t e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q &= \lbrack D_tD_t e^{-i\tilde\omega t}\rbrack^ne^{ikq\Delta x}\nonumber\\ &= -\frac{4}{\Delta t^2}\sin^2\left(
\frac{\tilde\omega\Delta t}{2}\right)e^{-i\tilde\omega n\Delta t}e^{ikq\Delta x}\\ 
\lbrack D_xD_x e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q &= \lbrack D_xD_x e^{ikx}\rbrack_q e^{-i\tilde\omega n\Delta t}\nonumber\\ &= -\frac{4}{\Delta x^2}\sin^2\left(
\frac{k\Delta x}{2}\right)e^{ikq\Delta x}e^{-i\tilde\omega n\Delta t}
\end{align*}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec108">The equation for \( \tilde\omega \) </h2>

<p>
The complete scheme,

<p>&nbsp;<br>
$$
\lbrack D_tD_t e^{ikx}e^{-i\tilde\omega t} = c^2D_xD_x e^{ikx}e^{-i\tilde\omega t}\rbrack^n_q
$$
<p>&nbsp;<br>

<p>
leads to an equation for \( \tilde\omega \) (which can readily be solved):

<p>&nbsp;<br>
$$
\sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
= C^2\sin^2\left(\frac{k\Delta x}{2}\right),\quad C = \frac{c\Delta t}{\Delta x}
\mbox{ (Courant number)}
$$
<p>&nbsp;<br>

<p>
Taking the square root:

<p>&nbsp;<br>
$$
\sin\left(\frac{\tilde\omega\Delta t}{2}\right)
= C\sin\left(\frac{k\Delta x}{2}\right)
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec109">The numerical dispersion relation </h2>

<p>
Can easily solve for an explicit formula for \( \tilde\omega \):

<p>&nbsp;<br>
$$
\tilde\omega = \frac{2}{\Delta t}
\sin^{-1}\left( C\sin\left(\frac{k\Delta x}{2}\right)\right)
$$
<p>&nbsp;<br>

<p>
Note:

<ul>
 <p><li> This \( \tilde\omega = \tilde\omega(k, c, \Delta x, \Delta t) \) is the
   <em>numerical dispersion relation</em></li>
 <p><li> Inserting \( e^{kx-\omega t} \) in the PDE leads to \( \omega = kc \), which is the <em>analytical/exact dispersion relation</em></li>
 <p><li> Speed of waves might be easier to imagine:</li>

<ul>

<p><li> Exact speed: \( c=\omega/k \),</li>

<p><li> Numerical speed: \( \tilde c = \tilde\omega/k \)</li>
</ul>
<p><li> We shall investigate \( \tilde c/c \) to see how wrong the speed of a numerical wave component is</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec110">The special case \( C=1 \) gives the exact solution </h2>

<ul>
 <p><li> For \( C=1 \), \( \tilde\omega = \omega \)</li>
 <p><li> The numerical solution is exact (at the mesh points), regardless of \( \Delta x \) and \( \Delta t = c^{-1}\Delta x \)!</li>
 <p><li> The only requirement is constant \( c \)</li>
 <p><li> The numerical scheme is then a simple-to-use analytical solution method for the wave equation</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec111">Computing the error in wave velocity </h2>

<ul>
 <p><li> Introduce \( p=k\Delta x/2 \) <br />
   (the important <em>dimensionless</em> spatial discretization parameter)</li>
 <p><li> \( p \) measures no of mesh points in space
   per wave length in space</li>
 <p><li> Shortest possible wave length in mesh: \( \lambda = 2\Delta x \), \( k=2\pi/\lambda=\pi/\Delta x \), and \( p=k\Delta x/2 = \pi/2\ \Rightarrow\ p\in (0,\pi/2] \)</li>
 <p><li> Study error in wave velocity through \( \tilde c/c \) as function of \( p \)</li>
</ul>
<p>&nbsp;<br>
$$
r(C, p) = \frac{\tilde c}{c} =
\frac{2}{kc\Delta t} \sin^{-1}(C\sin p) =
\frac{2}{kC\Delta x} \sin^{-1}(C\sin p) =
\frac{1}{Cp}{\sin}^{-1}\left(C\sin p\right)
$$
<p>&nbsp;<br>

<p>
Can plot \( r(C,p) \) for \( p\in (0,\pi/2] \), \( C\in (0,1] \)
</section>


<section class="slide">

<h2 id="___sec112">Visualizing the error in wave velocity </h2>

<p>

<!-- code=text (!bc cod) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">def r(C, p):
    return 1/(C*p)*asin(C*sin(p))
</pre></div>
<p>
<center><p><img src="fig-wave/disprel.png" align="bottom" width=600></p></center>

<p>
Note: the shortest
waves have the largest error, and short waves move too
slowly.
</section>


<section class="slide">

<h2 id="___sec113">Taylor expanding the error in wave velocity </h2>

<p>
For small \( p \), Taylor expand \( \tilde\omega \) as polynomial in \( p \):

<p>

<!-- code=python (!bc py) typeset with pygments style "perldoc" -->
<div class="highlight" style="background: #eeeedd"><pre style="line-height: 125%">&gt;&gt;&gt; C, p = symbols(<span style="color: #CD5555">&#39;C p&#39;</span>)
&gt;&gt;&gt; rs = r(C, p).series(p, <span style="color: #B452CD">0</span>, <span style="color: #B452CD">7</span>)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> rs
<span style="color: #B452CD">1</span> - p**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> + p**<span style="color: #B452CD">4</span>/<span style="color: #B452CD">120</span> - p**<span style="color: #B452CD">6</span>/<span style="color: #B452CD">5040</span> + C**<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">2</span>/<span style="color: #B452CD">6</span> -
C**<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">4</span>/<span style="color: #B452CD">12</span> + <span style="color: #B452CD">13</span>*C**<span style="color: #B452CD">2</span>*p**<span style="color: #B452CD">6</span>/<span style="color: #B452CD">720</span> + <span style="color: #B452CD">3</span>*C**<span style="color: #B452CD">4</span>*p**<span style="color: #B452CD">4</span>/<span style="color: #B452CD">40</span> -
C**<span style="color: #B452CD">4</span>*p**<span style="color: #B452CD">6</span>/<span style="color: #B452CD">16</span> + <span style="color: #B452CD">5</span>*C**<span style="color: #B452CD">6</span>*p**<span style="color: #B452CD">6</span>/<span style="color: #B452CD">112</span> + O(p**<span style="color: #B452CD">7</span>)

&gt;&gt;&gt; <span style="color: #228B22"># Drop the remainder O(...) term</span>
&gt;&gt;&gt; rs = rs.removeO()
&gt;&gt;&gt; <span style="color: #228B22"># Factorize each term</span>
&gt;&gt;&gt; rs = [factor(term) <span style="color: #8B008B; font-weight: bold">for</span> term <span style="color: #8B008B">in</span> rs.as_ordered_terms()]
&gt;&gt;&gt; rs = <span style="color: #658b00">sum</span>(rs)
&gt;&gt;&gt; <span style="color: #8B008B; font-weight: bold">print</span> rs
p**<span style="color: #B452CD">6</span>*(C - <span style="color: #B452CD">1</span>)*(C + <span style="color: #B452CD">1</span>)*(<span style="color: #B452CD">225</span>*C**<span style="color: #B452CD">4</span> - <span style="color: #B452CD">90</span>*C**<span style="color: #B452CD">2</span> + <span style="color: #B452CD">1</span>)/<span style="color: #B452CD">5040</span> +
p**<span style="color: #B452CD">4</span>*(C - <span style="color: #B452CD">1</span>)*(C + <span style="color: #B452CD">1</span>)*(<span style="color: #B452CD">3</span>*C - <span style="color: #B452CD">1</span>)*(<span style="color: #B452CD">3</span>*C + <span style="color: #B452CD">1</span>)/<span style="color: #B452CD">120</span> +
p**<span style="color: #B452CD">2</span>*(C - <span style="color: #B452CD">1</span>)*(C + <span style="color: #B452CD">1</span>)/<span style="color: #B452CD">6</span> + <span style="color: #B452CD">1</span>
</pre></div>
<p>
Leading error term is \( \frac{1}{6}(C^2-1)p^2 \) or

<p>&nbsp;<br>
$$
\frac{1}{6}\left(\frac{k\Delta x}{2}\right)^2(C^2-1)
= \frac{k^2}{24}\left( c^2\Delta t^2 - \Delta x^2\right) =
\Oof{\Delta t^2, \Delta x^2}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec114">Example on effect of wrong wave velocity (1) </h2>

<p>
Smooth wave, few short waves (large \( k \)) in \( I(x) \):

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-wave/pulse1_in_two_media/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/pulse1_in_two_media/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>
</section>


<section class="slide">

<h2 id="___sec115">Example on effect of wrong wave velocity (1) </h2>

<p>
Not so smooth wave, significant short waves (large \( k \)) in \( I(x) \):

<p>

<div>
<video  loop controls width='500' height='365' preload='none'>
    <source src='mov-wave/pulse2_in_two_media/movie.webm' type='video/webm; codecs="vp8, vorbis"'>
    <source src='mov-wave/pulse2_in_two_media/movie.ogg'  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em></em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script>
</section>


<section class="slide">

<h2 id="___sec116">Stability </h2>

<p>&nbsp;<br>
$$
\sin\left(\frac{\tilde\omega\Delta t}{2}\right)
= C\sin\left(\frac{k\Delta x}{2}\right)
$$
<p>&nbsp;<br>


<ul>
 <p><li> Exact \( \omega \) is real</li>
 <p><li> Complex \( \tilde\omega \) will lead to exponential growth of the
   amplitude</li>
 <p><li> Stability criterion: real \( \tilde\omega \)</li>
 <p><li> Then \( \sin(\tilde\omega\Delta t/2) \in [-1,1] \)</li>
 <p><li> \( k\Delta x/2 \) is always real, so right-hand side is in \( [-C,C] \)</li>
 <p><li> Then we must have \( C\leq 1 \)</li>
</ul>
<p>

Stability criterion:

<p>&nbsp;<br>
$$
C = \frac{c\Delta t}{\Delta x} \leq 1
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec117">Why \( C>1 \) leads to non-physical waves </h2>

<p>
Recall that right-hand side is in \( [-C,C] \). Then \( C>1 \) means

<p>&nbsp;<br>
$$
\underbrace{\sin\left(\frac{\tilde\omega\Delta t}{2}\right)}_{>1} = C\sin\left(\frac{k\Delta x}{2}\right)
$$
<p>&nbsp;<br>


<ul>
 <p><li> \( |\sin x| >1 \) implies complex \( x \)</li>
 <p><li> Here: complex \( \tilde\omega = \tilde\omega_r \pm i\tilde\omega_i \)</li>
 <p><li> One \( \tilde\omega_i < 0 \) gives \( \exp(i\cdot i\tilde\omega_i) =
   \exp (-\tilde\omega_i) \) and <em>exponential growth</em></li>
 <p><li> This wave component will after some time dominate the solution
   give an overall exponentially increasing amplitude (non-physical!)</li>
</ul>
</section>


<section class="slide">

<h2 id="wave:pde1:analysis:2D3D">Extending the analysis to 2D (and 3D)</h2>

<p>&nbsp;<br>
$$ u(x,y,t) = g(k_xx + k_yy - \omega t) $$
<p>&nbsp;<br>

<p>
is a typically solution of

<p>&nbsp;<br>
$$ u_{tt} = c^2(u_{xx} + u_{yy}) $$
<p>&nbsp;<br>

<p>
Can build solutions by adding complex Fourier components
of the form

<p>&nbsp;<br>
$$
e^{i(k_xx + k_yy - \omega t)}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec119">Discrete wave components in 2D </h2>

<p>&nbsp;<br>
$$
\lbrack D_tD_t u = c^2(D_xD_x u + D_yD_y u)\rbrack^n_{q,r}
$$
<p>&nbsp;<br>

<p>
This equation admits a Fourier component

<p>&nbsp;<br>
$$
u^n_{q,r} = e^{i(k_x q\Delta x + k_y r\Delta y -
\tilde\omega n\Delta t)}
$$
<p>&nbsp;<br>

<p>
Inserting the expression and using formulas from the 1D analysis:

<p>&nbsp;<br>
$$
\sin^2\left(\frac{\tilde\omega\Delta t}{2}\right)
= C_x^2\sin^2 p_x
+ C_y^2\sin^2 p_y
$$
<p>&nbsp;<br>

<p>
where

<p>&nbsp;<br>
$$ C_x = \frac{c^2\Delta t^2}{\Delta x^2},\quad
C_y = \frac{c^2\Delta t^2}{\Delta y^2}, \quad
p_x = \frac{k_x\Delta x}{2},\quad
p_y = \frac{k_y\Delta y}{2}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec120">Stability criterion in 2D </h2>

<p>
Rreal-valued \( \tilde\omega \) requires

<p>&nbsp;<br>
$$
C_x^2 + C_y^2 \leq 1
$$
<p>&nbsp;<br>

<p>
or

<p>&nbsp;<br>
$$
\Delta t \leq \frac{1}{c} \left( \frac{1}{\Delta x^2} +
\frac{1}{\Delta y^2}\right)^{-\halfi}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec121">Stability criterion in 3D </h2>

<p>&nbsp;<br>
$$
\Delta t \leq \frac{1}{c}\left( \frac{1}{\Delta x^2} +
\frac{1}{\Delta y^2} + \frac{1}{\Delta z^2}\right)^{-\halfi}
$$
<p>&nbsp;<br>

<p>
For \( c^2=c^2(\xpoint) \) we must use
the worst-case value \( \bar c = \sqrt{\max_{\xpoint\in\Omega} c^2(\xpoint)} \)
and a safety factor \( \beta\leq 1 \):

<p>&nbsp;<br>
$$
\Delta t \leq \beta \frac{1}{\bar c}
\left( \frac{1}{\Delta x^2} +
\frac{1}{\Delta y^2} + \frac{1}{\Delta z^2}\right)^{-\halfi}
$$
<p>&nbsp;<br>
</section>


<section class="slide">

<h2 id="___sec122">Numerical dispersion relation in 2D (1) </h2>

<p>&nbsp;<br>
$$
\tilde\omega = \frac{2}{\Delta t}\sin^{-1}\left(
\left( C_x^2\sin^2 p_x + C_y^2\sin^ p_y\right)^\half\right)
$$
<p>&nbsp;<br>

<p>
For visualization, introduce \( \theta \):

<p>&nbsp;<br>
$$ k_x = k\sin\theta,\quad k_y=k\cos\theta,
\quad p_x=\half kh\cos\theta,\quad p_y=\half kh\sin\theta$$
<p>&nbsp;<br>

<p>
Also: \( \Delta x=\Delta y=h \). Then \( C_x=C_y=c\Delta t/h\equiv C \).

<p>
Now \( \tilde\omega \) depends on

<ul>

<p><li> \( C \) reflecting the number cells a wave is displaced during a time step</li>

<p><li> \( kh \) reflecting the number of cells per wave length in space</li>

<p><li> \( \theta \) expressing the direction of the wave</li>
</ul>
</section>


<section class="slide">

<h2 id="___sec123">Numerical dispersion relation in 2D (2) </h2>

<p>&nbsp;<br>
$$ \frac{\tilde c}{c} = \frac{1}{Ckh}
\sin^{-1}\left(C\left(\sin^2 ({\half}kh\cos\theta)
+ \sin^2({\half}kh\sin\theta) \right)^\half\right)
$$
<p>&nbsp;<br>

<p>
Can make color contour plots of \( 1-\tilde c/c \) in
<em>polar coordinates</em> with \( \theta \) as the angular coordinate and
\( kh \) as the radial coordinate.
</section>


<section class="slide">

<h2 id="___sec124">Numerical dispersion relation in 2D (3) </h2>

<p>
<center><p><img src="fig-wave/disprel2D.png" align="bottom" width=800></p></center>
</section>




<footer>
<!-- Here goes a footer -->
</footer>

<!-- Begin extension snippets. Add or remove as needed. -->

<!-- deck.navigation snippet -->
<a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
<a href="#" class="deck-next-link" title="Next">&#8594;</a>

<!-- deck.status snippet
<p class="deck-status">
	<span class="deck-status-current"></span>
	/
	<span class="deck-status-total"></span>
</p>
-->

<!-- deck.goto snippet
<form action="." method="get" class="goto-form">
	<label for="goto-slide">Go to slide:</label>
	<input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
	<datalist id="goto-datalist"></datalist>
	<input type="submit" value="Go">
</form>
-->

<!-- deck.hash snippet
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>
-->

<!-- End extension snippets. -->


<!-- Required JS files. -->
<script src="deck.js/jquery.min.js"></script>
<script src="deck.js/core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="deck.js/core/deck.core.js"></script>
<script src="deck.js/extensions/hash/deck.hash.js"></script>
<script src="deck.js/extensions/menu/deck.menu.js"></script>
<script src="deck.js/extensions/goto/deck.goto.js"></script>
<script src="deck.js/extensions/status/deck.status.js"></script>
<script src="deck.js/extensions/navigation/deck.navigation.js"></script>
<script src="deck.js/extensions/scale/deck.scale.js"></script>
<script src="deck.js/extensions/notes/deck.notes.js"></script>

<!-- From https://github.com/mikeharris100/deck.pointer.js -->
<script src="deck.js/extensions/pointer/deck.pointer.js"></script>

<!-- From https://github.com/stvnwrgs/presenterview
<script type="text/javascript" src="deck.js/extensions/presenterview/deck.presenterview.js"></script> -->

<!-- From https://github.com/nemec/deck.annotate.js
<script type="text/javascript" src="deck.js/extensions/deck.annotate.js/deck.annotate.js"></script>
-->


<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>


</body>
</html>
