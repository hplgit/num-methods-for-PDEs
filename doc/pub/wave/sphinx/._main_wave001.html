
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Simulation of waves on a string</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Finite difference methods for wave motion" href="index.html" />
    <link rel="next" title="Implementation" href="._main_wave002.html" />
    <link rel="prev" title="Finite difference methods for wave motion" href="._main_wave000.html" /> 
  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_wave002.html" title="Implementation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._main_wave000.html" title="Finite difference methods for wave motion"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite difference methods for wave motion</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p>A very wide range of physical processes lead to wave motion, where
signals are propagated through a medium in space and time, normally
with little or no permanent movement of the medium itself.
The shape of the signals may undergo changes as they travel through
matter, but usually not so much that the signals cannot be recognized
at some later point in space and time.
Many types of wave motion can be described by the equation
<span class="math">\(u_{tt}=\nabla\cdot (c^2\nabla u) + f\)</span>, which we will solve
in the forthcoming text by finite difference methods.</p>
<div class="section" id="simulation-of-waves-on-a-string">
<span id="wave-string"></span><h1>Simulation of waves on a string<a class="headerlink" href="#simulation-of-waves-on-a-string" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p id="index-1">We begin our study of wave equations by simulating one-dimensional
waves on a string, say on a guitar or violin.
Let the string in the deformed state
coincide with the interval
<span class="math">\([0,L]\)</span> on the <span class="math">\(x\)</span> axis, and let <span class="math">\(u(x,t)\)</span> be the displacement at
time <span class="math">\(t\)</span> in the <span class="math">\(y\)</span> direction of a point initially at <span class="math">\(x\)</span>.
The displacement function <span class="math">\(u\)</span> is governed by the mathematical model</p>
<div class="math" id="eq-wave-pde1">
\[\tag{1}
\frac{\partial^2 u}{\partial t^2} =
    c^2 \frac{\partial^2 u}{\partial x^2}, \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde1-ic-u">
\[\tag{2}
u(x,0) = I(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde1-ic-ut">
\[\tag{3}
\frac{\partial}{\partial t}u(x,0) = 0, \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde1-bc-0">
\[\tag{4}
u(0,t)  = 0, \quad  t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde1-bc-l">
\[\tag{5}
u(L,t)  = 0, \quad  t\in (0,T]\]</div>
<p>The constant <span class="math">\(c\)</span> and the function <span class="math">\(I(x)\)</span> must be prescribed.</p>
<p>Equation <a class="reference internal" href="#eq-wave-pde1"><span>(1)</span></a> is known as the one-dimensional
<em>wave equation</em>. Since this PDE contains a second-order derivative
in time, we need <em>two initial conditions</em>. The condition
<a class="reference internal" href="#eq-wave-pde1-ic-u"><span>(2)</span></a> specifies
the initial shape of the string, <span class="math">\(I(x)\)</span>, and
<a class="reference internal" href="#eq-wave-pde1-ic-ut"><span>(3)</span></a> expresses that the initial velocity of the
string is zero. In addition, PDEs need <em>boundary conditions</em>, give here as
<a class="reference internal" href="#eq-wave-pde1-bc-0"><span>(4)</span></a> and <a class="reference internal" href="#eq-wave-pde1-bc-l"><span>(5)</span></a>. These two
conditions specify that
the string is fixed at the ends, i.e., that the displacement <span class="math">\(u\)</span> is zero.</p>
<p>The solution <span class="math">\(u(x,t)\)</span> varies in space and time and describes waves that
move with velocity <span class="math">\(c\)</span> to the left and right.</p>
<div>
<video  loop controls width='640' height='365' preload='none'>
    <source src="_static/mov-wave/guitar_C0.8/movie.webm" type='video/webm; codecs="vp8, vorbis"'>
    <source src="_static/mov-wave/guitar_C0.8/movie.ogg"  type='video/ogg;  codecs="theora, vorbis"'>
</video>
</div>
<p><em>Example of waves on a string.</em></p>

<!-- Issue warning if only .ogg or .webm movie in a Safari browser -->
<script language="javascript">
if (!!(window.safari)) {
  document.write("<div style=\"width: 95%%; padding: 10px; border: 1px solid #100; border-radius: 4px;\"><p><font color=\"red\">The above movie will not play in Safari - use Chrome, Firefox, or Opera.</font></p></div>")}
</script><p>Sometimes we will use a more compact notation for the partial derivatives
to save space:</p>
<div class="math" id="eq-auto1">
\[\tag{6}
u_t = \frac{\partial u}{\partial t}, \quad
    u_{tt} = \frac{\partial^2 u}{\partial t^2},\]</div>
<p>and similar expressions
for derivatives with respect to other variables. Then the
wave equation can be written compactly as <span class="math">\(u_{tt} = c^2u_{xx}\)</span>.</p>
<p id="index-2">The PDE problem <a class="reference internal" href="#eq-wave-pde1"><span>(1)</span></a>-<a class="reference internal" href="#eq-wave-pde1-bc-l"><span>(5)</span></a> will now be
discretized in space and time by a finite difference method.</p>
<div class="section" id="discretizing-the-domain">
<span id="wave-string-mesh"></span><span id="index-3"></span><h2>Discretizing the domain<a class="headerlink" href="#discretizing-the-domain" title="Permalink to this headline">¶</a></h2>
<p>The temporal domain <span class="math">\([0,T]\)</span> is represented by a finite number of mesh points</p>
<div class="math" id="eq-auto2">
\[\begin{split}\tag{7}
0 = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_{N_t-1} &lt; t_{N_t} = T {\thinspace .}\end{split}\]</div>
<p>Similarly, the spatial domain <span class="math">\([0,L]\)</span> is replaced by a set of mesh points</p>
<div class="math" id="eq-auto3">
\[\begin{split}\tag{8}
0 = x_0 &lt; x_1 &lt; x_2 &lt; \cdots &lt; x_{N_x-1} &lt; x_{N_x} = L {\thinspace .}\end{split}\]</div>
<p>One may view the mesh as two-dimensional in the <span class="math">\(x,t\)</span> plane, consisting
of points <span class="math">\((x_i, t_n)\)</span>, with <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.</p>
<div class="section" id="uniform-meshes">
<h3>Uniform meshes<a class="headerlink" href="#uniform-meshes" title="Permalink to this headline">¶</a></h3>
<p>For uniformly distributed mesh points we can introduce the constant
mesh spacings <span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span>. We have that</p>
<div class="math" id="eq-auto4">
\[\tag{9}
x_i = i\Delta x,\ i=0,\ldots,N_x,\quad
    t_n = n\Delta t,\ n=0,\ldots,N_t{\thinspace .}\]</div>
<p>We also have that <span class="math">\(\Delta x = x_i-x_{i-1}\)</span>, <span class="math">\(i=1,\ldots,N_x\)</span>, and
<span class="math">\(\Delta t = t_n - t_{n-1}\)</span>, <span class="math">\(n=1,\ldots,N_t\)</span>. Figure <a class="reference internal" href="#wave-pde1-fig-mesh"><span>Mesh in space and time. The circles show points connected in a finite difference equation</span></a>
displays a mesh in the <span class="math">\(x,t\)</span> plane with <span class="math">\(N_t=5\)</span>, <span class="math">\(N_x=5\)</span>, and constant
mesh spacings.</p>
</div>
</div>
<div class="section" id="the-discrete-solution">
<span id="wave-string-numerical-sol"></span><h2>The discrete solution<a class="headerlink" href="#the-discrete-solution" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-4"></span><p id="index-5">The solution <span class="math">\(u(x,t)\)</span> is sought at the mesh points. We introduce
the mesh function <span class="math">\(u_i^n\)</span>, which approximates the exact
solution at the
mesh point <span class="math">\((x_i,t_n)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span> and <span class="math">\(n=0,\ldots,N_t\)</span>.
Using the finite difference method, we shall
develop algebraic equations for computing the mesh function.</p>
</div>
<div class="section" id="fulfilling-the-equation-at-the-mesh-points">
<span id="wave-string-samplingpde"></span><h2>Fulfilling the equation at the mesh points<a class="headerlink" href="#fulfilling-the-equation-at-the-mesh-points" title="Permalink to this headline">¶</a></h2>
<p>In the finite difference method, we relax
the condition that <a class="reference internal" href="#eq-wave-pde1"><span>(1)</span></a> holds at all points in
the space-time domain <span class="math">\((0,L)\times (0,T]\)</span> to the requirement that the PDE is
fulfilled at the <em>interior</em> mesh points only:</p>
<div class="math" id="eq-wave-pde1-step2">
\[\tag{10}
\frac{\partial^2}{\partial t^2} u(x_i, t_n) =
    c^2\frac{\partial^2}{\partial x^2} u(x_i, t_n),\]</div>
<p>for <span class="math">\(i=1,\ldots,N_x-1\)</span> and <span class="math">\(n=1,\ldots,N_t-1\)</span>. For <span class="math">\(n=0\)</span> we have
the initial conditions <span class="math">\(u=I(x)\)</span> and <span class="math">\(u_t=0\)</span>,
and at the boundaries <span class="math">\(i=0,N_x\)</span> we
have the boundary condition <span class="math">\(u=0\)</span>.</p>
</div>
<div class="section" id="replacing-derivatives-by-finite-differences">
<span id="wave-string-fd"></span><h2>Replacing derivatives by finite differences<a class="headerlink" href="#replacing-derivatives-by-finite-differences" title="Permalink to this headline">¶</a></h2>
<p>The second-order derivatives can be replaced by central
differences. The most widely used difference approximation of
the second-order derivative is</p>
<div class="math">
\[\frac{\partial^2}{\partial t^2}u(x_i,t_n)\approx
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}{\thinspace .}\]</div>
<p>It is convenient to introduce the finite difference operator notation</p>
<div class="math">
\[[D_tD_t u]^n_i = \frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2}{\thinspace .}\]</div>
<p>A similar approximation of the second-order derivative in the <span class="math">\(x\)</span>
direction reads</p>
<div class="math">
\[\frac{\partial^2}{\partial x^2}u(x_i,t_n)\approx
\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2} = [D_xD_x u]^n_i
{\thinspace .}\]</div>
<div class="section" id="algebraic-version-of-the-pde">
<h3>Algebraic version of the PDE<a class="headerlink" href="#algebraic-version-of-the-pde" title="Permalink to this headline">¶</a></h3>
<p>We can now replace the derivatives in <a class="reference internal" href="#eq-wave-pde1-step2"><span>(10)</span></a>
and get</p>
<div class="math" id="eq-wave-pde1-step3b">
\[\tag{11}
\frac{u_i^{n+1} - 2u_i^n + u^{n-1}_i}{\Delta t^2} =
    c^2\frac{u_{i+1}^{n} - 2u_i^n + u^{n}_{i-1}}{\Delta x^2},\]</div>
<p>or written more compactly using the operator notation:</p>
<div class="math" id="eq-wave-pde1-step3a">
\[\tag{12}
[D_tD_t u = c^2 D_xD_x]^{n}_i
    {\thinspace .}\]</div>
</div>
<div class="section" id="interpretation-of-the-equation-as-a-stencil">
<h3>Interpretation of the equation as a stencil<a class="headerlink" href="#interpretation-of-the-equation-as-a-stencil" title="Permalink to this headline">¶</a></h3>
<p>A typical feature of <a class="reference internal" href="#eq-wave-pde1-step3b"><span>(11)</span></a> is that it involves
<span class="math">\(u\)</span> values from neighboring points only:
<span class="math">\(u_i^{n+1}\)</span>, <span class="math">\(u^n_{i\pm 1}\)</span>, <span class="math">\(u^n_i\)</span>, and <span class="math">\(u^{n-1}_i\)</span>.
The circles in Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><span>Mesh in space and time. The circles show points connected in a finite difference equation</span></a> illustrate such neighboring mesh points that
contributes to an algebraic equation. In this
particular case, we have sampled the PDE at the point <span class="math">\((2,2)\)</span>
and constructed <a class="reference internal" href="#eq-wave-pde1-step3b"><span>(11)</span></a>, which then
involves a coupling of <span class="math">\(u_2^1\)</span>, <span class="math">\(u_1^2\)</span>, <span class="math">\(u_2^2\)</span>, <span class="math">\(u_3^2\)</span>, and <span class="math">\(u_2^3\)</span>.
The term <em>stencil</em> is often used about the algebraic equation
at a mesh point, and the geometry of a typical stencil is
illustrated in Figure <a class="reference internal" href="#wave-pde1-fig-mesh"><span>Mesh in space and time. The circles show points connected in a finite difference equation</span></a>. One also often refers
to the algebraic equations as <em>discrete equations</em>,
<em>(finite) difference equations</em> or a <em>finite difference
scheme</em>.</p>
<div class="figure" id="id2">
<span id="wave-pde1-fig-mesh"></span><a class="reference internal image-reference" href="_images/stencil_n_interior.png"><img alt="_images/stencil_n_interior.png" src="_images/stencil_n_interior.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Mesh in space and time. The circles show points connected in a finite difference equation</em></span></p>
</div>
</div>
<div class="section" id="algebraic-version-of-the-initial-conditions">
<h3>Algebraic version of the initial conditions<a class="headerlink" href="#algebraic-version-of-the-initial-conditions" title="Permalink to this headline">¶</a></h3>
<p>We also need to replace the derivative in the initial condition
<a class="reference internal" href="#eq-wave-pde1-ic-ut"><span>(3)</span></a> by a finite difference approximation.
A centered difference of the type</p>
<div class="math">
\[\frac{\partial}{\partial t} u(x_i,t_n)\approx
\frac{u^1_i - u^{-1}_i}{2\Delta t} = [D_{2t} u]^0_i,\]</div>
<p>seems appropriate. In operator notation the initial condition is
written as</p>
<div class="math">
\[[D_{2t} u]^n_i = 0,\quad n=0 {\thinspace .}\]</div>
<p>Writing out this equation and ordering the terms give</p>
<div class="math" id="eq-wave-pde1-step3c">
\[\tag{13}
u^{n-1}_i=u^{n+1}_i,\quad i=0,\ldots,N_x,\ n=0{\thinspace .}\]</div>
<p>The other initial condition can be computed by</p>
<div class="math">
\[u_i^0 = I(x_i),\quad i=0,\ldots,N_x{\thinspace .}\]</div>
</div>
</div>
<div class="section" id="formulating-a-recursive-algorithm">
<span id="wave-string-alg"></span><h2>Formulating a recursive algorithm<a class="headerlink" href="#formulating-a-recursive-algorithm" title="Permalink to this headline">¶</a></h2>
<p>We assume that <span class="math">\(u^n_i\)</span> and
<span class="math">\(u^{n-1}_i\)</span> are already computed for <span class="math">\(i=0,\ldots,N_x\)</span>.
The only unknown quantity in <a class="reference internal" href="#eq-wave-pde1-step3b"><span>(11)</span></a> is
therefore <span class="math">\(u^{n+1}_i\)</span>, which we can solve for:</p>
<div class="math" id="eq-wave-pde1-step4">
\[\tag{14}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
    \left(u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}\right),\]</div>
<p>where we have introduced the parameter</p>
<div class="math" id="eq-auto5">
\[\tag{15}
C = c\frac{\Delta t}{\Delta x},\]</div>
<p>known as the <em>Courant number</em>.</p>
<div class="admonition-math-c-is-the-key-parameter-in-the-discrete-wave-equation admonition">
<p class="first admonition-title"><span class="math">\(C\)</span> is the key parameter in the discrete wave equation</p>
<p class="last">We see that the
discrete version of the PDE features only one parameter, <span class="math">\(C\)</span>,
which is therefore the key parameter that governs the
quality of the numerical solution (see the section <a class="reference internal" href="._main_wave004.html#wave-pde1-analysis"><span>Analysis of the difference equations</span></a>
for details). Both the primary
physical parameter <span class="math">\(c\)</span> and the numerical parameters <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>
are lumped together in <span class="math">\(C\)</span>. Note that <span class="math">\(C\)</span> is a dimensionless
parameter.</p>
</div>
<p>Given that <span class="math">\(u^{n-1}_i\)</span> and <span class="math">\(u^n_i\)</span> are computed for <span class="math">\(i=0,\ldots,N_x\)</span>,
we find new values at the next time level by applying the formula
<a class="reference internal" href="#eq-wave-pde1-step4"><span>(14)</span></a> for <span class="math">\(i=1,\ldots,N_x-1\)</span>. Figure
<a class="reference internal" href="#wave-pde1-fig-mesh"><span>Mesh in space and time. The circles show points connected in a finite difference equation</span></a> illustrates the points that are used to
compute <span class="math">\(u^3_2\)</span>. For the boundary points, <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>, we apply
the boundary conditions <span class="math">\(u_i^{n+1}=0\)</span>.</p>
<p>A problem with <a class="reference internal" href="#eq-wave-pde1-step4"><span>(14)</span></a> arises when <span class="math">\(n=0\)</span> since the
formula for <span class="math">\(u^1_i\)</span> involves <span class="math">\(u^{-1}_i\)</span>, which is an undefined
quantity outside the time mesh (and the time domain). However, we can
use the initial condition <a class="reference internal" href="#eq-wave-pde1-step3c"><span>(13)</span></a> in combination with
<a class="reference internal" href="#eq-wave-pde1-step4"><span>(14)</span></a> when <span class="math">\(n=0\)</span> to eliminate <span class="math">\(u^{-1}_i\)</span> and
arrive at a special formula for <span class="math">\(u_i^1\)</span>:</p>
<div class="math" id="eq-wave-pde1-step4-1">
\[\tag{16}
u_i^1 = u^0_i - \frac{1}{2}
    C^2\left(u^{0}_{i+1}-2u^{0}_{i} + u^{0}_{i-1}\right)
    {\thinspace .}\]</div>
<p>Figure <a class="reference internal" href="#wave-pde1-fig-stencil-u1"><span>Modified stencil for the first time step</span></a> illustrates how <a class="reference internal" href="#eq-wave-pde1-step4-1"><span>(16)</span></a>
connects four instead of five points: <span class="math">\(u^1_2\)</span>, <span class="math">\(u_1^0\)</span>, <span class="math">\(u_2^0\)</span>, and <span class="math">\(u_3^0\)</span>.</p>
<div class="figure" id="id3">
<span id="wave-pde1-fig-stencil-u1"></span><a class="reference internal image-reference" href="_images/stencil_n0_interior.png"><img alt="_images/stencil_n0_interior.png" src="_images/stencil_n0_interior.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Modified stencil for the first time step</em></span></p>
</div>
<p>We can now summarize the computational algorithm:</p>
<ol class="arabic simple">
<li>Compute <span class="math">\(u^0_i=I(x_i)\)</span> for <span class="math">\(i=0,\ldots,N_x\)</span></li>
<li>Compute <span class="math">\(u^1_i\)</span> by <a class="reference internal" href="#eq-wave-pde1-step4-1"><span>(16)</span></a> and set <span class="math">\(u_i^1=0\)</span>
for the boundary points <span class="math">\(i=0\)</span> and <span class="math">\(i=N_x\)</span>, for <span class="math">\(n=1,2,\ldots,N-1\)</span>,</li>
<li>For each time level <span class="math">\(n=1,2,\ldots,N_t-1\)</span></li>
</ol>
<blockquote>
<div><ol class="arabic simple">
<li>apply <a class="reference internal" href="#eq-wave-pde1-step4"><span>(14)</span></a> to find <span class="math">\(u^{n+1}_i\)</span> for <span class="math">\(i=1,\ldots,N_x-1\)</span></li>
<li>set <span class="math">\(u^{n+1}_i=0\)</span> for the boundary points <span class="math">\(i=0\)</span>, <span class="math">\(i=N_x\)</span>.</li>
</ol>
</div></blockquote>
<p>The algorithm essentially consists of moving
a finite difference stencil through all the mesh points, which can be
seen as an animation in a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/index.html">web page</a>
or a <a class="reference external" href="http://tinyurl.com/opdfafk/pub/mov-wave/wave1D_PDE_Dirichlet_stencil_gpl/movie.ogg">movie file</a>.</p>
</div>
<div class="section" id="sketch-of-an-implementation">
<span id="wave-string-impl"></span><h2>Sketch of an implementation<a class="headerlink" href="#sketch-of-an-implementation" title="Permalink to this headline">¶</a></h2>
<p>In a Python implementation of this algorithm, we use the array
elements <code class="docutils literal"><span class="pre">u[i]</span></code> to store <span class="math">\(u^{n+1}_i\)</span>, <code class="docutils literal"><span class="pre">u_1[i]</span></code> to store <span class="math">\(u^n_i\)</span>, and
<code class="docutils literal"><span class="pre">u_2[i]</span></code> to store <span class="math">\(u^{n-1}_i\)</span>. Our naming convention is use <code class="docutils literal"><span class="pre">u</span></code> for the
unknown new spatial field to be computed, <code class="docutils literal"><span class="pre">u_1</span></code> as the solution at
one time step back in time, <code class="docutils literal"><span class="pre">u_2</span></code> as the solution two time steps back
in time and so forth.</p>
<p>The algorithm only involves the three most recent time levels, so we
need only three arrays for <span class="math">\(u_i^{n+1}\)</span>, <span class="math">\(u_i^n\)</span>, and <span class="math">\(u_i^{n-1}\)</span>,
<span class="math">\(i=0,\ldots,N_x\)</span>.  Storing all the solutions in a two-dimensional
array of size <span class="math">\((N_x+1)\times (N_t+1)\)</span> would be possible in this simple
one-dimensional PDE problem, but is normally out of the question in
three-dimensional (3D) and large two-dimensional (2D) problems. We
shall therefore, in all our PDE solving programs, have the unknown in
memory at as few time levels as possible.</p>
<p>The following Python snippet realizes the steps in the computational
algorithm.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Given mesh points as arrays x and t (x[i], t[n])</span>
<span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">dt</span><span class="o">/</span><span class="n">dx</span>            <span class="c"># Courant number</span>
<span class="n">Nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
<span class="n">C2</span> <span class="o">=</span> <span class="n">C</span><span class="o">**</span><span class="mi">2</span>              <span class="c"># Help variable in the scheme</span>

<span class="c"># Set initial condition u(x,0) = I(x)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c"># Apply special formula for first step, incorporating du/dt=0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
    <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c"># Enforce boundary conditions</span>

<span class="c"># Switch variables before next step</span>
<span class="n">u_2</span><span class="p">[:],</span> <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nt</span><span class="p">):</span>
    <span class="c"># Update all inner mesh points at time t[n+1]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">u_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> \
               <span class="n">C</span><span class="o">**</span><span class="mi">2</span><span class="p">(</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">u_1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c"># Insert boundary conditions</span>
    <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="n">u</span><span class="p">[</span><span class="n">Nx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c"># Switch variables before next step</span>
    <span class="n">u_2</span><span class="p">[:],</span> <span class="n">u_1</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">u</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="verification-1">
<h1>Verification<a class="headerlink" href="#verification-1" title="Permalink to this headline">¶</a></h1>
<p>Before implementing the algorithm, it is convenient to add a source
term to the PDE <a class="reference internal" href="#eq-wave-pde1"><span>(1)</span></a>
since it gives us more freedom in finding test problems for
verification. Physically, a source term acts as a generation of waves
in the interior of the domain.</p>
<div class="section" id="a-slightly-generalized-model-problem">
<span id="wave-pde2-fd"></span><h2>A slightly generalized model problem<a class="headerlink" href="#a-slightly-generalized-model-problem" title="Permalink to this headline">¶</a></h2>
<p>We now address the following extended initial-boundary value problem
for one-dimensional wave phenomena:</p>
<div class="math" id="eq-wave-pde2">
\[\tag{17}
u_{tt} = c^2 u_{xx} + f(x,t), \quad x\in (0,L),\ t\in (0,T]\]</div>
<div class="math" id="eq-wave-pde2-ic-u">
\[\tag{18}
u(x,0) = I(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde2-ic-ut">
\[\tag{19}
u_t(x,0) = V(x), \quad x\in [0,L]\]</div>
<div class="math" id="eq-wave-pde2-bc-0">
\[\begin{split}\tag{20}
u(0,t)  = 0, \quad  t&gt;0\end{split}\]</div>
<div class="math" id="eq-wave-pde2-bc-l">
\[\begin{split}\tag{21}
u(L,t)  = 0, \quad  t&gt;0\end{split}\]</div>
<p>Sampling the PDE at <span class="math">\((x_i,t_n)\)</span> and using the same finite difference
approximations as above, yields</p>
<div class="math" id="eq-wave-pde2-fdop">
\[\tag{22}
[D_tD_t u = c^2 D_xD_x u + f]^{n}_i
    {\thinspace .}\]</div>
<p>Writing this out and solving for the unknown <span class="math">\(u^{n+1}_i\)</span> results in</p>
<div class="math" id="eq-wave-pde2-step3b">
\[\tag{23}
u^{n+1}_i = -u^{n-1}_i + 2u^n_i + C^2
    (u^{n}_{i+1}-2u^{n}_{i} + u^{n}_{i-1}) + \Delta t^2 f^n_i\]\[    {\thinspace .}\]</div>
<p>The equation for the first time step must be rederived. The discretization
of the initial condition <span class="math">\(u_t = V(x)\)</span> at <span class="math">\(t=0\)</span>
becomes</p>
<div class="math">
\[[D_{2t}u = V]^0_i\quad\Rightarrow\quad u^{-1}_i = u^{1}_i - 2\Delta t V_i,\]</div>
<p>which, when inserted in <a class="reference internal" href="#eq-wave-pde2-step3b"><span>(23)</span></a> for <span class="math">\(n=0\)</span>, gives
the special formula</p>
<div class="math" id="eq-wave-pde2-step3c">
\[\tag{24}
u^{1}_i = u^0_i - \Delta t V_i + {\frac{1}{2}}
    C^2
    \left(u^{0}_{i+1}-2u^{0}_{i} + u^{0}_{i-1}\right) + \frac{1}{2}\Delta t^2 f^0_i\]\[    {\thinspace .}\]</div>
</div>
<div class="section" id="using-an-analytical-solution-of-physical-significance">
<span id="wave-pde2-fd-standing-waves"></span><h2>Using an analytical solution of physical significance<a class="headerlink" href="#using-an-analytical-solution-of-physical-significance" title="Permalink to this headline">¶</a></h2>
<p>Many wave problems feature sinusoidal oscillations in time
and space. For example, the original PDE problem
<a class="reference internal" href="#eq-wave-pde1"><span>(1)</span></a>-<a class="reference internal" href="#eq-wave-pde1-bc-l"><span>(5)</span></a> allows an exact solution</p>
<div class="math" id="eq-wave-pde2-test-ue">
\[\tag{25}
{u_{\small\mbox{e}}}(x,t)) = A\sin\left(\frac{\pi}{L}x\right)
    \cos\left(\frac{\pi}{L}ct\right){\thinspace .}\]</div>
<p>This <span class="math">\({u_{\small\mbox{e}}}\)</span> fulfills the PDE with <span class="math">\(f=0\)</span>, boundary conditions
<span class="math">\({u_{\small\mbox{e}}}(0,t)={u_{\small\mbox{e}}}(L,0)=0\)</span>, as well as initial
conditions <span class="math">\(I(x)=A\sin\left(\frac{\pi}{L}x\right)\)</span> and <span class="math">\(V=0\)</span>.</p>
<p>It is common to use such exact solutions of physical interest
to verify implementations. However, the numerical
solution <span class="math">\(u^n_i\)</span> will only be an approximation to <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span>.
We have no knowledge of the precise size of the error in
this approximation, and therefore we can never know if discrepancies
between <span class="math">\(u^n_i\)</span> and <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span> are caused
by mathematical approximations or programming errors.
In particular, if a plot of the computed solution <span class="math">\(u^n_i\)</span> and
the exact one eq:ref:<cite>wave:pde2:test:ue</cite> looks similar, many
are tempted to claim that the implementation works. However,
even if color plots look nice and the accuracy is &#8220;deemed good&#8221;,
there can still be serious programming errors present!</p>
<p>The only way to use exact physical solutions like
<a class="reference internal" href="#eq-wave-pde2-test-ue"><span>(25)</span></a> for serious and thorough verification is to
run a series of finer and finer meshes, measure the integrated error
in each mesh, and from this information estimate the empirical convergence
rate of the method.
An introduction to the computing convergence rates is given in
the section
on <a class="reference external" href="http://hplgit.github.io/decay-book/doc/pub/book/sphinx/._book007.html#computing-convergence-rates">convergence rates</a> in <a class="reference internal" href="._main_wave010.html#ref1" id="id1">[Ref1]</a>.</p>
<p>In the present problem, one expects the method to have a convergence rate
of 2 (see the section <a class="reference internal" href="._main_wave004.html#wave-pde1-analysis"><span>Analysis of the difference equations</span></a>), so if the computed rates
are close to 2 on a sufficiently mesh, we have good evidence that
the implementation is free of programming mistakes.</p>
</div>
<div class="section" id="manufactured-solution">
<span id="wave-pde2-fd-mms"></span><h2>Manufactured solution<a class="headerlink" href="#manufactured-solution" title="Permalink to this headline">¶</a></h2>
<p>One problem with the exact solution <a class="reference internal" href="#eq-wave-pde2-test-ue"><span>(25)</span></a> is
that it requires a simplification (<span class="math">\(V=0, f=0\)</span>) of the implemented problem
<a class="reference internal" href="#eq-wave-pde2"><span>(17)</span></a>-<a class="reference internal" href="#eq-wave-pde2-bc-l"><span>(21)</span></a>. An advantage of using
a <em>manufactured solution</em> is that we can test all terms in the
PDE problem. The idea of this approach is to set up some chosen
solution and fit the source term, boundary conditions, and initial
conditions to be compatible with the chosen solution.
Given that our boundary conditions in the implementation are
<span class="math">\(u(0,t)=u(L,t)=0\)</span>, we must choose a solution that fulfills these
conditions. One example is</p>
<div class="math">
\[{u_{\small\mbox{e}}}(x,t) = x(L-x)\sin t{\thinspace .}\]</div>
<p>Inserted in the PDE <span class="math">\(u_{tt}=c^2u_{xx}+f\)</span> we get</p>
<div class="math">
\[-x(L-x)\sin t = -c^2 2\sin t + f\quad\Rightarrow f = (2c^2 - x(L-x))\sin t{\thinspace .}\]</div>
<p>The initial conditions become</p>
<div class="math">
\[\begin{split}u(x,0) =&amp; I(x) = 0,\\
u_t(x,0) &amp;= V(x) = x(L-x){\thinspace .}\end{split}\]</div>
<p>To verify the code, we compute the convergence rates in a series of
simulations, letting each simulation use a finer mesh than the
previous one. Such empirical estimation of convergence rates
tests rely on an assumption that some
measure <span class="math">\(E\)</span> of the numerical error is related to the discretization
parameters through</p>
<div class="math">
\[E = C_t\Delta t^r + C_x\Delta x^p,\]</div>
<p>where <span class="math">\(C_t\)</span>, <span class="math">\(C_x\)</span>, <span class="math">\(r\)</span>, and <span class="math">\(p\)</span> are constants. The constants
<span class="math">\(r\)</span> and <span class="math">\(p\)</span> are known as the <em>convergence rates</em> in time and space,
respectively.
From the
accuracy in the finite difference approximations, we expect <span class="math">\(r=p=2\)</span>,
since the error terms are of order <span class="math">\(\Delta t^2\)</span> and <span class="math">\(\Delta x^2\)</span>.
This is confirmed by truncation error analysis and other types of analysis.</p>
<p>By using an exact solution of the PDE problem, we will next compute
the error measure <span class="math">\(E\)</span> on a sequence of refined meshes and see if
the rates <span class="math">\(r=p=2\)</span> are obtained. We will not be concerned with estimating
the constants <span class="math">\(C_t\)</span> and <span class="math">\(C_x\)</span>.</p>
<p>It is advantageous to introduce a single discretization parameter
<span class="math">\(h=\Delta t=\hat c \Delta x\)</span> for some constant <span class="math">\(\hat c\)</span>.
Since <span class="math">\(\Delta t\)</span> and <span class="math">\(\Delta x\)</span>
are related through the Courant number, <span class="math">\(\Delta t = C\Delta x/c\)</span>, we
set <span class="math">\(h=\Delta t\)</span>, and then <span class="math">\(\Delta x = hc/C\)</span>.
Now the expression for the error measure is greatly simplified:</p>
<div class="math">
\[E = C_t\Delta t^r + C_x\Delta x^r = C_t h^r + C_x\left(\frac{c}{C}\right)^r h^r
= Dh^r,\quad D = C_t+C_x\left(\frac{c}{C}\right)^r {\thinspace .}\]</div>
<p>We choose an initial discretization parameter <span class="math">\(h_0\)</span> and run
experiments with decreasing <span class="math">\(h\)</span>: <span class="math">\(h_i=2^{-i}h_0\)</span>, <span class="math">\(i=1,2,\ldots,m\)</span>.
Halving <span class="math">\(h\)</span> in each experiment is not necessary, but it is a common choice.
For each experiment we must record <span class="math">\(E\)</span> and <span class="math">\(h\)</span>.
A standard choice of error measure
is the <span class="math">\(\ell^2\)</span> or <span class="math">\(\ell^\infty\)</span> norm of
the error mesh function <span class="math">\(e^n_i\)</span>:</p>
<div class="math" id="eq-auto6">
\[\tag{26}
E = ||e^n_i||_{\ell^2} = \left( \Delta t\Delta x
    \sum_{n=0}^{N_t}\sum_{i=0}^{N_x}
    (e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = {u_{\small\mbox{e}}}(x_i,t_n)-u^n_i,\]</div>
<div class="math" id="eq-auto7">
\[\tag{27}
E = ||e^n_i||_{\ell^\infty} = \max_{i,n} |e^i_n|{\thinspace .}\]</div>
<p>In Python, one can compute <span class="math">\(\sum_{i}(e^{n}_i)^2\)</span> at each time step
and accumulate the value in some sum variable, say <code class="docutils literal"><span class="pre">e2_sum</span></code>.  At the
final time step one can do <code class="docutils literal"><span class="pre">sqrt(dt*dx*e2_sum)</span></code>.  For the
<span class="math">\(\ell^\infty\)</span> norm one must compare the maximum error at a time level
(<code class="docutils literal"><span class="pre">e.max()</span></code>) with the global maximum over the time domain: <code class="docutils literal"><span class="pre">e_max</span> <span class="pre">=</span>
<span class="pre">max(e_max,</span> <span class="pre">e.max())</span></code>.</p>
<p>An alternative error measure
is to use a spatial norm at one time step only, e.g.,
the end time <span class="math">\(T\)</span> (<span class="math">\(n=N_t\)</span>):</p>
<div class="math" id="eq-auto8">
\[\tag{28}
E = ||e^n_i||_{\ell^2} = \left( \Delta x\sum_{i=0}^{N_x}
    (e^n_i)^2\right)^{\frac{1}{2}},\quad e^n_i = {u_{\small\mbox{e}}}(x_i,t_n)-u^n_i,\]</div>
<div class="math" id="eq-auto9">
\[\tag{29}
E = ||e^n_i||_{\ell^\infty} = \max_{0\leq i\leq N_x} |e^{n}_i|{\thinspace .}\]</div>
<p>The important issue is that our error measure <span class="math">\(E\)</span> must be one number
that represents the error in the simulation.</p>
<p>Let <span class="math">\(E_i\)</span> be the error measure in experiment (mesh) number <span class="math">\(i\)</span> and
let <span class="math">\(h_i\)</span> be the corresponding discretization parameter (<span class="math">\(h\)</span>).
With the error model <span class="math">\(E_i = Dh_i^r\)</span>, we can
estimate <span class="math">\(r\)</span> by comparing two consecutive
experiments:</p>
<div class="math">
\[\begin{split}E_{i+1}&amp; =D h_{i+1}^{r},\\
E_{i}&amp; =D h_{i}^{r}{\thinspace .}\end{split}\]</div>
<p>Dividing the two equations eliminates the (uninteresting) constant <span class="math">\(D\)</span>.
Thereafter, solving for <span class="math">\(r\)</span> yields</p>
<div class="math">
\[r = \frac{\ln E_{i+1}/E_{i}}{\ln h_{i+1}/h_{i}}{\thinspace .}\]</div>
<p>Since <span class="math">\(r\)</span> depends on <span class="math">\(i\)</span>, i.e., which simulations we compare,
we add an index to <span class="math">\(r\)</span>: <span class="math">\(r_i\)</span>, where <span class="math">\(i=0,\ldots,m-2\)</span>, if we
have <span class="math">\(m\)</span> experiments: <span class="math">\((h_0,E_0),\ldots,(h_{m-1}, E_{m-1})\)</span>.</p>
<p>In our present discretization of the wave equation we expect <span class="math">\(r=2\)</span>, and
hence the <span class="math">\(r_i\)</span> values should converge to 2 as <span class="math">\(i\)</span> increases.</p>
</div>
<div class="section" id="constructing-an-exact-solution-of-the-discrete-equations">
<span id="wave-pde2-fd-verify-quadratic"></span><h2>Constructing an exact solution of the discrete equations<a class="headerlink" href="#constructing-an-exact-solution-of-the-discrete-equations" title="Permalink to this headline">¶</a></h2>
<p>With a manufactured or known analytical solution, as outlined above,
we can estimate convergence rates and see if they have the correct
asymptotic behavior. Experience shows that this is a quite good
verification technique in that many common bugs will destroy the
convergence rates. A significantly better test though,
would be to check that the
numerical solution is exactly what it should be. This will in general
require exact knowledge of the numerical error, which we do not normally have
(although we in the section <a class="reference internal" href="._main_wave004.html#wave-pde1-analysis"><span>Analysis of the difference equations</span></a> establish such knowledge
in simple cases).
However, it is possible to look for solutions where we can show that
the numerical error vanishes, i.e., the solution of the original continuous
PDE problem is
also a solution of the discrete equations. This property often arises
if the exact solution of the PDE
is a lower-order polynomial. (Truncation error
analysis leads to error measures that involve derivatives of the
exact solution. In the present problem, the truncation error involves
4th-order derivatives of <span class="math">\(u\)</span> in space and time. Choosing <span class="math">\(u\)</span>
as a polynomial of degree three or less
will therefore lead to vanishing error.)</p>
<p>We shall now illustrate the construction of an exact solution to both the
PDE itself and the discrete equations.
Our chosen manufactured solution is quadratic in space
and linear in time. More specifically, we set</p>
<div class="math" id="eq-wave-pde2-fd-verify-quadratic-uex">
\[\tag{30}
{u_{\small\mbox{e}}} (x,t) = x(L-x)(1+{\frac{1}{2}}t),\]</div>
<p>which by insertion in the PDE leads to <span class="math">\(f(x,t)=2(1+t)c^2\)</span>. This <span class="math">\({u_{\small\mbox{e}}}\)</span>
fulfills the boundary conditions <span class="math">\(u=0\)</span> and demands <span class="math">\(I(x)=x(L-x)\)</span>
and <span class="math">\(V(x)={\frac{1}{2}}x(L-x)\)</span>.</p>
<p>To realize that the chosen <span class="math">\({u_{\small\mbox{e}}}\)</span> is also an exact
solution of the discrete equations,
we first remind ourselves that <span class="math">\(t_n=n\Delta t\)</span> before we
establish that</p>
<div class="math" id="eq-auto10">
\[\tag{31}
\lbrack D_tD_t t^2\rbrack^n = \frac{t_{n+1}^2 - 2t_n^2 + t_{n-1}^2}{\Delta t^2}
    = (n+1)^2 -2n^2 + (n-1)^2 = 2,\]</div>
<div class="math" id="eq-auto11">
\[\tag{32}
\lbrack D_tD_t t\rbrack^n = \frac{t_{n+1} - 2t_n + t_{n-1}}{\Delta t^2}
    = \frac{((n+1) -2n + (n-1))\Delta t}{\Delta t^2} = 0
    {\thinspace .}\]</div>
<p>Hence,</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}}]^n_i = x_i(L-x_i)[D_tD_t (1+{\frac{1}{2}}t)]^n =
x_i(L-x_i){\frac{1}{2}}[D_tD_t t]^n = 0{\thinspace .}\]</div>
<p>Similarly, we get that</p>
<div class="math">
\[\begin{split}\lbrack D_xD_x {u_{\small\mbox{e}}}\rbrack^n_i &amp;=
(1+{\frac{1}{2}}t_n)\lbrack D_xD_x (xL-x^2)\rbrack_i =
(1+{\frac{1}{2}}t_n)\lbrack LD_xD_x x - D_xD_x x^2\rbrack_i \\
&amp;= -2(1+{\frac{1}{2}}t_n)
{\thinspace .}\end{split}\]</div>
<p>Now, <span class="math">\(f^n_i = 2(1+{\frac{1}{2}}t_n)c^2\)</span>, which results in</p>
<div class="math">
\[[D_tD_t {u_{\small\mbox{e}}} - c^2D_xD_x{u_{\small\mbox{e}}} - f]^n_i = 0 - c^2(-1)2(1 + {\frac{1}{2}}t_n
+ 2(1+{\frac{1}{2}}t_n)c^2 = 0{\thinspace .}\]</div>
<p>Moreover, <span class="math">\({u_{\small\mbox{e}}}(x_i,0)=I(x_i)\)</span>,
<span class="math">\(\partial {u_{\small\mbox{e}}}/\partial t = V(x_i)\)</span> at <span class="math">\(t=0\)</span>, and
<span class="math">\({u_{\small\mbox{e}}}(x_0,t)={u_{\small\mbox{e}}}(x_{N_x},0)=0\)</span>. Also the modified scheme for the
first time step is fulfilled by <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span>.</p>
<p>Therefore, the exact solution <span class="math">\({u_{\small\mbox{e}}}(x,t)=x(L-x)(1+t/2)\)</span>
of the PDE problem is also an exact solution of the discrete problem.
We can use this result to check that the computed <span class="math">\(u^n_i\)</span> values from
an implementation equals <span class="math">\({u_{\small\mbox{e}}}(x_i,t_n)\)</span> within machine precision,
<em>regardless of the mesh spacings</em> <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>!
Nevertheless, there might be stability
restrictions on <span class="math">\(\Delta x\)</span> and <span class="math">\(\Delta t\)</span>, so the test can only be
run for a mesh that is compatible with the stability criterion (which
in the present case is <span class="math">\(C\leq 1\)</span>, to be derived later).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>A product of quadratic or linear expressions in the various
independent variables, as shown above, will often fulfill both the
PDE problem and the discrete equations, and can therefore be very useful
solutions for verifying implementations.</p>
<p class="last">However, for 1D wave
equations of the type <span class="math">\(u_{tt}=c^2u_{xx}\)</span> we shall see that there is always
another much more powerful way of generating exact
solutions (which consists in just setting <span class="math">\(C=1\)</span> (!), as shown in
the section <a class="reference internal" href="._main_wave004.html#wave-pde1-analysis"><span>Analysis of the difference equations</span></a>).</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Simulation of waves on a string</a><ul>
<li><a class="reference internal" href="#discretizing-the-domain">Discretizing the domain</a><ul>
<li><a class="reference internal" href="#uniform-meshes">Uniform meshes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-discrete-solution">The discrete solution</a></li>
<li><a class="reference internal" href="#fulfilling-the-equation-at-the-mesh-points">Fulfilling the equation at the mesh points</a></li>
<li><a class="reference internal" href="#replacing-derivatives-by-finite-differences">Replacing derivatives by finite differences</a><ul>
<li><a class="reference internal" href="#algebraic-version-of-the-pde">Algebraic version of the PDE</a></li>
<li><a class="reference internal" href="#interpretation-of-the-equation-as-a-stencil">Interpretation of the equation as a stencil</a></li>
<li><a class="reference internal" href="#algebraic-version-of-the-initial-conditions">Algebraic version of the initial conditions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#formulating-a-recursive-algorithm">Formulating a recursive algorithm</a></li>
<li><a class="reference internal" href="#sketch-of-an-implementation">Sketch of an implementation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#verification-1">Verification</a><ul>
<li><a class="reference internal" href="#a-slightly-generalized-model-problem">A slightly generalized model problem</a></li>
<li><a class="reference internal" href="#using-an-analytical-solution-of-physical-significance">Using an analytical solution of physical significance</a></li>
<li><a class="reference internal" href="#manufactured-solution">Manufactured solution</a></li>
<li><a class="reference internal" href="#constructing-an-exact-solution-of-the-discrete-equations">Constructing an exact solution of the discrete equations</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_wave000.html"
                        title="previous chapter">Finite difference methods for wave motion</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._main_wave002.html"
                        title="next chapter">Implementation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/._main_wave001.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_wave002.html" title="Implementation"
             >next</a> |</li>
        <li class="right" >
          <a href="._main_wave000.html" title="Finite difference methods for wave motion"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finite difference methods for wave motion</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
    <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
    <br />
    <br />
      &copy;2015, Hans Petter Langtangen.
  </div>
</div>

  </body>
</html>