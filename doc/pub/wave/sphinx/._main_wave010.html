

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Exercises (4)</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Finite difference methods for wave motion" href="index.html" />
    <link rel="prev" title="Waves in blood vessels" href="._main_wave009.html" />
 
  
   <style type="text/css">
     div.admonition {
       background-color: whiteSmoke;
       border: 1px solid #bababa;
     }
   </style>
  </head>

  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._main_wave009.html" title="Waves in blood vessels"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Finite difference methods for wave motion</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="exercises-4">
<span id="wave-app-exer"></span><h1>Exercises  (4)<a class="headerlink" href="#exercises-4" title="Permalink to this headline">¶</a></h1>
<div class="section" id="exercise-15-simulate-waves-on-a-non-homogeneous-string">
<span id="wave-app-exer-string-discont"></span><h2>Exercise 15: Simulate waves on a non-homogeneous string<a class="headerlink" href="#exercise-15-simulate-waves-on-a-non-homogeneous-string" title="Permalink to this headline">¶</a></h2>
<p>Simulate waves on a string that consists of two materials with
different density. The tension in the string is constant, but the
density has a jump at the middle of the string.  Experiment with
different sizes of the jump and produce animations that visualize the
effect of the jump on the wave motion.</p>
<p><strong>Hint.</strong>
According to the section <a class="reference internal" href="._main_wave007.html#wave-app-string"><em>Waves on a string</em></a>,
the density enters the mathematical model as <span class="math">\(\varrho\)</span> in
<span class="math">\(\varrho u_{tt} = Tu_{xx}\)</span>, where <span class="math">\(T\)</span> is the string tension. Modify, e.g., the
<tt class="docutils literal"><span class="pre">wave1D_u0v.py</span></tt> code to incorporate the tension and two density values.
Make a mesh function <tt class="docutils literal"><span class="pre">rho</span></tt> with density values at each spatial mesh point.
A value for the tension may be 150 N. Corresponding density values can
be computed from the wave velocity estimations in the <tt class="docutils literal"><span class="pre">guitar</span></tt> function
in the <tt class="docutils literal"><span class="pre">wave1D_u0v.py</span></tt> file.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">wave1D_u0_sv_discont.py</span></tt>.</p>
</div>
<div class="section" id="exercise-16-simulate-damped-waves-on-a-string">
<span id="wave-app-exer-string-damping"></span><h2>Exercise 16: Simulate damped waves on a string<a class="headerlink" href="#exercise-16-simulate-damped-waves-on-a-string" title="Permalink to this headline">¶</a></h2>
<p>Formulate a mathematical model for damped waves on a string.
Use data from the section <a class="reference internal" href="._main_wave002.html#wave-pde1-guitar-data"><em>Running a case</em></a>, and
tune the damping parameter so that the string is very close to
the rest state after 15 s. Make a movie of the wave motion.
Filename: <tt class="docutils literal"><span class="pre">wave1D_u0_sv_damping.py</span></tt>.</p>
</div>
<div class="section" id="exercise-17-simulate-elastic-waves-in-a-rod">
<span id="wave-app-exer-rod"></span><h2>Exercise 17: Simulate elastic waves in a rod<a class="headerlink" href="#exercise-17-simulate-elastic-waves-in-a-rod" title="Permalink to this headline">¶</a></h2>
<p>A hammer hits the end of an elastic rod. The exercise is to simulate
the resulting wave motion using the model <a class="reference internal" href="._main_wave007.html#eq-wave-app-elastic-rod-eq"><em>(8.8)</em></a>
from the section <a class="reference internal" href="._main_wave007.html#wave-app-elastic-rod"><em>Elastic waves in a rod</em></a>. Let the rod have length
<span class="math">\(L\)</span> and let the boundary <span class="math">\(x=L\)</span> be stress free so that <span class="math">\(\sigma_{xx}=0\)</span>,
implying that <span class="math">\(\partial u/\partial x=0\)</span>. The left end <span class="math">\(x=0\)</span> is
subject to a strong stress pulse (the hammer), modeled as</p>
<div class="math">
\[\begin{split}\sigma_{xx}(t) = \left\lbrace\begin{array}{ll}
S,&amp; 0 &lt; t \leq t_s,\\
0, &amp; t &gt; t_s
\end{array}\right.\end{split}\]</div>
<p>The corresponding condition on <span class="math">\(u\)</span> becomes <span class="math">\(u_x= S/E\)</span>
for <span class="math">\(t\leq t_s\)</span> and zero afterwards (recall that
<span class="math">\(\sigma_{xx} = Eu_x\)</span>). This is a non-homogeneous
Neumann condition, and you will need to approximate this condition
and combine it with the scheme (the ideas and manipulations follow
closely the handling of a non-zero initial condition
<span class="math">\(u_t=V\)</span> in wave PDEs or the corresponding
second-order ODEs for vibrations).
Filename: <tt class="docutils literal"><span class="pre">wave_rod.py</span></tt>.</p>
</div>
<div class="section" id="exercise-18-simulate-spherical-waves">
<span id="wave-app-exer-spherical"></span><h2>Exercise 18: Simulate spherical waves<a class="headerlink" href="#exercise-18-simulate-spherical-waves" title="Permalink to this headline">¶</a></h2>
<p>Implement a model for spherically symmetric waves using the method
described in the section <a class="reference internal" href="._main_wave008.html#wave-app-spherical"><em>Spherical waves</em></a>. The boundary condition
at <span class="math">\(r=0\)</span> must be <span class="math">\(\partial u/\partial r=0\)</span>, while the condition at
<span class="math">\(r=R\)</span> can either be <span class="math">\(u=0\)</span> or a radiation condition as described
in <a class="reference internal" href="#wave-app-exer-radiationbc"><em>Problem 21: Implement open boundary conditions</em></a>. The <span class="math">\(u=0\)</span> condition is
sufficient if <span class="math">\(R\)</span> is so large that the amplitude of the spherical
wave has become insignificant. Make movie(s) of the case where the source
term is located around <span class="math">\(r=0\)</span> and sends out pulses</p>
<div class="math">
\[\begin{split}f(r,t) = \left\lbrace\begin{array}{ll}
Q\exp{(-\frac{r^2}{2\Delta r^2})}\sin\omega t,&amp; \sin\omega t\geq 0\\
0, &amp; \sin\omega t &lt; 0
\end{array}\right.\end{split}\]</div>
<p>Here, <span class="math">\(Q\)</span> and <span class="math">\(\omega\)</span> are constants to be chosen.</p>
<p><strong>Hint.</strong>
Use the program <tt class="docutils literal"><span class="pre">wave1D_u0v.py</span></tt> as a starting point. Let <tt class="docutils literal"><span class="pre">solver</span></tt>
compute the <span class="math">\(v\)</span> function and then set <span class="math">\(u=v/r\)</span>. However,
<span class="math">\(u=v/r\)</span> for <span class="math">\(r=0\)</span> requires special treatment. One possibility is
to compute <tt class="docutils literal"><span class="pre">u[1:]</span> <span class="pre">=</span> <span class="pre">v[1:]/r[1:]</span></tt> and then set <tt class="docutils literal"><span class="pre">u[0]=u[1]</span></tt>. The latter
makes it evident that <span class="math">\(\partial u/\partial r = 0\)</span> in a plot.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">wave1D_spherical.py</span></tt>.</p>
</div>
<div class="section" id="exercise-19-explain-why-numerical-noise-occurs">
<span id="wave-app-exer-pulse1d-analysis"></span><h2>Exercise 19: Explain why numerical noise occurs<a class="headerlink" href="#exercise-19-explain-why-numerical-noise-occurs" title="Permalink to this headline">¶</a></h2>
<p>The experiments performed in <a class="reference internal" href="._main_wave003.html#wave-app-exer-pulse1d"><em>Exercise 8: Send pulse waves through a layered medium</em></a> shows
considerable numerical noise in the form of non-physical waves,
especially for <span class="math">\(s_f=4\)</span> and the plug pulse or the half a &#8220;cosinehat&#8221;
pulse. The noise is much less visible for a Gaussian pulse. Run the
case with the plug and half a &#8220;cosinehat&#8221; pulses for <span class="math">\(s_f=1\)</span>, <span class="math">\(C=0.9,
0.25\)</span>, and <span class="math">\(N_x=40,80,160\)</span>. Use the numerical dispersion relation to
explain the observations.
Filename: <tt class="docutils literal"><span class="pre">pulse1D_analysis.pdf</span></tt>.</p>
</div>
<div class="section" id="exercise-20-investigate-harmonic-averaging-in-a-1d-model">
<span id="wave-app-exer-pulse1d-harmonic"></span><h2>Exercise 20: Investigate harmonic averaging in a 1D model<a class="headerlink" href="#exercise-20-investigate-harmonic-averaging-in-a-1d-model" title="Permalink to this headline">¶</a></h2>
<p>Harmonic means are often used if the wave velocity is non-smooth or
discontinuous.  Will harmonic averaging of the wave velocity give less
numerical noise for the case <span class="math">\(s_f=4\)</span> in <a class="reference internal" href="._main_wave003.html#wave-app-exer-pulse1d"><em>Exercise 8: Send pulse waves through a layered medium</em></a>?
Filenames: <tt class="docutils literal"><span class="pre">pulse1D_harmonic.pdf</span></tt>, <tt class="docutils literal"><span class="pre">pulse1D_harmonic.py</span></tt>.</p>
</div>
<div class="section" id="problem-21-implement-open-boundary-conditions">
<span id="wave-app-exer-radiationbc"></span><h2>Problem 21: Implement open boundary conditions<a class="headerlink" href="#problem-21-implement-open-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><p id="index-2">To enable a wave to leave the computational domain and travel
undisturbed through
the boundary <span class="math">\(x=L\)</span>, one can in a one-dimensional problem impose the
following condition, called a <em>radiation condition</em> or
<em>open boundary condition</em>:</p>
<div class="math" id="equation-wave:app:exer:radiationBC:eq">
<span id="eq-wave-app-exer-radiationbc-eq"></span><span class="eqno">(1)</span>\[     \frac{\partial u}{\partial t} + c\frac{\partial u}{\partial x} = 0{\thinspace .}\]</div>
<p>The parameter <span class="math">\(c\)</span> is the wave velocity.</p>
<p>Show that <a href="#equation-wave:app:exer:radiationBC:eq">(1)</a> accepts
a solution <span class="math">\(u = g_R(x-ct)\)</span> (right-going wave),
but not <span class="math">\(u = g_L(x+ct)\)</span> (left-going wave). This means
that <a href="#equation-wave:app:exer:radiationBC:eq">(1)</a> will allow any
right-going wave <span class="math">\(g_R(x-ct)\)</span> to pass through the boundary undisturbed.</p>
<p>A corresponding open boundary condition for a left-going wave
through <span class="math">\(x=0\)</span> is</p>
<div class="math" id="equation-wave:app:exer:radiationBC:eqL">
<span id="eq-wave-app-exer-radiationbc-eql"></span><span class="eqno">(2)</span>\[     \frac{\partial u}{\partial t} - c\frac{\partial u}{\partial x} = 0{\thinspace .}\]</div>
<p><strong>a)</strong>
A natural idea for discretizing
the condition <a href="#equation-wave:app:exer:radiationBC:eq">(1)</a>
at the spatial end point <span class="math">\(i=N_x\)</span> is to apply
centered differences in time and space:</p>
<div class="math" id="equation-wave:app:exer:radiationBC:eq:op">
<span id="eq-wave-app-exer-radiationbc-eq-op"></span><span class="eqno">(3)</span>\[     [D_{2t}u + cD_{2x}u =0]^n_{i},\quad i=N_x{\thinspace .}\]</div>
<p>Eliminate the fictitious value <span class="math">\(u_{N_x+1}^n\)</span> by using
the discrete equation at the same point.</p>
<p>The equation for the first step, <span class="math">\(u_i^1\)</span>, is in principle also affected,
but we can then use the condition <span class="math">\(u_{N_x}=0\)</span> since the wave
has not yet reached the right boundary.</p>
<p><strong>b)</strong>
A much more convenient implementation of the open boundary condition
at <span class="math">\(x=L\)</span> can be based on an explicit discretization</p>
<div class="math" id="equation-wave:app:exer:radiationBC:eq:op:1storder">
<span id="eq-wave-app-exer-radiationbc-eq-op-1storder"></span><span class="eqno">(4)</span>\[     [D^+_tu + cD_x^- u = 0]_i^n,\quad i=N_x{\thinspace .}\]</div>
<p>From this equation, one can solve for <span class="math">\(u^{n+1}_{N_x}\)</span> and apply the
formula as a Dirichlet condition at the boundary point.
However, the finite difference approximations involved are of
first order.</p>
<p>Implement this scheme for a wave equation
<span class="math">\(u_{tt}=c^2u_{xx}\)</span> in a domain <span class="math">\([0,L]\)</span>,
where you have <span class="math">\(u_x=0\)</span> at <span class="math">\(x=0\)</span>, the condition <a href="#equation-wave:app:exer:radiationBC:eq">(1)</a>
at <span class="math">\(x=L\)</span>, and an initial disturbance in the middle
of the domain, e.g., a plug profile like</p>
<div class="math">
\[\begin{split}u(x,0) = \left\lbrace\begin{array}{ll} 1,&amp; L/2-\ell \leq x \leq  L/2+\ell,\\
0,\hbox{otherwise}\end{array}\right.\end{split}\]</div>
<p>Observe that the initial wave is split in two, the left-going wave
is reflected at <span class="math">\(x=0\)</span>, and both waves travel out of <span class="math">\(x=L\)</span>,
leaving the solution as <span class="math">\(u=0\)</span> in <span class="math">\([0,L]\)</span>. Use a unit Courant number
such that the numerical solution is exact.
Make a movie to illustrate what happens.</p>
<p>Because this simplified
implementation of the open boundary condition works, there is no
need to pursue the more complicated discretization in a).</p>
<p><strong>Hint.</strong>
Modify the solver function in
<a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn.py">wave1D_dn.py</a>.</p>
<p><strong>c)</strong>
Add the possibility to have either <span class="math">\(u_x=0\)</span> or an open boundary
condition at the left boundary. The latter condition is discretized
as</p>
<div class="math" id="equation-wave:app:exer:radiationBC:eq:op:1storder2">
<span id="eq-wave-app-exer-radiationbc-eq-op-1storder2"></span><span class="eqno">(5)</span>\[     [D^+_tu - cD_x^+ u = 0]_i^n,\quad i=0,\]</div>
<p>leading to an explicit update of the boundary value <span class="math">\(u^{n+1}_0\)</span>.</p>
<p>The implementation can be tested with a Gaussian function as initial condition:</p>
<div class="math">
\[g(x;m,s) = \frac{1}{\sqrt{2\pi}s}e^{-\frac{(x-m)^2}{2s^2}}{\thinspace .}\]</div>
<p>Run two tests:</p>
<ol class="arabic simple">
<li>Disturbance in the middle of the domain, <span class="math">\(I(x)=g(x;L/2,s)\)</span>, and
open boundary condition at the left end.</li>
<li>Disturbance at the left end, <span class="math">\(I(x)=g(x;0,s)\)</span>, and <span class="math">\(u_x=0\)</span>
as symmetry boundary condition at this end.</li>
</ol>
<p>Make nose tests for both cases, testing that the solution is zero
after the waves have left the domain.</p>
<p><strong>d)</strong>
In 2D and 3D it is difficult to compute the correct wave velocity
normal to the boundary, which is needed in generalizations of
the open boundary conditions in higher dimensions. Test the effect
of having a slightly wrong wave velocity in
<a href="#equation-wave:app:exer:radiationBC:eq:op:1storder">(4)</a>.
Make a movies to illustrate what happens.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">wave1D_open_BC.py</span></tt>.</p>
<div class="section" id="remarks-2">
<h3>Remarks  (2)<a class="headerlink" href="#remarks-2" title="Permalink to this headline">¶</a></h3>
<p>The condition <a href="#equation-wave:app:exer:radiationBC:eq">(1)</a>
works perfectly in 1D when <span class="math">\(c\)</span> is known. In 2D and 3D, however, the
condition reads <span class="math">\(u_t + c_x u_x + c_y u_y=0\)</span>, where <span class="math">\(c_x\)</span> and
<span class="math">\(c_y\)</span> are the wave speeds in the <span class="math">\(x\)</span> and <span class="math">\(y\)</span> directions. Estimating
these components (i.e., the direction of the wave) is often
challenging. Other methods are normally used in 2D and 3D to
let waves move out of a computational domain.</p>
</div>
</div>
<div class="section" id="exercise-22-implement-periodic-boundary-conditions">
<span id="wave-exer-periodic"></span><h2>Exercise 22: Implement periodic boundary conditions<a class="headerlink" href="#exercise-22-implement-periodic-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-3"></span><p id="index-4">It is frequently of interest to follow wave motion over large
distances and long times. A straightforward approach is to
work with a very large domain, but might lead to a lot of
computations in areas of the domain where the waves cannot
be noticed. A more efficient approach is to let a right-going
wave out of the domain and at the same time let it enter
the domain on the left. This is called a <em>periodic boundary
condition</em>.</p>
<p>The boundary condition at the right end <span class="math">\(x=L\)</span> is an open boundary
condition (see <a class="reference internal" href="#wave-app-exer-radiationbc"><em>Problem 21: Implement open boundary conditions</em></a>) to let a
right-going wave out of the domain.  At the left end, <span class="math">\(x=0\)</span>, we apply,
in the beginning of the simulation, either a symmetry boundary
condition (see <a class="reference internal" href="._main_wave003.html#wave-exer-symmetry-bc"><em>Problem 7: Explore symmetry boundary conditions</em></a>) <span class="math">\(u_x=0\)</span>, or an
open boundary condition.</p>
<p>This initial wave will split in two and either reflected or
transported out of the domain at <span class="math">\(x=0\)</span>. The purpose of the exercise is
to follow the right-going wave. We can do that with a <em>periodic
boundary condition</em>.  This means that when the right-going wave hits
the boundary <span class="math">\(x=L\)</span>, the open boundary condition lets the wave out of
the domain, but at the same time we use a boundary condition on the
left end <span class="math">\(x=0\)</span> that feeds the outgoing wave into the domain
again. This periodic condition is simply <span class="math">\(u(0)=u(L)\)</span>. The switch from
<span class="math">\(u_x=0\)</span> or an open boundary condition at the left end to a periodic
condition can happen when <span class="math">\(u(L,t)&gt;\epsilon\)</span>, where <span class="math">\(\epsilon =10^{-4}\)</span>
might be an appropriate value for determining when the right-going
wave hits the boundary <span class="math">\(x=L\)</span>.</p>
<p>The open boundary conditions can conveniently be discretized as
explained in <a class="reference internal" href="#wave-app-exer-radiationbc"><em>Problem 21: Implement open boundary conditions</em></a>.  Implement the
described type of boundary conditions and test them on two different
initial shapes: a plug <span class="math">\(u(x,0)=1\)</span> for <span class="math">\(x\leq 0.1\)</span>, <span class="math">\(u(x,0)=0\)</span> for
<span class="math">\(x&gt;0.1\)</span>, and a Gaussian function in the middle of the domain:
<span class="math">\(u(x,0)=\exp{(-\frac{1}{2}(x-0.5)^2/0.05)}\)</span>. The domain is the unit
interval <span class="math">\([0,1]\)</span>. Run these two shapes for Courant numbers 1 and
0.5. Assume constant wave velocity.  Make movies of the four cases.
Reason why the solutions are correct.
Filename: <tt class="docutils literal"><span class="pre">periodic.py</span></tt>.</p>
</div>
<div class="section" id="problem-23-earthquake-generated-tsunami-over-a-subsea-hill">
<span id="wave-app-exer-tsunami1d-hill"></span><h2>Problem 23: Earthquake-generated tsunami over a subsea hill<a class="headerlink" href="#problem-23-earthquake-generated-tsunami-over-a-subsea-hill" title="Permalink to this headline">¶</a></h2>
<p>A subsea earthquake leads to an immediate lift of the water surface, see
Figure <a class="reference internal" href="#wave-app-fig-1d-tsunami-flat"><em>Sketch of initial water surface due to a subsea earthquake</em></a>.  The lifted water surface
splits into two
tsunamis, one traveling to the right and one to the left, as depicted
in Figure <a class="reference internal" href="#wave-app-fig-1d-tsunami-2waves"><em>An initial surface elevation is split into two waves</em></a>.  Since tsunamis are
normally very long waves, compared to the depth, with a small
amplitude, compared to the wave length, the wave equation model
described in the section <a class="reference internal" href="._main_wave008.html#wave-app-sw-2d"><em>The linear shallow water equations</em></a> is relevant:</p>
<div class="math">
\[\eta_{tt} = (gH(x)\eta_x)_x,\]</div>
<p>where <span class="math">\(g\)</span> is the acceleration of gravity, and <span class="math">\(H(x)\)</span> is the still water depth.</p>
<div class="figure" id="wave-app-fig-1d-tsunami-flat">
<a class="reference internal image-reference" href="_images/earthquake_tsunami_flat.png"><img alt="_images/earthquake_tsunami_flat.png" src="_images/earthquake_tsunami_flat.png" style="width: 800px;" /></a>
<p class="caption"><em>Sketch of initial water surface due to a subsea earthquake</em></p>
</div>
<div class="figure" id="wave-app-fig-1d-tsunami-2waves">
<a class="reference internal image-reference" href="_images/earthquake_tsunami_2waves.png"><img alt="_images/earthquake_tsunami_2waves.png" src="_images/earthquake_tsunami_2waves.png" style="width: 800px;" /></a>
<p class="caption"><em>An initial surface elevation is split into two waves</em></p>
</div>
<p>To simulate the right-going tsunami, we can impose
a symmetry boundary at <span class="math">\(x=0\)</span>: <span class="math">\(\partial\eta\ \partial x =0\)</span>.
We then simulate the wave motion
in <span class="math">\([0,L]\)</span>. Unless the ocean ends at <span class="math">\(x=L\)</span>, the waves should travel
undisturbed through the boundary <span class="math">\(x=L\)</span>. A radiation condition
as explained in <a class="reference internal" href="#wave-app-exer-radiationbc"><em>Problem 21: Implement open boundary conditions</em></a> can be
used for this purpose. Alternatively, one can just stop the simulations
before the wave hits the boundary at <span class="math">\(x=L\)</span>. In that case it does not
matter what kind of boundary condition we use
at <span class="math">\(x=L\)</span>. Imposing <span class="math">\(\eta =0\)</span> and stopping the simulations when
<span class="math">\(|\eta_i^n| &gt; \epsilon\)</span>, <span class="math">\(i=N_x-1\)</span>, is a possibility (<span class="math">\(\epsilon\)</span> is a
small parameter).</p>
<p>The shape of the initial surface can be taken as a
Gaussian function,</p>
<div class="math">
\[I(x;I_0,I_a,I_m,I_s) =
I_0 + I_a\exp{\left(-\left(\frac{x-I_m}{I_s}\right)^2\right)},\]</div>
<p>with <span class="math">\(I_m=0\)</span> reflecting the location of the peak of <span class="math">\(I(x)\)</span> and
<span class="math">\(I_s\)</span> being a measure of the width of the function <span class="math">\(I(x)\)</span>
(<span class="math">\(I_s\)</span> is <span class="math">\(\sqrt{2}\)</span> times the standard deviation of the familiar
normal distribution curve).</p>
<p>Now we extend the problem with a hill at the sea
bottom, see Figure <a class="reference internal" href="#wave-app-fig-1d-tsunami-hill"><em>Sketch of an earthquake-generated tsunami passing over a subsea hill</em></a>. The wave speed
<span class="math">\(c=\sqrt{gH(x)} = \sqrt{g(H_0-B(x))}\)</span> will then be reduced in the
shallow water above the hill.</p>
<div class="figure" id="wave-app-fig-1d-tsunami-hill">
<a class="reference internal image-reference" href="_images/earthquake_tsunami_hill.png"><img alt="_images/earthquake_tsunami_hill.png" src="_images/earthquake_tsunami_hill.png" style="width: 800px;" /></a>
<p class="caption"><em>Sketch of an earthquake-generated tsunami passing over a subsea hill</em></p>
</div>
<p>One possible form of the
hill is a Gaussian function,</p>
<div class="math" id="equation-wave:app:exer:tsunami1D:hill:Gauss">
<span id="eq-wave-app-exer-tsunami1d-hill-gauss"></span><span class="eqno">(6)</span>\[     B(x;B_0,B_a,B_m,B_s) =
     B_0 + B_a\exp{\left(-\left(\frac{x-B_m}{B_s}\right)^2\right)},\]</div>
<p>but many other shapes are also possible, e.g., a &#8220;cosine hat&#8221; where</p>
<div class="math" id="equation-wave:app:exer:tsunami1D:hill:cohat">
<span id="eq-wave-app-exer-tsunami1d-hill-cohat"></span><span class="eqno">(7)</span>\[     B(x; B_0, B_a, B_m, B_s) = B_0 + B_a\cos{\left( \pi\frac{x-B_m}{2B_s}\right)},\]</div>
<p>when <span class="math">\(x\in [B_m - B_s, B_m + B_s]\)</span> while <span class="math">\(B=B_0\)</span> outside this
interval.</p>
<p>Also an abrupt construction may be tried:</p>
<div class="math" id="equation-wave:app:exer:tsunami1D:hill:box">
<span id="eq-wave-app-exer-tsunami1d-hill-box"></span><span class="eqno">(8)</span>\[     B(x; B_0, B_a, B_m, B_s) = B_0 + B_a,\]</div>
<p>for <span class="math">\(x\in [B_m - B_s, B_m + B_s]\)</span> while <span class="math">\(B=B_0\)</span> outside this
interval.</p>
<p>The <a class="reference external" href="http://tinyurl.com/nm5587k/wave/wave1D/wave1D_dn_vc.py">wave1D_dn_vc.py</a>
program can be used as starting point for the implementation.
Visualize both the bottom topography and the
water surface elevation in
the same plot.
Allow for a flexible choice of bottom shape:
<a href="#equation-wave:app:exer:tsunami1D:hill:Gauss">(6)</a>,
<a href="#equation-wave:app:exer:tsunami1D:hill:cohat">(7)</a>,
<a href="#equation-wave:app:exer:tsunami1D:hill:box">(8)</a>, or <span class="math">\(B(x)=B_0\)</span> (flat).</p>
<p>The purpose of this problem is to explore the quality of the numerical
solution <span class="math">\(\eta^n_i\)</span> for different shapes of the bottom obstruction.
The &#8220;cosine hat&#8221; and the box-shaped hills have abrupt changes in the
derivative of <span class="math">\(H(x)\)</span> and are more likely to generate numerical noise
than the smooth Gaussian shape of the hill. Investigate if this is true.
Filenames: <tt class="docutils literal"><span class="pre">tsunami1D_hill.py</span></tt>, <tt class="docutils literal"><span class="pre">tsunami1D_hill.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-24-earthquake-generated-tsunami-over-a-3d-hill">
<span id="wave-app-exer-tsunami2d-hill"></span><h2>Problem 24: Earthquake-generated tsunami over a 3D hill<a class="headerlink" href="#problem-24-earthquake-generated-tsunami-over-a-3d-hill" title="Permalink to this headline">¶</a></h2>
<p>This problem extends <a class="reference internal" href="#wave-app-exer-tsunami1d-hill"><em>Problem 23: Earthquake-generated tsunami over a subsea hill</em></a>
to a three-dimensional wave phenomenon, governed by the 2D PDE
<a class="reference internal" href="._main_wave008.html#eq-wave-app-sw-2d-eta-2ndoeq"><em>(9.5)</em></a>. We assume that the earthquake
arise from a fault along the line <span class="math">\(x=0\)</span> in the <span class="math">\(xy\)</span>-plane so that
the initial lift of the surface can be taken as <span class="math">\(I(x)\)</span> in
<a class="reference internal" href="#wave-app-exer-tsunami1d-hill"><em>Problem 23: Earthquake-generated tsunami over a subsea hill</em></a>. That is, a plane wave is
propagating to the right, but will experience bending because of
the bottom.</p>
<p>The bottom shape is now a function of <span class="math">\(x\)</span> and <span class="math">\(y\)</span>.
An &#8220;elliptic&#8221; Gaussian function in two dimensions, with its peak
at <span class="math">\((B_{mx}, B_{my})\)</span>, generalizes
<a href="#equation-wave:app:exer:tsunami1D:hill:Gauss">(6)</a>:</p>
<div class="math" id="equation-wave:app:exer:tsunami2D:hill:Gauss">
<span id="eq-wave-app-exer-tsunami2d-hill-gauss"></span><span class="eqno">(9)</span>\[     B(x;B_0,B_a,B_{mx}, B_{my} ,B_s, b) =
     B_0 + B_a\exp{\left(-\left(\frac{x-B_{mx}}{B_s}\right)^2
     -\left(\frac{y-B_{my}}{bB_s}\right)^2\right)},\]</div>
<p>where <span class="math">\(b\)</span> is a scaling parameter: <span class="math">\(b=1\)</span> gives a circular Gaussian
function with circular contour lines, while <span class="math">\(b\neq 1\)</span> gives an elliptic
shape with elliptic contour lines.</p>
<p>The &#8220;cosine hat&#8221; <a href="#equation-wave:app:exer:tsunami1D:hill:cohat">(7)</a> can also be
generalized to</p>
<div class="math" id="equation-wave:app:exer:tsunami2D:hill:cohat">
<span id="eq-wave-app-exer-tsunami2d-hill-cohat"></span><span class="eqno">(10)</span>\[     B(x; B_0, B_a, B_{mx}, B_{my}, B_s) =
     B_0 + B_a\cos{\left( \pi\frac{x-B_{mx}}{2B_s}\right)}
     \cos{\left( \pi\frac{y-B_{my}}{2B_s}\right)},\]</div>
<p>when <span class="math">\(0 \leq \sqrt{x^2+y^2} \leq B_s\)</span> and <span class="math">\(B=B_0\)</span> outside this circle.</p>
<p>A box-shaped obstacle means that</p>
<div class="math" id="equation-wave:app:exer:tsunami2D:hill:box">
<span id="eq-wave-app-exer-tsunami2d-hill-box"></span><span class="eqno">(11)</span>\[     B(x; B_0, B_a, B_m, B_s, b) = B_0 + B_a\]</div>
<p>for <span class="math">\(x\)</span> and <span class="math">\(y\)</span> inside a rectangle</p>
<div class="math">
\[B_{mx}-B_s \leq  x \leq B_{mx} + B_s,\quad
B_{my}-bB_s \leq  y \leq B_{my} + bB_s,\]</div>
<p>and <span class="math">\(B=B_0\)</span> outside this rectangle.
The <span class="math">\(b\)</span> parameter controls the rectangular shape of the cross section of
the box.</p>
<p>Note that the initial condition and the listed bottom shapes are
symmetric around the line <span class="math">\(y=B_{my}\)</span>. We therefore expect the surface
elevation also to be symmetric with respect to this line.  This means
that we can halve the computational domain by working with
<span class="math">\([0,L_x]\times [0, B_{my}]\)</span>. Along the upper boundary, <span class="math">\(y=B_{my}\)</span>, we
must impose the symmetry condition <span class="math">\(\partial \eta/\partial n=0\)</span>.  Such
a symmetry condition (<span class="math">\(-\eta_x=0\)</span>) is also needed at the <span class="math">\(x=0\)</span>
boundary because the initial condition has a symmetry here. At the
lower boundary <span class="math">\(y=0\)</span> we also set a Neumann condition (which becomes
<span class="math">\(-\eta_y=0\)</span>).  The wave motion is to be simulated until the wave hits
the reflecting boundaries where <span class="math">\(\partial\eta/\partial n =\eta_x =0\)</span>
(one can also set <span class="math">\(\eta =0\)</span> - the particular condition does not matter
as long as the simulation is stopped before the wave is influenced
by the boundary condition).</p>
<p>Visualize the surface elevation.  Investigate how different hill shapes,
different sizes of the water gap above the hill, and different
resolutions <span class="math">\(\Delta x = \Delta y = h\)</span> and <span class="math">\(\Delta t\)</span> influence
the numerical quality of the solution.
Filenames: <tt class="docutils literal"><span class="pre">tsunami2D_hill.py</span></tt>, <tt class="docutils literal"><span class="pre">tsunami2D_hill.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-25-investigate-matplotlib-for-visualization">
<span id="wave-app-exer-tsunami-hill-viz-matplotlib"></span><h2>Problem 25: Investigate Matplotlib for visualization<a class="headerlink" href="#problem-25-investigate-matplotlib-for-visualization" title="Permalink to this headline">¶</a></h2>
<p>Play with native Matplotlib code for visualizing 2D
solutions of the wave equation with variable wave velocity.
See if there
are effective ways to visualize both the solution and the wave
velocity.
Filename: <tt class="docutils literal"><span class="pre">tsunami2D_hill_mpl.py</span></tt>.</p>
</div>
<div class="section" id="problem-26-investigate-visualization-packages">
<span id="wave-app-exer-tsunami-hill-viz-packages"></span><h2>Problem 26: Investigate visualization packages<a class="headerlink" href="#problem-26-investigate-visualization-packages" title="Permalink to this headline">¶</a></h2>
<p>Create some fancy 3D visualization of the water waves <em>and</em> the subsea hill
in <a class="reference internal" href="#wave-app-exer-tsunami2d-hill"><em>Problem 24: Earthquake-generated tsunami over a 3D hill</em></a>.
Try to make the hill transparent. Possible visualization tools are</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference external" href="http://code.enthought.com/projects/mayavi/">Mayavi</a></li>
<li><a class="reference external" href="http://www.paraview.org/">Paraview</a></li>
<li><a class="reference external" href="http://www.opendx.org/">OpenDX</a></li>
</ul>
</div></blockquote>
<p>Filename: <tt class="docutils literal"><span class="pre">tsunami2D_hill_viz.py</span></tt>.</p>
</div>
<div class="section" id="problem-27-implement-loops-in-compiled-languages">
<span id="wave-app-exer-tsunami2d-hill-compiled"></span><h2>Problem 27: Implement loops in compiled languages<a class="headerlink" href="#problem-27-implement-loops-in-compiled-languages" title="Permalink to this headline">¶</a></h2>
<p>Extend the program from <a class="reference internal" href="#wave-app-exer-tsunami2d-hill"><em>Problem 24: Earthquake-generated tsunami over a 3D hill</em></a> such
that the loops over mesh points, inside the time loop, are
implemented in compiled languages.
Consider implementations in
Cython, Fortran via <tt class="docutils literal"><span class="pre">f2py</span></tt>, C via Cython, C via <tt class="docutils literal"><span class="pre">f2py</span></tt>, C/C++ via Instant,
and C/C++ via <tt class="docutils literal"><span class="pre">scipy.weave</span></tt>.
Perform efficiency experiments to investigate the relative performance
of the various implementations. It is often advantageous to normalize
CPU times by the fastest method on a given mesh.
Filename: <tt class="docutils literal"><span class="pre">tsunami2D_hill_compiled.py</span></tt>.</p>
</div>
<div class="section" id="exercise-28-simulate-seismic-waves-in-2d">
<span id="wave-app-exer-seismic2d"></span><h2>Exercise 28: Simulate seismic waves in 2D<a class="headerlink" href="#exercise-28-simulate-seismic-waves-in-2d" title="Permalink to this headline">¶</a></h2>
<p>The goal of this exercise is to simulate seismic waves using the
PDE model <a class="reference internal" href="._main_wave007.html#eq-wave-app-acoustic-seismic-accoustic1a"><em>(8.16)</em></a> in a
2D <span class="math">\(xz\)</span> domain with geological layers.
Introduce <span class="math">\(m\)</span> horizontal layers of thickness <span class="math">\(h_i\)</span>, <span class="math">\(i=0,\ldots,m-1\)</span>.
Inside layer number <span class="math">\(i\)</span> we have a vertical wave velocity <span class="math">\(c_{z,i}\)</span>
and a horizontal wave velocity <span class="math">\(c_{h,i}\)</span>. Make a program
for simulating such 2D waves. Test it on a case with 3 layers where</p>
<div class="math">
\[c_{z,0}=c_{z,1}=c_{z,2},\quad c_{h,0}=c_{h,2},\quad c_{h,1} \ll c_{h,0}
{\thinspace .}\]</div>
<p>Let <span class="math">\(s\)</span> be a localized point source at the middle of the Earth&#8217;s surface
(the upper boundary)
and investigate how the resulting wave travels through the medium.
The source can be a localized Gaussian peak that oscillates in
time for some time interval.
Place the boundaries far enough from the expanding wave so that the
boundary conditions do not disturb the wave. Then the type of
boundary condition does not matter, except that we physically need
to have <span class="math">\(p=p_0\)</span>, where <span class="math">\(p_0\)</span> is the atmospheric pressure,
at the upper boundary.
Filename: <tt class="docutils literal"><span class="pre">seismic2D.py</span></tt>.</p>
</div>
<div class="section" id="project-29-model-3d-acoustic-waves-in-a-room">
<span id="wave-app-exer-acoustics"></span><h2>Project 29: Model 3D acoustic waves in a room<a class="headerlink" href="#project-29-model-3d-acoustic-waves-in-a-room" title="Permalink to this headline">¶</a></h2>
<p>The equation for sound waves in air is derived in the section <a class="reference internal" href="._main_wave007.html#wave-app-sound"><em>Sound waves in liquids and gases</em></a>
and reads</p>
<div class="math">
\[p_{tt} = c^2\nabla^2 p,\]</div>
<p>where <span class="math">\(p(x,y,z,t)\)</span> is the pressure and <span class="math">\(c\)</span>
is the speed of sound, taken as 340 m/s.</p>
<p>However, sound is absorbed in the air due to relaxation of molecules
in the gas. A model for simple relaxation, valid for gases consisting
only of one type of molecules, is a term <span class="math">\(c^2\tau_s\nabla^2 p_t\)</span> in
the PDE, where <span class="math">\(\tau_s\)</span> is the relaxation time. If we generate sound
from, e.g., a loudspeaker in the room, this sound source must also
be added to the governing equation.</p>
<p>The PDE with the mentioned type of damping and source then becomes</p>
<div class="math">
\[p_tt = c^2\nabla^p + c^2\tau_s\nabla^2 p_t + f,\]</div>
<p>where <span class="math">\(f(x,y,z,t)\)</span> is the source term.</p>
<p>The walls can absorb some sound. A possible model is to have a &#8220;wall layer&#8221;
(thicker than the physical wall)
outside the room where <span class="math">\(c\)</span> is changed such that some of the wave energy
is reflected and some is absorbed in the wall. The absorption of
energy can be taken care of by adding a damping term <span class="math">\(bp_t\)</span> in
the equation:</p>
<div class="math">
\[p_tt + bp_t = c^2\nabla^p + c^2\tau_s\nabla^2 p_t + f{\thinspace .}\]</div>
<p>Typically, <span class="math">\(b=0\)</span> in the room and <span class="math">\(b&gt;0\)</span> in the wall. A discontinuity in <span class="math">\(b\)</span>
or <span class="math">\(c\)</span> will give rise to reflections. It can be wise to use a constant
<span class="math">\(c\)</span> in the wall to control reflections because of the discontinuity between
<span class="math">\(c\)</span> in the air and in the wall, while <span class="math">\(b\)</span> is gradually increased
as we go into the wall to avoid reflections because of rapid changes in <span class="math">\(b\)</span>.
At the outer boundary of the wall the condition <span class="math">\(p=0\)</span> or <span class="math">\(\partial p/\partial n=0\)</span> can be imposed. The waves should anyway be approximately dampened
to <span class="math">\(p=0\)</span> this far out in the wall layer.</p>
<p>There are two strategies for discretizing the <span class="math">\(\nabla^2 p_t\)</span> term: using
a center difference between times <span class="math">\(n+1\)</span> and <span class="math">\(n-1\)</span> (if the equation is
sampled at level <span class="math">\(n\)</span>), or use a one-sided difference based on levels <span class="math">\(n\)</span>
and <span class="math">\(n-1\)</span>. The latter has the advantage of not leading to any equation system,
while the former is second-order accurate as the scheme for the
simple wave equation <span class="math">\(p_tt = c^2\nabla^2 p\)</span>. To avoid an equation system,
go for the one-sided difference such that the overall scheme becomes
explicit and only of first order in time.</p>
<p>Develop a 3D solver for the specified PDE and introduce a wall layer.
Test the solver with the method of manufactured solutions. Make some
demonstrations where the wall reflects and absorbs the waves (reflection
because of discontinuity in <span class="math">\(b\)</span> and absorption because of growing <span class="math">\(b\)</span>).
Experiment with the impact of the <span class="math">\(\tau_s\)</span> parameter.
Filename: <tt class="docutils literal"><span class="pre">acoustics.py</span></tt>.</p>
</div>
<div class="section" id="project-30-solve-a-1d-transport-equation">
<span id="wave-app-exer-advec1d"></span><h2>Project 30: Solve a 1D transport equation<a class="headerlink" href="#project-30-solve-a-1d-transport-equation" title="Permalink to this headline">¶</a></h2>
<p>We shall study the wave equation</p>
<div class="math" id="equation-wave:app:exer:advec1D:ueq">
<span id="eq-wave-app-exer-advec1d-ueq"></span><span class="eqno">(12)</span>\[     u_t + cu_x = 0,\quad x\in (0,L],\ t\in (0, T],\]</div>
<p>with initial condition</p>
<div class="math">
\[u(x,0) = I(x),\quad x\in [0,L],\]</div>
<p>and <em>one</em> periodic boundary condition</p>
<div class="math">
\[u(0,t) = u(L,t)
{\thinspace .}\]</div>
<p>This boundary condition means that what goes out of the domain at <span class="math">\(x=L\)</span>
comes in at <span class="math">\(x=0\)</span>. Roughly speaking,
we need only one boundary condition because of
the spatial derivative is of first order only.</p>
<p><strong>Physical interpretation.</strong>
The parameter <span class="math">\(c\)</span> can be constant or variable, <span class="math">\(c=c(x)\)</span>. The
equation <a href="#equation-wave:app:exer:advec1D:ueq">(12)</a> arises in <em>transport</em>
problems where a quantity <span class="math">\(u\)</span>, which could be temperature or
concentration of some contaminant, is transported with the velocity
<span class="math">\(c\)</span> of a fluid. In addition to the transport imposed by &#8220;travelling with
the fluid&#8221;, <span class="math">\(u\)</span> may also be transported by diffusion (such as
heat conduction or Fickian diffusion), but we have in
the model <span class="math">\(u_t + cu_x\)</span> assumed that diffusion effects are negligible,
which they often are.</p>
<p>A widely used numerical scheme for <a href="#equation-wave:app:exer:advec1D:ueq">(12)</a>
applies a forward difference in time and a backward difference in
space when <span class="math">\(c&gt;0\)</span>:</p>
<div class="math" id="equation-wave:app:exer:advec1D:u:upwind">
<span id="eq-wave-app-exer-advec1d-u-upwind"></span><span class="eqno">(13)</span>\[     [D_t^+ u + cD_x^-u = 0]_i^n\]\[     {\thinspace .}\]</div>
<p>For <span class="math">\(c&lt;0\)</span> we use a forward difference in space: <span class="math">\([cD_x^+u]_i^n\)</span>.</p>
<p>We shall hereafter assume that <span class="math">\(=c(x)&gt;0\)</span>.</p>
<p>To compute <a href="#equation-wave:app:exer:advec1D:u:avar:sol">(18)</a> we need to integrate
<span class="math">\(1/c\)</span> to obtain <span class="math">\(C\)</span> and then compute the inverse of <span class="math">\(C\)</span>.</p>
<p>The inverse function computation can be easily done if we first think
discretely. Say we have some function <span class="math">\(y=g(x)\)</span> and seeks its inverse.
Plotting <span class="math">\((x_i,y_i)\)</span>, where <span class="math">\(y_i=g(x_i)\)</span> for some mesh points <span class="math">\(x_i\)</span>,
displays <span class="math">\(g\)</span> as a function of <span class="math">\(x\)</span>.
The inverse function is simply <span class="math">\(x\)</span> as a function of <span class="math">\(g\)</span>, i.e., the
curve with points <span class="math">\((y_i,x_i)\)</span>. We can therefore quickly compute points
at the curve of the inverse function. One way of extending these
points to a continuous function is to assume a linear variation
(known as linear interpolation)
between the points (which actually means to draw straight lines between
the points, exactly as done by a plotting program).</p>
<p>The function <tt class="docutils literal"><span class="pre">wrap2callable</span></tt> in <tt class="docutils literal"><span class="pre">scitools.std</span></tt> can take a set of points
and return a continuous function that corresponds to linear
variation between the points. The computation of the inverse of a
function <span class="math">\(g\)</span> on <span class="math">\([0,L]\)</span> can then be done by</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">101</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">domain</span><span class="p">[</span><span class="n">L</span><span class="p">],</span> <span class="n">resolution</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">scitools.std</span> <span class="kn">import</span> <span class="n">wrap2callable</span>
    <span class="n">g_inverse</span> <span class="o">=</span> <span class="n">wrap2callable</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">g_inverse</span>
</pre></div>
</div>
<p>To compute <span class="math">\(C(x)\)</span> we need to integrate <span class="math">\(1/c\)</span>, which can be done by
a Trapezoidal rule. Suppose we have computed <span class="math">\(C(x_i)\)</span> and need
to compute <span class="math">\(C(x_{i+1})\)</span>. Using the Trapezoidal rule with <span class="math">\(m\)</span> subintervals
over the integration domain <span class="math">\([x_i,x_{i+1}]\)</span> gives</p>
<div class="math" id="equation-wave:app:exer:advec1D:C:recursion">
<span id="eq-wave-app-exer-advec1d-c-recursion"></span><span class="eqno">(14)</span>\[     C(x_{i+1}) = C(x_i) + \int_{x_i}^{x_{i+1}} \frac{dx}{c}
     \approx h\left(
     \frac{1}{2}\frac{1}{c(x_i)} + \frac{1}{2}\frac{1}{c(x_{i+1})}
     + \sum_{j=1}^{m-1} \frac{1}{c(x_i + jh)}\right),\]</div>
<p>where <span class="math">\(h=(x_{i+1}-x_i)/m\)</span> is the length of the subintervals used
for the integral over <span class="math">\([x_i,x_{i+1}]\)</span>.
We observe that <a href="#equation-wave:app:exer:advec1D:C:recursion">(14)</a> is a
<em>difference equation</em> which we can solve by repeatedly
applying <a href="#equation-wave:app:exer:advec1D:C:recursion">(14)</a> for
<span class="math">\(i=0,1,\ldots,N_x-1\)</span> if a mesh <span class="math">\(x_0,x_,\ldots,x_{N_x}\)</span> is prescribed.
Note that <span class="math">\(C(0)=0\)</span>.</p>
<p><strong>a)</strong>
Show that under the assumption of <span class="math">\(a=\hbox{const}\)</span>,</p>
<div class="math" id="equation-wave:app:exer:advec1D:uexact">
<span id="eq-wave-app-exer-advec1d-uexact"></span><span class="eqno">(15)</span>\[     u(x,t) = I(x - ct)\]</div>
<p>fulfills the PDE as well as the initial and boundary condition
(provided <span class="math">\(I(0)=I(L)\)</span>).</p>
<p><strong>b)</strong>
Set up a computational algorithm and implement it in a function.
Assume <span class="math">\(a\)</span> is constant and positive.</p>
<p><strong>c)</strong>
Test implementation by using the remarkable property that
the numerical solution is exact at the mesh points if
<span class="math">\(\Delta t = c^{-1}\Delta x\)</span>.</p>
<p><strong>d)</strong>
Make a movie comparing the numerical and exact solution for the
following two choices of initial conditions:</p>
<div class="math" id="equation-wave:app:exer:advec1D:I:sin">
<span id="eq-wave-app-exer-advec1d-i-sin"></span><span class="eqno">(16)</span>\[      I(x) = \left\lbrack\sin\left(\pi\frac{x}{L}\right)\right\rbrack^{2n}\]</div>
<p>where <span class="math">\(n\)</span> is an integer, typically <span class="math">\(n=5\)</span>,
and</p>
<div class="math" id="equation-wave:app:exer:advec1D:I:gauss">
<span id="eq-wave-app-exer-advec1d-i-gauss"></span><span class="eqno">(17)</span>\[     I(x) = \exp{\left( -\frac{(x-L/2)^2}{2\sigma2}\right)} {\thinspace .}\]</div>
<p>Choose <span class="math">\(\Delta t = c^{-1}\Delta x, 0.9c^{-1}\Delta x, 0.5c^{-1}\Delta x\)</span>.</p>
<p><strong>e)</strong>
The performance of the suggested numerical scheme can be investigated
by analyzing the numerical dispersion relation.
Analytically, we have that the <em>Fourier component</em></p>
<div class="math">
\[u(x,t) = e^{i(kx-\omega t)},\]</div>
<p>is a solution of the PDE if <span class="math">\(\omega = kc\)</span>. This is the <em>analytical
dispersion relation</em>. A complete solution of the PDE can be built by
adding up such Fourier components with different amplitudes, where the
initial condition <span class="math">\(I\)</span> determines the amplitudes. The solution <span class="math">\(u\)</span> is
then represented by a Fourier series.</p>
<p>A similar discrete Fourier component at <span class="math">\((x_p,t_n)\)</span> is</p>
<div class="math">
\[u_p^q = e^{i(kp\Delta x -\tilde\omega n\Delta t)},\]</div>
<p>where in general <span class="math">\(\tilde\omega\)</span> is a function of <span class="math">\(k\)</span>, <span class="math">\(\Delta t\)</span>, and
<span class="math">\(\Delta x\)</span>, and differs from the exact <span class="math">\(\omega =kc\)</span>.</p>
<p>Insert the discrete Fourier component in the numerical scheme and
derive an expression for <span class="math">\(\tilde\omega\)</span>, i.e.,
the discrete dispersion relation. Show in particular that if
the <span class="math">\(\Delta t/(c\Delta x)=1\)</span>, the discrete solution coincides with the
exact solution at the mesh points, regardless of the mesh resolution (!).
Show that if the stability condition</p>
<div class="math">
\[\frac{\Delta t}{c\Delta x}\leq 1,\]</div>
<p>the discrete Fourier component cannot grow (i.e., <span class="math">\(\tilde\omega\)</span> is real).</p>
<p><strong>f)</strong>
Write a test for your implementation where you try to use information
from the numerical dispersion relation.</p>
<p><strong>g)</strong>
Set up a computational algorithm for the variable
coefficient case and implement it in a function.
Make a test that the function works for constant <span class="math">\(a\)</span>.</p>
<p><strong>h)</strong>
It can be shown that
for an observer moving with velocity <span class="math">\(c(x)\)</span>, <span class="math">\(u\)</span> is constant.
This can be used to derive an exact solution when <span class="math">\(a\)</span> varies
with <span class="math">\(x\)</span>. Show first that</p>
<div class="math" id="equation-wave:app:exer:advec1D:u:avar:sol">
<span id="eq-wave-app-exer-advec1d-u-avar-sol"></span><span class="eqno">(18)</span>\[     u(x,t) = f(C(x) - t),\]</div>
<p>where</p>
<div class="math">
\[C'(x) = \frac{1}{c(x)},\]</div>
<p>is a solution of <a href="#equation-wave:app:exer:advec1D:ueq">(12)</a> for any
differentiable function <span class="math">\(f\)</span>.</p>
<p><strong>i)</strong>
Use the initial condition to show that an exact solution is</p>
<div class="math">
\[u(x,t) = I(C^{-1}(C(x)-t)),\]</div>
<p>with <span class="math">\(C^{-1}\)</span> being the inverse function of <span class="math">\(C = \int c^{1}dx\)</span>.
Since <span class="math">\(C(x)\)</span> is an integral <span class="math">\(\int_0^x (1/c)dx\)</span>,
<span class="math">\(C(x)\)</span> is monotonically increasing and there exists hence an
inverse function <span class="math">\(C^{-1}\)</span> with values in <span class="math">\([0,L]\)</span>.</p>
<p><strong>j)</strong>
Implement a function for computing <span class="math">\(C(x_i)\)</span> and one for computing
<span class="math">\(C^{-1}(x)\)</span> for any <span class="math">\(x\)</span>. Use these two functions for computing
the exact solution <span class="math">\(I(C^{-1}(C(x)-t))\)</span>.
End up with a function <tt class="docutils literal"><span class="pre">u_exact_variable_c(x,</span> <span class="pre">n,</span> <span class="pre">c,</span> <span class="pre">I)</span></tt> that returns
the value of <span class="math">\(I(C^{-1}(C(x)-t_n))\)</span>.</p>
<p><strong>k)</strong>
Make movies showing a comparison of the numerical and exact solutions
for the two initial conditions
<a href="#equation-wave:app:exer:advec1D:I:sin">(16)</a> and <a href="#equation-wave:app:exer:advec1D:I:gauss">(17)</a>.
Choose <span class="math">\(\Delta t = \Delta x /\max_{0,L} c(x)\)</span>
and the velocity of the medium as</p>
<ol class="arabic simple">
<li><span class="math">\(c(x) = 1 + \epsilon\sin(k\pi x/L)\)</span>, <span class="math">\(\epsilon &lt;1\)</span>,</li>
<li><span class="math">\(c(x) = 1 + I(x)\)</span>, where <span class="math">\(I\)</span> is given by
<a href="#equation-wave:app:exer:advec1D:I:sin">(16)</a> or <a href="#equation-wave:app:exer:advec1D:I:gauss">(17)</a>.</li>
</ol>
<p>The PDE <span class="math">\(u_t + cu_x=0\)</span> expresses that the initial condition <span class="math">\(I(x)\)</span>
is transported with velocity <span class="math">\(c(x)\)</span>.</p>
<p>Filename: <tt class="docutils literal"><span class="pre">advec1D.py</span></tt>.</p>
</div>
<div class="section" id="problem-31-general-analytical-solution-of-a-1d-damped-wave-equation">
<span id="wave-app-exer-anal-damped-wave1d"></span><h2>Problem 31: General analytical solution of a 1D damped wave equation<a class="headerlink" href="#problem-31-general-analytical-solution-of-a-1d-damped-wave-equation" title="Permalink to this headline">¶</a></h2>
<p>We consider an initial-boundary value problem for the damped wave equation:</p>
<div class="math">
\[\begin{split}u_{tt} +bu_t &amp;= c^2 u_{xx}, \quad &amp;x\in (0,L),\ t\in (0,T]\\
u(0,t) &amp;= 0,\\
u(L,t) &amp;=0,\\
u(x, 0) &amp;= I(x),\\
u_t(x, 0) &amp;= V(x){\thinspace .}\end{split}\]</div>
<p>Here, <span class="math">\(b\geq 0\)</span> and <span class="math">\(c\)</span> are given constants. The aim is to derive a general
analytical solution of this problem. Familiarity with the method of
separation of variables for solving PDEs will be assumed.</p>
<p><strong>a)</strong>
Seek a solution on the form <span class="math">\(u(x,t)=X(x)T(t)\)</span>. Insert this solution in
the PDE and show that it leads to two differential equations for <span class="math">\(X\)</span> and <span class="math">\(T\)</span>:</p>
<div class="math">
\[T'' + bT' + \lambda T = 0,\quad c^2 X'' +\lambda X = 0,\]</div>
<p>with <span class="math">\(X(0)=X(L)=0\)</span> as boundary conditions, and <span class="math">\(\lambda\)</span> as a constant
to be determined.</p>
<p><strong>b)</strong>
Show that <span class="math">\(X(x)\)</span> is on the form</p>
<div class="math">
\[X_n(x) = C_n\sin kx,\quad k = \frac{n\pi}{L},\quad n=1,2,\ldots\]</div>
<p>where <span class="math">\(C_n\)</span> is an arbitrary constant.</p>
<p><strong>c)</strong>
Under the assumption that <span class="math">\((b/2)^2 &lt; k^2\)</span>, show that <span class="math">\(T(t)\)</span> is on
the form</p>
<div class="math">
\[T_n(t) = e^{-{\frac{1}{2}}bt}(a_n\cos\omega t + b_n\sin\omega t),
\quad\omega = \sqrt{k^2 - \frac{1}{4}b^2},\quad n=1,2,\ldots\]</div>
<p>The complete solution is then</p>
<div class="math">
\[u(x,t) = \sum_{n=1}^\infty \sin kx e^{-{\frac{1}{2}}bt}(
A_n\cos\omega t + B_n\sin\omega t),\]</div>
<p>where the constants <span class="math">\(A_n\)</span> and <span class="math">\(B_n\)</span> must be computed from the initial
conditions.</p>
<p><strong>d)</strong>
Derive a formula for <span class="math">\(A_n\)</span> from <span class="math">\(u(x,0)=I(x)\)</span> and developing <span class="math">\(I(x)\)</span> as a sine
Fourier series on <span class="math">\([0,L]\)</span>.</p>
<p><strong>e)</strong>
Derive a formula for <span class="math">\(B_n\)</span> from <span class="math">\(u_t(x,0)=V(x)\)</span> and developing <span class="math">\(V(x)\)</span> as
a sine Fourier series on <span class="math">\([0,L]\)</span>.</p>
<p><strong>f)</strong>
Calculate <span class="math">\(A_n\)</span> and <span class="math">\(B_n\)</span> from vibrations of a string where <span class="math">\(V(x)=0\)</span> and</p>
<div class="math" id="equation-wave:pde1:guitar:I">
<span id="eq-wave-pde1-guitar-i"></span><span class="eqno">(19)</span>\[\begin{split}     I(x) = \left\lbrace
     \begin{array}{ll}
     ax/x_0, &amp; x &lt; x_0,\\
     a(L-x)/(L-x_0), &amp; \hbox{otherwise}
     \end{array}\right.\end{split}\]</div>
<p><strong>g)</strong>
Implement the series for <span class="math">\(u(x,t)\)</span> in a function <tt class="docutils literal"><span class="pre">u_series(x,</span> <span class="pre">t,</span> <span class="pre">tol=1E-10)</span></tt>,
where <tt class="docutils literal"><span class="pre">tol</span></tt> is a tolerance for truncating the series. Simply sum
the terms until <span class="math">\(|a_n|\)</span> and <span class="math">\(|b_b|\)</span> both are less than <tt class="docutils literal"><span class="pre">tol</span></tt>.</p>
<p><strong>h)</strong>
What will change in the derivation of the analytical solution if we
have <span class="math">\(u_x(0,t)=u_x(L,t)=0\)</span> as boundary conditions?
And how will you solve the problem with <span class="math">\(u(0,t)=0\)</span> and <span class="math">\(u_x(L,t)=0\)</span>?</p>
<p>Filename: <tt class="docutils literal"><span class="pre">damped_wave1D.pdf</span></tt>.</p>
</div>
<div class="section" id="problem-32-general-analytical-solution-of-a-2d-damped-wave-equation">
<span id="wave-app-exer-anal-damped-wave2d"></span><h2>Problem 32: General analytical solution of a 2D damped wave equation<a class="headerlink" href="#problem-32-general-analytical-solution-of-a-2d-damped-wave-equation" title="Permalink to this headline">¶</a></h2>
<p>Carry out <a class="reference internal" href="#wave-app-exer-anal-damped-wave1d"><em>Problem 31: General analytical solution of a 1D damped wave equation</em></a> in the 2D
case: <span class="math">\(u_{tt}+bu_t = c^2(u_{xx}+u_{yy})\)</span>, where <span class="math">\((x,y)\in (0,L_x)\times
(0,L_y)\)</span>. Assume a solution on the form <span class="math">\(u(x,y,t)=X(x)Y(y)T(t)\)</span>.
Filename: <tt class="docutils literal"><span class="pre">damped_wave2D.pdf</span></tt>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <center>
            <p class="logo"><a href="http://cbc.simula.no/" title="Go to Center for Biomedical Computing">
              <img class="logo" src="_static/cbc_logo.png" alt="Logo"/>
            </a></p>
            </center>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Exercises  (4)</a><ul>
<li><a class="reference internal" href="#exercise-15-simulate-waves-on-a-non-homogeneous-string">Exercise 15: Simulate waves on a non-homogeneous string</a></li>
<li><a class="reference internal" href="#exercise-16-simulate-damped-waves-on-a-string">Exercise 16: Simulate damped waves on a string</a></li>
<li><a class="reference internal" href="#exercise-17-simulate-elastic-waves-in-a-rod">Exercise 17: Simulate elastic waves in a rod</a></li>
<li><a class="reference internal" href="#exercise-18-simulate-spherical-waves">Exercise 18: Simulate spherical waves</a></li>
<li><a class="reference internal" href="#exercise-19-explain-why-numerical-noise-occurs">Exercise 19: Explain why numerical noise occurs</a></li>
<li><a class="reference internal" href="#exercise-20-investigate-harmonic-averaging-in-a-1d-model">Exercise 20: Investigate harmonic averaging in a 1D model</a></li>
<li><a class="reference internal" href="#problem-21-implement-open-boundary-conditions">Problem 21: Implement open boundary conditions</a><ul>
<li><a class="reference internal" href="#remarks-2">Remarks  (2)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-22-implement-periodic-boundary-conditions">Exercise 22: Implement periodic boundary conditions</a></li>
<li><a class="reference internal" href="#problem-23-earthquake-generated-tsunami-over-a-subsea-hill">Problem 23: Earthquake-generated tsunami over a subsea hill</a></li>
<li><a class="reference internal" href="#problem-24-earthquake-generated-tsunami-over-a-3d-hill">Problem 24: Earthquake-generated tsunami over a 3D hill</a></li>
<li><a class="reference internal" href="#problem-25-investigate-matplotlib-for-visualization">Problem 25: Investigate Matplotlib for visualization</a></li>
<li><a class="reference internal" href="#problem-26-investigate-visualization-packages">Problem 26: Investigate visualization packages</a></li>
<li><a class="reference internal" href="#problem-27-implement-loops-in-compiled-languages">Problem 27: Implement loops in compiled languages</a></li>
<li><a class="reference internal" href="#exercise-28-simulate-seismic-waves-in-2d">Exercise 28: Simulate seismic waves in 2D</a></li>
<li><a class="reference internal" href="#project-29-model-3d-acoustic-waves-in-a-room">Project 29: Model 3D acoustic waves in a room</a></li>
<li><a class="reference internal" href="#project-30-solve-a-1d-transport-equation">Project 30: Solve a 1D transport equation</a></li>
<li><a class="reference internal" href="#problem-31-general-analytical-solution-of-a-1d-damped-wave-equation">Problem 31: General analytical solution of a 1D damped wave equation</a></li>
<li><a class="reference internal" href="#problem-32-general-analytical-solution-of-a-2d-damped-wave-equation">Problem 32: General analytical solution of a 2D damped wave equation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._main_wave009.html"
                        title="previous chapter">Waves in blood vessels</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._main_wave010.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="._main_wave009.html" title="Waves in blood vessels"
             >previous</a> |</li>
        <li><a href="index.html">Finite difference methods for wave motion</a> &raquo;</li> 
      </ul>
    </div>
<div class="wrapper">
  <div class="footer">
  <a href="http://cbc.simula.no"><img src="_static/cbc_banner.png" width="100%"><a>
  </div>
</div>

  </body>
</html>